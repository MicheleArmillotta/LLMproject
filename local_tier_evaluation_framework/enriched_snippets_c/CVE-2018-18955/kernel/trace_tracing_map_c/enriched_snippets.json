[
  {
    "function_name": "tracing_map_sort_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "1059-1125",
    "snippet": "int tracing_map_sort_entries(struct tracing_map *map,\n\t\t\t     struct tracing_map_sort_key *sort_keys,\n\t\t\t     unsigned int n_sort_keys,\n\t\t\t     struct tracing_map_sort_entry ***sort_entries)\n{\n\tint (*cmp_entries_fn)(const struct tracing_map_sort_entry **,\n\t\t\t      const struct tracing_map_sort_entry **);\n\tstruct tracing_map_sort_entry *sort_entry, **entries;\n\tint i, n_entries, ret;\n\n\tentries = vmalloc(array_size(sizeof(sort_entry), map->max_elts));\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, n_entries = 0; i < map->map_size; i++) {\n\t\tstruct tracing_map_entry *entry;\n\n\t\tentry = TRACING_MAP_ENTRY(map->map, i);\n\n\t\tif (!entry->key || !entry->val)\n\t\t\tcontinue;\n\n\t\tentries[n_entries] = create_sort_entry(entry->val->key,\n\t\t\t\t\t\t       entry->val);\n\t\tif (!entries[n_entries++]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (n_entries == 0) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\tif (n_entries == 1) {\n\t\t*sort_entries = entries;\n\t\treturn 1;\n\t}\n\n\tdetect_dups(entries, n_entries, map->key_size);\n\n\tif (is_key(map, sort_keys[0].field_idx))\n\t\tcmp_entries_fn = cmp_entries_key;\n\telse\n\t\tcmp_entries_fn = cmp_entries_sum;\n\n\tset_sort_key(map, &sort_keys[0]);\n\n\tsort(entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_fn, NULL);\n\n\tif (n_sort_keys > 1)\n\t\tsort_secondary(map,\n\t\t\t       (const struct tracing_map_sort_entry **)entries,\n\t\t\t       n_entries,\n\t\t\t       &sort_keys[0],\n\t\t\t       &sort_keys[1]);\n\n\t*sort_entries = entries;\n\n\treturn n_entries;\n free:\n\ttracing_map_destroy_sort_entries(entries, n_entries);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_destroy_sort_entries",
          "args": [
            "entries",
            "n_entries"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_destroy_sort_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "923-932",
          "snippet": "void tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort_secondary",
          "args": [
            "map",
            "(const struct tracing_map_sort_entry **)entries",
            "n_entries",
            "&sort_keys[0]",
            "&sort_keys[1]"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "986-1033",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sort_key",
          "args": [
            "map",
            "&sort_keys[0]"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "set_sort_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "704-708",
          "snippet": "static void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_key",
          "args": [
            "map",
            "sort_keys[0].field_idx"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "is_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "976-984",
          "snippet": "static bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_dups",
          "args": [
            "entries",
            "n_entries",
            "map->key_size"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "detect_dups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "949-974",
          "snippet": "static void detect_dups(struct tracing_map_sort_entry **sort_entries,\n\t\t      int n_entries, unsigned int key_size)\n{\n\tunsigned int dups = 0, total_dups = 0;\n\tint i;\n\tvoid *key;\n\n\tif (n_entries < 2)\n\t\treturn;\n\n\tsort(sort_entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_dup, NULL);\n\n\tkey = sort_entries[0]->key;\n\tfor (i = 1; i < n_entries; i++) {\n\t\tif (!memcmp(sort_entries[i]->key, key, key_size)) {\n\t\t\tdups++; total_dups++;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = sort_entries[i]->key;\n\t\tdups = 0;\n\t}\n\n\tWARN_ONCE(total_dups > 0,\n\t\t  \"Duplicates detected: %d\\n\", total_dups);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void detect_dups(struct tracing_map_sort_entry **sort_entries,\n\t\t      int n_entries, unsigned int key_size)\n{\n\tunsigned int dups = 0, total_dups = 0;\n\tint i;\n\tvoid *key;\n\n\tif (n_entries < 2)\n\t\treturn;\n\n\tsort(sort_entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_dup, NULL);\n\n\tkey = sort_entries[0]->key;\n\tfor (i = 1; i < n_entries; i++) {\n\t\tif (!memcmp(sort_entries[i]->key, key, key_size)) {\n\t\t\tdups++; total_dups++;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = sort_entries[i]->key;\n\t\tdups = 0;\n\t}\n\n\tWARN_ONCE(total_dups > 0,\n\t\t  \"Duplicates detected: %d\\n\", total_dups);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_sort_entry",
          "args": [
            "entry->val->key",
            "entry->val"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "create_sort_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "934-947",
          "snippet": "static struct tracing_map_sort_entry *\ncreate_sort_entry(void *key, struct tracing_map_elt *elt)\n{\n\tstruct tracing_map_sort_entry *sort_entry;\n\n\tsort_entry = kzalloc(sizeof(*sort_entry), GFP_KERNEL);\n\tif (!sort_entry)\n\t\treturn NULL;\n\n\tsort_entry->key = key;\n\tsort_entry->elt = elt;\n\n\treturn sort_entry;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_sort_entry *\ncreate_sort_entry(void *key, struct tracing_map_elt *elt)\n{\n\tstruct tracing_map_sort_entry *sort_entry;\n\n\tsort_entry = kzalloc(sizeof(*sort_entry), GFP_KERNEL);\n\tif (!sort_entry)\n\t\treturn NULL;\n\n\tsort_entry->key = key;\n\tsort_entry->elt = elt;\n\n\treturn sort_entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ENTRY",
          "args": [
            "map->map",
            "i"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "array_size(sizeof(sort_entry), map->max_elts)"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "sizeof(sort_entry)",
            "map->max_elts"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_sort_entries(struct tracing_map *map,\n\t\t\t     struct tracing_map_sort_key *sort_keys,\n\t\t\t     unsigned int n_sort_keys,\n\t\t\t     struct tracing_map_sort_entry ***sort_entries)\n{\n\tint (*cmp_entries_fn)(const struct tracing_map_sort_entry **,\n\t\t\t      const struct tracing_map_sort_entry **);\n\tstruct tracing_map_sort_entry *sort_entry, **entries;\n\tint i, n_entries, ret;\n\n\tentries = vmalloc(array_size(sizeof(sort_entry), map->max_elts));\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, n_entries = 0; i < map->map_size; i++) {\n\t\tstruct tracing_map_entry *entry;\n\n\t\tentry = TRACING_MAP_ENTRY(map->map, i);\n\n\t\tif (!entry->key || !entry->val)\n\t\t\tcontinue;\n\n\t\tentries[n_entries] = create_sort_entry(entry->val->key,\n\t\t\t\t\t\t       entry->val);\n\t\tif (!entries[n_entries++]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (n_entries == 0) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\tif (n_entries == 1) {\n\t\t*sort_entries = entries;\n\t\treturn 1;\n\t}\n\n\tdetect_dups(entries, n_entries, map->key_size);\n\n\tif (is_key(map, sort_keys[0].field_idx))\n\t\tcmp_entries_fn = cmp_entries_key;\n\telse\n\t\tcmp_entries_fn = cmp_entries_sum;\n\n\tset_sort_key(map, &sort_keys[0]);\n\n\tsort(entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_fn, NULL);\n\n\tif (n_sort_keys > 1)\n\t\tsort_secondary(map,\n\t\t\t       (const struct tracing_map_sort_entry **)entries,\n\t\t\t       n_entries,\n\t\t\t       &sort_keys[0],\n\t\t\t       &sort_keys[1]);\n\n\t*sort_entries = entries;\n\n\treturn n_entries;\n free:\n\ttracing_map_destroy_sort_entries(entries, n_entries);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sort_secondary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "986-1033",
    "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_sort_key",
          "args": [
            "map",
            "primary_key"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "set_sort_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "704-708",
          "snippet": "static void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "&entries[start]",
            "n_sub",
            "sizeof(struct tracing_map_sort_entry *)",
            "(int (*)(const void *, const void *))secondary_fn",
            "NULL"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "986-1033",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "primary_fn",
          "args": [
            "a",
            "b"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_key",
          "args": [
            "map",
            "secondary_key->field_idx"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "is_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "976-984",
          "snippet": "static bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
  },
  {
    "function_name": "is_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "976-984",
    "snippet": "static bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "detect_dups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "949-974",
    "snippet": "static void detect_dups(struct tracing_map_sort_entry **sort_entries,\n\t\t      int n_entries, unsigned int key_size)\n{\n\tunsigned int dups = 0, total_dups = 0;\n\tint i;\n\tvoid *key;\n\n\tif (n_entries < 2)\n\t\treturn;\n\n\tsort(sort_entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_dup, NULL);\n\n\tkey = sort_entries[0]->key;\n\tfor (i = 1; i < n_entries; i++) {\n\t\tif (!memcmp(sort_entries[i]->key, key, key_size)) {\n\t\t\tdups++; total_dups++;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = sort_entries[i]->key;\n\t\tdups = 0;\n\t}\n\n\tWARN_ONCE(total_dups > 0,\n\t\t  \"Duplicates detected: %d\\n\", total_dups);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "total_dups > 0",
            "\"Duplicates detected: %d\\n\"",
            "total_dups"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sort_entries[i]->key",
            "key",
            "key_size"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "sort_entries",
            "n_entries",
            "sizeof(struct tracing_map_sort_entry *)",
            "(int (*)(const void *, const void *))cmp_entries_dup",
            "NULL"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "986-1033",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void detect_dups(struct tracing_map_sort_entry **sort_entries,\n\t\t      int n_entries, unsigned int key_size)\n{\n\tunsigned int dups = 0, total_dups = 0;\n\tint i;\n\tvoid *key;\n\n\tif (n_entries < 2)\n\t\treturn;\n\n\tsort(sort_entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_dup, NULL);\n\n\tkey = sort_entries[0]->key;\n\tfor (i = 1; i < n_entries; i++) {\n\t\tif (!memcmp(sort_entries[i]->key, key, key_size)) {\n\t\t\tdups++; total_dups++;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = sort_entries[i]->key;\n\t\tdups = 0;\n\t}\n\n\tWARN_ONCE(total_dups > 0,\n\t\t  \"Duplicates detected: %d\\n\", total_dups);\n}"
  },
  {
    "function_name": "create_sort_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "934-947",
    "snippet": "static struct tracing_map_sort_entry *\ncreate_sort_entry(void *key, struct tracing_map_elt *elt)\n{\n\tstruct tracing_map_sort_entry *sort_entry;\n\n\tsort_entry = kzalloc(sizeof(*sort_entry), GFP_KERNEL);\n\tif (!sort_entry)\n\t\treturn NULL;\n\n\tsort_entry->key = key;\n\tsort_entry->elt = elt;\n\n\treturn sort_entry;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sort_entry)",
            "GFP_KERNEL"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_sort_entry *\ncreate_sort_entry(void *key, struct tracing_map_elt *elt)\n{\n\tstruct tracing_map_sort_entry *sort_entry;\n\n\tsort_entry = kzalloc(sizeof(*sort_entry), GFP_KERNEL);\n\tif (!sort_entry)\n\t\treturn NULL;\n\n\tsort_entry->key = key;\n\tsort_entry->elt = elt;\n\n\treturn sort_entry;\n}"
  },
  {
    "function_name": "tracing_map_destroy_sort_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "923-932",
    "snippet": "void tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "entries"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_sort_entry",
          "args": [
            "entries[i]"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_sort_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "905-914",
          "snippet": "static void destroy_sort_entry(struct tracing_map_sort_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tif (entry->elt_copied)\n\t\ttracing_map_elt_free(entry->elt);\n\n\tkfree(entry);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void destroy_sort_entry(struct tracing_map_sort_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tif (entry->elt_copied)\n\t\ttracing_map_elt_free(entry->elt);\n\n\tkfree(entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}"
  },
  {
    "function_name": "destroy_sort_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "905-914",
    "snippet": "static void destroy_sort_entry(struct tracing_map_sort_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tif (entry->elt_copied)\n\t\ttracing_map_elt_free(entry->elt);\n\n\tkfree(entry);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_elt_free",
          "args": [
            "entry->elt"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "386-398",
          "snippet": "static void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void destroy_sort_entry(struct tracing_map_sort_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tif (entry->elt_copied)\n\t\ttracing_map_elt_free(entry->elt);\n\n\tkfree(entry);\n}"
  },
  {
    "function_name": "cmp_entries_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "876-903",
    "snippet": "static int cmp_entries_key(const struct tracing_map_sort_entry **a,\n\t\t\t   const struct tracing_map_sort_entry **b)\n{\n\tconst struct tracing_map_elt *elt_a, *elt_b;\n\tstruct tracing_map_sort_key *sort_key;\n\tstruct tracing_map_field *field;\n\ttracing_map_cmp_fn_t cmp_fn;\n\tvoid *val_a, *val_b;\n\tint ret = 0;\n\n\telt_a = (*a)->elt;\n\telt_b = (*b)->elt;\n\n\tsort_key = &elt_a->map->sort_key;\n\n\tfield = &elt_a->fields[sort_key->field_idx];\n\n\tcmp_fn = field->cmp_fn;\n\n\tval_a = elt_a->key + field->offset;\n\tval_b = elt_b->key + field->offset;\n\n\tret = cmp_fn(val_a, val_b);\n\tif (sort_key->descending)\n\t\tret = -ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmp_fn",
          "args": [
            "val_a",
            "val_b"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int cmp_entries_key(const struct tracing_map_sort_entry **a,\n\t\t\t   const struct tracing_map_sort_entry **b)\n{\n\tconst struct tracing_map_elt *elt_a, *elt_b;\n\tstruct tracing_map_sort_key *sort_key;\n\tstruct tracing_map_field *field;\n\ttracing_map_cmp_fn_t cmp_fn;\n\tvoid *val_a, *val_b;\n\tint ret = 0;\n\n\telt_a = (*a)->elt;\n\telt_b = (*b)->elt;\n\n\tsort_key = &elt_a->map->sort_key;\n\n\tfield = &elt_a->fields[sort_key->field_idx];\n\n\tcmp_fn = field->cmp_fn;\n\n\tval_a = elt_a->key + field->offset;\n\tval_b = elt_b->key + field->offset;\n\n\tret = cmp_fn(val_a, val_b);\n\tif (sort_key->descending)\n\t\tret = -ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cmp_entries_sum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "848-874",
    "snippet": "static int cmp_entries_sum(const struct tracing_map_sort_entry **a,\n\t\t\t   const struct tracing_map_sort_entry **b)\n{\n\tconst struct tracing_map_elt *elt_a, *elt_b;\n\tstruct tracing_map_sort_key *sort_key;\n\tstruct tracing_map_field *field;\n\ttracing_map_cmp_fn_t cmp_fn;\n\tvoid *val_a, *val_b;\n\tint ret = 0;\n\n\telt_a = (*a)->elt;\n\telt_b = (*b)->elt;\n\n\tsort_key = &elt_a->map->sort_key;\n\n\tfield = &elt_a->fields[sort_key->field_idx];\n\tcmp_fn = field->cmp_fn;\n\n\tval_a = &elt_a->fields[sort_key->field_idx].sum;\n\tval_b = &elt_b->fields[sort_key->field_idx].sum;\n\n\tret = cmp_fn(val_a, val_b);\n\tif (sort_key->descending)\n\t\tret = -ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmp_fn",
          "args": [
            "val_a",
            "val_b"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int cmp_entries_sum(const struct tracing_map_sort_entry **a,\n\t\t\t   const struct tracing_map_sort_entry **b)\n{\n\tconst struct tracing_map_elt *elt_a, *elt_b;\n\tstruct tracing_map_sort_key *sort_key;\n\tstruct tracing_map_field *field;\n\ttracing_map_cmp_fn_t cmp_fn;\n\tvoid *val_a, *val_b;\n\tint ret = 0;\n\n\telt_a = (*a)->elt;\n\telt_b = (*b)->elt;\n\n\tsort_key = &elt_a->map->sort_key;\n\n\tfield = &elt_a->fields[sort_key->field_idx];\n\tcmp_fn = field->cmp_fn;\n\n\tval_a = &elt_a->fields[sort_key->field_idx].sum;\n\tval_b = &elt_b->fields[sort_key->field_idx].sum;\n\n\tret = cmp_fn(val_a, val_b);\n\tif (sort_key->descending)\n\t\tret = -ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cmp_entries_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "837-846",
    "snippet": "static int cmp_entries_dup(const struct tracing_map_sort_entry **a,\n\t\t\t   const struct tracing_map_sort_entry **b)\n{\n\tint ret = 0;\n\n\tif (memcmp((*a)->key, (*b)->key, (*a)->elt->map->key_size))\n\t\tret = 1;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "(*a)->key",
            "(*b)->key",
            "(*a)->elt->map->key_size"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int cmp_entries_dup(const struct tracing_map_sort_entry **a,\n\t\t\t   const struct tracing_map_sort_entry **b)\n{\n\tint ret = 0;\n\n\tif (memcmp((*a)->key, (*b)->key, (*a)->elt->map->key_size))\n\t\tret = 1;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tracing_map_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "821-835",
    "snippet": "int tracing_map_init(struct tracing_map *map)\n{\n\tint err;\n\n\tif (map->n_fields < 2)\n\t\treturn -EINVAL; /* need at least 1 key and 1 val */\n\n\terr = tracing_map_alloc_elts(map);\n\tif (err)\n\t\treturn err;\n\n\ttracing_map_clear(map);\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_clear",
          "args": [
            "map"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "690-702",
          "snippet": "void tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_alloc_elts",
          "args": [
            "map"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_alloc_elts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "480-500",
          "snippet": "static int tracing_map_alloc_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tmap->elts = tracing_map_array_alloc(map->max_elts,\n\t\t\t\t\t    sizeof(struct tracing_map_elt *));\n\tif (!map->elts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = tracing_map_elt_alloc(map);\n\t\tif (IS_ERR(*(TRACING_MAP_ELT(map->elts, i)))) {\n\t\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t\t\ttracing_map_free_elts(map);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_alloc_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tmap->elts = tracing_map_array_alloc(map->max_elts,\n\t\t\t\t\t    sizeof(struct tracing_map_elt *));\n\tif (!map->elts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = tracing_map_elt_alloc(map);\n\t\tif (IS_ERR(*(TRACING_MAP_ELT(map->elts, i)))) {\n\t\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t\t\ttracing_map_free_elts(map);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_init(struct tracing_map *map)\n{\n\tint err;\n\n\tif (map->n_fields < 2)\n\t\treturn -EINVAL; /* need at least 1 key and 1 val */\n\n\terr = tracing_map_alloc_elts(map);\n\tif (err)\n\t\treturn err;\n\n\ttracing_map_clear(map);\n\n\treturn err;\n}"
  },
  {
    "function_name": "tracing_map_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "760-800",
    "snippet": "struct tracing_map *tracing_map_create(unsigned int map_bits,\n\t\t\t\t       unsigned int key_size,\n\t\t\t\t       const struct tracing_map_ops *ops,\n\t\t\t\t       void *private_data)\n{\n\tstruct tracing_map *map;\n\tunsigned int i;\n\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map_bits = map_bits;\n\tmap->max_elts = (1 << map_bits);\n\tatomic_set(&map->next_elt, -1);\n\n\tmap->map_size = (1 << (map_bits + 1));\n\tmap->ops = ops;\n\n\tmap->private_data = private_data;\n\n\tmap->map = tracing_map_array_alloc(map->map_size,\n\t\t\t\t\t   sizeof(struct tracing_map_entry));\n\tif (!map->map)\n\t\tgoto free;\n\n\tmap->key_size = key_size;\n\tfor (i = 0; i < TRACING_MAP_KEYS_MAX; i++)\n\t\tmap->key_idx[i] = -1;\n out:\n\treturn map;\n free:\n\ttracing_map_destroy(map);\n\tmap = ERR_PTR(-ENOMEM);\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_destroy",
          "args": [
            "map"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "668-677",
          "snippet": "void tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_array_alloc",
          "args": [
            "map->map_size",
            "sizeof(struct tracing_map_entry)"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "319-353",
          "snippet": "struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&map->next_elt",
            "-1"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*map)",
            "GFP_KERNEL"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map *tracing_map_create(unsigned int map_bits,\n\t\t\t\t       unsigned int key_size,\n\t\t\t\t       const struct tracing_map_ops *ops,\n\t\t\t\t       void *private_data)\n{\n\tstruct tracing_map *map;\n\tunsigned int i;\n\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map_bits = map_bits;\n\tmap->max_elts = (1 << map_bits);\n\tatomic_set(&map->next_elt, -1);\n\n\tmap->map_size = (1 << (map_bits + 1));\n\tmap->ops = ops;\n\n\tmap->private_data = private_data;\n\n\tmap->map = tracing_map_array_alloc(map->map_size,\n\t\t\t\t\t   sizeof(struct tracing_map_entry));\n\tif (!map->map)\n\t\tgoto free;\n\n\tmap->key_size = key_size;\n\tfor (i = 0; i < TRACING_MAP_KEYS_MAX; i++)\n\t\tmap->key_idx[i] = -1;\n out:\n\treturn map;\n free:\n\ttracing_map_destroy(map);\n\tmap = ERR_PTR(-ENOMEM);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "set_sort_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "704-708",
    "snippet": "static void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}"
  },
  {
    "function_name": "tracing_map_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "690-702",
    "snippet": "void tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_elt_clear",
          "args": [
            "*(TRACING_MAP_ELT(map->elts, i))"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "355-370",
          "snippet": "static void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_array_clear",
          "args": [
            "map->map"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "286-295",
          "snippet": "void tracing_map_array_clear(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a->pages)\n\t\treturn;\n\n\tfor (i = 0; i < a->n_pages; i++)\n\t\tmemset(a->pages[i], 0, PAGE_SIZE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_array_clear(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a->pages)\n\t\treturn;\n\n\tfor (i = 0; i < a->n_pages; i++)\n\t\tmemset(a->pages[i], 0, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->drops",
            "0"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->hits",
            "0"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&map->next_elt",
            "-1"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}"
  },
  {
    "function_name": "tracing_map_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "668-677",
    "snippet": "void tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_array_free",
          "args": [
            "map->map"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "297-317",
          "snippet": "void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_free_elts",
          "args": [
            "map"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_free_elts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "464-478",
          "snippet": "static void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}"
  },
  {
    "function_name": "tracing_map_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "653-656",
    "snippet": "struct tracing_map_elt *tracing_map_lookup(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, true);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tracing_map_insert",
          "args": [
            "map",
            "key",
            "true"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "__tracing_map_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "512-592",
          "snippet": "static inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_elt *tracing_map_lookup(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, true);\n}"
  },
  {
    "function_name": "tracing_map_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "631-634",
    "snippet": "struct tracing_map_elt *tracing_map_insert(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, false);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tracing_map_insert",
          "args": [
            "map",
            "key",
            "false"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__tracing_map_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "512-592",
          "snippet": "static inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_elt *tracing_map_insert(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, false);\n}"
  },
  {
    "function_name": "__tracing_map_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "512-592",
    "snippet": "static inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->hits"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "elt->key",
            "key",
            "map->key_size"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->drops"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_free_elt",
          "args": [
            "map"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "get_free_elt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "449-462",
          "snippet": "static struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_inc_return(&map->next_elt);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_inc_return(&map->next_elt);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&entry->key",
            "0",
            "key_hash"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->drops"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!val"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->hits"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keys_match",
          "args": [
            "key",
            "val->key",
            "map->key_size"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "keys_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "502-510",
          "snippet": "static inline bool keys_match(void *key, void *test_key, unsigned key_size)\n{\n\tbool match = true;\n\n\tif (memcmp(key, test_key, key_size))\n\t\tmatch = false;\n\n\treturn match;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic inline bool keys_match(void *key, void *test_key, unsigned key_size)\n{\n\tbool match = true;\n\n\tif (memcmp(key, test_key, key_size))\n\t\tmatch = false;\n\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "entry->val"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ENTRY",
          "args": [
            "map->map",
            "idx"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "key",
            "map->key_size",
            "0"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "keys_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "502-510",
    "snippet": "static inline bool keys_match(void *key, void *test_key, unsigned key_size)\n{\n\tbool match = true;\n\n\tif (memcmp(key, test_key, key_size))\n\t\tmatch = false;\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "key",
            "test_key",
            "key_size"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic inline bool keys_match(void *key, void *test_key, unsigned key_size)\n{\n\tbool match = true;\n\n\tif (memcmp(key, test_key, key_size))\n\t\tmatch = false;\n\n\treturn match;\n}"
  },
  {
    "function_name": "tracing_map_alloc_elts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "480-500",
    "snippet": "static int tracing_map_alloc_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tmap->elts = tracing_map_array_alloc(map->max_elts,\n\t\t\t\t\t    sizeof(struct tracing_map_elt *));\n\tif (!map->elts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = tracing_map_elt_alloc(map);\n\t\tif (IS_ERR(*(TRACING_MAP_ELT(map->elts, i)))) {\n\t\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t\t\ttracing_map_free_elts(map);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_free_elts",
          "args": [
            "map"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_free_elts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "464-478",
          "snippet": "static void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*(TRACING_MAP_ELT(map->elts, i))"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_elt_alloc",
          "args": [
            "map"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "400-447",
          "snippet": "static struct tracing_map_elt *tracing_map_elt_alloc(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt;\n\tint err = 0;\n\n\telt = kzalloc(sizeof(*elt), GFP_KERNEL);\n\tif (!elt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\telt->map = map;\n\n\telt->key = kzalloc(map->key_size, GFP_KERNEL);\n\tif (!elt->key) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->fields = kcalloc(map->n_fields, sizeof(*elt->fields), GFP_KERNEL);\n\tif (!elt->fields) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->vars = kcalloc(map->n_vars, sizeof(*elt->vars), GFP_KERNEL);\n\tif (!elt->vars) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->var_set = kcalloc(map->n_vars, sizeof(*elt->var_set), GFP_KERNEL);\n\tif (!elt->var_set) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\ttracing_map_elt_init_fields(elt);\n\n\tif (map->ops && map->ops->elt_alloc) {\n\t\terr = map->ops->elt_alloc(elt);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\treturn elt;\n free:\n\ttracing_map_elt_free(elt);\n\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_elt *tracing_map_elt_alloc(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt;\n\tint err = 0;\n\n\telt = kzalloc(sizeof(*elt), GFP_KERNEL);\n\tif (!elt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\telt->map = map;\n\n\telt->key = kzalloc(map->key_size, GFP_KERNEL);\n\tif (!elt->key) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->fields = kcalloc(map->n_fields, sizeof(*elt->fields), GFP_KERNEL);\n\tif (!elt->fields) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->vars = kcalloc(map->n_vars, sizeof(*elt->vars), GFP_KERNEL);\n\tif (!elt->vars) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->var_set = kcalloc(map->n_vars, sizeof(*elt->var_set), GFP_KERNEL);\n\tif (!elt->var_set) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\ttracing_map_elt_init_fields(elt);\n\n\tif (map->ops && map->ops->elt_alloc) {\n\t\terr = map->ops->elt_alloc(elt);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\treturn elt;\n free:\n\ttracing_map_elt_free(elt);\n\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_array_alloc",
          "args": [
            "map->max_elts",
            "sizeof(struct tracing_map_elt *)"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "319-353",
          "snippet": "struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_alloc_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tmap->elts = tracing_map_array_alloc(map->max_elts,\n\t\t\t\t\t    sizeof(struct tracing_map_elt *));\n\tif (!map->elts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = tracing_map_elt_alloc(map);\n\t\tif (IS_ERR(*(TRACING_MAP_ELT(map->elts, i)))) {\n\t\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t\t\ttracing_map_free_elts(map);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tracing_map_free_elts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "464-478",
    "snippet": "static void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_array_free",
          "args": [
            "map->elts"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "297-317",
          "snippet": "void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_elt_free",
          "args": [
            "*(TRACING_MAP_ELT(map->elts, i))"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "386-398",
          "snippet": "static void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}"
  },
  {
    "function_name": "get_free_elt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "449-462",
    "snippet": "static struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_inc_return(&map->next_elt);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->elt_init",
          "args": [
            "elt"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "idx"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&map->next_elt"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_inc_return(&map->next_elt);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}"
  },
  {
    "function_name": "tracing_map_elt_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "400-447",
    "snippet": "static struct tracing_map_elt *tracing_map_elt_alloc(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt;\n\tint err = 0;\n\n\telt = kzalloc(sizeof(*elt), GFP_KERNEL);\n\tif (!elt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\telt->map = map;\n\n\telt->key = kzalloc(map->key_size, GFP_KERNEL);\n\tif (!elt->key) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->fields = kcalloc(map->n_fields, sizeof(*elt->fields), GFP_KERNEL);\n\tif (!elt->fields) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->vars = kcalloc(map->n_vars, sizeof(*elt->vars), GFP_KERNEL);\n\tif (!elt->vars) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->var_set = kcalloc(map->n_vars, sizeof(*elt->var_set), GFP_KERNEL);\n\tif (!elt->var_set) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\ttracing_map_elt_init_fields(elt);\n\n\tif (map->ops && map->ops->elt_alloc) {\n\t\terr = map->ops->elt_alloc(elt);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\treturn elt;\n free:\n\ttracing_map_elt_free(elt);\n\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_elt_free",
          "args": [
            "elt"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "386-398",
          "snippet": "static void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->elt_alloc",
          "args": [
            "elt"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_elt_init_fields",
          "args": [
            "elt"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_init_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "372-384",
          "snippet": "static void tracing_map_elt_init_fields(struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\ttracing_map_elt_clear(elt);\n\n\tfor (i = 0; i < elt->map->n_fields; i++) {\n\t\telt->fields[i].cmp_fn = elt->map->fields[i].cmp_fn;\n\n\t\tif (elt->fields[i].cmp_fn != tracing_map_cmp_atomic64)\n\t\t\telt->fields[i].offset = elt->map->fields[i].offset;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_init_fields(struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\ttracing_map_elt_clear(elt);\n\n\tfor (i = 0; i < elt->map->n_fields; i++) {\n\t\telt->fields[i].cmp_fn = elt->map->fields[i].cmp_fn;\n\n\t\tif (elt->fields[i].cmp_fn != tracing_map_cmp_atomic64)\n\t\t\telt->fields[i].offset = elt->map->fields[i].offset;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "map->n_vars",
            "sizeof(*elt->var_set)",
            "GFP_KERNEL"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "map->n_vars",
            "sizeof(*elt->vars)",
            "GFP_KERNEL"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "map->n_fields",
            "sizeof(*elt->fields)",
            "GFP_KERNEL"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "map->key_size",
            "GFP_KERNEL"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*elt)",
            "GFP_KERNEL"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_elt *tracing_map_elt_alloc(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt;\n\tint err = 0;\n\n\telt = kzalloc(sizeof(*elt), GFP_KERNEL);\n\tif (!elt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\telt->map = map;\n\n\telt->key = kzalloc(map->key_size, GFP_KERNEL);\n\tif (!elt->key) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->fields = kcalloc(map->n_fields, sizeof(*elt->fields), GFP_KERNEL);\n\tif (!elt->fields) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->vars = kcalloc(map->n_vars, sizeof(*elt->vars), GFP_KERNEL);\n\tif (!elt->vars) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->var_set = kcalloc(map->n_vars, sizeof(*elt->var_set), GFP_KERNEL);\n\tif (!elt->var_set) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\ttracing_map_elt_init_fields(elt);\n\n\tif (map->ops && map->ops->elt_alloc) {\n\t\terr = map->ops->elt_alloc(elt);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\treturn elt;\n free:\n\ttracing_map_elt_free(elt);\n\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "tracing_map_elt_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "386-398",
    "snippet": "static void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elt"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elt->map->ops->elt_free",
          "args": [
            "elt"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}"
  },
  {
    "function_name": "tracing_map_elt_init_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "372-384",
    "snippet": "static void tracing_map_elt_init_fields(struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\ttracing_map_elt_clear(elt);\n\n\tfor (i = 0; i < elt->map->n_fields; i++) {\n\t\telt->fields[i].cmp_fn = elt->map->fields[i].cmp_fn;\n\n\t\tif (elt->fields[i].cmp_fn != tracing_map_cmp_atomic64)\n\t\t\telt->fields[i].offset = elt->map->fields[i].offset;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_elt_clear",
          "args": [
            "elt"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "355-370",
          "snippet": "static void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_init_fields(struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\ttracing_map_elt_clear(elt);\n\n\tfor (i = 0; i < elt->map->n_fields; i++) {\n\t\telt->fields[i].cmp_fn = elt->map->fields[i].cmp_fn;\n\n\t\tif (elt->fields[i].cmp_fn != tracing_map_cmp_atomic64)\n\t\t\telt->fields[i].offset = elt->map->fields[i].offset;\n\t}\n}"
  },
  {
    "function_name": "tracing_map_elt_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "355-370",
    "snippet": "static void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elt->map->ops->elt_clear",
          "args": [
            "elt"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&elt->vars[i]",
            "0"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&elt->fields[i].sum",
            "0"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}"
  },
  {
    "function_name": "tracing_map_array_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "319-353",
    "snippet": "struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_array_free",
          "args": [
            "a"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "297-317",
          "snippet": "void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "a->n_pages",
            "sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "a->entries_per_page"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "roundup_pow_of_two(entry_size) - 1"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "entry_size"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*a)",
            "GFP_KERNEL"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}"
  },
  {
    "function_name": "tracing_map_array_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "297-317",
    "snippet": "void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "a"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)a->pages[i]"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "339-347",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}"
  },
  {
    "function_name": "tracing_map_array_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "286-295",
    "snippet": "void tracing_map_array_clear(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a->pages)\n\t\treturn;\n\n\tfor (i = 0; i < a->n_pages; i++)\n\t\tmemset(a->pages[i], 0, PAGE_SIZE);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "a->pages[i]",
            "0",
            "PAGE_SIZE"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_array_clear(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a->pages)\n\t\treturn;\n\n\tfor (i = 0; i < a->n_pages; i++)\n\t\tmemset(a->pages[i], 0, PAGE_SIZE);\n}"
  },
  {
    "function_name": "tracing_map_add_key_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "269-284",
    "snippet": "int tracing_map_add_key_field(struct tracing_map *map,\n\t\t\t      unsigned int offset,\n\t\t\t      tracing_map_cmp_fn_t cmp_fn)\n\n{\n\tint idx = tracing_map_add_field(map, cmp_fn);\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\tmap->fields[idx].offset = offset;\n\n\tmap->key_idx[map->n_keys++] = idx;\n\n\treturn idx;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_add_field",
          "args": [
            "map",
            "cmp_fn"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "201-212",
          "snippet": "static int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_key_field(struct tracing_map *map,\n\t\t\t      unsigned int offset,\n\t\t\t      tracing_map_cmp_fn_t cmp_fn)\n\n{\n\tint idx = tracing_map_add_field(map, cmp_fn);\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\tmap->fields[idx].offset = offset;\n\n\tmap->key_idx[map->n_keys++] = idx;\n\n\treturn idx;\n}"
  },
  {
    "function_name": "tracing_map_add_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "243-251",
    "snippet": "int tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tracing_map_add_sum_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "226-229",
    "snippet": "int tracing_map_add_sum_field(struct tracing_map *map)\n{\n\treturn tracing_map_add_field(map, tracing_map_cmp_atomic64);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_add_field",
          "args": [
            "map",
            "tracing_map_cmp_atomic64"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "201-212",
          "snippet": "static int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_sum_field(struct tracing_map *map)\n{\n\treturn tracing_map_add_field(map, tracing_map_cmp_atomic64);\n}"
  },
  {
    "function_name": "tracing_map_add_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "201-212",
    "snippet": "static int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tracing_map_cmp_num",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "166-199",
    "snippet": "tracing_map_cmp_fn_t tracing_map_cmp_num(int field_size,\n\t\t\t\t\t int field_is_signed)\n{\n\ttracing_map_cmp_fn_t fn = tracing_map_cmp_none;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s64;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s32;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s16;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s8;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\ntracing_map_cmp_fn_t tracing_map_cmp_num(int field_size,\n\t\t\t\t\t int field_is_signed)\n{\n\ttracing_map_cmp_fn_t fn = tracing_map_cmp_none;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s64;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s32;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s16;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s8;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
  },
  {
    "function_name": "tracing_map_cmp_atomic64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "140-146",
    "snippet": "static int tracing_map_cmp_atomic64(void *val_a, void *val_b)\n{\n\tu64 a = atomic64_read((atomic64_t *)val_a);\n\tu64 b = atomic64_read((atomic64_t *)val_b);\n\n\treturn (a > b) ? 1 : ((a < b) ? -1 : 0);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "(atomic64_t *)val_b"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "(atomic64_t *)val_a"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_cmp_atomic64(void *val_a, void *val_b)\n{\n\tu64 a = atomic64_read((atomic64_t *)val_a);\n\tu64 b = atomic64_read((atomic64_t *)val_b);\n\n\treturn (a > b) ? 1 : ((a < b) ? -1 : 0);\n}"
  },
  {
    "function_name": "tracing_map_cmp_none",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "135-138",
    "snippet": "int tracing_map_cmp_none(void *val_a, void *val_b)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_cmp_none(void *val_a, void *val_b)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "tracing_map_cmp_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "127-133",
    "snippet": "int tracing_map_cmp_string(void *val_a, void *val_b)\n{\n\tchar *a = val_a;\n\tchar *b = val_b;\n\n\treturn strcmp(a, b);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a",
            "b"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_cmp_string(void *val_a, void *val_b)\n{\n\tchar *a = val_a;\n\tchar *b = val_b;\n\n\treturn strcmp(a, b);\n}"
  },
  {
    "function_name": "tracing_map_read_var_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "121-125",
    "snippet": "u64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&elt->vars[i]"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}"
  },
  {
    "function_name": "tracing_map_read_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "102-105",
    "snippet": "u64 tracing_map_read_var(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&elt->vars[i]"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_var(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}"
  },
  {
    "function_name": "tracing_map_var_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "85-88",
    "snippet": "bool tracing_map_var_set(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn elt->var_set[i];\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nbool tracing_map_var_set(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn elt->var_set[i];\n}"
  },
  {
    "function_name": "tracing_map_set_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "70-74",
    "snippet": "void tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&elt->vars[i]",
            "n"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}"
  },
  {
    "function_name": "tracing_map_read_sum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "55-58",
    "snippet": "u64 tracing_map_read_sum(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->fields[i].sum);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&elt->fields[i].sum"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_sum(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->fields[i].sum);\n}"
  },
  {
    "function_name": "tracing_map_update_sum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
    "lines": "38-41",
    "snippet": "void tracing_map_update_sum(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_add(n, &elt->fields[i].sum);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "n",
            "&elt->fields[i].sum"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_update_sum(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_add(n, &elt->fields[i].sum);\n}"
  }
]