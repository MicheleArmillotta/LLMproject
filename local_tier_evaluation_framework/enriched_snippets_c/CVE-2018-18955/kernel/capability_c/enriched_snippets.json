[
  {
    "function_name": "ptracer_capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "499-509",
    "snippet": "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n{\n\tint ret = 0;  /* An absent tracer adds no restrictions */\n\tconst struct cred *cred;\n\trcu_read_lock();\n\tcred = rcu_dereference(tsk->ptracer_cred);\n\tif (cred)\n\t\tret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);\n\trcu_read_unlock();\n\treturn (ret == 0);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_capable_noaudit",
          "args": [
            "cred",
            "ns",
            "CAP_SYS_PTRACE"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "tsk->ptracer_cred"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n{\n\tint ret = 0;  /* An absent tracer adds no restrictions */\n\tconst struct cred *cred;\n\trcu_read_lock();\n\tcred = rcu_dereference(tsk->ptracer_cred);\n\tif (cred)\n\t\tret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);\n\trcu_read_unlock();\n\treturn (ret == 0);\n}"
  },
  {
    "function_name": "capable_wrt_inode_uidgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "483-488",
    "snippet": "bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\treturn ns_capable(ns, cap) && privileged_wrt_inode_uidgid(ns, inode);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "privileged_wrt_inode_uidgid",
          "args": [
            "ns",
            "inode"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "privileged_wrt_inode_uidgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "468-472",
          "snippet": "bool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode)\n{\n\treturn kuid_has_mapping(ns, inode->i_uid) &&\n\t\tkgid_has_mapping(ns, inode->i_gid);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode)\n{\n\treturn kuid_has_mapping(ns, inode->i_uid) &&\n\t\tkgid_has_mapping(ns, inode->i_gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "ns",
            "cap"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable_wrt_inode_uidgid(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\treturn ns_capable(ns, cap) && privileged_wrt_inode_uidgid(ns, inode);\n}"
  },
  {
    "function_name": "privileged_wrt_inode_uidgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "468-472",
    "snippet": "bool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode)\n{\n\treturn kuid_has_mapping(ns, inode->i_uid) &&\n\t\tkgid_has_mapping(ns, inode->i_gid);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgid_has_mapping",
          "args": [
            "ns",
            "inode->i_gid"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "ns",
            "inode->i_uid"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode)\n{\n\treturn kuid_has_mapping(ns, inode->i_uid) &&\n\t\tkgid_has_mapping(ns, inode->i_gid);\n}"
  },
  {
    "function_name": "file_ns_capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "448-458",
    "snippet": "bool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_capable",
          "args": [
            "file->f_cred",
            "ns",
            "cap"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cap_valid(cap)"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_valid",
          "args": [
            "cap"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "429-432",
    "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "&init_user_ns",
            "cap"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
  },
  {
    "function_name": "ns_capable_noaudit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "413-416",
    "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable_common",
          "args": [
            "ns",
            "cap",
            "false"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "366-382",
          "snippet": "static bool ns_capable_common(struct user_namespace *ns, int cap, bool audit)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = audit ? security_capable(current_cred(), ns, cap) :\n\t\t\t  security_capable_noaudit(current_cred(), ns, cap);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic bool ns_capable_common(struct user_namespace *ns, int cap, bool audit)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = audit ? security_capable(current_cred(), ns, cap) :\n\t\t\t  security_capable_noaudit(current_cred(), ns, cap);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
  },
  {
    "function_name": "ns_capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "395-398",
    "snippet": "bool ns_capable(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, true);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable_common",
          "args": [
            "ns",
            "cap",
            "true"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "366-382",
          "snippet": "static bool ns_capable_common(struct user_namespace *ns, int cap, bool audit)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = audit ? security_capable(current_cred(), ns, cap) :\n\t\t\t  security_capable_noaudit(current_cred(), ns, cap);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic bool ns_capable_common(struct user_namespace *ns, int cap, bool audit)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = audit ? security_capable(current_cred(), ns, cap) :\n\t\t\t  security_capable_noaudit(current_cred(), ns, cap);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, true);\n}"
  },
  {
    "function_name": "ns_capable_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "366-382",
    "snippet": "static bool ns_capable_common(struct user_namespace *ns, int cap, bool audit)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = audit ? security_capable(current_cred(), ns, cap) :\n\t\t\t  security_capable_noaudit(current_cred(), ns, cap);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_capable_noaudit",
          "args": [
            "current_cred()",
            "ns",
            "cap"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_capable",
          "args": [
            "current_cred()",
            "ns",
            "cap"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"capable() called with invalid cap=%u\\n\"",
            "cap"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cap_valid(cap)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_valid",
          "args": [
            "cap"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic bool ns_capable_common(struct user_namespace *ns, int cap, bool audit)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = audit ? security_capable(current_cred(), ns, cap) :\n\t\t\t  security_capable_noaudit(current_cred(), ns, cap);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "has_capability_noaudit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "361-364",
    "snippet": "bool has_capability_noaudit(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_ns_capability_noaudit",
          "args": [
            "t",
            "&init_user_ns",
            "cap"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "has_ns_capability_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "337-347",
          "snippet": "bool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable_noaudit(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable_noaudit(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_capability_noaudit(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);\n}"
  },
  {
    "function_name": "has_ns_capability_noaudit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "337-347",
    "snippet": "bool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable_noaudit(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_capable_noaudit",
          "args": [
            "__task_cred(t)",
            "ns",
            "cap"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "t"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable_noaudit(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}"
  },
  {
    "function_name": "has_capability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "318-321",
    "snippet": "bool has_capability(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability(t, &init_user_ns, cap);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_ns_capability",
          "args": [
            "t",
            "&init_user_ns",
            "cap"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "has_ns_capability_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "337-347",
          "snippet": "bool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable_noaudit(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable_noaudit(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_capability(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability(t, &init_user_ns, cap);\n}"
  },
  {
    "function_name": "has_ns_capability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "296-306",
    "snippet": "bool has_ns_capability(struct task_struct *t,\n\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_capable",
          "args": [
            "__task_cred(t)",
            "ns",
            "cap"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "t"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_ns_capability(struct task_struct *t,\n\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}"
  },
  {
    "function_name": "cap_get_target_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "118-139",
    "snippet": "static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,\n\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)\n{\n\tint ret;\n\n\tif (pid && (pid != task_pid_vnr(current))) {\n\t\tstruct task_struct *target;\n\n\t\trcu_read_lock();\n\n\t\ttarget = find_task_by_vpid(pid);\n\t\tif (!target)\n\t\t\tret = -ESRCH;\n\t\telse\n\t\t\tret = security_capget(target, pEp, pIp, pPp);\n\n\t\trcu_read_unlock();\n\t} else\n\t\tret = security_capget(current, pEp, pIp, pPp);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_capget",
          "args": [
            "current",
            "pEp",
            "pIp",
            "pPp"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_capget",
          "args": [
            "target",
            "pEp",
            "pIp",
            "pPp"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "348-351",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,\n\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)\n{\n\tint ret;\n\n\tif (pid && (pid != task_pid_vnr(current))) {\n\t\tstruct task_struct *target;\n\n\t\trcu_read_lock();\n\n\t\ttarget = find_task_by_vpid(pid);\n\t\tif (!target)\n\t\t\tret = -ESRCH;\n\t\telse\n\t\t\tret = security_capget(target, pEp, pIp, pPp);\n\n\t\trcu_read_unlock();\n\t} else\n\t\tret = security_capget(current, pEp, pIp, pPp);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cap_validate_magic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "82-109",
    "snippet": "static int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)\n{\n\t__u32 version;\n\n\tif (get_user(version, &header->version))\n\t\treturn -EFAULT;\n\n\tswitch (version) {\n\tcase _LINUX_CAPABILITY_VERSION_1:\n\t\twarn_legacy_capability_use();\n\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;\n\t\tbreak;\n\tcase _LINUX_CAPABILITY_VERSION_2:\n\t\twarn_deprecated_v2();\n\t\t/*\n\t\t * fall through - v3 is otherwise equivalent to v2.\n\t\t */\n\tcase _LINUX_CAPABILITY_VERSION_3:\n\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;\n\t\tbreak;\n\tdefault:\n\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))\n\t\t\treturn -EFAULT;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(u32)_KERNEL_CAPABILITY_VERSION",
            "&header->version"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_deprecated_v2",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "warn_deprecated_v2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "70-76",
          "snippet": "static void warn_deprecated_v2(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",\n\t\t     get_task_comm(name, current));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic void warn_deprecated_v2(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",\n\t\t     get_task_comm(name, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_legacy_capability_use",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "warn_legacy_capability_use",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "46-52",
          "snippet": "static void warn_legacy_capability_use(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",\n\t\t     get_task_comm(name, current));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic void warn_legacy_capability_use(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",\n\t\t     get_task_comm(name, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "version",
            "&header->version"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)\n{\n\t__u32 version;\n\n\tif (get_user(version, &header->version))\n\t\treturn -EFAULT;\n\n\tswitch (version) {\n\tcase _LINUX_CAPABILITY_VERSION_1:\n\t\twarn_legacy_capability_use();\n\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;\n\t\tbreak;\n\tcase _LINUX_CAPABILITY_VERSION_2:\n\t\twarn_deprecated_v2();\n\t\t/*\n\t\t * fall through - v3 is otherwise equivalent to v2.\n\t\t */\n\tcase _LINUX_CAPABILITY_VERSION_3:\n\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;\n\t\tbreak;\n\tdefault:\n\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))\n\t\t\treturn -EFAULT;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "warn_deprecated_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "70-76",
    "snippet": "static void warn_deprecated_v2(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",\n\t\t     get_task_comm(name, current));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info_once",
          "args": [
            "\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\"",
            "get_task_comm(name, current)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "name",
            "current"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic void warn_deprecated_v2(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",\n\t\t     get_task_comm(name, current));\n}"
  },
  {
    "function_name": "warn_legacy_capability_use",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "46-52",
    "snippet": "static void warn_legacy_capability_use(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",\n\t\t     get_task_comm(name, current));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info_once",
          "args": [
            "\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\"",
            "get_task_comm(name, current)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "name",
            "current"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nstatic void warn_legacy_capability_use(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",\n\t\t     get_task_comm(name, current));\n}"
  },
  {
    "function_name": "file_caps_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "32-36",
    "snippet": "static int __init file_caps_disable(char *str)\n{\n\tfile_caps_enabled = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int file_caps_enabled = 1;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nint file_caps_enabled = 1;\n\nstatic int __init file_caps_disable(char *str)\n{\n\tfile_caps_enabled = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "capget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "150-204",
    "snippet": "SYSCALL_DEFINE2(capget, cap_user_header_t, header, cap_user_data_t, dataptr)\n{\n\tint ret = 0;\n\tpid_t pid;\n\tunsigned tocopy;\n\tkernel_cap_t pE, pI, pP;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif ((dataptr == NULL) || (ret != 0))\n\t\treturn ((dataptr == NULL) && (ret == -EINVAL)) ? 0 : ret;\n\n\tif (get_user(pid, &header->pid))\n\t\treturn -EFAULT;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tret = cap_get_target_pid(pid, &pE, &pI, &pP);\n\tif (!ret) {\n\t\tstruct __user_cap_data_struct kdata[_KERNEL_CAPABILITY_U32S];\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < tocopy; i++) {\n\t\t\tkdata[i].effective = pE.cap[i];\n\t\t\tkdata[i].permitted = pP.cap[i];\n\t\t\tkdata[i].inheritable = pI.cap[i];\n\t\t}\n\n\t\t/*\n\t\t * Note, in the case, tocopy < _KERNEL_CAPABILITY_U32S,\n\t\t * we silently drop the upper capabilities here. This\n\t\t * has the effect of making older libcap\n\t\t * implementations implicitly drop upper capability\n\t\t * bits when they perform a: capget/modify/capset\n\t\t * sequence.\n\t\t *\n\t\t * This behavior is considered fail-safe\n\t\t * behavior. Upgrading the application to a newer\n\t\t * version of libcap will enable access to the newer\n\t\t * capabilities.\n\t\t *\n\t\t * An alternative would be to return an error here\n\t\t * (-ERANGE), but that causes legacy applications to\n\t\t * unexpectedly fail; the capget/modify/capset aborts\n\t\t * before modification is attempted and the application\n\t\t * fails.\n\t\t */\n\t\tif (copy_to_user(dataptr, kdata, tocopy\n\t\t\t\t * sizeof(struct __user_cap_data_struct))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nSYSCALL_DEFINE2(capget, cap_user_header_t, header, cap_user_data_t, dataptr)\n{\n\tint ret = 0;\n\tpid_t pid;\n\tunsigned tocopy;\n\tkernel_cap_t pE, pI, pP;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif ((dataptr == NULL) || (ret != 0))\n\t\treturn ((dataptr == NULL) && (ret == -EINVAL)) ? 0 : ret;\n\n\tif (get_user(pid, &header->pid))\n\t\treturn -EFAULT;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tret = cap_get_target_pid(pid, &pE, &pI, &pP);\n\tif (!ret) {\n\t\tstruct __user_cap_data_struct kdata[_KERNEL_CAPABILITY_U32S];\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < tocopy; i++) {\n\t\t\tkdata[i].effective = pE.cap[i];\n\t\t\tkdata[i].permitted = pP.cap[i];\n\t\t\tkdata[i].inheritable = pI.cap[i];\n\t\t}\n\n\t\t/*\n\t\t * Note, in the case, tocopy < _KERNEL_CAPABILITY_U32S,\n\t\t * we silently drop the upper capabilities here. This\n\t\t * has the effect of making older libcap\n\t\t * implementations implicitly drop upper capability\n\t\t * bits when they perform a: capget/modify/capset\n\t\t * sequence.\n\t\t *\n\t\t * This behavior is considered fail-safe\n\t\t * behavior. Upgrading the application to a newer\n\t\t * version of libcap will enable access to the newer\n\t\t * capabilities.\n\t\t *\n\t\t * An alternative would be to return an error here\n\t\t * (-ERANGE), but that causes legacy applications to\n\t\t * unexpectedly fail; the capget/modify/capset aborts\n\t\t * before modification is attempted and the application\n\t\t * fails.\n\t\t */\n\t\tif (copy_to_user(dataptr, kdata, tocopy\n\t\t\t\t * sizeof(struct __user_cap_data_struct))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "capset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
    "lines": "224-283",
    "snippet": "SYSCALL_DEFINE2(capset, cap_user_header_t, header, const cap_user_data_t, data)\n{\n\tstruct __user_cap_data_struct kdata[_KERNEL_CAPABILITY_U32S];\n\tunsigned i, tocopy, copybytes;\n\tkernel_cap_t inheritable, permitted, effective;\n\tstruct cred *new;\n\tint ret;\n\tpid_t pid;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (get_user(pid, &header->pid))\n\t\treturn -EFAULT;\n\n\t/* may only affect current now */\n\tif (pid != 0 && pid != task_pid_vnr(current))\n\t\treturn -EPERM;\n\n\tcopybytes = tocopy * sizeof(struct __user_cap_data_struct);\n\tif (copybytes > sizeof(kdata))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&kdata, data, copybytes))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < tocopy; i++) {\n\t\teffective.cap[i] = kdata[i].effective;\n\t\tpermitted.cap[i] = kdata[i].permitted;\n\t\tinheritable.cap[i] = kdata[i].inheritable;\n\t}\n\twhile (i < _KERNEL_CAPABILITY_U32S) {\n\t\teffective.cap[i] = 0;\n\t\tpermitted.cap[i] = 0;\n\t\tinheritable.cap[i] = 0;\n\t\ti++;\n\t}\n\n\teffective.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tpermitted.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tinheritable.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = security_capset(new, current_cred(),\n\t\t\t      &effective, &inheritable, &permitted);\n\tif (ret < 0)\n\t\tgoto error;\n\n\taudit_log_capset(new, current_cred());\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nSYSCALL_DEFINE2(capset, cap_user_header_t, header, const cap_user_data_t, data)\n{\n\tstruct __user_cap_data_struct kdata[_KERNEL_CAPABILITY_U32S];\n\tunsigned i, tocopy, copybytes;\n\tkernel_cap_t inheritable, permitted, effective;\n\tstruct cred *new;\n\tint ret;\n\tpid_t pid;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (get_user(pid, &header->pid))\n\t\treturn -EFAULT;\n\n\t/* may only affect current now */\n\tif (pid != 0 && pid != task_pid_vnr(current))\n\t\treturn -EPERM;\n\n\tcopybytes = tocopy * sizeof(struct __user_cap_data_struct);\n\tif (copybytes > sizeof(kdata))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&kdata, data, copybytes))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < tocopy; i++) {\n\t\teffective.cap[i] = kdata[i].effective;\n\t\tpermitted.cap[i] = kdata[i].permitted;\n\t\tinheritable.cap[i] = kdata[i].inheritable;\n\t}\n\twhile (i < _KERNEL_CAPABILITY_U32S) {\n\t\teffective.cap[i] = 0;\n\t\tpermitted.cap[i] = 0;\n\t\tinheritable.cap[i] = 0;\n\t\ti++;\n\t}\n\n\teffective.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tpermitted.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tinheritable.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = security_capset(new, current_cred(),\n\t\t\t      &effective, &inheritable, &permitted);\n\tif (ret < 0)\n\t\tgoto error;\n\n\taudit_log_capset(new, current_cred());\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn ret;\n}"
  }
]