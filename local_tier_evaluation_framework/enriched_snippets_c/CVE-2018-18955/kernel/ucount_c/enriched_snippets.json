[
  {
    "function_name": "user_namespace_sysctl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "229-245",
    "snippet": "static __init int user_namespace_sysctl_init(void)\n{\n#ifdef CONFIG_SYSCTL\n\tstatic struct ctl_table_header *user_header;\n\tstatic struct ctl_table empty[1];\n\t/*\n\t * It is necessary to register the user directory in the\n\t * default set so that registrations in the child sets work\n\t * properly.\n\t */\n\tuser_header = register_sysctl(\"user\", empty);\n\tkmemleak_ignore(user_header);\n\tBUG_ON(!user_header);\n\tBUG_ON(!setup_userns_sysctls(&init_user_ns));\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!setup_userns_sysctls(&init_user_ns)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_userns_sysctls",
          "args": [
            "&init_user_ns"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "setup_userns_sysctls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
          "lines": "87-107",
          "snippet": "bool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nbool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!user_header"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_ignore",
          "args": [
            "user_header"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_sysctl",
          "args": [
            "\"user\"",
            "empty"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic __init int user_namespace_sysctl_init(void)\n{\n#ifdef CONFIG_SYSCTL\n\tstatic struct ctl_table_header *user_header;\n\tstatic struct ctl_table empty[1];\n\t/*\n\t * It is necessary to register the user directory in the\n\t * default set so that registrations in the child sets work\n\t * properly.\n\t */\n\tuser_header = register_sysctl(\"user\", empty);\n\tkmemleak_ignore(user_header);\n\tBUG_ON(!user_header);\n\tBUG_ON(!setup_userns_sysctls(&init_user_ns));\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "dec_ucount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "219-227",
    "snippet": "void dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tint dec = atomic_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ucounts",
          "args": [
            "ucounts"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "put_ucounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
          "lines": "167-180",
          "snippet": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nstatic void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dec < 0"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_if_positive",
          "args": [
            "&iter->ucount[type]"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tint dec = atomic_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}"
  },
  {
    "function_name": "inc_ucount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "196-217",
    "snippet": "struct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = get_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tint max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ucounts",
          "args": [
            "ucounts"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "put_ucounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
          "lines": "167-180",
          "snippet": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nstatic void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&iter->ucount[type]"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_below",
          "args": [
            "&iter->ucount[type]",
            "max"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_inc_below",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
          "lines": "182-194",
          "snippet": "static inline bool atomic_inc_below(atomic_t *v, int u)\n{\n\tint c, old;\n\tc = atomic_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c >= u))\n\t\t\treturn false;\n\t\told = atomic_cmpxchg(v, c, c+1);\n\t\tif (likely(old == c))\n\t\t\treturn true;\n\t\tc = old;\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic inline bool atomic_inc_below(atomic_t *v, int u)\n{\n\tint c, old;\n\tc = atomic_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c >= u))\n\t\t\treturn false;\n\t\told = atomic_cmpxchg(v, c, c+1);\n\t\tif (likely(old == c))\n\t\t\treturn true;\n\t\tc = old;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "tns->ucount_max[type]"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ucounts",
          "args": [
            "ns",
            "uid"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "get_ucounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
          "lines": "132-165",
          "snippet": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tnew->count = 0;\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (ucounts->count == INT_MAX)\n\t\tucounts = NULL;\n\telse\n\t\tucounts->count += 1;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nstatic struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tnew->count = 0;\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (ucounts->count == INT_MAX)\n\t\tucounts = NULL;\n\telse\n\t\tucounts->count += 1;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = get_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tint max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}"
  },
  {
    "function_name": "atomic_inc_below",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "182-194",
    "snippet": "static inline bool atomic_inc_below(atomic_t *v, int u)\n{\n\tint c, old;\n\tc = atomic_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c >= u))\n\t\t\treturn false;\n\t\told = atomic_cmpxchg(v, c, c+1);\n\t\tif (likely(old == c))\n\t\t\treturn true;\n\t\tc = old;\n\t}\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "old == c"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "v",
            "c",
            "c+1"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "c >= u"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "v"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic inline bool atomic_inc_below(atomic_t *v, int u)\n{\n\tint c, old;\n\tc = atomic_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c >= u))\n\t\t\treturn false;\n\t\told = atomic_cmpxchg(v, c, c+1);\n\t\tif (likely(old == c))\n\t\t\treturn true;\n\t\tc = old;\n\t}\n}"
  },
  {
    "function_name": "put_ucounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "167-180",
    "snippet": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(ucounts_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ucounts"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ucounts_lock",
            "flags"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&ucounts->node"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ucounts_lock",
            "flags"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nstatic void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}"
  },
  {
    "function_name": "get_ucounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "132-165",
    "snippet": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tnew->count = 0;\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (ucounts->count == INT_MAX)\n\t\tucounts = NULL;\n\telse\n\t\tucounts->count += 1;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(ucounts_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ucounts_lock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&new->node",
            "hashent"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_ucounts",
          "args": [
            "ns",
            "uid",
            "hashent"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "find_ucounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
          "lines": "121-130",
          "snippet": "static struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct ucounts *ucounts;\n\n\thlist_for_each_entry(ucounts, hashent, node) {\n\t\tif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\n\t\t\treturn ucounts;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct ucounts *ucounts;\n\n\thlist_for_each_entry(ucounts, hashent, node) {\n\t\tif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\n\t\t\treturn ucounts;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ucounts_lock"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new)",
            "GFP_KERNEL"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucounts_hashentry",
          "args": [
            "ns",
            "uid"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nstatic struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tnew->count = 0;\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (ucounts->count == INT_MAX)\n\t\tucounts = NULL;\n\telse\n\t\tucounts->count += 1;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}"
  },
  {
    "function_name": "find_ucounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "121-130",
    "snippet": "static struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct ucounts *ucounts;\n\n\thlist_for_each_entry(ucounts, hashent, node) {\n\t\tif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\n\t\t\treturn ucounts;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "ucounts->uid",
            "uid"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "ucounts",
            "hashent",
            "node"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct ucounts *ucounts;\n\n\thlist_for_each_entry(ucounts, hashent, node) {\n\t\tif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\n\t\t\treturn ucounts;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "retire_userns_sysctls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "109-119",
    "snippet": "void retire_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = ns->sysctls->ctl_table_arg;\n\tunregister_sysctl_table(ns->sysctls);\n\tretire_sysctl_set(&ns->set);\n\tkfree(tbl);\n#endif\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tbl"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retire_sysctl_set",
          "args": [
            "&ns->set"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_sysctl_table",
          "args": [
            "ns->sysctls"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid retire_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = ns->sysctls->ctl_table_arg;\n\tunregister_sysctl_table(ns->sysctls);\n\tretire_sysctl_set(&ns->set);\n\tkfree(tbl);\n#endif\n}"
  },
  {
    "function_name": "setup_userns_sysctls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "87-107",
    "snippet": "bool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retire_sysctl_set",
          "args": [
            "&ns->set"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tbl"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_sysctl_table",
          "args": [
            "&ns->set",
            "\"user\"",
            "tbl"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "user_table",
            "sizeof(user_table)",
            "GFP_KERNEL"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_sysctl_set",
          "args": [
            "&ns->set",
            "&set_root",
            "set_is_seen"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nbool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}"
  },
  {
    "function_name": "set_permissions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "39-53",
    "snippet": "static int set_permissions(struct ctl_table_header *head,\n\t\t\t\t  struct ctl_table *table)\n{\n\tstruct user_namespace *user_ns =\n\t\tcontainer_of(head->set, struct user_namespace, set);\n\tint mode;\n\n\t/* Allow users with CAP_SYS_RESOURCE unrestrained access */\n\tif (ns_capable(user_ns, CAP_SYS_RESOURCE))\n\t\tmode = (table->mode & S_IRWXU) >> 6;\n\telse\n\t/* Allow all others at most read-only access */\n\t\tmode = table->mode & S_IROTH;\n\treturn (mode << 6) | (mode << 3) | mode;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_RESOURCE"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head->set",
            "structuser_namespace",
            "set"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic int set_permissions(struct ctl_table_header *head,\n\t\t\t\t  struct ctl_table *table)\n{\n\tstruct user_namespace *user_ns =\n\t\tcontainer_of(head->set, struct user_namespace, set);\n\tint mode;\n\n\t/* Allow users with CAP_SYS_RESOURCE unrestrained access */\n\tif (ns_capable(user_ns, CAP_SYS_RESOURCE))\n\t\tmode = (table->mode & S_IRWXU) >> 6;\n\telse\n\t/* Allow all others at most read-only access */\n\t\tmode = table->mode & S_IROTH;\n\treturn (mode << 6) | (mode << 3) | mode;\n}"
  },
  {
    "function_name": "set_is_seen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "34-37",
    "snippet": "static int set_is_seen(struct ctl_table_set *set)\n{\n\treturn &current_user_ns()->set == set;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic int set_is_seen(struct ctl_table_set *set)\n{\n\treturn &current_user_ns()->set == set;\n}"
  },
  {
    "function_name": "set_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
    "lines": "28-32",
    "snippet": "static struct ctl_table_set *\nset_lookup(struct ctl_table_root *root)\n{\n\treturn &current_user_ns()->set;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/hash.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic struct ctl_table_set *\nset_lookup(struct ctl_table_root *root)\n{\n\treturn &current_user_ns()->set;\n}"
  }
]