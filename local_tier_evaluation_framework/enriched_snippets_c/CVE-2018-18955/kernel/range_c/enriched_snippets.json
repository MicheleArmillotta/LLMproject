[
  {
    "function_name": "sort_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/range.c",
    "lines": "160-164",
    "snippet": "void sort_range(struct range *range, int nr_range)\n{\n\t/* sort them */\n\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "range",
            "nr_range",
            "sizeof(struct range)",
            "cmp_range",
            "NULL"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "986-1033",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid sort_range(struct range *range, int nr_range)\n{\n\t/* sort them */\n\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\n}"
  },
  {
    "function_name": "clean_sort_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/range.c",
    "lines": "125-158",
    "snippet": "int clean_sort_range(struct range *range, int az)\n{\n\tint i, j, k = az - 1, nr_range = az;\n\n\tfor (i = 0; i < k; i++) {\n\t\tif (range[i].end)\n\t\t\tcontinue;\n\t\tfor (j = k; j > i; j--) {\n\t\t\tif (range[j].end) {\n\t\t\t\tk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == i)\n\t\t\tbreak;\n\t\trange[i].start = range[k].start;\n\t\trange[i].end   = range[k].end;\n\t\trange[k].start = 0;\n\t\trange[k].end   = 0;\n\t\tk--;\n\t}\n\t/* count it */\n\tfor (i = 0; i < az; i++) {\n\t\tif (!range[i].end) {\n\t\t\tnr_range = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* sort them */\n\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\n\n\treturn nr_range;\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "range",
            "nr_range",
            "sizeof(struct range)",
            "cmp_range",
            "NULL"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "986-1033",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint clean_sort_range(struct range *range, int az)\n{\n\tint i, j, k = az - 1, nr_range = az;\n\n\tfor (i = 0; i < k; i++) {\n\t\tif (range[i].end)\n\t\t\tcontinue;\n\t\tfor (j = k; j > i; j--) {\n\t\t\tif (range[j].end) {\n\t\t\t\tk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == i)\n\t\t\tbreak;\n\t\trange[i].start = range[k].start;\n\t\trange[i].end   = range[k].end;\n\t\trange[k].start = 0;\n\t\trange[k].end   = 0;\n\t\tk--;\n\t}\n\t/* count it */\n\tfor (i = 0; i < az; i++) {\n\t\tif (!range[i].end) {\n\t\t\tnr_range = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* sort them */\n\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\n\n\treturn nr_range;\n}"
  },
  {
    "function_name": "cmp_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/range.c",
    "lines": "113-123",
    "snippet": "static int cmp_range(const void *x1, const void *x2)\n{\n\tconst struct range *r1 = x1;\n\tconst struct range *r2 = x2;\n\n\tif (r1->start < r2->start)\n\t\treturn -1;\n\tif (r1->start > r2->start)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int cmp_range(const void *x1, const void *x2)\n{\n\tconst struct range *r1 = x1;\n\tconst struct range *r2 = x2;\n\n\tif (r1->start < r2->start)\n\t\treturn -1;\n\tif (r1->start > r2->start)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "subtract_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/range.c",
    "lines": "64-111",
    "snippet": "void subtract_range(struct range *range, int az, u64 start, u64 end)\n{\n\tint i, j;\n\n\tif (start >= end)\n\t\treturn;\n\n\tfor (j = 0; j < az; j++) {\n\t\tif (!range[j].end)\n\t\t\tcontinue;\n\n\t\tif (start <= range[j].start && end >= range[j].end) {\n\t\t\trange[j].start = 0;\n\t\t\trange[j].end = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start <= range[j].start && end < range[j].end &&\n\t\t    range[j].start < end) {\n\t\t\trange[j].start = end;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (start > range[j].start && end >= range[j].end &&\n\t\t    range[j].end > start) {\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start > range[j].start && end < range[j].end) {\n\t\t\t/* Find the new spare: */\n\t\t\tfor (i = 0; i < az; i++) {\n\t\t\t\tif (range[i].end == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < az) {\n\t\t\t\trange[i].end = range[j].end;\n\t\t\t\trange[i].start = end;\n\t\t\t} else {\n\t\t\t\tpr_err(\"%s: run out of slot in ranges\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: run out of slot in ranges\\n\"",
            "__func__"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid subtract_range(struct range *range, int az, u64 start, u64 end)\n{\n\tint i, j;\n\n\tif (start >= end)\n\t\treturn;\n\n\tfor (j = 0; j < az; j++) {\n\t\tif (!range[j].end)\n\t\t\tcontinue;\n\n\t\tif (start <= range[j].start && end >= range[j].end) {\n\t\t\trange[j].start = 0;\n\t\t\trange[j].end = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start <= range[j].start && end < range[j].end &&\n\t\t    range[j].start < end) {\n\t\t\trange[j].start = end;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (start > range[j].start && end >= range[j].end &&\n\t\t    range[j].end > start) {\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start > range[j].start && end < range[j].end) {\n\t\t\t/* Find the new spare: */\n\t\t\tfor (i = 0; i < az; i++) {\n\t\t\t\tif (range[i].end == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < az) {\n\t\t\t\trange[i].end = range[j].end;\n\t\t\t\trange[i].start = end;\n\t\t\t} else {\n\t\t\t\tpr_err(\"%s: run out of slot in ranges\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "add_range_with_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/range.c",
    "lines": "28-62",
    "snippet": "int add_range_with_merge(struct range *range, int az, int nr_range,\n\t\t     u64 start, u64 end)\n{\n\tint i;\n\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t/* get new start/end: */\n\tfor (i = 0; i < nr_range; i++) {\n\t\tu64 common_start, common_end;\n\n\t\tif (!range[i].end)\n\t\t\tcontinue;\n\n\t\tcommon_start = max(range[i].start, start);\n\t\tcommon_end = min(range[i].end, end);\n\t\tif (common_start > common_end)\n\t\t\tcontinue;\n\n\t\t/* new start/end, will add it back at last */\n\t\tstart = min(range[i].start, start);\n\t\tend = max(range[i].end, end);\n\n\t\tmemmove(&range[i], &range[i + 1],\n\t\t\t(nr_range - (i + 1)) * sizeof(range[i]));\n\t\trange[nr_range - 1].start = 0;\n\t\trange[nr_range - 1].end   = 0;\n\t\tnr_range--;\n\t\ti--;\n\t}\n\n\t/* Need to add it: */\n\treturn add_range(range, az, nr_range, start, end);\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_range",
          "args": [
            "range",
            "az",
            "nr_range",
            "start",
            "end"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "add_range_with_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/range.c",
          "lines": "28-62",
          "snippet": "int add_range_with_merge(struct range *range, int az, int nr_range,\n\t\t     u64 start, u64 end)\n{\n\tint i;\n\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t/* get new start/end: */\n\tfor (i = 0; i < nr_range; i++) {\n\t\tu64 common_start, common_end;\n\n\t\tif (!range[i].end)\n\t\t\tcontinue;\n\n\t\tcommon_start = max(range[i].start, start);\n\t\tcommon_end = min(range[i].end, end);\n\t\tif (common_start > common_end)\n\t\t\tcontinue;\n\n\t\t/* new start/end, will add it back at last */\n\t\tstart = min(range[i].start, start);\n\t\tend = max(range[i].end, end);\n\n\t\tmemmove(&range[i], &range[i + 1],\n\t\t\t(nr_range - (i + 1)) * sizeof(range[i]));\n\t\trange[nr_range - 1].start = 0;\n\t\trange[nr_range - 1].end   = 0;\n\t\tnr_range--;\n\t\ti--;\n\t}\n\n\t/* Need to add it: */\n\treturn add_range(range, az, nr_range, start, end);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&range[i]",
            "&range[i + 1]",
            "(nr_range - (i + 1)) * sizeof(range[i])"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "range[i].end",
            "end"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "range[i].start",
            "start"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint add_range_with_merge(struct range *range, int az, int nr_range,\n\t\t     u64 start, u64 end)\n{\n\tint i;\n\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t/* get new start/end: */\n\tfor (i = 0; i < nr_range; i++) {\n\t\tu64 common_start, common_end;\n\n\t\tif (!range[i].end)\n\t\t\tcontinue;\n\n\t\tcommon_start = max(range[i].start, start);\n\t\tcommon_end = min(range[i].end, end);\n\t\tif (common_start > common_end)\n\t\t\tcontinue;\n\n\t\t/* new start/end, will add it back at last */\n\t\tstart = min(range[i].start, start);\n\t\tend = max(range[i].end, end);\n\n\t\tmemmove(&range[i], &range[i + 1],\n\t\t\t(nr_range - (i + 1)) * sizeof(range[i]));\n\t\trange[nr_range - 1].start = 0;\n\t\trange[nr_range - 1].end   = 0;\n\t\tnr_range--;\n\t\ti--;\n\t}\n\n\t/* Need to add it: */\n\treturn add_range(range, az, nr_range, start, end);\n}"
  },
  {
    "function_name": "add_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/range.c",
    "lines": "11-26",
    "snippet": "int add_range(struct range *range, int az, int nr_range, u64 start, u64 end)\n{\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t/* Out of slots: */\n\tif (nr_range >= az)\n\t\treturn nr_range;\n\n\trange[nr_range].start = start;\n\trange[nr_range].end = end;\n\n\tnr_range++;\n\n\treturn nr_range;\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint add_range(struct range *range, int az, int nr_range, u64 start, u64 end)\n{\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t/* Out of slots: */\n\tif (nr_range >= az)\n\t\treturn nr_range;\n\n\trange[nr_range].start = start;\n\trange[nr_range].end = end;\n\n\tnr_range++;\n\n\treturn nr_range;\n}"
  }
]