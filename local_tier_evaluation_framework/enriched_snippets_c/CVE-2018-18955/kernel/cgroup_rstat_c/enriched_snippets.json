[
  {
    "function_name": "cgroup_base_stat_cputime_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "395-416",
    "snippet": "void cgroup_base_stat_cputime_show(struct seq_file *seq)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tu64 usage, utime, stime;\n\n\tif (!cgroup_parent(cgrp))\n\t\treturn;\n\n\tcgroup_rstat_flush_hold(cgrp);\n\tusage = cgrp->bstat.cputime.sum_exec_runtime;\n\tcputime_adjust(&cgrp->bstat.cputime, &cgrp->prev_cputime, &utime, &stime);\n\tcgroup_rstat_flush_release();\n\n\tdo_div(usage, NSEC_PER_USEC);\n\tdo_div(utime, NSEC_PER_USEC);\n\tdo_div(stime, NSEC_PER_USEC);\n\n\tseq_printf(seq, \"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\",\n\t\t   usage, utime, stime);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\"",
            "usage",
            "utime",
            "stime"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stime",
            "NSEC_PER_USEC"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "utime",
            "NSEC_PER_USEC"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "usage",
            "NSEC_PER_USEC"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_release",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "243-247",
          "snippet": "void cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cputime_adjust",
          "args": [
            "&cgrp->bstat.cputime",
            "&cgrp->prev_cputime",
            "&utime",
            "&stime"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "cputime_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "590-660",
          "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicy code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = scale_stime(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicy code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = scale_stime(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_hold",
          "args": [
            "cgrp"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "232-238",
          "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_base_stat_cputime_show(struct seq_file *seq)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tu64 usage, utime, stime;\n\n\tif (!cgroup_parent(cgrp))\n\t\treturn;\n\n\tcgroup_rstat_flush_hold(cgrp);\n\tusage = cgrp->bstat.cputime.sum_exec_runtime;\n\tcputime_adjust(&cgrp->bstat.cputime, &cgrp->prev_cputime, &utime, &stime);\n\tcgroup_rstat_flush_release();\n\n\tdo_div(usage, NSEC_PER_USEC);\n\tdo_div(utime, NSEC_PER_USEC);\n\tdo_div(stime, NSEC_PER_USEC);\n\n\tseq_printf(seq, \"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\",\n\t\t   usage, utime, stime);\n}"
  },
  {
    "function_name": "__cgroup_account_cputime_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "371-393",
    "snippet": "void __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp);\n\n\tswitch (index) {\n\tcase CPUTIME_USER:\n\tcase CPUTIME_NICE:\n\t\trstatc->bstat.cputime.utime += delta_exec;\n\t\tbreak;\n\tcase CPUTIME_SYSTEM:\n\tcase CPUTIME_IRQ:\n\tcase CPUTIME_SOFTIRQ:\n\t\trstatc->bstat.cputime.stime += delta_exec;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_end",
          "args": [
            "cgrp",
            "rstatc"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "354-360",
          "snippet": "static void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc)\n{\n\tu64_stats_update_end(&rstatc->bsync);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc)\n{\n\tu64_stats_update_end(&rstatc->bsync);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_begin",
          "args": [
            "cgrp"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "344-352",
          "snippet": "static struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\tu64_stats_update_begin(&rstatc->bsync);\n\treturn rstatc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\tu64_stats_update_begin(&rstatc->bsync);\n\treturn rstatc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp);\n\n\tswitch (index) {\n\tcase CPUTIME_USER:\n\tcase CPUTIME_NICE:\n\t\trstatc->bstat.cputime.utime += delta_exec;\n\t\tbreak;\n\tcase CPUTIME_SYSTEM:\n\tcase CPUTIME_IRQ:\n\tcase CPUTIME_SOFTIRQ:\n\t\trstatc->bstat.cputime.stime += delta_exec;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc);\n}"
  },
  {
    "function_name": "__cgroup_account_cputime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "362-369",
    "snippet": "void __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp);\n\trstatc->bstat.cputime.sum_exec_runtime += delta_exec;\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_end",
          "args": [
            "cgrp",
            "rstatc"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "354-360",
          "snippet": "static void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc)\n{\n\tu64_stats_update_end(&rstatc->bsync);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc)\n{\n\tu64_stats_update_end(&rstatc->bsync);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_begin",
          "args": [
            "cgrp"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "344-352",
          "snippet": "static struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\tu64_stats_update_begin(&rstatc->bsync);\n\treturn rstatc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\tu64_stats_update_begin(&rstatc->bsync);\n\treturn rstatc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp);\n\trstatc->bstat.cputime.sum_exec_runtime += delta_exec;\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc);\n}"
  },
  {
    "function_name": "cgroup_base_stat_cputime_account_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "354-360",
    "snippet": "static void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc)\n{\n\tu64_stats_update_end(&rstatc->bsync);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_ptr",
          "args": [
            "rstatc"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_updated",
          "args": [
            "cgrp",
            "smp_processor_id()"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_updated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "24-68",
          "snippet": "void cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tstruct cgroup *parent;\n\tunsigned long flags;\n\n\t/* nothing to do for root */\n\tif (!cgroup_parent(cgrp))\n\t\treturn;\n\n\t/*\n\t * Paired with the one in cgroup_rstat_cpu_pop_upated().  Either we\n\t * see NULL updated_next or they see our updated stat.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (cgroup_rstat_cpu(cgrp, cpu)->updated_next)\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\tfor (parent = cgroup_parent(cgrp); parent;\n\t     cgrp = parent, parent = cgroup_parent(cgrp)) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup_rstat_cpu *prstatc = cgroup_rstat_cpu(parent, cpu);\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tstruct cgroup *parent;\n\tunsigned long flags;\n\n\t/* nothing to do for root */\n\tif (!cgroup_parent(cgrp))\n\t\treturn;\n\n\t/*\n\t * Paired with the one in cgroup_rstat_cpu_pop_upated().  Either we\n\t * see NULL updated_next or they see our updated stat.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (cgroup_rstat_cpu(cgrp, cpu)->updated_next)\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\tfor (parent = cgroup_parent(cgrp); parent;\n\t     cgrp = parent, parent = cgroup_parent(cgrp)) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup_rstat_cpu *prstatc = cgroup_rstat_cpu(parent, cpu);\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_update_end",
          "args": [
            "&rstatc->bsync"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc)\n{\n\tu64_stats_update_end(&rstatc->bsync);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}"
  },
  {
    "function_name": "cgroup_base_stat_cputime_account_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "344-352",
    "snippet": "static struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\tu64_stats_update_begin(&rstatc->bsync);\n\treturn rstatc;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_update_begin",
          "args": [
            "&rstatc->bsync"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_ptr",
          "args": [
            "cgrp->rstat_cpu"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\tu64_stats_update_begin(&rstatc->bsync);\n\treturn rstatc;\n}"
  },
  {
    "function_name": "cgroup_base_stat_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "312-342",
    "snippet": "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct task_cputime *last_cputime = &rstatc->last_bstat.cputime;\n\tstruct task_cputime cputime;\n\tstruct cgroup_base_stat delta;\n\tunsigned seq;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* calculate the delta to propgate */\n\tdelta.cputime.utime = cputime.utime - last_cputime->utime;\n\tdelta.cputime.stime = cputime.stime - last_cputime->stime;\n\tdelta.cputime.sum_exec_runtime = cputime.sum_exec_runtime -\n\t\t\t\t\t last_cputime->sum_exec_runtime;\n\t*last_cputime = cputime;\n\n\t/* transfer the pending stat into delta */\n\tcgroup_base_stat_accumulate(&delta, &cgrp->pending_bstat);\n\tmemset(&cgrp->pending_bstat, 0, sizeof(cgrp->pending_bstat));\n\n\t/* propagate delta into the global stat and the parent's pending */\n\tcgroup_base_stat_accumulate(&cgrp->bstat, &delta);\n\tif (parent)\n\t\tcgroup_base_stat_accumulate(&parent->pending_bstat, &delta);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_stat_accumulate",
          "args": [
            "&parent->pending_bstat",
            "&delta"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_accumulate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "304-310",
          "snippet": "static void cgroup_base_stat_accumulate(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t\tstruct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_accumulate(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t\tstruct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cgrp->pending_bstat",
            "0",
            "sizeof(cgrp->pending_bstat)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__u64_stats_fetch_retry",
          "args": [
            "&rstatc->bsync",
            "seq"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__u64_stats_fetch_begin",
          "args": [
            "&rstatc->bsync"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "cgrp",
            "cpu"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "10-13",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct task_cputime *last_cputime = &rstatc->last_bstat.cputime;\n\tstruct task_cputime cputime;\n\tstruct cgroup_base_stat delta;\n\tunsigned seq;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* calculate the delta to propgate */\n\tdelta.cputime.utime = cputime.utime - last_cputime->utime;\n\tdelta.cputime.stime = cputime.stime - last_cputime->stime;\n\tdelta.cputime.sum_exec_runtime = cputime.sum_exec_runtime -\n\t\t\t\t\t last_cputime->sum_exec_runtime;\n\t*last_cputime = cputime;\n\n\t/* transfer the pending stat into delta */\n\tcgroup_base_stat_accumulate(&delta, &cgrp->pending_bstat);\n\tmemset(&cgrp->pending_bstat, 0, sizeof(cgrp->pending_bstat));\n\n\t/* propagate delta into the global stat and the parent's pending */\n\tcgroup_base_stat_accumulate(&cgrp->bstat, &delta);\n\tif (parent)\n\t\tcgroup_base_stat_accumulate(&parent->pending_bstat, &delta);\n}"
  },
  {
    "function_name": "cgroup_base_stat_accumulate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "304-310",
    "snippet": "static void cgroup_base_stat_accumulate(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t\tstruct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_accumulate(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t\tstruct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}"
  },
  {
    "function_name": "cgroup_rstat_boot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "290-298",
    "snippet": "void __init cgroup_rstat_boot(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu));\n\n\tBUG_ON(cgroup_rstat_init(&cgrp_dfl_root.cgrp));\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgroup_rstat_init(&cgrp_dfl_root.cgrp)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_init",
          "args": [
            "&cgrp_dfl_root.cgrp"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "249-269",
          "snippet": "int cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nint cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid __init cgroup_rstat_boot(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu));\n\n\tBUG_ON(cgroup_rstat_init(&cgrp_dfl_root.cgrp));\n}"
  },
  {
    "function_name": "cgroup_rstat_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "271-288",
    "snippet": "void cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "cgrp->rstat_cpu"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rstatc->updated_next"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rstatc->updated_children != cgrp"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "cgrp",
            "cpu"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "10-13",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush",
          "args": [
            "cgrp"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "232-238",
          "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}"
  },
  {
    "function_name": "cgroup_rstat_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "249-269",
    "snippet": "int cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_init",
          "args": [
            "&rstatc->bsync"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "cgrp",
            "cpu"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "10-13",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structcgroup_rstat_cpu"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nint cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "243-247",
    "snippet": "void cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_hold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "232-238",
    "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_locked",
          "args": [
            "cgrp",
            "true"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "149-184",
          "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_irqsafe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "214-221",
    "snippet": "void cgroup_rstat_flush_irqsafe(struct cgroup *cgrp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_rstat_lock, flags);\n\tcgroup_rstat_flush_locked(cgrp, false);\n\tspin_unlock_irqrestore(&cgroup_rstat_lock, flags);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&cgroup_rstat_lock",
            "flags"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_locked",
          "args": [
            "cgrp",
            "false"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "149-184",
          "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&cgroup_rstat_lock",
            "flags"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_irqsafe(struct cgroup *cgrp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_rstat_lock, flags);\n\tcgroup_rstat_flush_locked(cgrp, false);\n\tspin_unlock_irqrestore(&cgroup_rstat_lock, flags);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "199-206",
    "snippet": "void cgroup_rstat_flush(struct cgroup *cgrp)\n{\n\tmight_sleep();\n\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_locked",
          "args": [
            "cgrp",
            "true"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "149-184",
          "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush(struct cgroup *cgrp)\n{\n\tmight_sleep();\n\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "149-184",
    "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
      "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "cpu_lock"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "css",
            "cpu"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "css",
            "&pos->rstat_css_list",
            "rstat_css_node"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_flush",
          "args": [
            "pos",
            "cpu"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "312-342",
          "snippet": "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct task_cputime *last_cputime = &rstatc->last_bstat.cputime;\n\tstruct task_cputime cputime;\n\tstruct cgroup_base_stat delta;\n\tunsigned seq;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* calculate the delta to propgate */\n\tdelta.cputime.utime = cputime.utime - last_cputime->utime;\n\tdelta.cputime.stime = cputime.stime - last_cputime->stime;\n\tdelta.cputime.sum_exec_runtime = cputime.sum_exec_runtime -\n\t\t\t\t\t last_cputime->sum_exec_runtime;\n\t*last_cputime = cputime;\n\n\t/* transfer the pending stat into delta */\n\tcgroup_base_stat_accumulate(&delta, &cgrp->pending_bstat);\n\tmemset(&cgrp->pending_bstat, 0, sizeof(cgrp->pending_bstat));\n\n\t/* propagate delta into the global stat and the parent's pending */\n\tcgroup_base_stat_accumulate(&cgrp->bstat, &delta);\n\tif (parent)\n\t\tcgroup_base_stat_accumulate(&parent->pending_bstat, &delta);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct task_cputime *last_cputime = &rstatc->last_bstat.cputime;\n\tstruct task_cputime cputime;\n\tstruct cgroup_base_stat delta;\n\tunsigned seq;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* calculate the delta to propgate */\n\tdelta.cputime.utime = cputime.utime - last_cputime->utime;\n\tdelta.cputime.stime = cputime.stime - last_cputime->stime;\n\tdelta.cputime.sum_exec_runtime = cputime.sum_exec_runtime -\n\t\t\t\t\t last_cputime->sum_exec_runtime;\n\t*last_cputime = cputime;\n\n\t/* transfer the pending stat into delta */\n\tcgroup_base_stat_accumulate(&delta, &cgrp->pending_bstat);\n\tmemset(&cgrp->pending_bstat, 0, sizeof(cgrp->pending_bstat));\n\n\t/* propagate delta into the global stat and the parent's pending */\n\tcgroup_base_stat_accumulate(&cgrp->bstat, &delta);\n\tif (parent)\n\t\tcgroup_base_stat_accumulate(&parent->pending_bstat, &delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu_pop_updated",
          "args": [
            "pos",
            "cgrp",
            "cpu"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu_pop_updated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "86-146",
          "snippet": "static struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos)\n\t\tpos = root;\n\telse\n\t\tpos = cgroup_parent(pos);\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent && rstatc->updated_next) {\n\t\tstruct cgroup_rstat_cpu *prstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tstruct cgroup_rstat_cpu *nrstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (true) {\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tif (*nextp == pos)\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\n\t\t*nextp = rstatc->updated_next;\n\t\trstatc->updated_next = NULL;\n\n\t\t/*\n\t\t * Paired with the one in cgroup_rstat_cpu_updated().\n\t\t * Either they see NULL updated_next or we see their\n\t\t * updated stat.\n\t\t */\n\t\tsmp_mb();\n\t}\n\n\treturn pos;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos)\n\t\tpos = root;\n\telse\n\t\tpos = cgroup_parent(pos);\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent && rstatc->updated_next) {\n\t\tstruct cgroup_rstat_cpu *prstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tstruct cgroup_rstat_cpu *nrstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (true) {\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tif (*nextp == pos)\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\n\t\t*nextp = rstatc->updated_next;\n\t\trstatc->updated_next = NULL;\n\n\t\t/*\n\t\t * Paired with the one in cgroup_rstat_cpu_updated().\n\t\t * Either they see NULL updated_next or we see their\n\t\t * updated stat.\n\t\t */\n\t\tsmp_mb();\n\t}\n\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "cpu_lock"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cgroup_rstat_cpu_lock",
            "cpu"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cgroup_rstat_cpu_pop_updated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "86-146",
    "snippet": "static struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos)\n\t\tpos = root;\n\telse\n\t\tpos = cgroup_parent(pos);\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent && rstatc->updated_next) {\n\t\tstruct cgroup_rstat_cpu *prstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tstruct cgroup_rstat_cpu *nrstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (true) {\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tif (*nextp == pos)\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\n\t\t*nextp = rstatc->updated_next;\n\t\trstatc->updated_next = NULL;\n\n\t\t/*\n\t\t * Paired with the one in cgroup_rstat_cpu_updated().\n\t\t * Either they see NULL updated_next or we see their\n\t\t * updated stat.\n\t\t */\n\t\tsmp_mb();\n\t}\n\n\treturn pos;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "*nextp == parent"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "*nextp",
            "cpu"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "10-13",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "pos"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "pos"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos)\n\t\tpos = root;\n\telse\n\t\tpos = cgroup_parent(pos);\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent && rstatc->updated_next) {\n\t\tstruct cgroup_rstat_cpu *prstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tstruct cgroup_rstat_cpu *nrstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (true) {\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tif (*nextp == pos)\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\n\t\t*nextp = rstatc->updated_next;\n\t\trstatc->updated_next = NULL;\n\n\t\t/*\n\t\t * Paired with the one in cgroup_rstat_cpu_updated().\n\t\t * Either they see NULL updated_next or we see their\n\t\t * updated stat.\n\t\t */\n\t\tsmp_mb();\n\t}\n\n\treturn pos;\n}"
  },
  {
    "function_name": "cgroup_rstat_updated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "24-68",
    "snippet": "void cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tstruct cgroup *parent;\n\tunsigned long flags;\n\n\t/* nothing to do for root */\n\tif (!cgroup_parent(cgrp))\n\t\treturn;\n\n\t/*\n\t * Paired with the one in cgroup_rstat_cpu_pop_upated().  Either we\n\t * see NULL updated_next or they see our updated stat.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (cgroup_rstat_cpu(cgrp, cpu)->updated_next)\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\tfor (parent = cgroup_parent(cgrp); parent;\n\t     cgrp = parent, parent = cgroup_parent(cgrp)) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup_rstat_cpu *prstatc = cgroup_rstat_cpu(parent, cpu);\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "cpu_lock",
            "flags"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "parent",
            "cpu"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "10-13",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "cpu_lock",
            "flags"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cgroup_rstat_cpu_lock",
            "cpu"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tstruct cgroup *parent;\n\tunsigned long flags;\n\n\t/* nothing to do for root */\n\tif (!cgroup_parent(cgrp))\n\t\treturn;\n\n\t/*\n\t * Paired with the one in cgroup_rstat_cpu_pop_upated().  Either we\n\t * see NULL updated_next or they see our updated stat.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (cgroup_rstat_cpu(cgrp, cpu)->updated_next)\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\tfor (parent = cgroup_parent(cgrp); parent;\n\t     cgrp = parent, parent = cgroup_parent(cgrp)) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup_rstat_cpu *prstatc = cgroup_rstat_cpu(parent, cpu);\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}"
  },
  {
    "function_name": "cgroup_rstat_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
    "lines": "10-13",
    "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cgrp->rstat_cpu",
            "cpu"
          ],
          "line": 12
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
  }
]