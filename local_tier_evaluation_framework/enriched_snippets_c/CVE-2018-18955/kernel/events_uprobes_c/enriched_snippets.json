[
  {
    "function_name": "init_uprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2300-2311",
    "snippet": "static int __init init_uprobes(void)\n{\n\tint i;\n\n\tfor (i = 0; i < UPROBES_HASH_SZ; i++)\n\t\tmutex_init(&uprobes_mmap_mutex[i]);\n\n\tif (percpu_init_rwsem(&dup_mmap_sem))\n\t\treturn -ENOMEM;\n\n\treturn register_die_notifier(&uprobe_exception_nb);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UPROBES_HASH_SZ\t13"
    ],
    "globals_used": [
      "static struct mutex uprobes_mmap_mutex[UPROBES_HASH_SZ];",
      "static struct percpu_rw_semaphore dup_mmap_sem;",
      "static struct notifier_block uprobe_exception_nb = {\n\t.notifier_call\t\t= arch_uprobe_exception_notify,\n\t.priority\t\t= INT_MAX-1,\t/* notified after kprobes, kgdb */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_die_notifier",
          "args": [
            "&uprobe_exception_nb"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_die_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "560-563",
          "snippet": "int unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ATOMIC_NOTIFIER_HEAD(die_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(die_chain);\n\nint unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_init_rwsem",
          "args": [
            "&dup_mmap_sem"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&uprobes_mmap_mutex[i]"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UPROBES_HASH_SZ\t13\n\nstatic struct mutex uprobes_mmap_mutex[UPROBES_HASH_SZ];\nstatic struct percpu_rw_semaphore dup_mmap_sem;\nstatic struct notifier_block uprobe_exception_nb = {\n\t.notifier_call\t\t= arch_uprobe_exception_notify,\n\t.priority\t\t= INT_MAX-1,\t/* notified after kprobes, kgdb */\n};\n\nstatic int __init init_uprobes(void)\n{\n\tint i;\n\n\tfor (i = 0; i < UPROBES_HASH_SZ; i++)\n\t\tmutex_init(&uprobes_mmap_mutex[i]);\n\n\tif (percpu_init_rwsem(&dup_mmap_sem))\n\t\treturn -ENOMEM;\n\n\treturn register_die_notifier(&uprobe_exception_nb);\n}"
  },
  {
    "function_name": "uprobe_post_sstep_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2282-2293",
    "snippet": "int uprobe_post_sstep_notifier(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tif (!current->mm || !utask || !utask->active_uprobe)\n\t\t/* task is currently not uprobed */\n\t\treturn 0;\n\n\tutask->state = UTASK_SSTEP_ACK;\n\tset_thread_flag(TIF_UPROBE);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_UPROBE"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_post_sstep_notifier(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tif (!current->mm || !utask || !utask->active_uprobe)\n\t\t/* task is currently not uprobed */\n\t\treturn 0;\n\n\tutask->state = UTASK_SSTEP_ACK;\n\tset_thread_flag(TIF_UPROBE);\n\treturn 1;\n}"
  },
  {
    "function_name": "uprobe_pre_sstep_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2265-2276",
    "snippet": "int uprobe_pre_sstep_notifier(struct pt_regs *regs)\n{\n\tif (!current->mm)\n\t\treturn 0;\n\n\tif (!test_bit(MMF_HAS_UPROBES, &current->mm->flags) &&\n\t    (!current->utask || !current->utask->return_instances))\n\t\treturn 0;\n\n\tset_thread_flag(TIF_UPROBE);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_UPROBE"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&current->mm->flags"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_pre_sstep_notifier(struct pt_regs *regs)\n{\n\tif (!current->mm)\n\t\treturn 0;\n\n\tif (!test_bit(MMF_HAS_UPROBES, &current->mm->flags) &&\n\t    (!current->utask || !current->utask->return_instances))\n\t\treturn 0;\n\n\tset_thread_flag(TIF_UPROBE);\n\treturn 1;\n}"
  },
  {
    "function_name": "uprobe_notify_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2248-2259",
    "snippet": "void uprobe_notify_resume(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\n\tclear_thread_flag(TIF_UPROBE);\n\n\tutask = current->utask;\n\tif (utask && utask->active_uprobe)\n\t\thandle_singlestep(utask, regs);\n\telse\n\t\thandle_swbp(regs);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_swbp",
          "args": [
            "regs"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "handle_swbp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "2144-2203",
          "snippet": "static void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint uninitialized_var(is_swbp);\n\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\t/* No matching uprobe; signal SIGTRAP. */\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Either we raced with uprobe_unregister() or we can't\n\t\t\t * access this memory. The latter is only possible if\n\t\t\t * another thread plays with our ->mm. In both cases\n\t\t\t * we can simply restart. If this vma was unmapped we\n\t\t\t * can pretend this insn was not executed yet and get\n\t\t\t * the (correct) SIGSEGV after restart.\n\t\t\t */\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* change it in advance for ->handler() and restart */\n\tinstruction_pointer_set(regs, bp_vaddr);\n\n\t/*\n\t * TODO: move copy_insn/etc into _register and remove this hack.\n\t * After we hit the bp, _unregister + _register can install the\n\t * new and not-yet-analyzed uprobe at the same address, restart.\n\t */\n\tsmp_rmb(); /* pairs with wmb() in install_breakpoint() */\n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\n\t/* Tracing handlers use ->utask to communicate with fetch methods */\n\tif (!get_utask())\n\t\tgoto out;\n\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\n\thandler_chain(uprobe, regs);\n\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\n\n\t/* arch_uprobe_skip_sstep() succeeded, or restart if can't singlestep */\nout:\n\tput_uprobe(uprobe);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UPROBE_COPY_INSN\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UPROBE_COPY_INSN\t0\n\nstatic void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint uninitialized_var(is_swbp);\n\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\t/* No matching uprobe; signal SIGTRAP. */\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Either we raced with uprobe_unregister() or we can't\n\t\t\t * access this memory. The latter is only possible if\n\t\t\t * another thread plays with our ->mm. In both cases\n\t\t\t * we can simply restart. If this vma was unmapped we\n\t\t\t * can pretend this insn was not executed yet and get\n\t\t\t * the (correct) SIGSEGV after restart.\n\t\t\t */\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* change it in advance for ->handler() and restart */\n\tinstruction_pointer_set(regs, bp_vaddr);\n\n\t/*\n\t * TODO: move copy_insn/etc into _register and remove this hack.\n\t * After we hit the bp, _unregister + _register can install the\n\t * new and not-yet-analyzed uprobe at the same address, restart.\n\t */\n\tsmp_rmb(); /* pairs with wmb() in install_breakpoint() */\n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\n\t/* Tracing handlers use ->utask to communicate with fetch methods */\n\tif (!get_utask())\n\t\tgoto out;\n\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\n\thandler_chain(uprobe, regs);\n\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\n\n\t/* arch_uprobe_skip_sstep() succeeded, or restart if can't singlestep */\nout:\n\tput_uprobe(uprobe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_singlestep",
          "args": [
            "utask",
            "regs"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "handle_singlestep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "2209-2235",
          "snippet": "static void handle_singlestep(struct uprobe_task *utask, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tint err = 0;\n\n\tuprobe = utask->active_uprobe;\n\tif (utask->state == UTASK_SSTEP_ACK)\n\t\terr = arch_uprobe_post_xol(&uprobe->arch, regs);\n\telse if (utask->state == UTASK_SSTEP_TRAPPED)\n\t\tarch_uprobe_abort_xol(&uprobe->arch, regs);\n\telse\n\t\tWARN_ON_ONCE(1);\n\n\tput_uprobe(uprobe);\n\tutask->active_uprobe = NULL;\n\tutask->state = UTASK_RUNNING;\n\txol_free_insn_slot(current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\trecalc_sigpending(); /* see uprobe_deny_signal() */\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (unlikely(err)) {\n\t\tuprobe_warn(current, \"execute the probed insn, sending SIGILL.\");\n\t\tforce_sig(SIGILL, current);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handle_singlestep(struct uprobe_task *utask, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tint err = 0;\n\n\tuprobe = utask->active_uprobe;\n\tif (utask->state == UTASK_SSTEP_ACK)\n\t\terr = arch_uprobe_post_xol(&uprobe->arch, regs);\n\telse if (utask->state == UTASK_SSTEP_TRAPPED)\n\t\tarch_uprobe_abort_xol(&uprobe->arch, regs);\n\telse\n\t\tWARN_ON_ONCE(1);\n\n\tput_uprobe(uprobe);\n\tutask->active_uprobe = NULL;\n\tutask->state = UTASK_RUNNING;\n\txol_free_insn_slot(current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\trecalc_sigpending(); /* see uprobe_deny_signal() */\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (unlikely(err)) {\n\t\tuprobe_warn(current, \"execute the probed insn, sending SIGILL.\");\n\t\tforce_sig(SIGILL, current);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_thread_flag",
          "args": [
            "TIF_UPROBE"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_notify_resume(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\n\tclear_thread_flag(TIF_UPROBE);\n\n\tutask = current->utask;\n\tif (utask && utask->active_uprobe)\n\t\thandle_singlestep(utask, regs);\n\telse\n\t\thandle_swbp(regs);\n}"
  },
  {
    "function_name": "handle_singlestep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2209-2235",
    "snippet": "static void handle_singlestep(struct uprobe_task *utask, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tint err = 0;\n\n\tuprobe = utask->active_uprobe;\n\tif (utask->state == UTASK_SSTEP_ACK)\n\t\terr = arch_uprobe_post_xol(&uprobe->arch, regs);\n\telse if (utask->state == UTASK_SSTEP_TRAPPED)\n\t\tarch_uprobe_abort_xol(&uprobe->arch, regs);\n\telse\n\t\tWARN_ON_ONCE(1);\n\n\tput_uprobe(uprobe);\n\tutask->active_uprobe = NULL;\n\tutask->state = UTASK_RUNNING;\n\txol_free_insn_slot(current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\trecalc_sigpending(); /* see uprobe_deny_signal() */\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (unlikely(err)) {\n\t\tuprobe_warn(current, \"execute the probed insn, sending SIGILL.\");\n\t\tforce_sig(SIGILL, current);\n\t}\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGILL",
            "current"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_ptrace_errno_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1638-1648",
          "snippet": "int force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_warn",
          "args": [
            "current",
            "\"execute the probed insn, sending SIGILL.\""
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1739-1743",
          "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "172-178",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xol_free_insn_slot",
          "args": [
            "current"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "xol_free_insn_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1594-1626",
          "snippet": "static void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "567-578",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uprobe_abort_xol",
          "args": [
            "&uprobe->arch",
            "regs"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uprobe_post_xol",
          "args": [
            "&uprobe->arch",
            "regs"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handle_singlestep(struct uprobe_task *utask, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tint err = 0;\n\n\tuprobe = utask->active_uprobe;\n\tif (utask->state == UTASK_SSTEP_ACK)\n\t\terr = arch_uprobe_post_xol(&uprobe->arch, regs);\n\telse if (utask->state == UTASK_SSTEP_TRAPPED)\n\t\tarch_uprobe_abort_xol(&uprobe->arch, regs);\n\telse\n\t\tWARN_ON_ONCE(1);\n\n\tput_uprobe(uprobe);\n\tutask->active_uprobe = NULL;\n\tutask->state = UTASK_RUNNING;\n\txol_free_insn_slot(current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\trecalc_sigpending(); /* see uprobe_deny_signal() */\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (unlikely(err)) {\n\t\tuprobe_warn(current, \"execute the probed insn, sending SIGILL.\");\n\t\tforce_sig(SIGILL, current);\n\t}\n}"
  },
  {
    "function_name": "handle_swbp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2144-2203",
    "snippet": "static void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint uninitialized_var(is_swbp);\n\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\t/* No matching uprobe; signal SIGTRAP. */\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Either we raced with uprobe_unregister() or we can't\n\t\t\t * access this memory. The latter is only possible if\n\t\t\t * another thread plays with our ->mm. In both cases\n\t\t\t * we can simply restart. If this vma was unmapped we\n\t\t\t * can pretend this insn was not executed yet and get\n\t\t\t * the (correct) SIGSEGV after restart.\n\t\t\t */\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* change it in advance for ->handler() and restart */\n\tinstruction_pointer_set(regs, bp_vaddr);\n\n\t/*\n\t * TODO: move copy_insn/etc into _register and remove this hack.\n\t * After we hit the bp, _unregister + _register can install the\n\t * new and not-yet-analyzed uprobe at the same address, restart.\n\t */\n\tsmp_rmb(); /* pairs with wmb() in install_breakpoint() */\n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\n\t/* Tracing handlers use ->utask to communicate with fetch methods */\n\tif (!get_utask())\n\t\tgoto out;\n\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\n\thandler_chain(uprobe, regs);\n\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\n\n\t/* arch_uprobe_skip_sstep() succeeded, or restart if can't singlestep */\nout:\n\tput_uprobe(uprobe);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UPROBE_COPY_INSN\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "567-578",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pre_ssout",
          "args": [
            "uprobe",
            "regs",
            "bp_vaddr"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "pre_ssout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1887-1914",
          "snippet": "static int\npre_ssout(struct uprobe *uprobe, struct pt_regs *regs, unsigned long bp_vaddr)\n{\n\tstruct uprobe_task *utask;\n\tunsigned long xol_vaddr;\n\tint err;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn -ENOMEM;\n\n\txol_vaddr = xol_get_insn_slot(uprobe);\n\tif (!xol_vaddr)\n\t\treturn -ENOMEM;\n\n\tutask->xol_vaddr = xol_vaddr;\n\tutask->vaddr = bp_vaddr;\n\n\terr = arch_uprobe_pre_xol(&uprobe->arch, regs);\n\tif (unlikely(err)) {\n\t\txol_free_insn_slot(current);\n\t\treturn err;\n\t}\n\n\tutask->active_uprobe = uprobe;\n\tutask->state = UTASK_SSTEP;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\npre_ssout(struct uprobe *uprobe, struct pt_regs *regs, unsigned long bp_vaddr)\n{\n\tstruct uprobe_task *utask;\n\tunsigned long xol_vaddr;\n\tint err;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn -ENOMEM;\n\n\txol_vaddr = xol_get_insn_slot(uprobe);\n\tif (!xol_vaddr)\n\t\treturn -ENOMEM;\n\n\tutask->xol_vaddr = xol_vaddr;\n\tutask->vaddr = bp_vaddr;\n\n\terr = arch_uprobe_pre_xol(&uprobe->arch, regs);\n\tif (unlikely(err)) {\n\t\txol_free_insn_slot(current);\n\t\treturn err;\n\t}\n\n\tutask->active_uprobe = uprobe;\n\tutask->state = UTASK_SSTEP;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_uprobe_skip_sstep",
          "args": [
            "&uprobe->arch",
            "regs"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler_chain",
          "args": [
            "uprobe",
            "regs"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "handler_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "2029-2059",
          "snippet": "static void handler_chain(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_consumer *uc;\n\tint remove = UPROBE_HANDLER_REMOVE;\n\tbool need_prep = false; /* prepare return uprobe, when needed */\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tint rc = 0;\n\n\t\tif (uc->handler) {\n\t\t\trc = uc->handler(uc, regs);\n\t\t\tWARN(rc & ~UPROBE_HANDLER_MASK,\n\t\t\t\t\"bad rc=0x%x from %pf()\\n\", rc, uc->handler);\n\t\t}\n\n\t\tif (uc->ret_handler)\n\t\t\tneed_prep = true;\n\n\t\tremove &= rc;\n\t}\n\n\tif (need_prep && !remove)\n\t\tprepare_uretprobe(uprobe, regs); /* put bp at return */\n\n\tif (remove && uprobe->consumers) {\n\t\tWARN_ON(!uprobe_is_active(uprobe));\n\t\tunapply_uprobe(uprobe, current->mm);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handler_chain(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_consumer *uc;\n\tint remove = UPROBE_HANDLER_REMOVE;\n\tbool need_prep = false; /* prepare return uprobe, when needed */\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tint rc = 0;\n\n\t\tif (uc->handler) {\n\t\t\trc = uc->handler(uc, regs);\n\t\t\tWARN(rc & ~UPROBE_HANDLER_MASK,\n\t\t\t\t\"bad rc=0x%x from %pf()\\n\", rc, uc->handler);\n\t\t}\n\n\t\tif (uc->ret_handler)\n\t\t\tneed_prep = true;\n\n\t\tremove &= rc;\n\t}\n\n\tif (need_prep && !remove)\n\t\tprepare_uretprobe(uprobe, regs); /* put bp at return */\n\n\tif (remove && uprobe->consumers) {\n\t\tWARN_ON(!uprobe_is_active(uprobe));\n\t\tunapply_uprobe(uprobe, current->mm);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_uprobe_ignore",
          "args": [
            "&uprobe->arch",
            "regs"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "arch_uprobe_ignore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "2129-2132",
          "snippet": "bool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_utask",
          "args": [],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "get_utask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1704-1709",
          "snippet": "static struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!test_bit(UPROBE_COPY_INSN, &uprobe->flags)"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "UPROBE_COPY_INSN",
            "&uprobe->flags"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer_set",
          "args": [
            "regs",
            "bp_vaddr"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer_set",
          "args": [
            "regs",
            "bp_vaddr"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGTRAP",
            "current",
            "0"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1712-1758",
          "snippet": "int send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_active_uprobe",
          "args": [
            "bp_vaddr",
            "&is_swbp"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "find_active_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "2000-2027",
          "snippet": "static struct uprobe *find_active_uprobe(unsigned long bp_vaddr, int *is_swbp)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct uprobe *uprobe = NULL;\n\tstruct vm_area_struct *vma;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, bp_vaddr);\n\tif (vma && vma->vm_start <= bp_vaddr) {\n\t\tif (valid_vma(vma, false)) {\n\t\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\t\tloff_t offset = vaddr_to_offset(vma, bp_vaddr);\n\n\t\t\tuprobe = find_uprobe(inode, offset);\n\t\t}\n\n\t\tif (!uprobe)\n\t\t\t*is_swbp = is_trap_at_addr(mm, bp_vaddr);\n\t} else {\n\t\t*is_swbp = -EFAULT;\n\t}\n\n\tif (!uprobe && test_and_clear_bit(MMF_RECALC_UPROBES, &mm->flags))\n\t\tmmf_recalc_uprobes(mm);\n\tup_read(&mm->mmap_sem);\n\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *find_active_uprobe(unsigned long bp_vaddr, int *is_swbp)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct uprobe *uprobe = NULL;\n\tstruct vm_area_struct *vma;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, bp_vaddr);\n\tif (vma && vma->vm_start <= bp_vaddr) {\n\t\tif (valid_vma(vma, false)) {\n\t\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\t\tloff_t offset = vaddr_to_offset(vma, bp_vaddr);\n\n\t\t\tuprobe = find_uprobe(inode, offset);\n\t\t}\n\n\t\tif (!uprobe)\n\t\t\t*is_swbp = is_trap_at_addr(mm, bp_vaddr);\n\t} else {\n\t\t*is_swbp = -EFAULT;\n\t}\n\n\tif (!uprobe && test_and_clear_bit(MMF_RECALC_UPROBES, &mm->flags))\n\t\tmmf_recalc_uprobes(mm);\n\tup_read(&mm->mmap_sem);\n\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_trampoline",
          "args": [
            "regs"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "handle_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "2087-2127",
          "snippet": "static void handle_trampoline(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\tstruct return_instance *ri, *next;\n\tbool valid;\n\n\tutask = current->utask;\n\tif (!utask)\n\t\tgoto sigill;\n\n\tri = utask->return_instances;\n\tif (!ri)\n\t\tgoto sigill;\n\n\tdo {\n\t\t/*\n\t\t * We should throw out the frames invalidated by longjmp().\n\t\t * If this chain is valid, then the next one should be alive\n\t\t * or NULL; the latter case means that nobody but ri->func\n\t\t * could hit this trampoline on return. TODO: sigaltstack().\n\t\t */\n\t\tnext = find_next_ret_chain(ri);\n\t\tvalid = !next || arch_uretprobe_is_alive(next, RP_CHECK_RET, regs);\n\n\t\tinstruction_pointer_set(regs, ri->orig_ret_vaddr);\n\t\tdo {\n\t\t\tif (valid)\n\t\t\t\thandle_uretprobe_chain(ri, regs);\n\t\t\tri = free_ret_instance(ri);\n\t\t\tutask->depth--;\n\t\t} while (ri != next);\n\t} while (!valid);\n\n\tutask->return_instances = ri;\n\treturn;\n\n sigill:\n\tuprobe_warn(current, \"handle uretprobe, sending SIGILL.\");\n\tforce_sig(SIGILL, current);\n\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handle_trampoline(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\tstruct return_instance *ri, *next;\n\tbool valid;\n\n\tutask = current->utask;\n\tif (!utask)\n\t\tgoto sigill;\n\n\tri = utask->return_instances;\n\tif (!ri)\n\t\tgoto sigill;\n\n\tdo {\n\t\t/*\n\t\t * We should throw out the frames invalidated by longjmp().\n\t\t * If this chain is valid, then the next one should be alive\n\t\t * or NULL; the latter case means that nobody but ri->func\n\t\t * could hit this trampoline on return. TODO: sigaltstack().\n\t\t */\n\t\tnext = find_next_ret_chain(ri);\n\t\tvalid = !next || arch_uretprobe_is_alive(next, RP_CHECK_RET, regs);\n\n\t\tinstruction_pointer_set(regs, ri->orig_ret_vaddr);\n\t\tdo {\n\t\t\tif (valid)\n\t\t\t\thandle_uretprobe_chain(ri, regs);\n\t\t\tri = free_ret_instance(ri);\n\t\t\tutask->depth--;\n\t\t} while (ri != next);\n\t} while (!valid);\n\n\tutask->return_instances = ri;\n\treturn;\n\n sigill:\n\tuprobe_warn(current, \"handle uretprobe, sending SIGILL.\");\n\tforce_sig(SIGILL, current);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_trampoline_vaddr",
          "args": [],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "get_trampoline_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1794-1805",
          "snippet": "static unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_get_swbp_addr",
          "args": [
            "regs"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_get_swbp_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1649-1652",
          "snippet": "unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs) - UPROBE_SWBP_INSN_SIZE;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nunsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs) - UPROBE_SWBP_INSN_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UPROBE_COPY_INSN\t0\n\nstatic void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint uninitialized_var(is_swbp);\n\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\t/* No matching uprobe; signal SIGTRAP. */\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Either we raced with uprobe_unregister() or we can't\n\t\t\t * access this memory. The latter is only possible if\n\t\t\t * another thread plays with our ->mm. In both cases\n\t\t\t * we can simply restart. If this vma was unmapped we\n\t\t\t * can pretend this insn was not executed yet and get\n\t\t\t * the (correct) SIGSEGV after restart.\n\t\t\t */\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* change it in advance for ->handler() and restart */\n\tinstruction_pointer_set(regs, bp_vaddr);\n\n\t/*\n\t * TODO: move copy_insn/etc into _register and remove this hack.\n\t * After we hit the bp, _unregister + _register can install the\n\t * new and not-yet-analyzed uprobe at the same address, restart.\n\t */\n\tsmp_rmb(); /* pairs with wmb() in install_breakpoint() */\n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\n\t/* Tracing handlers use ->utask to communicate with fetch methods */\n\tif (!get_utask())\n\t\tgoto out;\n\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\n\thandler_chain(uprobe, regs);\n\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\n\n\t/* arch_uprobe_skip_sstep() succeeded, or restart if can't singlestep */\nout:\n\tput_uprobe(uprobe);\n}"
  },
  {
    "function_name": "arch_uretprobe_is_alive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2134-2138",
    "snippet": "bool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "arch_uprobe_ignore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2129-2132",
    "snippet": "bool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs)\n{\n\treturn false;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "handle_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2087-2127",
    "snippet": "static void handle_trampoline(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\tstruct return_instance *ri, *next;\n\tbool valid;\n\n\tutask = current->utask;\n\tif (!utask)\n\t\tgoto sigill;\n\n\tri = utask->return_instances;\n\tif (!ri)\n\t\tgoto sigill;\n\n\tdo {\n\t\t/*\n\t\t * We should throw out the frames invalidated by longjmp().\n\t\t * If this chain is valid, then the next one should be alive\n\t\t * or NULL; the latter case means that nobody but ri->func\n\t\t * could hit this trampoline on return. TODO: sigaltstack().\n\t\t */\n\t\tnext = find_next_ret_chain(ri);\n\t\tvalid = !next || arch_uretprobe_is_alive(next, RP_CHECK_RET, regs);\n\n\t\tinstruction_pointer_set(regs, ri->orig_ret_vaddr);\n\t\tdo {\n\t\t\tif (valid)\n\t\t\t\thandle_uretprobe_chain(ri, regs);\n\t\t\tri = free_ret_instance(ri);\n\t\t\tutask->depth--;\n\t\t} while (ri != next);\n\t} while (!valid);\n\n\tutask->return_instances = ri;\n\treturn;\n\n sigill:\n\tuprobe_warn(current, \"handle uretprobe, sending SIGILL.\");\n\tforce_sig(SIGILL, current);\n\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGILL",
            "current"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_ptrace_errno_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1638-1648",
          "snippet": "int force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_warn",
          "args": [
            "current",
            "\"handle uretprobe, sending SIGILL.\""
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1739-1743",
          "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ret_instance",
          "args": [
            "ri"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "free_ret_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1664-1670",
          "snippet": "static struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_uretprobe_chain",
          "args": [
            "ri",
            "regs"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "handle_uretprobe_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "2061-2073",
          "snippet": "static void\nhandle_uretprobe_chain(struct return_instance *ri, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe = ri->uprobe;\n\tstruct uprobe_consumer *uc;\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tif (uc->ret_handler)\n\t\t\tuc->ret_handler(uc, ri->func, regs);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\nhandle_uretprobe_chain(struct return_instance *ri, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe = ri->uprobe;\n\tstruct uprobe_consumer *uc;\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tif (uc->ret_handler)\n\t\t\tuc->ret_handler(uc, ri->func, regs);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer_set",
          "args": [
            "regs",
            "ri->orig_ret_vaddr"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uretprobe_is_alive",
          "args": [
            "next",
            "RP_CHECK_RET",
            "regs"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "arch_uretprobe_is_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "2134-2138",
          "snippet": "bool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_ret_chain",
          "args": [
            "ri"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_ret_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "2075-2085",
          "snippet": "static struct return_instance *find_next_ret_chain(struct return_instance *ri)\n{\n\tbool chained;\n\n\tdo {\n\t\tchained = ri->chained;\n\t\tri = ri->next;\t/* can't be NULL if chained */\n\t} while (chained);\n\n\treturn ri;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *find_next_ret_chain(struct return_instance *ri)\n{\n\tbool chained;\n\n\tdo {\n\t\tchained = ri->chained;\n\t\tri = ri->next;\t/* can't be NULL if chained */\n\t} while (chained);\n\n\treturn ri;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handle_trampoline(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\tstruct return_instance *ri, *next;\n\tbool valid;\n\n\tutask = current->utask;\n\tif (!utask)\n\t\tgoto sigill;\n\n\tri = utask->return_instances;\n\tif (!ri)\n\t\tgoto sigill;\n\n\tdo {\n\t\t/*\n\t\t * We should throw out the frames invalidated by longjmp().\n\t\t * If this chain is valid, then the next one should be alive\n\t\t * or NULL; the latter case means that nobody but ri->func\n\t\t * could hit this trampoline on return. TODO: sigaltstack().\n\t\t */\n\t\tnext = find_next_ret_chain(ri);\n\t\tvalid = !next || arch_uretprobe_is_alive(next, RP_CHECK_RET, regs);\n\n\t\tinstruction_pointer_set(regs, ri->orig_ret_vaddr);\n\t\tdo {\n\t\t\tif (valid)\n\t\t\t\thandle_uretprobe_chain(ri, regs);\n\t\t\tri = free_ret_instance(ri);\n\t\t\tutask->depth--;\n\t\t} while (ri != next);\n\t} while (!valid);\n\n\tutask->return_instances = ri;\n\treturn;\n\n sigill:\n\tuprobe_warn(current, \"handle uretprobe, sending SIGILL.\");\n\tforce_sig(SIGILL, current);\n\n}"
  },
  {
    "function_name": "find_next_ret_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2075-2085",
    "snippet": "static struct return_instance *find_next_ret_chain(struct return_instance *ri)\n{\n\tbool chained;\n\n\tdo {\n\t\tchained = ri->chained;\n\t\tri = ri->next;\t/* can't be NULL if chained */\n\t} while (chained);\n\n\treturn ri;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *find_next_ret_chain(struct return_instance *ri)\n{\n\tbool chained;\n\n\tdo {\n\t\tchained = ri->chained;\n\t\tri = ri->next;\t/* can't be NULL if chained */\n\t} while (chained);\n\n\treturn ri;\n}"
  },
  {
    "function_name": "handle_uretprobe_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2061-2073",
    "snippet": "static void\nhandle_uretprobe_chain(struct return_instance *ri, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe = ri->uprobe;\n\tstruct uprobe_consumer *uc;\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tif (uc->ret_handler)\n\t\t\tuc->ret_handler(uc, ri->func, regs);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uc->ret_handler",
          "args": [
            "uc",
            "ri->func",
            "regs"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\nhandle_uretprobe_chain(struct return_instance *ri, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe = ri->uprobe;\n\tstruct uprobe_consumer *uc;\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tif (uc->ret_handler)\n\t\t\tuc->ret_handler(uc, ri->func, regs);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}"
  },
  {
    "function_name": "handler_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2029-2059",
    "snippet": "static void handler_chain(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_consumer *uc;\n\tint remove = UPROBE_HANDLER_REMOVE;\n\tbool need_prep = false; /* prepare return uprobe, when needed */\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tint rc = 0;\n\n\t\tif (uc->handler) {\n\t\t\trc = uc->handler(uc, regs);\n\t\t\tWARN(rc & ~UPROBE_HANDLER_MASK,\n\t\t\t\t\"bad rc=0x%x from %pf()\\n\", rc, uc->handler);\n\t\t}\n\n\t\tif (uc->ret_handler)\n\t\t\tneed_prep = true;\n\n\t\tremove &= rc;\n\t}\n\n\tif (need_prep && !remove)\n\t\tprepare_uretprobe(uprobe, regs); /* put bp at return */\n\n\tif (remove && uprobe->consumers) {\n\t\tWARN_ON(!uprobe_is_active(uprobe));\n\t\tunapply_uprobe(uprobe, current->mm);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unapply_uprobe",
          "args": [
            "uprobe",
            "current->mm"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "unapply_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1197-1222",
          "snippet": "static int unapply_uprobe(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tdown_read(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tunsigned long vaddr;\n\t\tloff_t offset;\n\n\t\tif (!valid_vma(vma, false) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tcontinue;\n\n\t\toffset = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t\tif (uprobe->offset <  offset ||\n\t\t    uprobe->offset >= offset + vma->vm_end - vma->vm_start)\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\terr |= remove_breakpoint(uprobe, mm, vaddr);\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int unapply_uprobe(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tdown_read(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tunsigned long vaddr;\n\t\tloff_t offset;\n\n\t\tif (!valid_vma(vma, false) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tcontinue;\n\n\t\toffset = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t\tif (uprobe->offset <  offset ||\n\t\t    uprobe->offset >= offset + vma->vm_end - vma->vm_start)\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\terr |= remove_breakpoint(uprobe, mm, vaddr);\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe_is_active(uprobe)"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_is_active",
          "args": [
            "uprobe"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_is_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "899-902",
          "snippet": "static inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_uretprobe",
          "args": [
            "uprobe",
            "regs"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_uretprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1820-1884",
          "snippet": "static void prepare_uretprobe(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct return_instance *ri;\n\tstruct uprobe_task *utask;\n\tunsigned long orig_ret_vaddr, trampoline_vaddr;\n\tbool chained;\n\n\tif (!get_xol_area())\n\t\treturn;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->depth >= MAX_URETPROBE_DEPTH) {\n\t\tprintk_ratelimited(KERN_INFO \"uprobe: omit uretprobe due to\"\n\t\t\t\t\" nestedness limit pid/tgid=%d/%d\\n\",\n\t\t\t\tcurrent->pid, current->tgid);\n\t\treturn;\n\t}\n\n\tri = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\tif (!ri)\n\t\treturn;\n\n\ttrampoline_vaddr = get_trampoline_vaddr();\n\torig_ret_vaddr = arch_uretprobe_hijack_return_addr(trampoline_vaddr, regs);\n\tif (orig_ret_vaddr == -1)\n\t\tgoto fail;\n\n\t/* drop the entries invalidated by longjmp() */\n\tchained = (orig_ret_vaddr == trampoline_vaddr);\n\tcleanup_return_instances(utask, chained, regs);\n\n\t/*\n\t * We don't want to keep trampoline address in stack, rather keep the\n\t * original return address of first caller thru all the consequent\n\t * instances. This also makes breakpoint unwrapping easier.\n\t */\n\tif (chained) {\n\t\tif (!utask->return_instances) {\n\t\t\t/*\n\t\t\t * This situation is not possible. Likely we have an\n\t\t\t * attack from user-space.\n\t\t\t */\n\t\t\tuprobe_warn(current, \"handle tail call\");\n\t\t\tgoto fail;\n\t\t}\n\t\torig_ret_vaddr = utask->return_instances->orig_ret_vaddr;\n\t}\n\n\tri->uprobe = get_uprobe(uprobe);\n\tri->func = instruction_pointer(regs);\n\tri->stack = user_stack_pointer(regs);\n\tri->orig_ret_vaddr = orig_ret_vaddr;\n\tri->chained = chained;\n\n\tutask->depth++;\n\tri->next = utask->return_instances;\n\tutask->return_instances = ri;\n\n\treturn;\n fail:\n\tkfree(ri);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void prepare_uretprobe(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct return_instance *ri;\n\tstruct uprobe_task *utask;\n\tunsigned long orig_ret_vaddr, trampoline_vaddr;\n\tbool chained;\n\n\tif (!get_xol_area())\n\t\treturn;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->depth >= MAX_URETPROBE_DEPTH) {\n\t\tprintk_ratelimited(KERN_INFO \"uprobe: omit uretprobe due to\"\n\t\t\t\t\" nestedness limit pid/tgid=%d/%d\\n\",\n\t\t\t\tcurrent->pid, current->tgid);\n\t\treturn;\n\t}\n\n\tri = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\tif (!ri)\n\t\treturn;\n\n\ttrampoline_vaddr = get_trampoline_vaddr();\n\torig_ret_vaddr = arch_uretprobe_hijack_return_addr(trampoline_vaddr, regs);\n\tif (orig_ret_vaddr == -1)\n\t\tgoto fail;\n\n\t/* drop the entries invalidated by longjmp() */\n\tchained = (orig_ret_vaddr == trampoline_vaddr);\n\tcleanup_return_instances(utask, chained, regs);\n\n\t/*\n\t * We don't want to keep trampoline address in stack, rather keep the\n\t * original return address of first caller thru all the consequent\n\t * instances. This also makes breakpoint unwrapping easier.\n\t */\n\tif (chained) {\n\t\tif (!utask->return_instances) {\n\t\t\t/*\n\t\t\t * This situation is not possible. Likely we have an\n\t\t\t * attack from user-space.\n\t\t\t */\n\t\t\tuprobe_warn(current, \"handle tail call\");\n\t\t\tgoto fail;\n\t\t}\n\t\torig_ret_vaddr = utask->return_instances->orig_ret_vaddr;\n\t}\n\n\tri->uprobe = get_uprobe(uprobe);\n\tri->func = instruction_pointer(regs);\n\tri->stack = user_stack_pointer(regs);\n\tri->orig_ret_vaddr = orig_ret_vaddr;\n\tri->chained = chained;\n\n\tutask->depth++;\n\tri->next = utask->return_instances;\n\tutask->return_instances = ri;\n\n\treturn;\n fail:\n\tkfree(ri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "rc & ~UPROBE_HANDLER_MASK",
            "\"bad rc=0x%x from %pf()\\n\"",
            "rc",
            "uc->handler"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uc->handler",
          "args": [
            "uc",
            "regs"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handler_chain(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_consumer *uc;\n\tint remove = UPROBE_HANDLER_REMOVE;\n\tbool need_prep = false; /* prepare return uprobe, when needed */\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tint rc = 0;\n\n\t\tif (uc->handler) {\n\t\t\trc = uc->handler(uc, regs);\n\t\t\tWARN(rc & ~UPROBE_HANDLER_MASK,\n\t\t\t\t\"bad rc=0x%x from %pf()\\n\", rc, uc->handler);\n\t\t}\n\n\t\tif (uc->ret_handler)\n\t\t\tneed_prep = true;\n\n\t\tremove &= rc;\n\t}\n\n\tif (need_prep && !remove)\n\t\tprepare_uretprobe(uprobe, regs); /* put bp at return */\n\n\tif (remove && uprobe->consumers) {\n\t\tWARN_ON(!uprobe_is_active(uprobe));\n\t\tunapply_uprobe(uprobe, current->mm);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}"
  },
  {
    "function_name": "find_active_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "2000-2027",
    "snippet": "static struct uprobe *find_active_uprobe(unsigned long bp_vaddr, int *is_swbp)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct uprobe *uprobe = NULL;\n\tstruct vm_area_struct *vma;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, bp_vaddr);\n\tif (vma && vma->vm_start <= bp_vaddr) {\n\t\tif (valid_vma(vma, false)) {\n\t\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\t\tloff_t offset = vaddr_to_offset(vma, bp_vaddr);\n\n\t\t\tuprobe = find_uprobe(inode, offset);\n\t\t}\n\n\t\tif (!uprobe)\n\t\t\t*is_swbp = is_trap_at_addr(mm, bp_vaddr);\n\t} else {\n\t\t*is_swbp = -EFAULT;\n\t}\n\n\tif (!uprobe && test_and_clear_bit(MMF_RECALC_UPROBES, &mm->flags))\n\t\tmmf_recalc_uprobes(mm);\n\tup_read(&mm->mmap_sem);\n\n\treturn uprobe;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmf_recalc_uprobes",
          "args": [
            "mm"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "mmf_recalc_uprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1949-1967",
          "snippet": "static void mmf_recalc_uprobes(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (!valid_vma(vma, false))\n\t\t\tcontinue;\n\t\t/*\n\t\t * This is not strictly accurate, we can race with\n\t\t * uprobe_unregister() and see the already removed\n\t\t * uprobe if delete_uprobe() was not yet called.\n\t\t * Or this uprobe can be filtered out.\n\t\t */\n\t\tif (vma_has_uprobes(vma, vma->vm_start, vma->vm_end))\n\t\t\treturn;\n\t}\n\n\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void mmf_recalc_uprobes(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (!valid_vma(vma, false))\n\t\t\tcontinue;\n\t\t/*\n\t\t * This is not strictly accurate, we can race with\n\t\t * uprobe_unregister() and see the already removed\n\t\t * uprobe if delete_uprobe() was not yet called.\n\t\t * Or this uprobe can be filtered out.\n\t\t */\n\t\tif (vma_has_uprobes(vma, vma->vm_start, vma->vm_end))\n\t\t\treturn;\n\t}\n\n\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "MMF_RECALC_UPROBES",
            "&mm->flags"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_trap_at_addr",
          "args": [
            "mm",
            "bp_vaddr"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "is_trap_at_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1969-1998",
          "snippet": "static int is_trap_at_addr(struct mm_struct *mm, unsigned long vaddr)\n{\n\tstruct page *page;\n\tuprobe_opcode_t opcode;\n\tint result;\n\n\tpagefault_disable();\n\tresult = __get_user(opcode, (uprobe_opcode_t __user *)vaddr);\n\tpagefault_enable();\n\n\tif (likely(result == 0))\n\t\tgoto out;\n\n\t/*\n\t * The NULL 'tsk' here ensures that any faults that occur here\n\t * will not be accounted to the task.  'mm' *is* current->mm,\n\t * but we treat this as a 'remote' access since it is\n\t * essentially a kernel access to the memory.\n\t */\n\tresult = get_user_pages_remote(NULL, mm, vaddr, 1, FOLL_FORCE, &page,\n\t\t\tNULL, NULL);\n\tif (result < 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\tput_page(page);\n out:\n\t/* This needs to return true for any variant of the trap insn */\n\treturn is_trap_insn(&opcode);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int is_trap_at_addr(struct mm_struct *mm, unsigned long vaddr)\n{\n\tstruct page *page;\n\tuprobe_opcode_t opcode;\n\tint result;\n\n\tpagefault_disable();\n\tresult = __get_user(opcode, (uprobe_opcode_t __user *)vaddr);\n\tpagefault_enable();\n\n\tif (likely(result == 0))\n\t\tgoto out;\n\n\t/*\n\t * The NULL 'tsk' here ensures that any faults that occur here\n\t * will not be accounted to the task.  'mm' *is* current->mm,\n\t * but we treat this as a 'remote' access since it is\n\t * essentially a kernel access to the memory.\n\t */\n\tresult = get_user_pages_remote(NULL, mm, vaddr, 1, FOLL_FORCE, &page,\n\t\t\tNULL, NULL);\n\tif (result < 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\tput_page(page);\n out:\n\t/* This needs to return true for any variant of the trap insn */\n\treturn is_trap_insn(&opcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_uprobe",
          "args": [
            "inode",
            "offset"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "find_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "622-631",
          "snippet": "static struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vaddr_to_offset",
          "args": [
            "vma",
            "bp_vaddr"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "vaddr_to_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "148-151",
          "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "false"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "133-141",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "bp_vaddr"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *find_active_uprobe(unsigned long bp_vaddr, int *is_swbp)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct uprobe *uprobe = NULL;\n\tstruct vm_area_struct *vma;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, bp_vaddr);\n\tif (vma && vma->vm_start <= bp_vaddr) {\n\t\tif (valid_vma(vma, false)) {\n\t\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\t\tloff_t offset = vaddr_to_offset(vma, bp_vaddr);\n\n\t\t\tuprobe = find_uprobe(inode, offset);\n\t\t}\n\n\t\tif (!uprobe)\n\t\t\t*is_swbp = is_trap_at_addr(mm, bp_vaddr);\n\t} else {\n\t\t*is_swbp = -EFAULT;\n\t}\n\n\tif (!uprobe && test_and_clear_bit(MMF_RECALC_UPROBES, &mm->flags))\n\t\tmmf_recalc_uprobes(mm);\n\tup_read(&mm->mmap_sem);\n\n\treturn uprobe;\n}"
  },
  {
    "function_name": "is_trap_at_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1969-1998",
    "snippet": "static int is_trap_at_addr(struct mm_struct *mm, unsigned long vaddr)\n{\n\tstruct page *page;\n\tuprobe_opcode_t opcode;\n\tint result;\n\n\tpagefault_disable();\n\tresult = __get_user(opcode, (uprobe_opcode_t __user *)vaddr);\n\tpagefault_enable();\n\n\tif (likely(result == 0))\n\t\tgoto out;\n\n\t/*\n\t * The NULL 'tsk' here ensures that any faults that occur here\n\t * will not be accounted to the task.  'mm' *is* current->mm,\n\t * but we treat this as a 'remote' access since it is\n\t * essentially a kernel access to the memory.\n\t */\n\tresult = get_user_pages_remote(NULL, mm, vaddr, 1, FOLL_FORCE, &page,\n\t\t\tNULL, NULL);\n\tif (result < 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\tput_page(page);\n out:\n\t/* This needs to return true for any variant of the trap insn */\n\treturn is_trap_insn(&opcode);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_trap_insn",
          "args": [
            "&opcode"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "is_trap_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "248-251",
          "snippet": "bool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_page",
          "args": [
            "page",
            "vaddr",
            "&opcode",
            "UPROBE_SWBP_INSN_SIZE"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "copy_from_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "253-258",
          "snippet": "static void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_pages_remote",
          "args": [
            "NULL",
            "mm",
            "vaddr",
            "1",
            "FOLL_FORCE",
            "&page",
            "NULL",
            "NULL"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "result == 0"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagefault_enable",
          "args": [],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "opcode",
            "(uprobe_opcode_t __user *)vaddr"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagefault_disable",
          "args": [],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int is_trap_at_addr(struct mm_struct *mm, unsigned long vaddr)\n{\n\tstruct page *page;\n\tuprobe_opcode_t opcode;\n\tint result;\n\n\tpagefault_disable();\n\tresult = __get_user(opcode, (uprobe_opcode_t __user *)vaddr);\n\tpagefault_enable();\n\n\tif (likely(result == 0))\n\t\tgoto out;\n\n\t/*\n\t * The NULL 'tsk' here ensures that any faults that occur here\n\t * will not be accounted to the task.  'mm' *is* current->mm,\n\t * but we treat this as a 'remote' access since it is\n\t * essentially a kernel access to the memory.\n\t */\n\tresult = get_user_pages_remote(NULL, mm, vaddr, 1, FOLL_FORCE, &page,\n\t\t\tNULL, NULL);\n\tif (result < 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\tput_page(page);\n out:\n\t/* This needs to return true for any variant of the trap insn */\n\treturn is_trap_insn(&opcode);\n}"
  },
  {
    "function_name": "mmf_recalc_uprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1949-1967",
    "snippet": "static void mmf_recalc_uprobes(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (!valid_vma(vma, false))\n\t\t\tcontinue;\n\t\t/*\n\t\t * This is not strictly accurate, we can race with\n\t\t * uprobe_unregister() and see the already removed\n\t\t * uprobe if delete_uprobe() was not yet called.\n\t\t * Or this uprobe can be filtered out.\n\t\t */\n\t\tif (vma_has_uprobes(vma, vma->vm_start, vma->vm_end))\n\t\t\treturn;\n\t}\n\n\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&mm->flags"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_has_uprobes",
          "args": [
            "vma",
            "vma->vm_start",
            "vma->vm_end"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "vma_has_uprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1362-1379",
          "snippet": "static bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "false"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "133-141",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void mmf_recalc_uprobes(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (!valid_vma(vma, false))\n\t\t\tcontinue;\n\t\t/*\n\t\t * This is not strictly accurate, we can race with\n\t\t * uprobe_unregister() and see the already removed\n\t\t * uprobe if delete_uprobe() was not yet called.\n\t\t * Or this uprobe can be filtered out.\n\t\t */\n\t\tif (vma_has_uprobes(vma, vma->vm_start, vma->vm_end))\n\t\t\treturn;\n\t}\n\n\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n}"
  },
  {
    "function_name": "uprobe_deny_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1925-1947",
    "snippet": "bool uprobe_deny_signal(void)\n{\n\tstruct task_struct *t = current;\n\tstruct uprobe_task *utask = t->utask;\n\n\tif (likely(!utask || !utask->active_uprobe))\n\t\treturn false;\n\n\tWARN_ON_ONCE(utask->state != UTASK_SSTEP);\n\n\tif (signal_pending(t)) {\n\t\tspin_lock_irq(&t->sighand->siglock);\n\t\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\tspin_unlock_irq(&t->sighand->siglock);\n\n\t\tif (__fatal_signal_pending(t) || arch_uprobe_xol_was_trapped(t)) {\n\t\t\tutask->state = UTASK_SSTEP_TRAPPED;\n\t\t\tset_tsk_thread_flag(t, TIF_UPROBE);\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "t",
            "TIF_UPROBE"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uprobe_xol_was_trapped",
          "args": [
            "t"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "t"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "t",
            "TIF_SIGPENDING"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "t"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "utask->state != UTASK_SSTEP"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!utask || !utask->active_uprobe"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool uprobe_deny_signal(void)\n{\n\tstruct task_struct *t = current;\n\tstruct uprobe_task *utask = t->utask;\n\n\tif (likely(!utask || !utask->active_uprobe))\n\t\treturn false;\n\n\tWARN_ON_ONCE(utask->state != UTASK_SSTEP);\n\n\tif (signal_pending(t)) {\n\t\tspin_lock_irq(&t->sighand->siglock);\n\t\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\tspin_unlock_irq(&t->sighand->siglock);\n\n\t\tif (__fatal_signal_pending(t) || arch_uprobe_xol_was_trapped(t)) {\n\t\t\tutask->state = UTASK_SSTEP_TRAPPED;\n\t\t\tset_tsk_thread_flag(t, TIF_UPROBE);\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "pre_ssout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1887-1914",
    "snippet": "static int\npre_ssout(struct uprobe *uprobe, struct pt_regs *regs, unsigned long bp_vaddr)\n{\n\tstruct uprobe_task *utask;\n\tunsigned long xol_vaddr;\n\tint err;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn -ENOMEM;\n\n\txol_vaddr = xol_get_insn_slot(uprobe);\n\tif (!xol_vaddr)\n\t\treturn -ENOMEM;\n\n\tutask->xol_vaddr = xol_vaddr;\n\tutask->vaddr = bp_vaddr;\n\n\terr = arch_uprobe_pre_xol(&uprobe->arch, regs);\n\tif (unlikely(err)) {\n\t\txol_free_insn_slot(current);\n\t\treturn err;\n\t}\n\n\tutask->active_uprobe = uprobe;\n\tutask->state = UTASK_SSTEP;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xol_free_insn_slot",
          "args": [
            "current"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "xol_free_insn_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1594-1626",
          "snippet": "static void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uprobe_pre_xol",
          "args": [
            "&uprobe->arch",
            "regs"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xol_get_insn_slot",
          "args": [
            "uprobe"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "xol_get_insn_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1570-1587",
          "snippet": "static unsigned long xol_get_insn_slot(struct uprobe *uprobe)\n{\n\tstruct xol_area *area;\n\tunsigned long xol_vaddr;\n\n\tarea = get_xol_area();\n\tif (!area)\n\t\treturn 0;\n\n\txol_vaddr = xol_take_insn_slot(area);\n\tif (unlikely(!xol_vaddr))\n\t\treturn 0;\n\n\tarch_uprobe_copy_ixol(area->pages[0], xol_vaddr,\n\t\t\t      &uprobe->arch.ixol, sizeof(uprobe->arch.ixol));\n\n\treturn xol_vaddr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long xol_get_insn_slot(struct uprobe *uprobe)\n{\n\tstruct xol_area *area;\n\tunsigned long xol_vaddr;\n\n\tarea = get_xol_area();\n\tif (!area)\n\t\treturn 0;\n\n\txol_vaddr = xol_take_insn_slot(area);\n\tif (unlikely(!xol_vaddr))\n\t\treturn 0;\n\n\tarch_uprobe_copy_ixol(area->pages[0], xol_vaddr,\n\t\t\t      &uprobe->arch.ixol, sizeof(uprobe->arch.ixol));\n\n\treturn xol_vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_utask",
          "args": [],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "get_utask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1704-1709",
          "snippet": "static struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\npre_ssout(struct uprobe *uprobe, struct pt_regs *regs, unsigned long bp_vaddr)\n{\n\tstruct uprobe_task *utask;\n\tunsigned long xol_vaddr;\n\tint err;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn -ENOMEM;\n\n\txol_vaddr = xol_get_insn_slot(uprobe);\n\tif (!xol_vaddr)\n\t\treturn -ENOMEM;\n\n\tutask->xol_vaddr = xol_vaddr;\n\tutask->vaddr = bp_vaddr;\n\n\terr = arch_uprobe_pre_xol(&uprobe->arch, regs);\n\tif (unlikely(err)) {\n\t\txol_free_insn_slot(current);\n\t\treturn err;\n\t}\n\n\tutask->active_uprobe = uprobe;\n\tutask->state = UTASK_SSTEP;\n\treturn 0;\n}"
  },
  {
    "function_name": "prepare_uretprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1820-1884",
    "snippet": "static void prepare_uretprobe(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct return_instance *ri;\n\tstruct uprobe_task *utask;\n\tunsigned long orig_ret_vaddr, trampoline_vaddr;\n\tbool chained;\n\n\tif (!get_xol_area())\n\t\treturn;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->depth >= MAX_URETPROBE_DEPTH) {\n\t\tprintk_ratelimited(KERN_INFO \"uprobe: omit uretprobe due to\"\n\t\t\t\t\" nestedness limit pid/tgid=%d/%d\\n\",\n\t\t\t\tcurrent->pid, current->tgid);\n\t\treturn;\n\t}\n\n\tri = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\tif (!ri)\n\t\treturn;\n\n\ttrampoline_vaddr = get_trampoline_vaddr();\n\torig_ret_vaddr = arch_uretprobe_hijack_return_addr(trampoline_vaddr, regs);\n\tif (orig_ret_vaddr == -1)\n\t\tgoto fail;\n\n\t/* drop the entries invalidated by longjmp() */\n\tchained = (orig_ret_vaddr == trampoline_vaddr);\n\tcleanup_return_instances(utask, chained, regs);\n\n\t/*\n\t * We don't want to keep trampoline address in stack, rather keep the\n\t * original return address of first caller thru all the consequent\n\t * instances. This also makes breakpoint unwrapping easier.\n\t */\n\tif (chained) {\n\t\tif (!utask->return_instances) {\n\t\t\t/*\n\t\t\t * This situation is not possible. Likely we have an\n\t\t\t * attack from user-space.\n\t\t\t */\n\t\t\tuprobe_warn(current, \"handle tail call\");\n\t\t\tgoto fail;\n\t\t}\n\t\torig_ret_vaddr = utask->return_instances->orig_ret_vaddr;\n\t}\n\n\tri->uprobe = get_uprobe(uprobe);\n\tri->func = instruction_pointer(regs);\n\tri->stack = user_stack_pointer(regs);\n\tri->orig_ret_vaddr = orig_ret_vaddr;\n\tri->chained = chained;\n\n\tutask->depth++;\n\tri->next = utask->return_instances;\n\tutask->return_instances = ri;\n\n\treturn;\n fail:\n\tkfree(ri);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_stack_pointer",
          "args": [
            "regs"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "get_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "561-565",
          "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_warn",
          "args": [
            "current",
            "\"handle tail call\""
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1739-1743",
          "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_return_instances",
          "args": [
            "utask",
            "chained",
            "regs"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_return_instances",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1807-1818",
          "snippet": "static void cleanup_return_instances(struct uprobe_task *utask, bool chained,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct return_instance *ri = utask->return_instances;\n\tenum rp_check ctx = chained ? RP_CHECK_CHAIN_CALL : RP_CHECK_CALL;\n\n\twhile (ri && !arch_uretprobe_is_alive(ri, ctx, regs)) {\n\t\tri = free_ret_instance(ri);\n\t\tutask->depth--;\n\t}\n\tutask->return_instances = ri;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void cleanup_return_instances(struct uprobe_task *utask, bool chained,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct return_instance *ri = utask->return_instances;\n\tenum rp_check ctx = chained ? RP_CHECK_CHAIN_CALL : RP_CHECK_CALL;\n\n\twhile (ri && !arch_uretprobe_is_alive(ri, ctx, regs)) {\n\t\tri = free_ret_instance(ri);\n\t\tutask->depth--;\n\t}\n\tutask->return_instances = ri;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_uretprobe_hijack_return_addr",
          "args": [
            "trampoline_vaddr",
            "regs"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_trampoline_vaddr",
          "args": [],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "get_trampoline_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1794-1805",
          "snippet": "static unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct return_instance)",
            "GFP_KERNEL"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_INFO \"uprobe: omit uretprobe due to\"\n\t\t\t\t\" nestedness limit pid/tgid=%d/%d\\n\"",
            "current->pid",
            "current->tgid"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_utask",
          "args": [],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "get_utask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1704-1709",
          "snippet": "static struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xol_area",
          "args": [],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "get_xol_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1489-1500",
          "snippet": "static struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void prepare_uretprobe(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct return_instance *ri;\n\tstruct uprobe_task *utask;\n\tunsigned long orig_ret_vaddr, trampoline_vaddr;\n\tbool chained;\n\n\tif (!get_xol_area())\n\t\treturn;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->depth >= MAX_URETPROBE_DEPTH) {\n\t\tprintk_ratelimited(KERN_INFO \"uprobe: omit uretprobe due to\"\n\t\t\t\t\" nestedness limit pid/tgid=%d/%d\\n\",\n\t\t\t\tcurrent->pid, current->tgid);\n\t\treturn;\n\t}\n\n\tri = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\tif (!ri)\n\t\treturn;\n\n\ttrampoline_vaddr = get_trampoline_vaddr();\n\torig_ret_vaddr = arch_uretprobe_hijack_return_addr(trampoline_vaddr, regs);\n\tif (orig_ret_vaddr == -1)\n\t\tgoto fail;\n\n\t/* drop the entries invalidated by longjmp() */\n\tchained = (orig_ret_vaddr == trampoline_vaddr);\n\tcleanup_return_instances(utask, chained, regs);\n\n\t/*\n\t * We don't want to keep trampoline address in stack, rather keep the\n\t * original return address of first caller thru all the consequent\n\t * instances. This also makes breakpoint unwrapping easier.\n\t */\n\tif (chained) {\n\t\tif (!utask->return_instances) {\n\t\t\t/*\n\t\t\t * This situation is not possible. Likely we have an\n\t\t\t * attack from user-space.\n\t\t\t */\n\t\t\tuprobe_warn(current, \"handle tail call\");\n\t\t\tgoto fail;\n\t\t}\n\t\torig_ret_vaddr = utask->return_instances->orig_ret_vaddr;\n\t}\n\n\tri->uprobe = get_uprobe(uprobe);\n\tri->func = instruction_pointer(regs);\n\tri->stack = user_stack_pointer(regs);\n\tri->orig_ret_vaddr = orig_ret_vaddr;\n\tri->chained = chained;\n\n\tutask->depth++;\n\tri->next = utask->return_instances;\n\tutask->return_instances = ri;\n\n\treturn;\n fail:\n\tkfree(ri);\n}"
  },
  {
    "function_name": "cleanup_return_instances",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1807-1818",
    "snippet": "static void cleanup_return_instances(struct uprobe_task *utask, bool chained,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct return_instance *ri = utask->return_instances;\n\tenum rp_check ctx = chained ? RP_CHECK_CHAIN_CALL : RP_CHECK_CALL;\n\n\twhile (ri && !arch_uretprobe_is_alive(ri, ctx, regs)) {\n\t\tri = free_ret_instance(ri);\n\t\tutask->depth--;\n\t}\n\tutask->return_instances = ri;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ret_instance",
          "args": [
            "ri"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "free_ret_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1664-1670",
          "snippet": "static struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_uretprobe_is_alive",
          "args": [
            "ri",
            "ctx",
            "regs"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "arch_uretprobe_is_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "2134-2138",
          "snippet": "bool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void cleanup_return_instances(struct uprobe_task *utask, bool chained,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct return_instance *ri = utask->return_instances;\n\tenum rp_check ctx = chained ? RP_CHECK_CHAIN_CALL : RP_CHECK_CALL;\n\n\twhile (ri && !arch_uretprobe_is_alive(ri, ctx, regs)) {\n\t\tri = free_ret_instance(ri);\n\t\tutask->depth--;\n\t}\n\tutask->return_instances = ri;\n}"
  },
  {
    "function_name": "get_trampoline_vaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1794-1805",
    "snippet": "static unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current->mm->uprobes_state.xol_area"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}"
  },
  {
    "function_name": "uprobe_copy_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1758-1786",
    "snippet": "void uprobe_copy_process(struct task_struct *t, unsigned long flags)\n{\n\tstruct uprobe_task *utask = current->utask;\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tt->utask = NULL;\n\n\tif (!utask || !utask->return_instances)\n\t\treturn;\n\n\tif (mm == t->mm && !(flags & CLONE_VFORK))\n\t\treturn;\n\n\tif (dup_utask(t, utask))\n\t\treturn uprobe_warn(t, \"dup ret instances\");\n\n\t/* The task can fork() after dup_xol_work() fails */\n\tarea = mm->uprobes_state.xol_area;\n\tif (!area)\n\t\treturn uprobe_warn(t, \"dup xol area\");\n\n\tif (mm == t->mm)\n\t\treturn;\n\n\tt->utask->dup_xol_addr = area->vaddr;\n\tinit_task_work(&t->utask->dup_xol_work, dup_xol_work);\n\ttask_work_add(t, &t->utask->dup_xol_work, true);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_work_add",
          "args": [
            "t",
            "&t->utask->dup_xol_work",
            "true"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/task_work.c",
          "lines": "27-42",
          "snippet": "int\ntask_work_add(struct task_struct *task, struct callback_head *work, bool notify)\n{\n\tstruct callback_head *head;\n\n\tdo {\n\t\thead = READ_ONCE(task->task_works);\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (cmpxchg(&task->task_works, head, work) != head);\n\n\tif (notify)\n\t\tset_notify_resume(task);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/tracehook.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_head work_exited;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracehook.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nint\ntask_work_add(struct task_struct *task, struct callback_head *work, bool notify)\n{\n\tstruct callback_head *head;\n\n\tdo {\n\t\thead = READ_ONCE(task->task_works);\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (cmpxchg(&task->task_works, head, work) != head);\n\n\tif (notify)\n\t\tset_notify_resume(task);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_task_work",
          "args": [
            "&t->utask->dup_xol_work",
            "dup_xol_work"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_warn",
          "args": [
            "t",
            "\"dup xol area\""
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1739-1743",
          "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup_utask",
          "args": [
            "t",
            "utask"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "dup_utask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1711-1737",
          "snippet": "static int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)\n{\n\tstruct uprobe_task *n_utask;\n\tstruct return_instance **p, *o, *n;\n\n\tn_utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\tif (!n_utask)\n\t\treturn -ENOMEM;\n\tt->utask = n_utask;\n\n\tp = &n_utask->return_instances;\n\tfor (o = o_utask->return_instances; o; o = o->next) {\n\t\tn = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\t\tif (!n)\n\t\t\treturn -ENOMEM;\n\n\t\t*n = *o;\n\t\tget_uprobe(n->uprobe);\n\t\tn->next = NULL;\n\n\t\t*p = n;\n\t\tp = &n->next;\n\t\tn_utask->depth++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)\n{\n\tstruct uprobe_task *n_utask;\n\tstruct return_instance **p, *o, *n;\n\n\tn_utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\tif (!n_utask)\n\t\treturn -ENOMEM;\n\tt->utask = n_utask;\n\n\tp = &n_utask->return_instances;\n\tfor (o = o_utask->return_instances; o; o = o->next) {\n\t\tn = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\t\tif (!n)\n\t\t\treturn -ENOMEM;\n\n\t\t*n = *o;\n\t\tget_uprobe(n->uprobe);\n\t\tn->next = NULL;\n\n\t\t*p = n;\n\t\tp = &n->next;\n\t\tn_utask->depth++;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_copy_process(struct task_struct *t, unsigned long flags)\n{\n\tstruct uprobe_task *utask = current->utask;\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tt->utask = NULL;\n\n\tif (!utask || !utask->return_instances)\n\t\treturn;\n\n\tif (mm == t->mm && !(flags & CLONE_VFORK))\n\t\treturn;\n\n\tif (dup_utask(t, utask))\n\t\treturn uprobe_warn(t, \"dup ret instances\");\n\n\t/* The task can fork() after dup_xol_work() fails */\n\tarea = mm->uprobes_state.xol_area;\n\tif (!area)\n\t\treturn uprobe_warn(t, \"dup xol area\");\n\n\tif (mm == t->mm)\n\t\treturn;\n\n\tt->utask->dup_xol_addr = area->vaddr;\n\tinit_task_work(&t->utask->dup_xol_work, dup_xol_work);\n\ttask_work_add(t, &t->utask->dup_xol_work, true);\n}"
  },
  {
    "function_name": "dup_xol_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1745-1753",
    "snippet": "static void dup_xol_work(struct callback_head *work)\n{\n\tif (current->flags & PF_EXITING)\n\t\treturn;\n\n\tif (!__create_xol_area(current->utask->dup_xol_addr) &&\n\t\t\t!fatal_signal_pending(current))\n\t\tuprobe_warn(current, \"dup xol area\");\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_warn",
          "args": [
            "current",
            "\"dup xol area\""
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1739-1743",
          "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__create_xol_area",
          "args": [
            "current->utask->dup_xol_addr"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "__create_xol_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1441-1481",
          "snippet": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void dup_xol_work(struct callback_head *work)\n{\n\tif (current->flags & PF_EXITING)\n\t\treturn;\n\n\tif (!__create_xol_area(current->utask->dup_xol_addr) &&\n\t\t\t!fatal_signal_pending(current))\n\t\tuprobe_warn(current, \"dup xol area\");\n}"
  },
  {
    "function_name": "uprobe_warn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1739-1743",
    "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"uprobe: %s:%d failed to %s\\n\"",
            "current->comm",
            "current->pid",
            "msg"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
  },
  {
    "function_name": "dup_utask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1711-1737",
    "snippet": "static int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)\n{\n\tstruct uprobe_task *n_utask;\n\tstruct return_instance **p, *o, *n;\n\n\tn_utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\tif (!n_utask)\n\t\treturn -ENOMEM;\n\tt->utask = n_utask;\n\n\tp = &n_utask->return_instances;\n\tfor (o = o_utask->return_instances; o; o = o->next) {\n\t\tn = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\t\tif (!n)\n\t\t\treturn -ENOMEM;\n\n\t\t*n = *o;\n\t\tget_uprobe(n->uprobe);\n\t\tn->next = NULL;\n\n\t\t*p = n;\n\t\tp = &n->next;\n\t\tn_utask->depth++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_uprobe",
          "args": [
            "n->uprobe"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "get_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "561-565",
          "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct return_instance)",
            "GFP_KERNEL"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct uprobe_task)",
            "GFP_KERNEL"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)\n{\n\tstruct uprobe_task *n_utask;\n\tstruct return_instance **p, *o, *n;\n\n\tn_utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\tif (!n_utask)\n\t\treturn -ENOMEM;\n\tt->utask = n_utask;\n\n\tp = &n_utask->return_instances;\n\tfor (o = o_utask->return_instances; o; o = o->next) {\n\t\tn = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\t\tif (!n)\n\t\t\treturn -ENOMEM;\n\n\t\t*n = *o;\n\t\tget_uprobe(n->uprobe);\n\t\tn->next = NULL;\n\n\t\t*p = n;\n\t\tp = &n->next;\n\t\tn_utask->depth++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_utask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1704-1709",
    "snippet": "static struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct uprobe_task)",
            "GFP_KERNEL"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}"
  },
  {
    "function_name": "uprobe_free_utask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1676-1694",
    "snippet": "void uprobe_free_utask(struct task_struct *t)\n{\n\tstruct uprobe_task *utask = t->utask;\n\tstruct return_instance *ri;\n\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->active_uprobe)\n\t\tput_uprobe(utask->active_uprobe);\n\n\tri = utask->return_instances;\n\twhile (ri)\n\t\tri = free_ret_instance(ri);\n\n\txol_free_insn_slot(t);\n\tkfree(utask);\n\tt->utask = NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utask"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xol_free_insn_slot",
          "args": [
            "t"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "xol_free_insn_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1594-1626",
          "snippet": "static void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ret_instance",
          "args": [
            "ri"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "free_ret_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1664-1670",
          "snippet": "static struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "utask->active_uprobe"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "567-578",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_free_utask(struct task_struct *t)\n{\n\tstruct uprobe_task *utask = t->utask;\n\tstruct return_instance *ri;\n\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->active_uprobe)\n\t\tput_uprobe(utask->active_uprobe);\n\n\tri = utask->return_instances;\n\twhile (ri)\n\t\tri = free_ret_instance(ri);\n\n\txol_free_insn_slot(t);\n\tkfree(utask);\n\tt->utask = NULL;\n}"
  },
  {
    "function_name": "free_ret_instance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1664-1670",
    "snippet": "static struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "ri->uprobe"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "567-578",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}"
  },
  {
    "function_name": "uprobe_get_trap_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1654-1662",
    "snippet": "unsigned long uprobe_get_trap_addr(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tif (unlikely(utask && utask->active_uprobe))\n\t\treturn utask->vaddr;\n\n\treturn instruction_pointer(regs);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "utask && utask->active_uprobe"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nunsigned long uprobe_get_trap_addr(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tif (unlikely(utask && utask->active_uprobe))\n\t\treturn utask->vaddr;\n\n\treturn instruction_pointer(regs);\n}"
  },
  {
    "function_name": "uprobe_get_swbp_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1649-1652",
    "snippet": "unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs) - UPROBE_SWBP_INSN_SIZE;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nunsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs) - UPROBE_SWBP_INSN_SIZE;\n}"
  },
  {
    "function_name": "arch_uprobe_copy_ixol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1628-1641",
    "snippet": "void __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_range() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_page",
          "args": [
            "page",
            "vaddr",
            "src",
            "len"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "copy_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "260-265",
          "snippet": "static void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_range() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}"
  },
  {
    "function_name": "xol_free_insn_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1594-1626",
    "snippet": "static void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&area->wq"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&area->wq"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&area->slot_count"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "slot_nr",
            "area->bitmap"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!slot_addr"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}"
  },
  {
    "function_name": "xol_get_insn_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1570-1587",
    "snippet": "static unsigned long xol_get_insn_slot(struct uprobe *uprobe)\n{\n\tstruct xol_area *area;\n\tunsigned long xol_vaddr;\n\n\tarea = get_xol_area();\n\tif (!area)\n\t\treturn 0;\n\n\txol_vaddr = xol_take_insn_slot(area);\n\tif (unlikely(!xol_vaddr))\n\t\treturn 0;\n\n\tarch_uprobe_copy_ixol(area->pages[0], xol_vaddr,\n\t\t\t      &uprobe->arch.ixol, sizeof(uprobe->arch.ixol));\n\n\treturn xol_vaddr;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_uprobe_copy_ixol",
          "args": [
            "area->pages[0]",
            "xol_vaddr",
            "&uprobe->arch.ixol",
            "sizeof(uprobe->arch.ixol)"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "arch_uprobe_copy_ixol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1628-1641",
          "snippet": "void __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_range() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_range() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!xol_vaddr"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xol_take_insn_slot",
          "args": [
            "area"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "xol_take_insn_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1543-1564",
          "snippet": "static unsigned long xol_take_insn_slot(struct xol_area *area)\n{\n\tunsigned long slot_addr;\n\tint slot_nr;\n\n\tdo {\n\t\tslot_nr = find_first_zero_bit(area->bitmap, UINSNS_PER_PAGE);\n\t\tif (slot_nr < UINSNS_PER_PAGE) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->bitmap))\n\t\t\t\tbreak;\n\n\t\t\tslot_nr = UINSNS_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\t\twait_event(area->wq, (atomic_read(&area->slot_count) < UINSNS_PER_PAGE));\n\t} while (slot_nr >= UINSNS_PER_PAGE);\n\n\tslot_addr = area->vaddr + (slot_nr * UPROBE_XOL_SLOT_BYTES);\n\tatomic_inc(&area->slot_count);\n\n\treturn slot_addr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic unsigned long xol_take_insn_slot(struct xol_area *area)\n{\n\tunsigned long slot_addr;\n\tint slot_nr;\n\n\tdo {\n\t\tslot_nr = find_first_zero_bit(area->bitmap, UINSNS_PER_PAGE);\n\t\tif (slot_nr < UINSNS_PER_PAGE) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->bitmap))\n\t\t\t\tbreak;\n\n\t\t\tslot_nr = UINSNS_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\t\twait_event(area->wq, (atomic_read(&area->slot_count) < UINSNS_PER_PAGE));\n\t} while (slot_nr >= UINSNS_PER_PAGE);\n\n\tslot_addr = area->vaddr + (slot_nr * UPROBE_XOL_SLOT_BYTES);\n\tatomic_inc(&area->slot_count);\n\n\treturn slot_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xol_area",
          "args": [],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "get_xol_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1489-1500",
          "snippet": "static struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long xol_get_insn_slot(struct uprobe *uprobe)\n{\n\tstruct xol_area *area;\n\tunsigned long xol_vaddr;\n\n\tarea = get_xol_area();\n\tif (!area)\n\t\treturn 0;\n\n\txol_vaddr = xol_take_insn_slot(area);\n\tif (unlikely(!xol_vaddr))\n\t\treturn 0;\n\n\tarch_uprobe_copy_ixol(area->pages[0], xol_vaddr,\n\t\t\t      &uprobe->arch.ixol, sizeof(uprobe->arch.ixol));\n\n\treturn xol_vaddr;\n}"
  },
  {
    "function_name": "xol_take_insn_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1543-1564",
    "snippet": "static unsigned long xol_take_insn_slot(struct xol_area *area)\n{\n\tunsigned long slot_addr;\n\tint slot_nr;\n\n\tdo {\n\t\tslot_nr = find_first_zero_bit(area->bitmap, UINSNS_PER_PAGE);\n\t\tif (slot_nr < UINSNS_PER_PAGE) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->bitmap))\n\t\t\t\tbreak;\n\n\t\t\tslot_nr = UINSNS_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\t\twait_event(area->wq, (atomic_read(&area->slot_count) < UINSNS_PER_PAGE));\n\t} while (slot_nr >= UINSNS_PER_PAGE);\n\n\tslot_addr = area->vaddr + (slot_nr * UPROBE_XOL_SLOT_BYTES);\n\tatomic_inc(&area->slot_count);\n\n\treturn slot_addr;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&area->slot_count"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "area->wq",
            "(atomic_read(&area->slot_count) < UINSNS_PER_PAGE)"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&area->slot_count"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "slot_nr",
            "area->bitmap"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "area->bitmap",
            "UINSNS_PER_PAGE"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic unsigned long xol_take_insn_slot(struct xol_area *area)\n{\n\tunsigned long slot_addr;\n\tint slot_nr;\n\n\tdo {\n\t\tslot_nr = find_first_zero_bit(area->bitmap, UINSNS_PER_PAGE);\n\t\tif (slot_nr < UINSNS_PER_PAGE) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->bitmap))\n\t\t\t\tbreak;\n\n\t\t\tslot_nr = UINSNS_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\t\twait_event(area->wq, (atomic_read(&area->slot_count) < UINSNS_PER_PAGE));\n\t} while (slot_nr >= UINSNS_PER_PAGE);\n\n\tslot_addr = area->vaddr + (slot_nr * UPROBE_XOL_SLOT_BYTES);\n\tatomic_inc(&area->slot_count);\n\n\treturn slot_addr;\n}"
  },
  {
    "function_name": "uprobe_dup_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1531-1538",
    "snippet": "void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm)\n{\n\tif (test_bit(MMF_HAS_UPROBES, &oldmm->flags)) {\n\t\tset_bit(MMF_HAS_UPROBES, &newmm->flags);\n\t\t/* unconditionally, dup_mmap() skips VM_DONTCOPY vmas */\n\t\tset_bit(MMF_RECALC_UPROBES, &newmm->flags);\n\t}\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_RECALC_UPROBES",
            "&newmm->flags"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&oldmm->flags"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm)\n{\n\tif (test_bit(MMF_HAS_UPROBES, &oldmm->flags)) {\n\t\tset_bit(MMF_HAS_UPROBES, &newmm->flags);\n\t\t/* unconditionally, dup_mmap() skips VM_DONTCOPY vmas */\n\t\tset_bit(MMF_RECALC_UPROBES, &newmm->flags);\n\t}\n}"
  },
  {
    "function_name": "uprobe_end_dup_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1526-1529",
    "snippet": "void uprobe_end_dup_mmap(void)\n{\n\tpercpu_up_read(&dup_mmap_sem);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore dup_mmap_sem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_read",
          "args": [
            "&dup_mmap_sem"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_up_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "94-106",
          "snippet": "void __percpu_up_read(struct percpu_rw_semaphore *sem)\n{\n\tsmp_mb(); /* B matches C */\n\t/*\n\t * In other words, if they see our decrement (presumably to aggregate\n\t * zero, as that is the only time it matters) they will also see our\n\t * critical section.\n\t */\n\t__this_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to recheck readers_active */\n\trcuwait_wake_up(&sem->writer);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid __percpu_up_read(struct percpu_rw_semaphore *sem)\n{\n\tsmp_mb(); /* B matches C */\n\t/*\n\t * In other words, if they see our decrement (presumably to aggregate\n\t * zero, as that is the only time it matters) they will also see our\n\t * critical section.\n\t */\n\t__this_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to recheck readers_active */\n\trcuwait_wake_up(&sem->writer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore dup_mmap_sem;\n\nvoid uprobe_end_dup_mmap(void)\n{\n\tpercpu_up_read(&dup_mmap_sem);\n}"
  },
  {
    "function_name": "uprobe_start_dup_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1521-1524",
    "snippet": "void uprobe_start_dup_mmap(void)\n{\n\tpercpu_down_read(&dup_mmap_sem);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore dup_mmap_sem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_read",
          "args": [
            "&dup_mmap_sem"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore dup_mmap_sem;\n\nvoid uprobe_start_dup_mmap(void)\n{\n\tpercpu_down_read(&dup_mmap_sem);\n}"
  },
  {
    "function_name": "uprobe_clear_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1505-1519",
    "snippet": "void uprobe_clear_state(struct mm_struct *mm)\n{\n\tstruct xol_area *area = mm->uprobes_state.xol_area;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tdelayed_uprobe_remove(NULL, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\tif (!area)\n\t\treturn;\n\n\tput_page(area->pages[0]);\n\tkfree(area->bitmap);\n\tkfree(area);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(delayed_uprobe_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "area"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "area->pages[0]"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_remove",
          "args": [
            "NULL",
            "mm"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "331-349",
          "snippet": "static void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\n\nvoid uprobe_clear_state(struct mm_struct *mm)\n{\n\tstruct xol_area *area = mm->uprobes_state.xol_area;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tdelayed_uprobe_remove(NULL, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\tif (!area)\n\t\treturn;\n\n\tput_page(area->pages[0]);\n\tkfree(area->bitmap);\n\tkfree(area);\n}"
  },
  {
    "function_name": "get_xol_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1489-1500",
    "snippet": "static struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "mm->uprobes_state.xol_area"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__create_xol_area",
          "args": [
            "0"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "__create_xol_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1441-1481",
          "snippet": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}"
  },
  {
    "function_name": "__create_xol_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1441-1481",
    "snippet": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "area"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "area->pages[0]"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xol_add_vma",
          "args": [
            "mm",
            "area"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "xol_add_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1401-1439",
          "snippet": "static int xol_add_vma(struct mm_struct *mm, struct xol_area *area)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tif (mm->uprobes_state.xol_area) {\n\t\tret = -EALREADY;\n\t\tgoto fail;\n\t}\n\n\tif (!area->vaddr) {\n\t\t/* Try to map as high as possible, this is only a hint. */\n\t\tarea->vaddr = get_unmapped_area(NULL, TASK_SIZE - PAGE_SIZE,\n\t\t\t\t\t\tPAGE_SIZE, 0, 0);\n\t\tif (area->vaddr & ~PAGE_MASK) {\n\t\t\tret = area->vaddr;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tvma = _install_special_mapping(mm, area->vaddr, PAGE_SIZE,\n\t\t\t\tVM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO,\n\t\t\t\t&area->xol_mapping);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\t/* pairs with get_xol_area() */\n\tsmp_store_release(&mm->uprobes_state.xol_area, area); /* ^^^ */\n fail:\n\tup_write(&mm->mmap_sem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int xol_add_vma(struct mm_struct *mm, struct xol_area *area)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tif (mm->uprobes_state.xol_area) {\n\t\tret = -EALREADY;\n\t\tgoto fail;\n\t}\n\n\tif (!area->vaddr) {\n\t\t/* Try to map as high as possible, this is only a hint. */\n\t\tarea->vaddr = get_unmapped_area(NULL, TASK_SIZE - PAGE_SIZE,\n\t\t\t\t\t\tPAGE_SIZE, 0, 0);\n\t\tif (area->vaddr & ~PAGE_MASK) {\n\t\t\tret = area->vaddr;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tvma = _install_special_mapping(mm, area->vaddr, PAGE_SIZE,\n\t\t\t\tVM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO,\n\t\t\t\t&area->xol_mapping);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\t/* pairs with get_xol_area() */\n\tsmp_store_release(&mm->uprobes_state.xol_area, area); /* ^^^ */\n fail:\n\tup_write(&mm->mmap_sem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_uprobe_copy_ixol",
          "args": [
            "area->pages[0]",
            "0",
            "&insn",
            "UPROBE_SWBP_INSN_SIZE"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "arch_uprobe_copy_ixol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1628-1641",
          "snippet": "void __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_range() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_range() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&area->slot_count",
            "1"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "0",
            "area->bitmap"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&area->wq"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_HIGHUSER"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mmap_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "715-726",
          "snippet": "static void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "BITS_TO_LONGS(UINSNS_PER_PAGE)",
            "sizeof(long)",
            "GFP_KERNEL"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "UINSNS_PER_PAGE"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!area"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*area)",
            "GFP_KERNEL"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}"
  },
  {
    "function_name": "xol_add_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1401-1439",
    "snippet": "static int xol_add_vma(struct mm_struct *mm, struct xol_area *area)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tif (mm->uprobes_state.xol_area) {\n\t\tret = -EALREADY;\n\t\tgoto fail;\n\t}\n\n\tif (!area->vaddr) {\n\t\t/* Try to map as high as possible, this is only a hint. */\n\t\tarea->vaddr = get_unmapped_area(NULL, TASK_SIZE - PAGE_SIZE,\n\t\t\t\t\t\tPAGE_SIZE, 0, 0);\n\t\tif (area->vaddr & ~PAGE_MASK) {\n\t\t\tret = area->vaddr;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tvma = _install_special_mapping(mm, area->vaddr, PAGE_SIZE,\n\t\t\t\tVM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO,\n\t\t\t\t&area->xol_mapping);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\t/* pairs with get_xol_area() */\n\tsmp_store_release(&mm->uprobes_state.xol_area, area); /* ^^^ */\n fail:\n\tup_write(&mm->mmap_sem);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&mm->uprobes_state.xol_area",
            "area"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vma"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vma"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_install_special_mapping",
          "args": [
            "mm",
            "area->vaddr",
            "PAGE_SIZE",
            "VM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO",
            "&area->xol_mapping"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unmapped_area",
          "args": [
            "NULL",
            "TASK_SIZE - PAGE_SIZE",
            "PAGE_SIZE",
            "0",
            "0"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "down_write_killable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "81-93",
          "snippet": "int __sched down_write_killable(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\tif (LOCK_CONTENDED_RETURN(sem, __down_write_trylock, __down_write_killable)) {\n\t\trwsem_release(&sem->dep_map, 1, _RET_IP_);\n\t\treturn -EINTR;\n\t}\n\n\trwsem_set_owner(sem);\n\treturn 0;\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint __sched down_write_killable(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\tif (LOCK_CONTENDED_RETURN(sem, __down_write_trylock, __down_write_killable)) {\n\t\trwsem_release(&sem->dep_map, 1, _RET_IP_);\n\t\treturn -EINTR;\n\t}\n\n\trwsem_set_owner(sem);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int xol_add_vma(struct mm_struct *mm, struct xol_area *area)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tif (mm->uprobes_state.xol_area) {\n\t\tret = -EALREADY;\n\t\tgoto fail;\n\t}\n\n\tif (!area->vaddr) {\n\t\t/* Try to map as high as possible, this is only a hint. */\n\t\tarea->vaddr = get_unmapped_area(NULL, TASK_SIZE - PAGE_SIZE,\n\t\t\t\t\t\tPAGE_SIZE, 0, 0);\n\t\tif (area->vaddr & ~PAGE_MASK) {\n\t\t\tret = area->vaddr;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tvma = _install_special_mapping(mm, area->vaddr, PAGE_SIZE,\n\t\t\t\tVM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO,\n\t\t\t\t&area->xol_mapping);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\t/* pairs with get_xol_area() */\n\tsmp_store_release(&mm->uprobes_state.xol_area, area); /* ^^^ */\n fail:\n\tup_write(&mm->mmap_sem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "uprobe_munmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1384-1398",
    "snippet": "void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tif (no_uprobe_events() || !valid_vma(vma, false))\n\t\treturn;\n\n\tif (!atomic_read(&vma->vm_mm->mm_users)) /* called by mmput() ? */\n\t\treturn;\n\n\tif (!test_bit(MMF_HAS_UPROBES, &vma->vm_mm->flags) ||\n\t     test_bit(MMF_RECALC_UPROBES, &vma->vm_mm->flags))\n\t\treturn;\n\n\tif (vma_has_uprobes(vma, start, end))\n\t\tset_bit(MMF_RECALC_UPROBES, &vma->vm_mm->flags);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_RECALC_UPROBES",
            "&vma->vm_mm->flags"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_has_uprobes",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "vma_has_uprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1362-1379",
          "snippet": "static bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_RECALC_UPROBES",
            "&vma->vm_mm->flags"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vma->vm_mm->mm_users"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "false"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "133-141",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_uprobe_events",
          "args": [],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tif (no_uprobe_events() || !valid_vma(vma, false))\n\t\treturn;\n\n\tif (!atomic_read(&vma->vm_mm->mm_users)) /* called by mmput() ? */\n\t\treturn;\n\n\tif (!test_bit(MMF_HAS_UPROBES, &vma->vm_mm->flags) ||\n\t     test_bit(MMF_RECALC_UPROBES, &vma->vm_mm->flags))\n\t\treturn;\n\n\tif (vma_has_uprobes(vma, start, end))\n\t\tset_bit(MMF_RECALC_UPROBES, &vma->vm_mm->flags);\n}"
  },
  {
    "function_name": "vma_has_uprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1362-1379",
    "snippet": "static bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(uprobes_treelock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_node_in_range",
          "args": [
            "inode",
            "min",
            "max"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "find_node_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1224-1247",
          "snippet": "static struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vaddr_to_offset",
          "args": [
            "vma",
            "start"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "vaddr_to_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "148-151",
          "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}"
  },
  {
    "function_name": "uprobe_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1321-1360",
    "snippet": "int uprobe_mmap(struct vm_area_struct *vma)\n{\n\tstruct list_head tmp_list;\n\tstruct uprobe *uprobe, *u;\n\tstruct inode *inode;\n\n\tif (no_uprobe_events())\n\t\treturn 0;\n\n\tif (vma->vm_file &&\n\t    (vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t    test_bit(MMF_HAS_UPROBES, &vma->vm_mm->flags))\n\t\tdelayed_ref_ctr_inc(vma);\n\n\tif (!valid_vma(vma, true))\n\t\treturn 0;\n\n\tinode = file_inode(vma->vm_file);\n\tif (!inode)\n\t\treturn 0;\n\n\tmutex_lock(uprobes_mmap_hash(inode));\n\tbuild_probe_list(inode, vma, vma->vm_start, vma->vm_end, &tmp_list);\n\t/*\n\t * We can race with uprobe_unregister(), this uprobe can be already\n\t * removed. But in this case filter_chain() must return false, all\n\t * consumers have gone away.\n\t */\n\tlist_for_each_entry_safe(uprobe, u, &tmp_list, pending_list) {\n\t\tif (!fatal_signal_pending(current) &&\n\t\t    filter_chain(uprobe, UPROBE_FILTER_MMAP, vma->vm_mm)) {\n\t\t\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\t\tinstall_breakpoint(uprobe, vma->vm_mm, vma, vaddr);\n\t\t}\n\t\tput_uprobe(uprobe);\n\t}\n\tmutex_unlock(uprobes_mmap_hash(inode));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "uprobes_mmap_hash(inode)"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobes_mmap_hash",
          "args": [
            "inode"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "567-578",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_breakpoint",
          "args": [
            "uprobe",
            "vma->vm_mm",
            "vma",
            "vaddr"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "install_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "864-890",
          "snippet": "static int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "vma",
            "uprobe->offset"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "143-146",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_chain",
          "args": [
            "uprobe",
            "UPROBE_FILTER_MMAP",
            "vma->vm_mm"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "filter_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "847-862",
          "snippet": "static bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "uprobe",
            "u",
            "&tmp_list",
            "pending_list"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_probe_list",
          "args": [
            "inode",
            "vma",
            "vma->vm_start",
            "vma->vm_end",
            "&tmp_list"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "build_probe_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1252-1284",
          "snippet": "static void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "uprobes_mmap_hash(inode)"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobes_mmap_hash",
          "args": [
            "inode"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "true"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "133-141",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_ref_ctr_inc",
          "args": [
            "vma"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_ref_ctr_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1287-1313",
          "snippet": "static int delayed_ref_ctr_inc(struct vm_area_struct *vma)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\tunsigned long vaddr;\n\tint ret = 0, err = 0;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (du->mm != vma->vm_mm ||\n\t\t    !valid_ref_ctr_vma(du->uprobe, vma))\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, du->uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(vma->vm_mm, vaddr, 1);\n\t\tif (ret) {\n\t\t\tupdate_ref_ctr_warn(du->uprobe, vma->vm_mm, 1);\n\t\t\tif (!err)\n\t\t\t\terr = ret;\n\t\t}\n\t\tdelayed_uprobe_delete(du);\n\t}\n\tmutex_unlock(&delayed_uprobe_lock);\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic int delayed_ref_ctr_inc(struct vm_area_struct *vma)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\tunsigned long vaddr;\n\tint ret = 0, err = 0;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (du->mm != vma->vm_mm ||\n\t\t    !valid_ref_ctr_vma(du->uprobe, vma))\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, du->uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(vma->vm_mm, vaddr, 1);\n\t\tif (ret) {\n\t\t\tupdate_ref_ctr_warn(du->uprobe, vma->vm_mm, 1);\n\t\t\tif (!err)\n\t\t\t\terr = ret;\n\t\t}\n\t\tdelayed_uprobe_delete(du);\n\t}\n\tmutex_unlock(&delayed_uprobe_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&vma->vm_mm->flags"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_uprobe_events",
          "args": [],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_mmap(struct vm_area_struct *vma)\n{\n\tstruct list_head tmp_list;\n\tstruct uprobe *uprobe, *u;\n\tstruct inode *inode;\n\n\tif (no_uprobe_events())\n\t\treturn 0;\n\n\tif (vma->vm_file &&\n\t    (vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t    test_bit(MMF_HAS_UPROBES, &vma->vm_mm->flags))\n\t\tdelayed_ref_ctr_inc(vma);\n\n\tif (!valid_vma(vma, true))\n\t\treturn 0;\n\n\tinode = file_inode(vma->vm_file);\n\tif (!inode)\n\t\treturn 0;\n\n\tmutex_lock(uprobes_mmap_hash(inode));\n\tbuild_probe_list(inode, vma, vma->vm_start, vma->vm_end, &tmp_list);\n\t/*\n\t * We can race with uprobe_unregister(), this uprobe can be already\n\t * removed. But in this case filter_chain() must return false, all\n\t * consumers have gone away.\n\t */\n\tlist_for_each_entry_safe(uprobe, u, &tmp_list, pending_list) {\n\t\tif (!fatal_signal_pending(current) &&\n\t\t    filter_chain(uprobe, UPROBE_FILTER_MMAP, vma->vm_mm)) {\n\t\t\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\t\tinstall_breakpoint(uprobe, vma->vm_mm, vma, vaddr);\n\t\t}\n\t\tput_uprobe(uprobe);\n\t}\n\tmutex_unlock(uprobes_mmap_hash(inode));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "delayed_ref_ctr_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1287-1313",
    "snippet": "static int delayed_ref_ctr_inc(struct vm_area_struct *vma)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\tunsigned long vaddr;\n\tint ret = 0, err = 0;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (du->mm != vma->vm_mm ||\n\t\t    !valid_ref_ctr_vma(du->uprobe, vma))\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, du->uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(vma->vm_mm, vaddr, 1);\n\t\tif (ret) {\n\t\t\tupdate_ref_ctr_warn(du->uprobe, vma->vm_mm, 1);\n\t\t\tif (!err)\n\t\t\t\terr = ret;\n\t\t}\n\t\tdelayed_uprobe_delete(du);\n\t}\n\tmutex_unlock(&delayed_uprobe_lock);\n\treturn err;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(delayed_uprobe_lock);",
      "static LIST_HEAD(delayed_uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_delete",
          "args": [
            "du"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "323-329",
          "snippet": "static void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ref_ctr_warn",
          "args": [
            "du->uprobe",
            "vma->vm_mm",
            "1"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "update_ref_ctr_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "416-424",
          "snippet": "static void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_ref_ctr",
          "args": [
            "vma->vm_mm",
            "vaddr",
            "1"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "__update_ref_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "376-414",
          "snippet": "static int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "vma",
            "du->uprobe->ref_ctr_offset"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "143-146",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_ref_ctr_vma",
          "args": [
            "du->uprobe",
            "vma"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "valid_ref_ctr_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "351-362",
          "snippet": "static bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structdelayed_uprobe",
            "list"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "q",
            "&delayed_uprobe_list"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic int delayed_ref_ctr_inc(struct vm_area_struct *vma)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\tunsigned long vaddr;\n\tint ret = 0, err = 0;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (du->mm != vma->vm_mm ||\n\t\t    !valid_ref_ctr_vma(du->uprobe, vma))\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, du->uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(vma->vm_mm, vaddr, 1);\n\t\tif (ret) {\n\t\t\tupdate_ref_ctr_warn(du->uprobe, vma->vm_mm, 1);\n\t\t\tif (!err)\n\t\t\t\terr = ret;\n\t\t}\n\t\tdelayed_uprobe_delete(du);\n\t}\n\tmutex_unlock(&delayed_uprobe_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "build_probe_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1252-1284",
    "snippet": "static void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(uprobes_treelock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_uprobe",
          "args": [
            "u"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "get_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "561-565",
          "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&u->pending_list",
            "head"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "t",
            "structuprobe",
            "rb_node"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "t"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "t",
            "structuprobe",
            "rb_node"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "t"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_node_in_range",
          "args": [
            "inode",
            "min",
            "max"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "find_node_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1224-1247",
          "snippet": "static struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vaddr_to_offset",
          "args": [
            "vma",
            "start"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "vaddr_to_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "148-151",
          "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "head"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}"
  },
  {
    "function_name": "find_node_in_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1224-1247",
    "snippet": "static struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root uprobes_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structuprobe",
            "rb_node"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}"
  },
  {
    "function_name": "unapply_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1197-1222",
    "snippet": "static int unapply_uprobe(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tdown_read(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tunsigned long vaddr;\n\t\tloff_t offset;\n\n\t\tif (!valid_vma(vma, false) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tcontinue;\n\n\t\toffset = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t\tif (uprobe->offset <  offset ||\n\t\t    uprobe->offset >= offset + vma->vm_end - vma->vm_start)\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\terr |= remove_breakpoint(uprobe, mm, vaddr);\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_breakpoint",
          "args": [
            "uprobe",
            "mm",
            "vaddr"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "remove_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "892-897",
          "snippet": "static int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "vma",
            "uprobe->offset"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "143-146",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "false"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "133-141",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int unapply_uprobe(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tdown_read(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tunsigned long vaddr;\n\t\tloff_t offset;\n\n\t\tif (!valid_vma(vma, false) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tcontinue;\n\n\t\toffset = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t\tif (uprobe->offset <  offset ||\n\t\t    uprobe->offset >= offset + vma->vm_end - vma->vm_start)\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\terr |= remove_breakpoint(uprobe, mm, vaddr);\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn err;\n}"
  },
  {
    "function_name": "uprobe_apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1175-1195",
    "snippet": "int uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "567-578",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_for_each_vma",
          "args": [
            "uprobe",
            "add ? uc : NULL"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "register_for_each_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1003-1055",
          "snippet": "static int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_rw_semaphore dup_mmap_sem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore dup_mmap_sem;\n\nstatic int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_uprobe",
          "args": [
            "inode",
            "offset"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "find_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "622-631",
          "snippet": "static struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "uprobe_register_refctr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1161-1165",
    "snippet": "int uprobe_register_refctr(struct inode *inode, loff_t offset,\n\t\t\t   loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, ref_ctr_offset, uc);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__uprobe_register",
          "args": [
            "inode",
            "offset",
            "ref_ctr_offset",
            "uc"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1110-1152",
          "snippet": "static int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_register_refctr(struct inode *inode, loff_t offset,\n\t\t\t   loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, ref_ctr_offset, uc);\n}"
  },
  {
    "function_name": "uprobe_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1154-1158",
    "snippet": "int uprobe_register(struct inode *inode, loff_t offset,\n\t\t    struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, 0, uc);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__uprobe_register",
          "args": [
            "inode",
            "offset",
            "0",
            "uc"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1110-1152",
          "snippet": "static int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_register(struct inode *inode, loff_t offset,\n\t\t    struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, 0, uc);\n}"
  },
  {
    "function_name": "__uprobe_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1110-1152",
    "snippet": "static int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EAGAIN"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "567-578",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__uprobe_unregister",
          "args": [
            "uprobe",
            "uc"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1057-1069",
          "snippet": "static void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_for_each_vma",
          "args": [
            "uprobe",
            "uc"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "register_for_each_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1003-1055",
          "snippet": "static int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_rw_semaphore dup_mmap_sem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore dup_mmap_sem;\n\nstatic int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "consumer_add",
          "args": [
            "uprobe",
            "uc"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "consumer_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "724-730",
          "snippet": "static void consumer_add(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tdown_write(&uprobe->consumer_rwsem);\n\tuc->next = uprobe->consumers;\n\tuprobe->consumers = uc;\n\tup_write(&uprobe->consumer_rwsem);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void consumer_add(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tdown_write(&uprobe->consumer_rwsem);\n\tuc->next = uprobe->consumers;\n\tuprobe->consumers = uc;\n\tup_write(&uprobe->consumer_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "uprobe_is_active(uprobe)"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_is_active",
          "args": [
            "uprobe"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_is_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "899-902",
          "snippet": "static inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "uprobe"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "uprobe"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_uprobe",
          "args": [
            "inode",
            "offset",
            "ref_ctr_offset"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "692-722",
          "snippet": "static struct uprobe *alloc_uprobe(struct inode *inode, loff_t offset,\n\t\t\t\t   loff_t ref_ctr_offset)\n{\n\tstruct uprobe *uprobe, *cur_uprobe;\n\n\tuprobe = kzalloc(sizeof(struct uprobe), GFP_KERNEL);\n\tif (!uprobe)\n\t\treturn NULL;\n\n\tuprobe->inode = inode;\n\tuprobe->offset = offset;\n\tuprobe->ref_ctr_offset = ref_ctr_offset;\n\tinit_rwsem(&uprobe->register_rwsem);\n\tinit_rwsem(&uprobe->consumer_rwsem);\n\n\t/* add to uprobes_tree, sorted on inode:offset */\n\tcur_uprobe = insert_uprobe(uprobe);\n\t/* a uprobe exists for this inode:offset combination */\n\tif (cur_uprobe) {\n\t\tif (cur_uprobe->ref_ctr_offset != uprobe->ref_ctr_offset) {\n\t\t\tref_ctr_mismatch_warn(cur_uprobe, uprobe);\n\t\t\tput_uprobe(cur_uprobe);\n\t\t\tkfree(uprobe);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tkfree(uprobe);\n\t\tuprobe = cur_uprobe;\n\t}\n\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *alloc_uprobe(struct inode *inode, loff_t offset,\n\t\t\t\t   loff_t ref_ctr_offset)\n{\n\tstruct uprobe *uprobe, *cur_uprobe;\n\n\tuprobe = kzalloc(sizeof(struct uprobe), GFP_KERNEL);\n\tif (!uprobe)\n\t\treturn NULL;\n\n\tuprobe->inode = inode;\n\tuprobe->offset = offset;\n\tuprobe->ref_ctr_offset = ref_ctr_offset;\n\tinit_rwsem(&uprobe->register_rwsem);\n\tinit_rwsem(&uprobe->consumer_rwsem);\n\n\t/* add to uprobes_tree, sorted on inode:offset */\n\tcur_uprobe = insert_uprobe(uprobe);\n\t/* a uprobe exists for this inode:offset combination */\n\tif (cur_uprobe) {\n\t\tif (cur_uprobe->ref_ctr_offset != uprobe->ref_ctr_offset) {\n\t\t\tref_ctr_mismatch_warn(cur_uprobe, uprobe);\n\t\t\tput_uprobe(cur_uprobe);\n\t\t\tkfree(uprobe);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tkfree(uprobe);\n\t\tuprobe = cur_uprobe;\n\t}\n\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_mapping",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}"
  },
  {
    "function_name": "uprobe_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1077-1089",
    "snippet": "void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn;\n\n\tdown_write(&uprobe->register_rwsem);\n\t__uprobe_unregister(uprobe, uc);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "567-578",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__uprobe_unregister",
          "args": [
            "uprobe",
            "uc"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1057-1069",
          "snippet": "static void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_uprobe",
          "args": [
            "inode",
            "offset"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "find_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "622-631",
          "snippet": "static struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn;\n\n\tdown_write(&uprobe->register_rwsem);\n\t__uprobe_unregister(uprobe, uc);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n}"
  },
  {
    "function_name": "__uprobe_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1057-1069",
    "snippet": "static void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delete_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "delete_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "908-918",
          "snippet": "static void delete_uprobe(struct uprobe *uprobe)\n{\n\tif (WARN_ON(!uprobe_is_active(uprobe)))\n\t\treturn;\n\n\tspin_lock(&uprobes_treelock);\n\trb_erase(&uprobe->rb_node, &uprobes_tree);\n\tspin_unlock(&uprobes_treelock);\n\tRB_CLEAR_NODE(&uprobe->rb_node); /* for uprobe_is_active() */\n\tput_uprobe(uprobe);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;",
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic void delete_uprobe(struct uprobe *uprobe)\n{\n\tif (WARN_ON(!uprobe_is_active(uprobe)))\n\t\treturn;\n\n\tspin_lock(&uprobes_treelock);\n\trb_erase(&uprobe->rb_node, &uprobes_tree);\n\tspin_unlock(&uprobes_treelock);\n\tRB_CLEAR_NODE(&uprobe->rb_node); /* for uprobe_is_active() */\n\tput_uprobe(uprobe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_for_each_vma",
          "args": [
            "uprobe",
            "NULL"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "register_for_each_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1003-1055",
          "snippet": "static int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_rw_semaphore dup_mmap_sem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore dup_mmap_sem;\n\nstatic int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!consumer_del(uprobe, uc)"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "consumer_del",
          "args": [
            "uprobe",
            "uc"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "consumer_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "737-753",
          "snippet": "static bool consumer_del(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tstruct uprobe_consumer **con;\n\tbool ret = false;\n\n\tdown_write(&uprobe->consumer_rwsem);\n\tfor (con = &uprobe->consumers; *con; con = &(*con)->next) {\n\t\tif (*con == uc) {\n\t\t\t*con = uc->next;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool consumer_del(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tstruct uprobe_consumer **con;\n\tbool ret = false;\n\n\tdown_write(&uprobe->consumer_rwsem);\n\tfor (con = &uprobe->consumers; *con; con = &(*con)->next) {\n\t\tif (*con == uc) {\n\t\t\t*con = uc->next;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}"
  },
  {
    "function_name": "register_for_each_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "1003-1055",
    "snippet": "static int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore dup_mmap_sem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&dup_mmap_sem"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_map_info",
          "args": [
            "info"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "free_map_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "926-931",
          "snippet": "static inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1079-1085",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_breakpoint",
          "args": [
            "uprobe",
            "mm",
            "info->vaddr"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "remove_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "892-897",
          "snippet": "static int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_chain",
          "args": [
            "uprobe",
            "UPROBE_FILTER_UNREGISTER",
            "mm"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "filter_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "847-862",
          "snippet": "static bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&mm->flags"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_breakpoint",
          "args": [
            "uprobe",
            "mm",
            "vma",
            "info->vaddr"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "install_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "864-890",
          "snippet": "static int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "consumer_filter",
          "args": [
            "new",
            "UPROBE_FILTER_REGISTER",
            "mm"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "consumer_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "841-845",
          "snippet": "static inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vaddr_to_offset",
          "args": [
            "vma",
            "info->vaddr"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "vaddr_to_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "148-151",
          "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "is_register"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "133-141",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "info->vaddr"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "info"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "info"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_map_info",
          "args": [
            "uprobe->inode->i_mapping",
            "uprobe->offset",
            "is_register"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "build_map_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "933-1001",
          "snippet": "static struct map_info *\nbuild_map_info(struct address_space *mapping, loff_t offset, bool is_register)\n{\n\tunsigned long pgoff = offset >> PAGE_SHIFT;\n\tstruct vm_area_struct *vma;\n\tstruct map_info *curr = NULL;\n\tstruct map_info *prev = NULL;\n\tstruct map_info *info;\n\tint more = 0;\n\n again:\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (!valid_vma(vma, is_register))\n\t\t\tcontinue;\n\n\t\tif (!prev && !more) {\n\t\t\t/*\n\t\t\t * Needs GFP_NOWAIT to avoid i_mmap_rwsem recursion through\n\t\t\t * reclaim. This is optimistic, no harm done if it fails.\n\t\t\t */\n\t\t\tprev = kmalloc(sizeof(struct map_info),\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\tif (prev)\n\t\t\t\tprev->next = NULL;\n\t\t}\n\t\tif (!prev) {\n\t\t\tmore++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mmget_not_zero(vma->vm_mm))\n\t\t\tcontinue;\n\n\t\tinfo = prev;\n\t\tprev = prev->next;\n\t\tinfo->next = curr;\n\t\tcurr = info;\n\n\t\tinfo->mm = vma->vm_mm;\n\t\tinfo->vaddr = offset_to_vaddr(vma, offset);\n\t}\n\ti_mmap_unlock_read(mapping);\n\n\tif (!more)\n\t\tgoto out;\n\n\tprev = curr;\n\twhile (curr) {\n\t\tmmput(curr->mm);\n\t\tcurr = curr->next;\n\t}\n\n\tdo {\n\t\tinfo = kmalloc(sizeof(struct map_info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tcurr = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tinfo->next = prev;\n\t\tprev = info;\n\t} while (--more);\n\n\tgoto again;\n out:\n\twhile (prev)\n\t\tprev = free_map_info(prev);\n\treturn curr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct map_info *\nbuild_map_info(struct address_space *mapping, loff_t offset, bool is_register)\n{\n\tunsigned long pgoff = offset >> PAGE_SHIFT;\n\tstruct vm_area_struct *vma;\n\tstruct map_info *curr = NULL;\n\tstruct map_info *prev = NULL;\n\tstruct map_info *info;\n\tint more = 0;\n\n again:\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (!valid_vma(vma, is_register))\n\t\t\tcontinue;\n\n\t\tif (!prev && !more) {\n\t\t\t/*\n\t\t\t * Needs GFP_NOWAIT to avoid i_mmap_rwsem recursion through\n\t\t\t * reclaim. This is optimistic, no harm done if it fails.\n\t\t\t */\n\t\t\tprev = kmalloc(sizeof(struct map_info),\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\tif (prev)\n\t\t\t\tprev->next = NULL;\n\t\t}\n\t\tif (!prev) {\n\t\t\tmore++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mmget_not_zero(vma->vm_mm))\n\t\t\tcontinue;\n\n\t\tinfo = prev;\n\t\tprev = prev->next;\n\t\tinfo->next = curr;\n\t\tcurr = info;\n\n\t\tinfo->mm = vma->vm_mm;\n\t\tinfo->vaddr = offset_to_vaddr(vma, offset);\n\t}\n\ti_mmap_unlock_read(mapping);\n\n\tif (!more)\n\t\tgoto out;\n\n\tprev = curr;\n\twhile (curr) {\n\t\tmmput(curr->mm);\n\t\tcurr = curr->next;\n\t}\n\n\tdo {\n\t\tinfo = kmalloc(sizeof(struct map_info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tcurr = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tinfo->next = prev;\n\t\tprev = info;\n\t} while (--more);\n\n\tgoto again;\n out:\n\twhile (prev)\n\t\tprev = free_map_info(prev);\n\treturn curr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore dup_mmap_sem;\n\nstatic int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}"
  },
  {
    "function_name": "build_map_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "933-1001",
    "snippet": "static struct map_info *\nbuild_map_info(struct address_space *mapping, loff_t offset, bool is_register)\n{\n\tunsigned long pgoff = offset >> PAGE_SHIFT;\n\tstruct vm_area_struct *vma;\n\tstruct map_info *curr = NULL;\n\tstruct map_info *prev = NULL;\n\tstruct map_info *info;\n\tint more = 0;\n\n again:\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (!valid_vma(vma, is_register))\n\t\t\tcontinue;\n\n\t\tif (!prev && !more) {\n\t\t\t/*\n\t\t\t * Needs GFP_NOWAIT to avoid i_mmap_rwsem recursion through\n\t\t\t * reclaim. This is optimistic, no harm done if it fails.\n\t\t\t */\n\t\t\tprev = kmalloc(sizeof(struct map_info),\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\tif (prev)\n\t\t\t\tprev->next = NULL;\n\t\t}\n\t\tif (!prev) {\n\t\t\tmore++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mmget_not_zero(vma->vm_mm))\n\t\t\tcontinue;\n\n\t\tinfo = prev;\n\t\tprev = prev->next;\n\t\tinfo->next = curr;\n\t\tcurr = info;\n\n\t\tinfo->mm = vma->vm_mm;\n\t\tinfo->vaddr = offset_to_vaddr(vma, offset);\n\t}\n\ti_mmap_unlock_read(mapping);\n\n\tif (!more)\n\t\tgoto out;\n\n\tprev = curr;\n\twhile (curr) {\n\t\tmmput(curr->mm);\n\t\tcurr = curr->next;\n\t}\n\n\tdo {\n\t\tinfo = kmalloc(sizeof(struct map_info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tcurr = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tinfo->next = prev;\n\t\tprev = info;\n\t} while (--more);\n\n\tgoto again;\n out:\n\twhile (prev)\n\t\tprev = free_map_info(prev);\n\treturn curr;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_map_info",
          "args": [
            "prev"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "free_map_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "926-931",
          "snippet": "static inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct map_info)",
            "GFP_KERNEL"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "curr->mm"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1079-1085",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_read",
          "args": [
            "mapping"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "vma",
            "offset"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "143-146",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmget_not_zero",
          "args": [
            "vma->vm_mm"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "is_register"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "133-141",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_foreach",
          "args": [
            "vma",
            "&mapping->i_mmap",
            "pgoff",
            "pgoff"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_read",
          "args": [
            "mapping"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct map_info *\nbuild_map_info(struct address_space *mapping, loff_t offset, bool is_register)\n{\n\tunsigned long pgoff = offset >> PAGE_SHIFT;\n\tstruct vm_area_struct *vma;\n\tstruct map_info *curr = NULL;\n\tstruct map_info *prev = NULL;\n\tstruct map_info *info;\n\tint more = 0;\n\n again:\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (!valid_vma(vma, is_register))\n\t\t\tcontinue;\n\n\t\tif (!prev && !more) {\n\t\t\t/*\n\t\t\t * Needs GFP_NOWAIT to avoid i_mmap_rwsem recursion through\n\t\t\t * reclaim. This is optimistic, no harm done if it fails.\n\t\t\t */\n\t\t\tprev = kmalloc(sizeof(struct map_info),\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\tif (prev)\n\t\t\t\tprev->next = NULL;\n\t\t}\n\t\tif (!prev) {\n\t\t\tmore++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mmget_not_zero(vma->vm_mm))\n\t\t\tcontinue;\n\n\t\tinfo = prev;\n\t\tprev = prev->next;\n\t\tinfo->next = curr;\n\t\tcurr = info;\n\n\t\tinfo->mm = vma->vm_mm;\n\t\tinfo->vaddr = offset_to_vaddr(vma, offset);\n\t}\n\ti_mmap_unlock_read(mapping);\n\n\tif (!more)\n\t\tgoto out;\n\n\tprev = curr;\n\twhile (curr) {\n\t\tmmput(curr->mm);\n\t\tcurr = curr->next;\n\t}\n\n\tdo {\n\t\tinfo = kmalloc(sizeof(struct map_info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tcurr = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tinfo->next = prev;\n\t\tprev = info;\n\t} while (--more);\n\n\tgoto again;\n out:\n\twhile (prev)\n\t\tprev = free_map_info(prev);\n\treturn curr;\n}"
  },
  {
    "function_name": "free_map_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "926-931",
    "snippet": "static inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}"
  },
  {
    "function_name": "delete_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "908-918",
    "snippet": "static void delete_uprobe(struct uprobe *uprobe)\n{\n\tif (WARN_ON(!uprobe_is_active(uprobe)))\n\t\treturn;\n\n\tspin_lock(&uprobes_treelock);\n\trb_erase(&uprobe->rb_node, &uprobes_tree);\n\tspin_unlock(&uprobes_treelock);\n\tRB_CLEAR_NODE(&uprobe->rb_node); /* for uprobe_is_active() */\n\tput_uprobe(uprobe);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root uprobes_tree = RB_ROOT;",
      "static DEFINE_SPINLOCK(uprobes_treelock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "567-578",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&uprobe->rb_node"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&uprobe->rb_node",
            "&uprobes_tree"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe_is_active(uprobe)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_is_active",
          "args": [
            "uprobe"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_is_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "899-902",
          "snippet": "static inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic void delete_uprobe(struct uprobe *uprobe)\n{\n\tif (WARN_ON(!uprobe_is_active(uprobe)))\n\t\treturn;\n\n\tspin_lock(&uprobes_treelock);\n\trb_erase(&uprobe->rb_node, &uprobes_tree);\n\tspin_unlock(&uprobes_treelock);\n\tRB_CLEAR_NODE(&uprobe->rb_node); /* for uprobe_is_active() */\n\tput_uprobe(uprobe);\n}"
  },
  {
    "function_name": "uprobe_is_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "899-902",
    "snippet": "static inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&uprobe->rb_node"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}"
  },
  {
    "function_name": "remove_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "892-897",
    "snippet": "static int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_orig_insn",
          "args": [
            "&uprobe->arch",
            "mm",
            "vaddr"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "set_orig_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "554-559",
          "snippet": "int __weak\nset_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr,\n\t\t\t*(uprobe_opcode_t *)&auprobe->insn);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint __weak\nset_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr,\n\t\t\t*(uprobe_opcode_t *)&auprobe->insn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_RECALC_UPROBES",
            "&mm->flags"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}"
  },
  {
    "function_name": "install_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "864-890",
    "snippet": "static int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&mm->flags"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_swbp",
          "args": [
            "&uprobe->arch",
            "mm",
            "vaddr"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "set_swbp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "540-543",
          "snippet": "int __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr, UPROBE_SWBP_INSN);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr, UPROBE_SWBP_INSN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&mm->flags"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&mm->flags"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_uprobe",
          "args": [
            "uprobe",
            "vma->vm_file",
            "mm",
            "vaddr"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "803-839",
          "snippet": "static int prepare_uprobe(struct uprobe *uprobe, struct file *file,\n\t\t\t\tstruct mm_struct *mm, unsigned long vaddr)\n{\n\tint ret = 0;\n\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\treturn ret;\n\n\t/* TODO: move this into _register, until then we abuse this sem. */\n\tdown_write(&uprobe->consumer_rwsem);\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\tgoto out;\n\n\tret = copy_insn(uprobe, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -ENOTSUPP;\n\tif (is_trap_insn((uprobe_opcode_t *)&uprobe->arch.insn))\n\t\tgoto out;\n\n\tret = arch_uprobe_analyze_insn(&uprobe->arch, mm, vaddr);\n\tif (ret)\n\t\tgoto out;\n\n\t/* uprobe_write_opcode() assumes we don't cross page boundary */\n\tBUG_ON((uprobe->offset & ~PAGE_MASK) +\n\t\t\tUPROBE_SWBP_INSN_SIZE > PAGE_SIZE);\n\n\tsmp_wmb(); /* pairs with rmb() in find_active_uprobe() */\n\tset_bit(UPROBE_COPY_INSN, &uprobe->flags);\n\n out:\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UPROBE_COPY_INSN\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UPROBE_COPY_INSN\t0\n\nstatic int prepare_uprobe(struct uprobe *uprobe, struct file *file,\n\t\t\t\tstruct mm_struct *mm, unsigned long vaddr)\n{\n\tint ret = 0;\n\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\treturn ret;\n\n\t/* TODO: move this into _register, until then we abuse this sem. */\n\tdown_write(&uprobe->consumer_rwsem);\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\tgoto out;\n\n\tret = copy_insn(uprobe, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -ENOTSUPP;\n\tif (is_trap_insn((uprobe_opcode_t *)&uprobe->arch.insn))\n\t\tgoto out;\n\n\tret = arch_uprobe_analyze_insn(&uprobe->arch, mm, vaddr);\n\tif (ret)\n\t\tgoto out;\n\n\t/* uprobe_write_opcode() assumes we don't cross page boundary */\n\tBUG_ON((uprobe->offset & ~PAGE_MASK) +\n\t\t\tUPROBE_SWBP_INSN_SIZE > PAGE_SIZE);\n\n\tsmp_wmb(); /* pairs with rmb() in find_active_uprobe() */\n\tset_bit(UPROBE_COPY_INSN, &uprobe->flags);\n\n out:\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "filter_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "847-862",
    "snippet": "static bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "consumer_filter",
          "args": [
            "uc",
            "ctx",
            "mm"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "consumer_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "841-845",
          "snippet": "static inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "consumer_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "841-845",
    "snippet": "static inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uc->filter",
          "args": [
            "uc",
            "ctx",
            "mm"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}"
  },
  {
    "function_name": "prepare_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "803-839",
    "snippet": "static int prepare_uprobe(struct uprobe *uprobe, struct file *file,\n\t\t\t\tstruct mm_struct *mm, unsigned long vaddr)\n{\n\tint ret = 0;\n\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\treturn ret;\n\n\t/* TODO: move this into _register, until then we abuse this sem. */\n\tdown_write(&uprobe->consumer_rwsem);\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\tgoto out;\n\n\tret = copy_insn(uprobe, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -ENOTSUPP;\n\tif (is_trap_insn((uprobe_opcode_t *)&uprobe->arch.insn))\n\t\tgoto out;\n\n\tret = arch_uprobe_analyze_insn(&uprobe->arch, mm, vaddr);\n\tif (ret)\n\t\tgoto out;\n\n\t/* uprobe_write_opcode() assumes we don't cross page boundary */\n\tBUG_ON((uprobe->offset & ~PAGE_MASK) +\n\t\t\tUPROBE_SWBP_INSN_SIZE > PAGE_SIZE);\n\n\tsmp_wmb(); /* pairs with rmb() in find_active_uprobe() */\n\tset_bit(UPROBE_COPY_INSN, &uprobe->flags);\n\n out:\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UPROBE_COPY_INSN\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "UPROBE_COPY_INSN",
            "&uprobe->flags"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(uprobe->offset & ~PAGE_MASK) +\n\t\t\tUPROBE_SWBP_INSN_SIZE > PAGE_SIZE"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uprobe_analyze_insn",
          "args": [
            "&uprobe->arch",
            "mm",
            "vaddr"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_trap_insn",
          "args": [
            "(uprobe_opcode_t *)&uprobe->arch.insn"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "is_trap_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "248-251",
          "snippet": "bool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_insn",
          "args": [
            "uprobe",
            "file"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "copy_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "777-801",
          "snippet": "static int copy_insn(struct uprobe *uprobe, struct file *filp)\n{\n\tstruct address_space *mapping = uprobe->inode->i_mapping;\n\tloff_t offs = uprobe->offset;\n\tvoid *insn = &uprobe->arch.insn;\n\tint size = sizeof(uprobe->arch.insn);\n\tint len, err = -EIO;\n\n\t/* Copy only available bytes, -EIO if nothing was read */\n\tdo {\n\t\tif (offs >= i_size_read(uprobe->inode))\n\t\t\tbreak;\n\n\t\tlen = min_t(int, size, PAGE_SIZE - (offs & ~PAGE_MASK));\n\t\terr = __copy_insn(mapping, filp, insn, len, offs);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tinsn += len;\n\t\toffs += len;\n\t\tsize -= len;\n\t} while (size);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int copy_insn(struct uprobe *uprobe, struct file *filp)\n{\n\tstruct address_space *mapping = uprobe->inode->i_mapping;\n\tloff_t offs = uprobe->offset;\n\tvoid *insn = &uprobe->arch.insn;\n\tint size = sizeof(uprobe->arch.insn);\n\tint len, err = -EIO;\n\n\t/* Copy only available bytes, -EIO if nothing was read */\n\tdo {\n\t\tif (offs >= i_size_read(uprobe->inode))\n\t\t\tbreak;\n\n\t\tlen = min_t(int, size, PAGE_SIZE - (offs & ~PAGE_MASK));\n\t\terr = __copy_insn(mapping, filp, insn, len, offs);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tinsn += len;\n\t\toffs += len;\n\t\tsize -= len;\n\t} while (size);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "UPROBE_COPY_INSN",
            "&uprobe->flags"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UPROBE_COPY_INSN\t0\n\nstatic int prepare_uprobe(struct uprobe *uprobe, struct file *file,\n\t\t\t\tstruct mm_struct *mm, unsigned long vaddr)\n{\n\tint ret = 0;\n\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\treturn ret;\n\n\t/* TODO: move this into _register, until then we abuse this sem. */\n\tdown_write(&uprobe->consumer_rwsem);\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\tgoto out;\n\n\tret = copy_insn(uprobe, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -ENOTSUPP;\n\tif (is_trap_insn((uprobe_opcode_t *)&uprobe->arch.insn))\n\t\tgoto out;\n\n\tret = arch_uprobe_analyze_insn(&uprobe->arch, mm, vaddr);\n\tif (ret)\n\t\tgoto out;\n\n\t/* uprobe_write_opcode() assumes we don't cross page boundary */\n\tBUG_ON((uprobe->offset & ~PAGE_MASK) +\n\t\t\tUPROBE_SWBP_INSN_SIZE > PAGE_SIZE);\n\n\tsmp_wmb(); /* pairs with rmb() in find_active_uprobe() */\n\tset_bit(UPROBE_COPY_INSN, &uprobe->flags);\n\n out:\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "copy_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "777-801",
    "snippet": "static int copy_insn(struct uprobe *uprobe, struct file *filp)\n{\n\tstruct address_space *mapping = uprobe->inode->i_mapping;\n\tloff_t offs = uprobe->offset;\n\tvoid *insn = &uprobe->arch.insn;\n\tint size = sizeof(uprobe->arch.insn);\n\tint len, err = -EIO;\n\n\t/* Copy only available bytes, -EIO if nothing was read */\n\tdo {\n\t\tif (offs >= i_size_read(uprobe->inode))\n\t\t\tbreak;\n\n\t\tlen = min_t(int, size, PAGE_SIZE - (offs & ~PAGE_MASK));\n\t\terr = __copy_insn(mapping, filp, insn, len, offs);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tinsn += len;\n\t\toffs += len;\n\t\tsize -= len;\n\t} while (size);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_insn",
          "args": [
            "mapping",
            "filp",
            "insn",
            "len",
            "offs"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "__copy_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "755-775",
          "snippet": "static int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\t/*\n\t * Ensure that the page that has the original instruction is populated\n\t * and in page-cache. If ->readpage == NULL it must be shmem_mapping(),\n\t * see uprobe_register().\n\t */\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\t/*\n\t * Ensure that the page that has the original instruction is populated\n\t * and in page-cache. If ->readpage == NULL it must be shmem_mapping(),\n\t * see uprobe_register().\n\t */\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "size",
            "PAGE_SIZE - (offs & ~PAGE_MASK)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "uprobe->inode"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int copy_insn(struct uprobe *uprobe, struct file *filp)\n{\n\tstruct address_space *mapping = uprobe->inode->i_mapping;\n\tloff_t offs = uprobe->offset;\n\tvoid *insn = &uprobe->arch.insn;\n\tint size = sizeof(uprobe->arch.insn);\n\tint len, err = -EIO;\n\n\t/* Copy only available bytes, -EIO if nothing was read */\n\tdo {\n\t\tif (offs >= i_size_read(uprobe->inode))\n\t\t\tbreak;\n\n\t\tlen = min_t(int, size, PAGE_SIZE - (offs & ~PAGE_MASK));\n\t\terr = __copy_insn(mapping, filp, insn, len, offs);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tinsn += len;\n\t\toffs += len;\n\t\tsize -= len;\n\t} while (size);\n\n\treturn err;\n}"
  },
  {
    "function_name": "__copy_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "755-775",
    "snippet": "static int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\t/*\n\t * Ensure that the page that has the original instruction is populated\n\t * and in page-cache. If ->readpage == NULL it must be shmem_mapping(),\n\t * see uprobe_register().\n\t */\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_page",
          "args": [
            "page",
            "offset",
            "insn",
            "nbytes"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "copy_from_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "253-258",
          "snippet": "static void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_read_mapping_page",
          "args": [
            "mapping",
            "offset >> PAGE_SHIFT"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "offset >> PAGE_SHIFT",
            "filp"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\t/*\n\t * Ensure that the page that has the original instruction is populated\n\t * and in page-cache. If ->readpage == NULL it must be shmem_mapping(),\n\t * see uprobe_register().\n\t */\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "consumer_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "737-753",
    "snippet": "static bool consumer_del(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tstruct uprobe_consumer **con;\n\tbool ret = false;\n\n\tdown_write(&uprobe->consumer_rwsem);\n\tfor (con = &uprobe->consumers; *con; con = &(*con)->next) {\n\t\tif (*con == uc) {\n\t\t\t*con = uc->next;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool consumer_del(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tstruct uprobe_consumer **con;\n\tbool ret = false;\n\n\tdown_write(&uprobe->consumer_rwsem);\n\tfor (con = &uprobe->consumers; *con; con = &(*con)->next) {\n\t\tif (*con == uc) {\n\t\t\t*con = uc->next;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "consumer_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "724-730",
    "snippet": "static void consumer_add(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tdown_write(&uprobe->consumer_rwsem);\n\tuc->next = uprobe->consumers;\n\tuprobe->consumers = uc;\n\tup_write(&uprobe->consumer_rwsem);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void consumer_add(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tdown_write(&uprobe->consumer_rwsem);\n\tuc->next = uprobe->consumers;\n\tuprobe->consumers = uc;\n\tup_write(&uprobe->consumer_rwsem);\n}"
  },
  {
    "function_name": "alloc_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "692-722",
    "snippet": "static struct uprobe *alloc_uprobe(struct inode *inode, loff_t offset,\n\t\t\t\t   loff_t ref_ctr_offset)\n{\n\tstruct uprobe *uprobe, *cur_uprobe;\n\n\tuprobe = kzalloc(sizeof(struct uprobe), GFP_KERNEL);\n\tif (!uprobe)\n\t\treturn NULL;\n\n\tuprobe->inode = inode;\n\tuprobe->offset = offset;\n\tuprobe->ref_ctr_offset = ref_ctr_offset;\n\tinit_rwsem(&uprobe->register_rwsem);\n\tinit_rwsem(&uprobe->consumer_rwsem);\n\n\t/* add to uprobes_tree, sorted on inode:offset */\n\tcur_uprobe = insert_uprobe(uprobe);\n\t/* a uprobe exists for this inode:offset combination */\n\tif (cur_uprobe) {\n\t\tif (cur_uprobe->ref_ctr_offset != uprobe->ref_ctr_offset) {\n\t\t\tref_ctr_mismatch_warn(cur_uprobe, uprobe);\n\t\t\tput_uprobe(cur_uprobe);\n\t\t\tkfree(uprobe);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tkfree(uprobe);\n\t\tuprobe = cur_uprobe;\n\t}\n\n\treturn uprobe;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root uprobes_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "uprobe"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "cur_uprobe"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "567-578",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref_ctr_mismatch_warn",
          "args": [
            "cur_uprobe",
            "uprobe"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "ref_ctr_mismatch_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "682-690",
          "snippet": "static void\nref_ctr_mismatch_warn(struct uprobe *cur_uprobe, struct uprobe *uprobe)\n{\n\tpr_warn(\"ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx \"\n\t\t\"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\\n\",\n\t\tuprobe->inode->i_ino, (unsigned long long) uprobe->offset,\n\t\t(unsigned long long) cur_uprobe->ref_ctr_offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\nref_ctr_mismatch_warn(struct uprobe *cur_uprobe, struct uprobe *uprobe)\n{\n\tpr_warn(\"ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx \"\n\t\t\"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\\n\",\n\t\tuprobe->inode->i_ino, (unsigned long long) uprobe->offset,\n\t\t(unsigned long long) cur_uprobe->ref_ctr_offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "insert_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "671-680",
          "snippet": "static struct uprobe *insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct uprobe *u;\n\n\tspin_lock(&uprobes_treelock);\n\tu = __insert_uprobe(uprobe);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn u;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct uprobe *u;\n\n\tspin_lock(&uprobes_treelock);\n\tu = __insert_uprobe(uprobe);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn u;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct uprobe)",
            "GFP_KERNEL"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *alloc_uprobe(struct inode *inode, loff_t offset,\n\t\t\t\t   loff_t ref_ctr_offset)\n{\n\tstruct uprobe *uprobe, *cur_uprobe;\n\n\tuprobe = kzalloc(sizeof(struct uprobe), GFP_KERNEL);\n\tif (!uprobe)\n\t\treturn NULL;\n\n\tuprobe->inode = inode;\n\tuprobe->offset = offset;\n\tuprobe->ref_ctr_offset = ref_ctr_offset;\n\tinit_rwsem(&uprobe->register_rwsem);\n\tinit_rwsem(&uprobe->consumer_rwsem);\n\n\t/* add to uprobes_tree, sorted on inode:offset */\n\tcur_uprobe = insert_uprobe(uprobe);\n\t/* a uprobe exists for this inode:offset combination */\n\tif (cur_uprobe) {\n\t\tif (cur_uprobe->ref_ctr_offset != uprobe->ref_ctr_offset) {\n\t\t\tref_ctr_mismatch_warn(cur_uprobe, uprobe);\n\t\t\tput_uprobe(cur_uprobe);\n\t\t\tkfree(uprobe);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tkfree(uprobe);\n\t\tuprobe = cur_uprobe;\n\t}\n\n\treturn uprobe;\n}"
  },
  {
    "function_name": "ref_ctr_mismatch_warn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "682-690",
    "snippet": "static void\nref_ctr_mismatch_warn(struct uprobe *cur_uprobe, struct uprobe *uprobe)\n{\n\tpr_warn(\"ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx \"\n\t\t\"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\\n\",\n\t\tuprobe->inode->i_ino, (unsigned long long) uprobe->offset,\n\t\t(unsigned long long) cur_uprobe->ref_ctr_offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx \"\n\t\t\"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\\n\"",
            "uprobe->inode->i_ino",
            "(unsigned long long) uprobe->offset",
            "(unsigned long long) cur_uprobe->ref_ctr_offset",
            "(unsigned long long) uprobe->ref_ctr_offset"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\nref_ctr_mismatch_warn(struct uprobe *cur_uprobe, struct uprobe *uprobe)\n{\n\tpr_warn(\"ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx \"\n\t\t\"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\\n\",\n\t\tuprobe->inode->i_ino, (unsigned long long) uprobe->offset,\n\t\t(unsigned long long) cur_uprobe->ref_ctr_offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset);\n}"
  },
  {
    "function_name": "insert_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "671-680",
    "snippet": "static struct uprobe *insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct uprobe *u;\n\n\tspin_lock(&uprobes_treelock);\n\tu = __insert_uprobe(uprobe);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn u;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(uprobes_treelock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__insert_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "633-661",
          "snippet": "static struct uprobe *__insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct rb_node **p = &uprobes_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct uprobe *u;\n\tint match;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tu = rb_entry(parent, struct uprobe, rb_node);\n\t\tmatch = match_uprobe(uprobe, u);\n\t\tif (!match)\n\t\t\treturn get_uprobe(u);\n\n\t\tif (match < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\n\t}\n\n\tu = NULL;\n\trb_link_node(&uprobe->rb_node, parent, p);\n\trb_insert_color(&uprobe->rb_node, &uprobes_tree);\n\t/* get access + creation ref */\n\tatomic_set(&uprobe->ref, 2);\n\n\treturn u;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *__insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct rb_node **p = &uprobes_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct uprobe *u;\n\tint match;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tu = rb_entry(parent, struct uprobe, rb_node);\n\t\tmatch = match_uprobe(uprobe, u);\n\t\tif (!match)\n\t\t\treturn get_uprobe(u);\n\n\t\tif (match < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\n\t}\n\n\tu = NULL;\n\trb_link_node(&uprobe->rb_node, parent, p);\n\trb_insert_color(&uprobe->rb_node, &uprobes_tree);\n\t/* get access + creation ref */\n\tatomic_set(&uprobe->ref, 2);\n\n\treturn u;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct uprobe *u;\n\n\tspin_lock(&uprobes_treelock);\n\tu = __insert_uprobe(uprobe);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn u;\n}"
  },
  {
    "function_name": "__insert_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "633-661",
    "snippet": "static struct uprobe *__insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct rb_node **p = &uprobes_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct uprobe *u;\n\tint match;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tu = rb_entry(parent, struct uprobe, rb_node);\n\t\tmatch = match_uprobe(uprobe, u);\n\t\tif (!match)\n\t\t\treturn get_uprobe(u);\n\n\t\tif (match < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\n\t}\n\n\tu = NULL;\n\trb_link_node(&uprobe->rb_node, parent, p);\n\trb_insert_color(&uprobe->rb_node, &uprobes_tree);\n\t/* get access + creation ref */\n\tatomic_set(&uprobe->ref, 2);\n\n\treturn u;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root uprobes_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&uprobe->ref",
            "2"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&uprobe->rb_node",
            "&uprobes_tree"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&uprobe->rb_node",
            "parent",
            "p"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uprobe",
          "args": [
            "u"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "get_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "561-565",
          "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_uprobe",
          "args": [
            "uprobe",
            "u"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "match_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "580-595",
          "snippet": "static int match_uprobe(struct uprobe *l, struct uprobe *r)\n{\n\tif (l->inode < r->inode)\n\t\treturn -1;\n\n\tif (l->inode > r->inode)\n\t\treturn 1;\n\n\tif (l->offset < r->offset)\n\t\treturn -1;\n\n\tif (l->offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int match_uprobe(struct uprobe *l, struct uprobe *r)\n{\n\tif (l->inode < r->inode)\n\t\treturn -1;\n\n\tif (l->inode > r->inode)\n\t\treturn 1;\n\n\tif (l->offset < r->offset)\n\t\treturn -1;\n\n\tif (l->offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structuprobe",
            "rb_node"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *__insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct rb_node **p = &uprobes_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct uprobe *u;\n\tint match;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tu = rb_entry(parent, struct uprobe, rb_node);\n\t\tmatch = match_uprobe(uprobe, u);\n\t\tif (!match)\n\t\t\treturn get_uprobe(u);\n\n\t\tif (match < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\n\t}\n\n\tu = NULL;\n\trb_link_node(&uprobe->rb_node, parent, p);\n\trb_insert_color(&uprobe->rb_node, &uprobes_tree);\n\t/* get access + creation ref */\n\tatomic_set(&uprobe->ref, 2);\n\n\treturn u;\n}"
  },
  {
    "function_name": "find_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "622-631",
    "snippet": "static struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(uprobes_treelock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_uprobe",
          "args": [
            "inode",
            "offset"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "__find_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "597-616",
          "snippet": "static struct uprobe *__find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe u = { .inode = inode, .offset = offset };\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\tstruct uprobe *uprobe;\n\tint match;\n\n\twhile (n) {\n\t\tuprobe = rb_entry(n, struct uprobe, rb_node);\n\t\tmatch = match_uprobe(&u, uprobe);\n\t\tif (!match)\n\t\t\treturn get_uprobe(uprobe);\n\n\t\tif (match < 0)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tn = n->rb_right;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *__find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe u = { .inode = inode, .offset = offset };\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\tstruct uprobe *uprobe;\n\tint match;\n\n\twhile (n) {\n\t\tuprobe = rb_entry(n, struct uprobe, rb_node);\n\t\tmatch = match_uprobe(&u, uprobe);\n\t\tif (!match)\n\t\t\treturn get_uprobe(uprobe);\n\n\t\tif (match < 0)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tn = n->rb_right;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}"
  },
  {
    "function_name": "__find_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "597-616",
    "snippet": "static struct uprobe *__find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe u = { .inode = inode, .offset = offset };\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\tstruct uprobe *uprobe;\n\tint match;\n\n\twhile (n) {\n\t\tuprobe = rb_entry(n, struct uprobe, rb_node);\n\t\tmatch = match_uprobe(&u, uprobe);\n\t\tif (!match)\n\t\t\treturn get_uprobe(uprobe);\n\n\t\tif (match < 0)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tn = n->rb_right;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root uprobes_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "get_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "561-565",
          "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_uprobe",
          "args": [
            "&u",
            "uprobe"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "match_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "580-595",
          "snippet": "static int match_uprobe(struct uprobe *l, struct uprobe *r)\n{\n\tif (l->inode < r->inode)\n\t\treturn -1;\n\n\tif (l->inode > r->inode)\n\t\treturn 1;\n\n\tif (l->offset < r->offset)\n\t\treturn -1;\n\n\tif (l->offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int match_uprobe(struct uprobe *l, struct uprobe *r)\n{\n\tif (l->inode < r->inode)\n\t\treturn -1;\n\n\tif (l->inode > r->inode)\n\t\treturn 1;\n\n\tif (l->offset < r->offset)\n\t\treturn -1;\n\n\tif (l->offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structuprobe",
            "rb_node"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *__find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe u = { .inode = inode, .offset = offset };\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\tstruct uprobe *uprobe;\n\tint match;\n\n\twhile (n) {\n\t\tuprobe = rb_entry(n, struct uprobe, rb_node);\n\t\tmatch = match_uprobe(&u, uprobe);\n\t\tif (!match)\n\t\t\treturn get_uprobe(uprobe);\n\n\t\tif (match < 0)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tn = n->rb_right;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "match_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "580-595",
    "snippet": "static int match_uprobe(struct uprobe *l, struct uprobe *r)\n{\n\tif (l->inode < r->inode)\n\t\treturn -1;\n\n\tif (l->inode > r->inode)\n\t\treturn 1;\n\n\tif (l->offset < r->offset)\n\t\treturn -1;\n\n\tif (l->offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int match_uprobe(struct uprobe *l, struct uprobe *r)\n{\n\tif (l->inode < r->inode)\n\t\treturn -1;\n\n\tif (l->inode > r->inode)\n\t\treturn 1;\n\n\tif (l->offset < r->offset)\n\t\treturn -1;\n\n\tif (l->offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "put_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "567-578",
    "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(delayed_uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "uprobe"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_remove",
          "args": [
            "uprobe",
            "NULL"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "331-349",
          "snippet": "static void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&uprobe->ref"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (atomic_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tkfree(uprobe);\n\t}\n}"
  },
  {
    "function_name": "get_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "561-565",
    "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&uprobe->ref"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\tatomic_inc(&uprobe->ref);\n\treturn uprobe;\n}"
  },
  {
    "function_name": "set_orig_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "554-559",
    "snippet": "int __weak\nset_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr,\n\t\t\t*(uprobe_opcode_t *)&auprobe->insn);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_write_opcode",
          "args": [
            "auprobe",
            "mm",
            "vaddr",
            "*(uprobe_opcode_t *)&auprobe->insn"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_write_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "472-529",
          "snippet": "int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_FORCE | FOLL_SPLIT, &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_FORCE | FOLL_SPLIT, &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint __weak\nset_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr,\n\t\t\t*(uprobe_opcode_t *)&auprobe->insn);\n}"
  },
  {
    "function_name": "set_swbp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "540-543",
    "snippet": "int __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr, UPROBE_SWBP_INSN);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_write_opcode",
          "args": [
            "auprobe",
            "mm",
            "vaddr",
            "UPROBE_SWBP_INSN"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_write_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "472-529",
          "snippet": "int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_FORCE | FOLL_SPLIT, &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_FORCE | FOLL_SPLIT, &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr, UPROBE_SWBP_INSN);\n}"
  },
  {
    "function_name": "uprobe_write_opcode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "472-529",
    "snippet": "int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_FORCE | FOLL_SPLIT, &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_ref_ctr",
          "args": [
            "uprobe",
            "mm",
            "-1"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "update_ref_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "426-453",
          "snippet": "static int update_ref_ctr(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\t  short d)\n{\n\tstruct vm_area_struct *rc_vma;\n\tunsigned long rc_vaddr;\n\tint ret = 0;\n\n\trc_vma = find_ref_ctr_vma(uprobe, mm);\n\n\tif (rc_vma) {\n\t\trc_vaddr = offset_to_vaddr(rc_vma, uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(mm, rc_vaddr, d);\n\t\tif (ret)\n\t\t\tupdate_ref_ctr_warn(uprobe, mm, d);\n\n\t\tif (d > 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tif (d > 0)\n\t\tret = delayed_uprobe_add(uprobe, mm);\n\telse\n\t\tdelayed_uprobe_remove(uprobe, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\n\nstatic int update_ref_ctr(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\t  short d)\n{\n\tstruct vm_area_struct *rc_vma;\n\tunsigned long rc_vaddr;\n\tint ret = 0;\n\n\trc_vma = find_ref_ctr_vma(uprobe, mm);\n\n\tif (rc_vma) {\n\t\trc_vaddr = offset_to_vaddr(rc_vma, uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(mm, rc_vaddr, d);\n\t\tif (ret)\n\t\t\tupdate_ref_ctr_warn(uprobe, mm, d);\n\n\t\tif (d > 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tif (d > 0)\n\t\tret = delayed_uprobe_add(uprobe, mm);\n\telse\n\t\tdelayed_uprobe_remove(uprobe, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EAGAIN"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "old_page"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "new_page"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__replace_page",
          "args": [
            "vma",
            "vaddr",
            "old_page",
            "new_page"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "__replace_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "164-226",
          "snippet": "static int __replace_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tstruct page *old_page, struct page *new_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = old_page,\n\t\t.vma = vma,\n\t\t.address = addr,\n\t};\n\tint err;\n\t/* For mmu_notifiers */\n\tconst unsigned long mmun_start = addr;\n\tconst unsigned long mmun_end   = addr + PAGE_SIZE;\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(PageTransHuge(old_page), old_page);\n\n\terr = mem_cgroup_try_charge(new_page, vma->vm_mm, GFP_KERNEL, &memcg,\n\t\t\tfalse);\n\tif (err)\n\t\treturn err;\n\n\t/* For try_to_free_swap() and munlock_vma_page() below */\n\tlock_page(old_page);\n\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\terr = -EAGAIN;\n\tif (!page_vma_mapped_walk(&pvmw)) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, false);\n\t\tgoto unlock;\n\t}\n\tVM_BUG_ON_PAGE(addr != pvmw.address, old_page);\n\n\tget_page(new_page);\n\tpage_add_new_anon_rmap(new_page, vma, addr, false);\n\tmem_cgroup_commit_charge(new_page, memcg, false, false);\n\tlru_cache_add_active_or_unevictable(new_page, vma);\n\n\tif (!PageAnon(old_page)) {\n\t\tdec_mm_counter(mm, mm_counter_file(old_page));\n\t\tinc_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*pvmw.pte));\n\tptep_clear_flush_notify(vma, addr, pvmw.pte);\n\tset_pte_at_notify(mm, addr, pvmw.pte,\n\t\t\tmk_pte(new_page, vma->vm_page_prot));\n\n\tpage_remove_rmap(old_page, false);\n\tif (!page_mapped(old_page))\n\t\ttry_to_free_swap(old_page);\n\tpage_vma_mapped_walk_done(&pvmw);\n\n\tif (vma->vm_flags & VM_LOCKED)\n\t\tmunlock_vma_page(old_page);\n\tput_page(old_page);\n\n\terr = 0;\n unlock:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\tunlock_page(old_page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __replace_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tstruct page *old_page, struct page *new_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = old_page,\n\t\t.vma = vma,\n\t\t.address = addr,\n\t};\n\tint err;\n\t/* For mmu_notifiers */\n\tconst unsigned long mmun_start = addr;\n\tconst unsigned long mmun_end   = addr + PAGE_SIZE;\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(PageTransHuge(old_page), old_page);\n\n\terr = mem_cgroup_try_charge(new_page, vma->vm_mm, GFP_KERNEL, &memcg,\n\t\t\tfalse);\n\tif (err)\n\t\treturn err;\n\n\t/* For try_to_free_swap() and munlock_vma_page() below */\n\tlock_page(old_page);\n\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\terr = -EAGAIN;\n\tif (!page_vma_mapped_walk(&pvmw)) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, false);\n\t\tgoto unlock;\n\t}\n\tVM_BUG_ON_PAGE(addr != pvmw.address, old_page);\n\n\tget_page(new_page);\n\tpage_add_new_anon_rmap(new_page, vma, addr, false);\n\tmem_cgroup_commit_charge(new_page, memcg, false, false);\n\tlru_cache_add_active_or_unevictable(new_page, vma);\n\n\tif (!PageAnon(old_page)) {\n\t\tdec_mm_counter(mm, mm_counter_file(old_page));\n\t\tinc_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*pvmw.pte));\n\tptep_clear_flush_notify(vma, addr, pvmw.pte);\n\tset_pte_at_notify(mm, addr, pvmw.pte,\n\t\t\tmk_pte(new_page, vma->vm_page_prot));\n\n\tpage_remove_rmap(old_page, false);\n\tif (!page_mapped(old_page))\n\t\ttry_to_free_swap(old_page);\n\tpage_vma_mapped_walk_done(&pvmw);\n\n\tif (vma->vm_flags & VM_LOCKED)\n\t\tmunlock_vma_page(old_page);\n\tput_page(old_page);\n\n\terr = 0;\n unlock:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\tunlock_page(old_page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_page",
          "args": [
            "new_page",
            "vaddr",
            "&opcode",
            "UPROBE_SWBP_INSN_SIZE"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "copy_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "260-265",
          "snippet": "static void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "new_page",
            "old_page"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "new_page"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page_vma",
          "args": [
            "GFP_HIGHUSER_MOVABLE",
            "vma",
            "vaddr"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_opcode",
          "args": [
            "old_page",
            "vaddr",
            "&opcode"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "verify_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "267-293",
          "snippet": "static int verify_opcode(struct page *page, unsigned long vaddr, uprobe_opcode_t *new_opcode)\n{\n\tuprobe_opcode_t old_opcode;\n\tbool is_swbp;\n\n\t/*\n\t * Note: We only check if the old_opcode is UPROBE_SWBP_INSN here.\n\t * We do not check if it is any other 'trap variant' which could\n\t * be conditional trap instruction such as the one powerpc supports.\n\t *\n\t * The logic is that we do not care if the underlying instruction\n\t * is a trap variant; uprobes always wins over any other (gdb)\n\t * breakpoint.\n\t */\n\tcopy_from_page(page, vaddr, &old_opcode, UPROBE_SWBP_INSN_SIZE);\n\tis_swbp = is_swbp_insn(&old_opcode);\n\n\tif (is_swbp_insn(new_opcode)) {\n\t\tif (is_swbp)\t\t/* register: already installed? */\n\t\t\treturn 0;\n\t} else {\n\t\tif (!is_swbp)\t\t/* unregister: was it changed by us? */\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int verify_opcode(struct page *page, unsigned long vaddr, uprobe_opcode_t *new_opcode)\n{\n\tuprobe_opcode_t old_opcode;\n\tbool is_swbp;\n\n\t/*\n\t * Note: We only check if the old_opcode is UPROBE_SWBP_INSN here.\n\t * We do not check if it is any other 'trap variant' which could\n\t * be conditional trap instruction such as the one powerpc supports.\n\t *\n\t * The logic is that we do not care if the underlying instruction\n\t * is a trap variant; uprobes always wins over any other (gdb)\n\t * breakpoint.\n\t */\n\tcopy_from_page(page, vaddr, &old_opcode, UPROBE_SWBP_INSN_SIZE);\n\tis_swbp = is_swbp_insn(&old_opcode);\n\n\tif (is_swbp_insn(new_opcode)) {\n\t\tif (is_swbp)\t\t/* register: already installed? */\n\t\t\treturn 0;\n\t} else {\n\t\tif (!is_swbp)\t\t/* unregister: was it changed by us? */\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_pages_remote",
          "args": [
            "NULL",
            "mm",
            "vaddr",
            "1",
            "FOLL_FORCE | FOLL_SPLIT",
            "&old_page",
            "&vma",
            "NULL"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "auprobe",
            "structuprobe",
            "arch"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swbp_insn",
          "args": [
            "&opcode"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "is_swbp_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "234-237",
          "snippet": "bool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_FORCE | FOLL_SPLIT, &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "update_ref_ctr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "426-453",
    "snippet": "static int update_ref_ctr(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\t  short d)\n{\n\tstruct vm_area_struct *rc_vma;\n\tunsigned long rc_vaddr;\n\tint ret = 0;\n\n\trc_vma = find_ref_ctr_vma(uprobe, mm);\n\n\tif (rc_vma) {\n\t\trc_vaddr = offset_to_vaddr(rc_vma, uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(mm, rc_vaddr, d);\n\t\tif (ret)\n\t\t\tupdate_ref_ctr_warn(uprobe, mm, d);\n\n\t\tif (d > 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tif (d > 0)\n\t\tret = delayed_uprobe_add(uprobe, mm);\n\telse\n\t\tdelayed_uprobe_remove(uprobe, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(delayed_uprobe_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_remove",
          "args": [
            "uprobe",
            "mm"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "331-349",
          "snippet": "static void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_add",
          "args": [
            "uprobe",
            "mm"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "306-321",
          "snippet": "static int delayed_uprobe_add(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tif (delayed_uprobe_check(uprobe, mm))\n\t\treturn 0;\n\n\tdu  = kzalloc(sizeof(*du), GFP_KERNEL);\n\tif (!du)\n\t\treturn -ENOMEM;\n\n\tdu->uprobe = uprobe;\n\tdu->mm = mm;\n\tlist_add(&du->list, &delayed_uprobe_list);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic int delayed_uprobe_add(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tif (delayed_uprobe_check(uprobe, mm))\n\t\treturn 0;\n\n\tdu  = kzalloc(sizeof(*du), GFP_KERNEL);\n\tif (!du)\n\t\treturn -ENOMEM;\n\n\tdu->uprobe = uprobe;\n\tdu->mm = mm;\n\tlist_add(&du->list, &delayed_uprobe_list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ref_ctr_warn",
          "args": [
            "uprobe",
            "mm",
            "d"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "update_ref_ctr_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "416-424",
          "snippet": "static void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_ref_ctr",
          "args": [
            "mm",
            "rc_vaddr",
            "d"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "__update_ref_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "376-414",
          "snippet": "static int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "rc_vma",
            "uprobe->ref_ctr_offset"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "143-146",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_ref_ctr_vma",
          "args": [
            "uprobe",
            "mm"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "find_ref_ctr_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "364-374",
          "snippet": "static struct vm_area_struct *\nfind_ref_ctr_vma(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *tmp;\n\n\tfor (tmp = mm->mmap; tmp; tmp = tmp->vm_next)\n\t\tif (valid_ref_ctr_vma(uprobe, tmp))\n\t\t\treturn tmp;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct vm_area_struct *\nfind_ref_ctr_vma(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *tmp;\n\n\tfor (tmp = mm->mmap; tmp; tmp = tmp->vm_next)\n\t\tif (valid_ref_ctr_vma(uprobe, tmp))\n\t\t\treturn tmp;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\n\nstatic int update_ref_ctr(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\t  short d)\n{\n\tstruct vm_area_struct *rc_vma;\n\tunsigned long rc_vaddr;\n\tint ret = 0;\n\n\trc_vma = find_ref_ctr_vma(uprobe, mm);\n\n\tif (rc_vma) {\n\t\trc_vaddr = offset_to_vaddr(rc_vma, uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(mm, rc_vaddr, d);\n\t\tif (ret)\n\t\t\tupdate_ref_ctr_warn(uprobe, mm, d);\n\n\t\tif (d > 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tif (d > 0)\n\t\tret = delayed_uprobe_add(uprobe, mm);\n\telse\n\t\tdelayed_uprobe_remove(uprobe, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "update_ref_ctr_warn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "416-424",
    "snippet": "static void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\"",
            "d > 0 ? \"increment\" : \"decrement\"",
            "uprobe->inode->i_ino",
            "(unsigned long long) uprobe->offset",
            "(unsigned long long) uprobe->ref_ctr_offset",
            "mm"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}"
  },
  {
    "function_name": "__update_ref_ctr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "376-414",
    "snippet": "static int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\"",
            "vaddr",
            "*ptr",
            "d"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*ptr + d < 0"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret <= 0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_remote",
          "args": [
            "NULL",
            "mm",
            "vaddr",
            "1",
            "FOLL_WRITE",
            "&page",
            "&vma",
            "NULL"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(NULL, mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_ref_ctr_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "364-374",
    "snippet": "static struct vm_area_struct *\nfind_ref_ctr_vma(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *tmp;\n\n\tfor (tmp = mm->mmap; tmp; tmp = tmp->vm_next)\n\t\tif (valid_ref_ctr_vma(uprobe, tmp))\n\t\t\treturn tmp;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "valid_ref_ctr_vma",
          "args": [
            "uprobe",
            "tmp"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "valid_ref_ctr_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "351-362",
          "snippet": "static bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct vm_area_struct *\nfind_ref_ctr_vma(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *tmp;\n\n\tfor (tmp = mm->mmap; tmp; tmp = tmp->vm_next)\n\t\tif (valid_ref_ctr_vma(uprobe, tmp))\n\t\t\treturn tmp;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "valid_ref_ctr_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "351-362",
    "snippet": "static bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "vma",
            "uprobe->ref_ctr_offset"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "143-146",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}"
  },
  {
    "function_name": "delayed_uprobe_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "331-349",
    "snippet": "static void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(delayed_uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delayed_uprobe_delete",
          "args": [
            "du"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "323-329",
          "snippet": "static void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structdelayed_uprobe",
            "list"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "q",
            "&delayed_uprobe_list"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}"
  },
  {
    "function_name": "delayed_uprobe_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "323-329",
    "snippet": "static void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "du"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&du->list"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!du"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}"
  },
  {
    "function_name": "delayed_uprobe_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "306-321",
    "snippet": "static int delayed_uprobe_add(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tif (delayed_uprobe_check(uprobe, mm))\n\t\treturn 0;\n\n\tdu  = kzalloc(sizeof(*du), GFP_KERNEL);\n\tif (!du)\n\t\treturn -ENOMEM;\n\n\tdu->uprobe = uprobe;\n\tdu->mm = mm;\n\tlist_add(&du->list, &delayed_uprobe_list);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(delayed_uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&du->list",
            "&delayed_uprobe_list"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*du)",
            "GFP_KERNEL"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_check",
          "args": [
            "uprobe",
            "mm"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "295-304",
          "snippet": "static struct delayed_uprobe *\ndelayed_uprobe_check(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tlist_for_each_entry(du, &delayed_uprobe_list, list)\n\t\tif (du->uprobe == uprobe && du->mm == mm)\n\t\t\treturn du;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic struct delayed_uprobe *\ndelayed_uprobe_check(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tlist_for_each_entry(du, &delayed_uprobe_list, list)\n\t\tif (du->uprobe == uprobe && du->mm == mm)\n\t\t\treturn du;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic int delayed_uprobe_add(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tif (delayed_uprobe_check(uprobe, mm))\n\t\treturn 0;\n\n\tdu  = kzalloc(sizeof(*du), GFP_KERNEL);\n\tif (!du)\n\t\treturn -ENOMEM;\n\n\tdu->uprobe = uprobe;\n\tdu->mm = mm;\n\tlist_add(&du->list, &delayed_uprobe_list);\n\treturn 0;\n}"
  },
  {
    "function_name": "delayed_uprobe_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "295-304",
    "snippet": "static struct delayed_uprobe *\ndelayed_uprobe_check(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tlist_for_each_entry(du, &delayed_uprobe_list, list)\n\t\tif (du->uprobe == uprobe && du->mm == mm)\n\t\t\treturn du;\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(delayed_uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "du",
            "&delayed_uprobe_list",
            "list"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic struct delayed_uprobe *\ndelayed_uprobe_check(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tlist_for_each_entry(du, &delayed_uprobe_list, list)\n\t\tif (du->uprobe == uprobe && du->mm == mm)\n\t\t\treturn du;\n\treturn NULL;\n}"
  },
  {
    "function_name": "verify_opcode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "267-293",
    "snippet": "static int verify_opcode(struct page *page, unsigned long vaddr, uprobe_opcode_t *new_opcode)\n{\n\tuprobe_opcode_t old_opcode;\n\tbool is_swbp;\n\n\t/*\n\t * Note: We only check if the old_opcode is UPROBE_SWBP_INSN here.\n\t * We do not check if it is any other 'trap variant' which could\n\t * be conditional trap instruction such as the one powerpc supports.\n\t *\n\t * The logic is that we do not care if the underlying instruction\n\t * is a trap variant; uprobes always wins over any other (gdb)\n\t * breakpoint.\n\t */\n\tcopy_from_page(page, vaddr, &old_opcode, UPROBE_SWBP_INSN_SIZE);\n\tis_swbp = is_swbp_insn(&old_opcode);\n\n\tif (is_swbp_insn(new_opcode)) {\n\t\tif (is_swbp)\t\t/* register: already installed? */\n\t\t\treturn 0;\n\t} else {\n\t\tif (!is_swbp)\t\t/* unregister: was it changed by us? */\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_swbp_insn",
          "args": [
            "new_opcode"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "is_swbp_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "234-237",
          "snippet": "bool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_page",
          "args": [
            "page",
            "vaddr",
            "&old_opcode",
            "UPROBE_SWBP_INSN_SIZE"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "copy_from_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "253-258",
          "snippet": "static void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int verify_opcode(struct page *page, unsigned long vaddr, uprobe_opcode_t *new_opcode)\n{\n\tuprobe_opcode_t old_opcode;\n\tbool is_swbp;\n\n\t/*\n\t * Note: We only check if the old_opcode is UPROBE_SWBP_INSN here.\n\t * We do not check if it is any other 'trap variant' which could\n\t * be conditional trap instruction such as the one powerpc supports.\n\t *\n\t * The logic is that we do not care if the underlying instruction\n\t * is a trap variant; uprobes always wins over any other (gdb)\n\t * breakpoint.\n\t */\n\tcopy_from_page(page, vaddr, &old_opcode, UPROBE_SWBP_INSN_SIZE);\n\tis_swbp = is_swbp_insn(&old_opcode);\n\n\tif (is_swbp_insn(new_opcode)) {\n\t\tif (is_swbp)\t\t/* register: already installed? */\n\t\t\treturn 0;\n\t} else {\n\t\tif (!is_swbp)\t\t/* unregister: was it changed by us? */\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "copy_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "260-265",
    "snippet": "static void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr + (vaddr & ~PAGE_MASK)",
            "src",
            "len"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}"
  },
  {
    "function_name": "copy_from_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "253-258",
    "snippet": "static void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "kaddr + (vaddr & ~PAGE_MASK)",
            "len"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}"
  },
  {
    "function_name": "is_trap_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "248-251",
    "snippet": "bool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_swbp_insn",
          "args": [
            "insn"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "is_swbp_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "234-237",
          "snippet": "bool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}"
  },
  {
    "function_name": "is_swbp_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "234-237",
    "snippet": "bool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}"
  },
  {
    "function_name": "__replace_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "164-226",
    "snippet": "static int __replace_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tstruct page *old_page, struct page *new_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = old_page,\n\t\t.vma = vma,\n\t\t.address = addr,\n\t};\n\tint err;\n\t/* For mmu_notifiers */\n\tconst unsigned long mmun_start = addr;\n\tconst unsigned long mmun_end   = addr + PAGE_SIZE;\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(PageTransHuge(old_page), old_page);\n\n\terr = mem_cgroup_try_charge(new_page, vma->vm_mm, GFP_KERNEL, &memcg,\n\t\t\tfalse);\n\tif (err)\n\t\treturn err;\n\n\t/* For try_to_free_swap() and munlock_vma_page() below */\n\tlock_page(old_page);\n\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\terr = -EAGAIN;\n\tif (!page_vma_mapped_walk(&pvmw)) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, false);\n\t\tgoto unlock;\n\t}\n\tVM_BUG_ON_PAGE(addr != pvmw.address, old_page);\n\n\tget_page(new_page);\n\tpage_add_new_anon_rmap(new_page, vma, addr, false);\n\tmem_cgroup_commit_charge(new_page, memcg, false, false);\n\tlru_cache_add_active_or_unevictable(new_page, vma);\n\n\tif (!PageAnon(old_page)) {\n\t\tdec_mm_counter(mm, mm_counter_file(old_page));\n\t\tinc_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*pvmw.pte));\n\tptep_clear_flush_notify(vma, addr, pvmw.pte);\n\tset_pte_at_notify(mm, addr, pvmw.pte,\n\t\t\tmk_pte(new_page, vma->vm_page_prot));\n\n\tpage_remove_rmap(old_page, false);\n\tif (!page_mapped(old_page))\n\t\ttry_to_free_swap(old_page);\n\tpage_vma_mapped_walk_done(&pvmw);\n\n\tif (vma->vm_flags & VM_LOCKED)\n\t\tmunlock_vma_page(old_page);\n\tput_page(old_page);\n\n\terr = 0;\n unlock:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\tunlock_page(old_page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "old_page"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "old_page"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munlock_vma_page",
          "args": [
            "old_page"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_swap",
          "args": [
            "old_page"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "old_page"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "old_page",
            "false"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at_notify",
          "args": [
            "mm",
            "addr",
            "pvmw.pte",
            "mk_pte(new_page, vma->vm_page_prot)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "new_page",
            "vma->vm_page_prot"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush_notify",
          "args": [
            "vma",
            "addr",
            "pvmw.pte"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "addr",
            "pte_pfn(*pvmw.pte)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pvmw.pte"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter",
          "args": [
            "mm",
            "mm_counter_file(old_page)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter_file",
          "args": [
            "old_page"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "old_page"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "new_page",
            "vma"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "new_page",
            "memcg",
            "false",
            "false"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "new_page",
            "vma",
            "addr",
            "false"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "new_page"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "addr != pvmw.address",
            "old_page"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "new_page",
            "memcg",
            "false"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk",
          "args": [
            "&pvmw"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "old_page"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge",
          "args": [
            "new_page",
            "vma->vm_mm",
            "GFP_KERNEL",
            "&memcg",
            "false"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTransHuge(old_page)",
            "old_page"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "old_page"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __replace_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tstruct page *old_page, struct page *new_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = old_page,\n\t\t.vma = vma,\n\t\t.address = addr,\n\t};\n\tint err;\n\t/* For mmu_notifiers */\n\tconst unsigned long mmun_start = addr;\n\tconst unsigned long mmun_end   = addr + PAGE_SIZE;\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(PageTransHuge(old_page), old_page);\n\n\terr = mem_cgroup_try_charge(new_page, vma->vm_mm, GFP_KERNEL, &memcg,\n\t\t\tfalse);\n\tif (err)\n\t\treturn err;\n\n\t/* For try_to_free_swap() and munlock_vma_page() below */\n\tlock_page(old_page);\n\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\terr = -EAGAIN;\n\tif (!page_vma_mapped_walk(&pvmw)) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, false);\n\t\tgoto unlock;\n\t}\n\tVM_BUG_ON_PAGE(addr != pvmw.address, old_page);\n\n\tget_page(new_page);\n\tpage_add_new_anon_rmap(new_page, vma, addr, false);\n\tmem_cgroup_commit_charge(new_page, memcg, false, false);\n\tlru_cache_add_active_or_unevictable(new_page, vma);\n\n\tif (!PageAnon(old_page)) {\n\t\tdec_mm_counter(mm, mm_counter_file(old_page));\n\t\tinc_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*pvmw.pte));\n\tptep_clear_flush_notify(vma, addr, pvmw.pte);\n\tset_pte_at_notify(mm, addr, pvmw.pte,\n\t\t\tmk_pte(new_page, vma->vm_page_prot));\n\n\tpage_remove_rmap(old_page, false);\n\tif (!page_mapped(old_page))\n\t\ttry_to_free_swap(old_page);\n\tpage_vma_mapped_walk_done(&pvmw);\n\n\tif (vma->vm_flags & VM_LOCKED)\n\t\tmunlock_vma_page(old_page);\n\tput_page(old_page);\n\n\terr = 0;\n unlock:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\tunlock_page(old_page);\n\treturn err;\n}"
  },
  {
    "function_name": "vaddr_to_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "148-151",
    "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
  },
  {
    "function_name": "offset_to_vaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "143-146",
    "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
  },
  {
    "function_name": "valid_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
    "lines": "133-141",
    "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
  }
]