[
  {
    "function_name": "klp_unpatch_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
    "lines": "270-277",
    "snippet": "void klp_unpatch_objects(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_unpatch_object(obj);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_unpatch_object",
          "args": [
            "obj"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "klp_unpatch_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "270-277",
          "snippet": "void klp_unpatch_objects(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_unpatch_object(obj);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "patch",
            "obj"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nvoid klp_unpatch_objects(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_unpatch_object(obj);\n}"
  },
  {
    "function_name": "klp_patch_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
    "lines": "250-268",
    "snippet": "int klp_patch_object(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tif (WARN_ON(obj->patched))\n\t\treturn -EINVAL;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_patch_func(func);\n\t\tif (ret) {\n\t\t\tklp_unpatch_object(obj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tobj->patched = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_unpatch_object",
          "args": [
            "obj"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "klp_unpatch_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "270-277",
          "snippet": "void klp_unpatch_objects(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_unpatch_object(obj);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nvoid klp_unpatch_objects(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_unpatch_object(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_patch_func",
          "args": [
            "func"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "klp_patch_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "172-237",
          "snippet": "static int klp_patch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\tint ret;\n\n\tif (WARN_ON(!func->old_addr))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(func->patched))\n\t\treturn -EINVAL;\n\n\tops = klp_find_ops(func->old_addr);\n\tif (!ops) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc = klp_get_ftrace_location(func->old_addr);\n\t\tif (!ftrace_loc) {\n\t\t\tpr_err(\"failed to find location for function '%s'\\n\",\n\t\t\t\tfunc->old_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\t\tif (!ops)\n\t\t\treturn -ENOMEM;\n\n\t\tops->fops.func = klp_ftrace_handler;\n\t\tops->fops.flags = FTRACE_OPS_FL_SAVE_REGS |\n\t\t\t\t  FTRACE_OPS_FL_DYNAMIC |\n\t\t\t\t  FTRACE_OPS_FL_IPMODIFY;\n\n\t\tlist_add(&ops->node, &klp_ops);\n\n\t\tINIT_LIST_HEAD(&ops->func_stack);\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\n\t\tret = ftrace_set_filter_ip(&ops->fops, ftrace_loc, 0, 0);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set ftrace filter for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = register_ftrace_function(&ops->fops);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to register ftrace handler for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0);\n\t\t\tgoto err;\n\t\t}\n\n\n\t} else {\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\t}\n\n\tfunc->patched = true;\n\n\treturn 0;\n\nerr:\n\tlist_del_rcu(&func->stack_node);\n\tlist_del(&ops->node);\n\tkfree(ops);\n\treturn ret;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstatic int klp_patch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\tint ret;\n\n\tif (WARN_ON(!func->old_addr))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(func->patched))\n\t\treturn -EINVAL;\n\n\tops = klp_find_ops(func->old_addr);\n\tif (!ops) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc = klp_get_ftrace_location(func->old_addr);\n\t\tif (!ftrace_loc) {\n\t\t\tpr_err(\"failed to find location for function '%s'\\n\",\n\t\t\t\tfunc->old_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\t\tif (!ops)\n\t\t\treturn -ENOMEM;\n\n\t\tops->fops.func = klp_ftrace_handler;\n\t\tops->fops.flags = FTRACE_OPS_FL_SAVE_REGS |\n\t\t\t\t  FTRACE_OPS_FL_DYNAMIC |\n\t\t\t\t  FTRACE_OPS_FL_IPMODIFY;\n\n\t\tlist_add(&ops->node, &klp_ops);\n\n\t\tINIT_LIST_HEAD(&ops->func_stack);\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\n\t\tret = ftrace_set_filter_ip(&ops->fops, ftrace_loc, 0, 0);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set ftrace filter for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = register_ftrace_function(&ops->fops);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to register ftrace handler for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0);\n\t\t\tgoto err;\n\t\t}\n\n\n\t} else {\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\t}\n\n\tfunc->patched = true;\n\n\treturn 0;\n\nerr:\n\tlist_del_rcu(&func->stack_node);\n\tlist_del(&ops->node);\n\tkfree(ops);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "obj->patched"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nint klp_patch_object(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tif (WARN_ON(obj->patched))\n\t\treturn -EINVAL;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_patch_func(func);\n\t\tif (ret) {\n\t\t\tklp_unpatch_object(obj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tobj->patched = true;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_unpatch_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
    "lines": "239-248",
    "snippet": "void klp_unpatch_object(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\n\tklp_for_each_func(obj, func)\n\t\tif (func->patched)\n\t\t\tklp_unpatch_func(func);\n\n\tobj->patched = false;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_unpatch_func",
          "args": [
            "func"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "klp_unpatch_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "139-170",
          "snippet": "static void klp_unpatch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\n\tif (WARN_ON(!func->patched))\n\t\treturn;\n\tif (WARN_ON(!func->old_addr))\n\t\treturn;\n\n\tops = klp_find_ops(func->old_addr);\n\tif (WARN_ON(!ops))\n\t\treturn;\n\n\tif (list_is_singular(&ops->func_stack)) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc = klp_get_ftrace_location(func->old_addr);\n\t\tif (WARN_ON(!ftrace_loc))\n\t\t\treturn;\n\n\t\tWARN_ON(unregister_ftrace_function(&ops->fops));\n\t\tWARN_ON(ftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0));\n\n\t\tlist_del_rcu(&func->stack_node);\n\t\tlist_del(&ops->node);\n\t\tkfree(ops);\n\t} else {\n\t\tlist_del_rcu(&func->stack_node);\n\t}\n\n\tfunc->patched = false;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstatic void klp_unpatch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\n\tif (WARN_ON(!func->patched))\n\t\treturn;\n\tif (WARN_ON(!func->old_addr))\n\t\treturn;\n\n\tops = klp_find_ops(func->old_addr);\n\tif (WARN_ON(!ops))\n\t\treturn;\n\n\tif (list_is_singular(&ops->func_stack)) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc = klp_get_ftrace_location(func->old_addr);\n\t\tif (WARN_ON(!ftrace_loc))\n\t\t\treturn;\n\n\t\tWARN_ON(unregister_ftrace_function(&ops->fops));\n\t\tWARN_ON(ftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0));\n\n\t\tlist_del_rcu(&func->stack_node);\n\t\tlist_del(&ops->node);\n\t\tkfree(ops);\n\t} else {\n\t\tlist_del_rcu(&func->stack_node);\n\t}\n\n\tfunc->patched = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nvoid klp_unpatch_object(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\n\tklp_for_each_func(obj, func)\n\t\tif (func->patched)\n\t\t\tklp_unpatch_func(func);\n\n\tobj->patched = false;\n}"
  },
  {
    "function_name": "klp_patch_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
    "lines": "172-237",
    "snippet": "static int klp_patch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\tint ret;\n\n\tif (WARN_ON(!func->old_addr))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(func->patched))\n\t\treturn -EINVAL;\n\n\tops = klp_find_ops(func->old_addr);\n\tif (!ops) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc = klp_get_ftrace_location(func->old_addr);\n\t\tif (!ftrace_loc) {\n\t\t\tpr_err(\"failed to find location for function '%s'\\n\",\n\t\t\t\tfunc->old_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\t\tif (!ops)\n\t\t\treturn -ENOMEM;\n\n\t\tops->fops.func = klp_ftrace_handler;\n\t\tops->fops.flags = FTRACE_OPS_FL_SAVE_REGS |\n\t\t\t\t  FTRACE_OPS_FL_DYNAMIC |\n\t\t\t\t  FTRACE_OPS_FL_IPMODIFY;\n\n\t\tlist_add(&ops->node, &klp_ops);\n\n\t\tINIT_LIST_HEAD(&ops->func_stack);\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\n\t\tret = ftrace_set_filter_ip(&ops->fops, ftrace_loc, 0, 0);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set ftrace filter for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = register_ftrace_function(&ops->fops);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to register ftrace handler for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0);\n\t\t\tgoto err;\n\t\t}\n\n\n\t} else {\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\t}\n\n\tfunc->patched = true;\n\n\treturn 0;\n\nerr:\n\tlist_del_rcu(&func->stack_node);\n\tlist_del(&ops->node);\n\tkfree(ops);\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ops"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ops->node"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&func->stack_node"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&func->stack_node",
            "&ops->func_stack"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "&ops->fops",
            "ftrace_loc",
            "1",
            "0"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4754-4759",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to register ftrace handler for function '%s' (%d)\\n\"",
            "func->old_name",
            "ret"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "&ops->fops"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to set ftrace filter for function '%s' (%d)\\n\"",
            "func->old_name",
            "ret"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&func->stack_node",
            "&ops->func_stack"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ops->func_stack"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ops->node",
            "&klp_ops"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ops)",
            "GFP_KERNEL"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to find location for function '%s'\\n\"",
            "func->old_name"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_get_ftrace_location",
          "args": [
            "func->old_addr"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "klp_get_ftrace_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "133-136",
          "snippet": "static unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_find_ops",
          "args": [
            "func->old_addr"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "klp_find_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "37-50",
          "snippet": "struct klp_ops *klp_find_ops(unsigned long old_addr)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_addr == old_addr)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstruct klp_ops *klp_find_ops(unsigned long old_addr)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_addr == old_addr)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "func->patched"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!func->old_addr"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstatic int klp_patch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\tint ret;\n\n\tif (WARN_ON(!func->old_addr))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(func->patched))\n\t\treturn -EINVAL;\n\n\tops = klp_find_ops(func->old_addr);\n\tif (!ops) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc = klp_get_ftrace_location(func->old_addr);\n\t\tif (!ftrace_loc) {\n\t\t\tpr_err(\"failed to find location for function '%s'\\n\",\n\t\t\t\tfunc->old_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\t\tif (!ops)\n\t\t\treturn -ENOMEM;\n\n\t\tops->fops.func = klp_ftrace_handler;\n\t\tops->fops.flags = FTRACE_OPS_FL_SAVE_REGS |\n\t\t\t\t  FTRACE_OPS_FL_DYNAMIC |\n\t\t\t\t  FTRACE_OPS_FL_IPMODIFY;\n\n\t\tlist_add(&ops->node, &klp_ops);\n\n\t\tINIT_LIST_HEAD(&ops->func_stack);\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\n\t\tret = ftrace_set_filter_ip(&ops->fops, ftrace_loc, 0, 0);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set ftrace filter for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = register_ftrace_function(&ops->fops);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to register ftrace handler for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0);\n\t\t\tgoto err;\n\t\t}\n\n\n\t} else {\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\t}\n\n\tfunc->patched = true;\n\n\treturn 0;\n\nerr:\n\tlist_del_rcu(&func->stack_node);\n\tlist_del(&ops->node);\n\tkfree(ops);\n\treturn ret;\n}"
  },
  {
    "function_name": "klp_unpatch_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
    "lines": "139-170",
    "snippet": "static void klp_unpatch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\n\tif (WARN_ON(!func->patched))\n\t\treturn;\n\tif (WARN_ON(!func->old_addr))\n\t\treturn;\n\n\tops = klp_find_ops(func->old_addr);\n\tif (WARN_ON(!ops))\n\t\treturn;\n\n\tif (list_is_singular(&ops->func_stack)) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc = klp_get_ftrace_location(func->old_addr);\n\t\tif (WARN_ON(!ftrace_loc))\n\t\t\treturn;\n\n\t\tWARN_ON(unregister_ftrace_function(&ops->fops));\n\t\tWARN_ON(ftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0));\n\n\t\tlist_del_rcu(&func->stack_node);\n\t\tlist_del(&ops->node);\n\t\tkfree(ops);\n\t} else {\n\t\tlist_del_rcu(&func->stack_node);\n\t}\n\n\tfunc->patched = false;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&func->stack_node"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ops"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ops->node"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&func->stack_node"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "&ops->fops",
            "ftrace_loc",
            "1",
            "0"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4754-4759",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "unregister_ftrace_function(&ops->fops)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&ops->fops"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ftrace_loc"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_get_ftrace_location",
          "args": [
            "func->old_addr"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "klp_get_ftrace_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "133-136",
          "snippet": "static unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&ops->func_stack"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ops"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_find_ops",
          "args": [
            "func->old_addr"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "klp_find_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "37-50",
          "snippet": "struct klp_ops *klp_find_ops(unsigned long old_addr)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_addr == old_addr)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstruct klp_ops *klp_find_ops(unsigned long old_addr)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_addr == old_addr)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!func->old_addr"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!func->patched"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstatic void klp_unpatch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\n\tif (WARN_ON(!func->patched))\n\t\treturn;\n\tif (WARN_ON(!func->old_addr))\n\t\treturn;\n\n\tops = klp_find_ops(func->old_addr);\n\tif (WARN_ON(!ops))\n\t\treturn;\n\n\tif (list_is_singular(&ops->func_stack)) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc = klp_get_ftrace_location(func->old_addr);\n\t\tif (WARN_ON(!ftrace_loc))\n\t\t\treturn;\n\n\t\tWARN_ON(unregister_ftrace_function(&ops->fops));\n\t\tWARN_ON(ftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0));\n\n\t\tlist_del_rcu(&func->stack_node);\n\t\tlist_del(&ops->node);\n\t\tkfree(ops);\n\t} else {\n\t\tlist_del_rcu(&func->stack_node);\n\t}\n\n\tfunc->patched = false;\n}"
  },
  {
    "function_name": "klp_get_ftrace_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
    "lines": "133-136",
    "snippet": "static unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}"
  },
  {
    "function_name": "klp_ftrace_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
    "lines": "52-124",
    "snippet": "static void notrace klp_ftrace_handler(unsigned long ip,\n\t\t\t\t       unsigned long parent_ip,\n\t\t\t\t       struct ftrace_ops *fops,\n\t\t\t\t       struct pt_regs *regs)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\tint patch_state;\n\n\tops = container_of(fops, struct klp_ops, fops);\n\n\t/*\n\t * A variant of synchronize_sched() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\tfunc = list_first_or_null_rcu(&ops->func_stack, struct klp_func,\n\t\t\t\t      stack_node);\n\n\t/*\n\t * func should never be NULL because preemption should be disabled here\n\t * and unregister_ftrace_function() does the equivalent of a\n\t * synchronize_sched() before the func_stack removal.\n\t */\n\tif (WARN_ON_ONCE(!func))\n\t\tgoto unlock;\n\n\t/*\n\t * In the enable path, enforce the order of the ops->func_stack and\n\t * func->transition reads.  The corresponding write barrier is in\n\t * __klp_enable_patch().\n\t *\n\t * (Note that this barrier technically isn't needed in the disable\n\t * path.  In the rare case where klp_update_patch_state() runs before\n\t * this handler, its TIF_PATCH_PENDING read and this func->transition\n\t * read need to be ordered.  But klp_update_patch_state() already\n\t * enforces that.)\n\t */\n\tsmp_rmb();\n\n\tif (unlikely(func->transition)) {\n\n\t\t/*\n\t\t * Enforce the order of the func->transition and\n\t\t * current->patch_state reads.  Otherwise we could read an\n\t\t * out-of-date task state and pick the wrong function.  The\n\t\t * corresponding write barrier is in klp_init_transition().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tpatch_state = current->patch_state;\n\n\t\tWARN_ON_ONCE(patch_state == KLP_UNDEFINED);\n\n\t\tif (patch_state == KLP_UNPATCHED) {\n\t\t\t/*\n\t\t\t * Use the previously patched version of the function.\n\t\t\t * If no previous patches exist, continue with the\n\t\t\t * original function.\n\t\t\t */\n\t\t\tfunc = list_entry_rcu(func->stack_node.next,\n\t\t\t\t\t      struct klp_func, stack_node);\n\n\t\t\tif (&func->stack_node == &ops->func_stack)\n\t\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tklp_arch_set_pc(regs, (unsigned long)func->new_func);\nunlock:\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_arch_set_pc",
          "args": [
            "regs",
            "(unsigned long)func->new_func"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "func->stack_node.next",
            "structklp_func",
            "stack_node"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "patch_state == KLP_UNDEFINED"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "func->transition"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!func"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_or_null_rcu",
          "args": [
            "&ops->func_stack",
            "structklp_func",
            "stack_node"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fops",
            "structklp_ops",
            "fops"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstatic void notrace klp_ftrace_handler(unsigned long ip,\n\t\t\t\t       unsigned long parent_ip,\n\t\t\t\t       struct ftrace_ops *fops,\n\t\t\t\t       struct pt_regs *regs)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\tint patch_state;\n\n\tops = container_of(fops, struct klp_ops, fops);\n\n\t/*\n\t * A variant of synchronize_sched() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\tfunc = list_first_or_null_rcu(&ops->func_stack, struct klp_func,\n\t\t\t\t      stack_node);\n\n\t/*\n\t * func should never be NULL because preemption should be disabled here\n\t * and unregister_ftrace_function() does the equivalent of a\n\t * synchronize_sched() before the func_stack removal.\n\t */\n\tif (WARN_ON_ONCE(!func))\n\t\tgoto unlock;\n\n\t/*\n\t * In the enable path, enforce the order of the ops->func_stack and\n\t * func->transition reads.  The corresponding write barrier is in\n\t * __klp_enable_patch().\n\t *\n\t * (Note that this barrier technically isn't needed in the disable\n\t * path.  In the rare case where klp_update_patch_state() runs before\n\t * this handler, its TIF_PATCH_PENDING read and this func->transition\n\t * read need to be ordered.  But klp_update_patch_state() already\n\t * enforces that.)\n\t */\n\tsmp_rmb();\n\n\tif (unlikely(func->transition)) {\n\n\t\t/*\n\t\t * Enforce the order of the func->transition and\n\t\t * current->patch_state reads.  Otherwise we could read an\n\t\t * out-of-date task state and pick the wrong function.  The\n\t\t * corresponding write barrier is in klp_init_transition().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tpatch_state = current->patch_state;\n\n\t\tWARN_ON_ONCE(patch_state == KLP_UNDEFINED);\n\n\t\tif (patch_state == KLP_UNPATCHED) {\n\t\t\t/*\n\t\t\t * Use the previously patched version of the function.\n\t\t\t * If no previous patches exist, continue with the\n\t\t\t * original function.\n\t\t\t */\n\t\t\tfunc = list_entry_rcu(func->stack_node.next,\n\t\t\t\t\t      struct klp_func, stack_node);\n\n\t\t\tif (&func->stack_node == &ops->func_stack)\n\t\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tklp_arch_set_pc(regs, (unsigned long)func->new_func);\nunlock:\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "klp_find_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
    "lines": "37-50",
    "snippet": "struct klp_ops *klp_find_ops(unsigned long old_addr)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_addr == old_addr)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ops->func_stack",
            "structklp_func",
            "stack_node"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ops",
            "&klp_ops",
            "node"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstruct klp_ops *klp_find_ops(unsigned long old_addr)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_addr == old_addr)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}"
  }
]