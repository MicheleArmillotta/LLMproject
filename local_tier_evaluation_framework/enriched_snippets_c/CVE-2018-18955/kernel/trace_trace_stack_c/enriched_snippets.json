[
  {
    "function_name": "stack_trace_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "460-486",
    "snippet": "static __init int stack_trace_init(void)\n{\n\tstruct dentry *d_tracer;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\ttrace_create_file(\"stack_max_size\", 0644, d_tracer,\n\t\t\t&stack_trace_max_size, &stack_max_size_fops);\n\n\ttrace_create_file(\"stack_trace\", 0444, d_tracer,\n\t\t\tNULL, &stack_trace_fops);\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\ttrace_create_file(\"stack_trace_filter\", 0644, d_tracer,\n\t\t\t  &trace_ops, &stack_trace_filter_fops);\n#endif\n\n\tif (stack_trace_filter_buf[0])\n\t\tftrace_set_early_filter(&trace_ops, stack_trace_filter_buf, 1);\n\n\tif (stack_tracer_enabled)\n\t\tregister_ftrace_function(&trace_ops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long stack_trace_max_size;",
      "int stack_tracer_enabled;",
      "static const struct file_operations stack_max_size_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= stack_max_size_read,\n\t.write\t\t= stack_max_size_write,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct file_operations stack_trace_fops = {\n\t.open\t\t= stack_trace_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};",
      "static char stack_trace_filter_buf[COMMAND_LINE_SIZE+1]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "&trace_ops"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_early_filter",
          "args": [
            "&trace_ops",
            "stack_trace_filter_buf",
            "1"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_early_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4933-4944",
          "snippet": "void __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"stack_trace_filter\"",
            "0644",
            "d_tracer",
            "&trace_ops",
            "&stack_trace_filter_fops"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "7459-7472",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d_tracer"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8023-8050",
          "snippet": "struct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nstruct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nunsigned long stack_trace_max_size;\nint stack_tracer_enabled;\nstatic const struct file_operations stack_max_size_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= stack_max_size_read,\n\t.write\t\t= stack_max_size_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations stack_trace_fops = {\n\t.open\t\t= stack_trace_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\nstatic char stack_trace_filter_buf[COMMAND_LINE_SIZE+1];\n\nstatic __init int stack_trace_init(void)\n{\n\tstruct dentry *d_tracer;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\ttrace_create_file(\"stack_max_size\", 0644, d_tracer,\n\t\t\t&stack_trace_max_size, &stack_max_size_fops);\n\n\ttrace_create_file(\"stack_trace\", 0444, d_tracer,\n\t\t\tNULL, &stack_trace_fops);\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\ttrace_create_file(\"stack_trace_filter\", 0644, d_tracer,\n\t\t\t  &trace_ops, &stack_trace_filter_fops);\n#endif\n\n\tif (stack_trace_filter_buf[0])\n\t\tftrace_set_early_filter(&trace_ops, stack_trace_filter_buf, 1);\n\n\tif (stack_tracer_enabled)\n\t\tregister_ftrace_function(&trace_ops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "enable_stacktrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "449-457",
    "snippet": "static __init int enable_stacktrace(char *str)\n{\n\tif (strncmp(str, \"_filter=\", 8) == 0)\n\t\tstrncpy(stack_trace_filter_buf, str+8, COMMAND_LINE_SIZE);\n\n\tstack_tracer_enabled = 1;\n\tlast_stack_tracer_enabled = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int stack_tracer_enabled;",
      "static int last_stack_tracer_enabled;",
      "static char stack_trace_filter_buf[COMMAND_LINE_SIZE+1]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "stack_trace_filter_buf",
            "str+8",
            "COMMAND_LINE_SIZE"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"_filter=\"",
            "8"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nint stack_tracer_enabled;\nstatic int last_stack_tracer_enabled;\nstatic char stack_trace_filter_buf[COMMAND_LINE_SIZE+1];\n\nstatic __init int enable_stacktrace(char *str)\n{\n\tif (strncmp(str, \"_filter=\", 8) == 0)\n\t\tstrncpy(stack_trace_filter_buf, str+8, COMMAND_LINE_SIZE);\n\n\tstack_tracer_enabled = 1;\n\tlast_stack_tracer_enabled = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "stack_trace_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "420-445",
    "snippet": "int\nstack_trace_sysctl(struct ctl_table *table, int write,\n\t\t   void __user *buffer, size_t *lenp,\n\t\t   loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&stack_sysctl_mutex);\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write ||\n\t    (last_stack_tracer_enabled == !!stack_tracer_enabled))\n\t\tgoto out;\n\n\tlast_stack_tracer_enabled = !!stack_tracer_enabled;\n\n\tif (stack_tracer_enabled)\n\t\tregister_ftrace_function(&trace_ops);\n\telse\n\t\tunregister_ftrace_function(&trace_ops);\n\n out:\n\tmutex_unlock(&stack_sysctl_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(stack_sysctl_mutex);",
      "int stack_tracer_enabled;",
      "static int last_stack_tracer_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stack_sysctl_mutex"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&trace_ops"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_ms_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3224-3228",
          "snippet": "int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&stack_sysctl_mutex"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic DEFINE_MUTEX(stack_sysctl_mutex);\nint stack_tracer_enabled;\nstatic int last_stack_tracer_enabled;\n\nint\nstack_trace_sysctl(struct ctl_table *table, int write,\n\t\t   void __user *buffer, size_t *lenp,\n\t\t   loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&stack_sysctl_mutex);\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write ||\n\t    (last_stack_tracer_enabled == !!stack_tracer_enabled))\n\t\tgoto out;\n\n\tlast_stack_tracer_enabled = !!stack_tracer_enabled;\n\n\tif (stack_tracer_enabled)\n\t\tregister_ftrace_function(&trace_ops);\n\telse\n\t\tunregister_ftrace_function(&trace_ops);\n\n out:\n\tmutex_unlock(&stack_sysctl_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "stack_trace_filter_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "401-408",
    "snippet": "static int\nstack_trace_filter_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\treturn ftrace_regex_open(ops, FTRACE_ITER_FILTER,\n\t\t\t\t inode, file);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_regex_open",
          "args": [
            "ops",
            "FTRACE_ITER_FILTER",
            "inode",
            "file"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_regex_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3542-3621",
          "snippet": "int\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = 0;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX)) {\n\t\tkfree(iter);\n\t\treturn -ENOMEM;\n\t}\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = 0;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX)) {\n\t\tkfree(iter);\n\t\treturn -ENOMEM;\n\t}\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic int\nstack_trace_filter_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\treturn ftrace_regex_open(ops, FTRACE_ITER_FILTER,\n\t\t\t\t inode, file);\n}"
  },
  {
    "function_name": "stack_trace_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "387-390",
    "snippet": "static int stack_trace_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &stack_trace_seq_ops);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations stack_trace_seq_ops = {\n\t.start\t\t= t_start,\n\t.next\t\t= t_next,\n\t.stop\t\t= t_stop,\n\t.show\t\t= t_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&stack_trace_seq_ops"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic const struct seq_operations stack_trace_seq_ops = {\n\t.start\t\t= t_start,\n\t.next\t\t= t_next,\n\t.stop\t\t= t_stop,\n\t.show\t\t= t_show,\n};\n\nstatic int stack_trace_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &stack_trace_seq_ops);\n}"
  },
  {
    "function_name": "t_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "344-378",
    "snippet": "static int t_show(struct seq_file *m, void *v)\n{\n\tlong i;\n\tint size;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(m, \"        Depth    Size   Location\"\n\t\t\t   \"    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_max.nr_entries);\n\n\t\tif (!stack_tracer_enabled && !stack_trace_max_size)\n\t\t\tprint_disabled(m);\n\n\t\treturn 0;\n\t}\n\n\ti = *(long *)v;\n\n\tif (i >= stack_trace_max.nr_entries ||\n\t    stack_dump_trace[i] == ULONG_MAX)\n\t\treturn 0;\n\n\tif (i+1 == stack_trace_max.nr_entries ||\n\t    stack_dump_trace[i+1] == ULONG_MAX)\n\t\tsize = stack_trace_index[i];\n\telse\n\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\tseq_printf(m, \"%3ld) %8d   %5d   \", i, stack_trace_index[i], size);\n\n\ttrace_lookup_stack(m, i);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };",
      "unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
      "struct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};",
      "unsigned long stack_trace_max_size;",
      "int stack_tracer_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_lookup_stack",
          "args": [
            "m",
            "i"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "trace_lookup_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
          "lines": "326-331",
          "snippet": "static void trace_lookup_stack(struct seq_file *m, long i)\n{\n\tunsigned long addr = stack_dump_trace[i];\n\n\tseq_printf(m, \"%pS\\n\", (void *)addr);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };\n\nstatic void trace_lookup_stack(struct seq_file *m, long i)\n{\n\tunsigned long addr = stack_dump_trace[i];\n\n\tseq_printf(m, \"%pS\\n\", (void *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%3ld) %8d   %5d   \"",
            "i",
            "stack_trace_index[i]",
            "size"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_disabled",
          "args": [
            "m"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "print_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
          "lines": "333-342",
          "snippet": "static void print_disabled(struct seq_file *m)\n{\n\tseq_puts(m, \"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\");\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int stack_tracer_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nint stack_tracer_enabled;\n\nstatic void print_disabled(struct seq_file *m)\n{\n\tseq_puts(m, \"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };\nunsigned stack_trace_index[STACK_TRACE_ENTRIES];\nstruct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};\nunsigned long stack_trace_max_size;\nint stack_tracer_enabled;\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tlong i;\n\tint size;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(m, \"        Depth    Size   Location\"\n\t\t\t   \"    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_max.nr_entries);\n\n\t\tif (!stack_tracer_enabled && !stack_trace_max_size)\n\t\t\tprint_disabled(m);\n\n\t\treturn 0;\n\t}\n\n\ti = *(long *)v;\n\n\tif (i >= stack_trace_max.nr_entries ||\n\t    stack_dump_trace[i] == ULONG_MAX)\n\t\treturn 0;\n\n\tif (i+1 == stack_trace_max.nr_entries ||\n\t    stack_dump_trace[i+1] == ULONG_MAX)\n\t\tsize = stack_trace_index[i];\n\telse\n\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\tseq_printf(m, \"%3ld) %8d   %5d   \", i, stack_trace_index[i], size);\n\n\ttrace_lookup_stack(m, i);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_disabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "333-342",
    "snippet": "static void print_disabled(struct seq_file *m)\n{\n\tseq_puts(m, \"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\");\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int stack_tracer_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\""
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nint stack_tracer_enabled;\n\nstatic void print_disabled(struct seq_file *m)\n{\n\tseq_puts(m, \"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\");\n}"
  },
  {
    "function_name": "trace_lookup_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "326-331",
    "snippet": "static void trace_lookup_stack(struct seq_file *m, long i)\n{\n\tunsigned long addr = stack_dump_trace[i];\n\n\tseq_printf(m, \"%pS\\n\", (void *)addr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%pS\\n\"",
            "(void *)addr"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };\n\nstatic void trace_lookup_stack(struct seq_file *m, long i)\n{\n\tunsigned long addr = stack_dump_trace[i];\n\n\tseq_printf(m, \"%pS\\n\", (void *)addr);\n}"
  },
  {
    "function_name": "t_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "317-324",
    "snippet": "static void t_stop(struct seq_file *m, void *p)\n{\n\tarch_spin_unlock(&stack_trace_max_lock);\n\n\t__this_cpu_dec(disable_stack_tracer);\n\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\narch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tarch_spin_unlock(&stack_trace_max_lock);\n\n\t__this_cpu_dec(disable_stack_tracer);\n\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "t_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "303-315",
    "snippet": "static void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tlocal_irq_disable();\n\n\t__this_cpu_inc(disable_stack_tracer);\n\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn __next(m, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__next",
          "args": [
            "m",
            "pos"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "__next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
          "lines": "284-294",
          "snippet": "static void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n > stack_trace_max.nr_entries || stack_dump_trace[n] == ULONG_MAX)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };",
            "struct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };\nstruct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};\n\nstatic void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n > stack_trace_max.nr_entries || stack_dump_trace[n] == ULONG_MAX)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\narch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tlocal_irq_disable();\n\n\t__this_cpu_inc(disable_stack_tracer);\n\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn __next(m, pos);\n}"
  },
  {
    "function_name": "t_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "296-301",
    "snippet": "static void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __next(m, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__next",
          "args": [
            "m",
            "pos"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "__next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
          "lines": "284-294",
          "snippet": "static void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n > stack_trace_max.nr_entries || stack_dump_trace[n] == ULONG_MAX)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };",
            "struct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };\nstruct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};\n\nstatic void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n > stack_trace_max.nr_entries || stack_dump_trace[n] == ULONG_MAX)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __next(m, pos);\n}"
  },
  {
    "function_name": "__next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "284-294",
    "snippet": "static void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n > stack_trace_max.nr_entries || stack_dump_trace[n] == ULONG_MAX)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };",
      "struct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };\nstruct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};\n\nstatic void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n > stack_trace_max.nr_entries || stack_dump_trace[n] == ULONG_MAX)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}"
  },
  {
    "function_name": "stack_max_size_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "246-275",
    "snippet": "static ssize_t\nstack_max_size_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tlong *ptr = filp->private_data;\n\tunsigned long val, flags;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, count, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tlocal_irq_save(flags);\n\n\t/*\n\t * In case we trace inside arch_spin_lock() or after (NMI),\n\t * we will cause circular lock, so we also need to increase\n\t * the percpu disable_stack_tracer here.\n\t */\n\t__this_cpu_inc(disable_stack_tracer);\n\n\tarch_spin_lock(&stack_trace_max_lock);\n\t*ptr = val;\n\tarch_spin_unlock(&stack_trace_max_lock);\n\n\t__this_cpu_dec(disable_stack_tracer);\n\tlocal_irq_restore(flags);\n\n\treturn count;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "ubuf",
            "count",
            "10",
            "&val"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\narch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic ssize_t\nstack_max_size_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tlong *ptr = filp->private_data;\n\tunsigned long val, flags;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, count, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tlocal_irq_save(flags);\n\n\t/*\n\t * In case we trace inside arch_spin_lock() or after (NMI),\n\t * we will cause circular lock, so we also need to increase\n\t * the percpu disable_stack_tracer here.\n\t */\n\t__this_cpu_inc(disable_stack_tracer);\n\n\tarch_spin_lock(&stack_trace_max_lock);\n\t*ptr = val;\n\tarch_spin_unlock(&stack_trace_max_lock);\n\n\t__this_cpu_dec(disable_stack_tracer);\n\tlocal_irq_restore(flags);\n\n\treturn count;\n}"
  },
  {
    "function_name": "stack_max_size_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "232-244",
    "snippet": "static ssize_t\nstack_max_size_read(struct file *filp, char __user *ubuf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned long *ptr = filp->private_data;\n\tchar buf[64];\n\tint r;\n\n\tr = snprintf(buf, sizeof(buf), \"%ld\\n\", *ptr);\n\tif (r > sizeof(buf))\n\t\tr = sizeof(buf);\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, r);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "count",
            "ppos",
            "buf",
            "r"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%ld\\n\"",
            "*ptr"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic ssize_t\nstack_max_size_read(struct file *filp, char __user *ubuf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned long *ptr = filp->private_data;\n\tchar buf[64];\n\tint r;\n\n\tr = snprintf(buf, sizeof(buf), \"%ld\\n\", *ptr);\n\tif (r > sizeof(buf))\n\t\tr = sizeof(buf);\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, r);\n}"
  },
  {
    "function_name": "stack_trace_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "199-224",
    "snippet": "static void\nstack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tunsigned long stack;\n\n\tpreempt_disable_notrace();\n\n\t/* no atomic needed, we only modify this variable by this cpu */\n\t__this_cpu_inc(disable_stack_tracer);\n\tif (__this_cpu_read(disable_stack_tracer) != 1)\n\t\tgoto out;\n\n\t/* If rcu is not watching, then save stack trace can fail */\n\tif (!rcu_is_watching())\n\t\tgoto out;\n\n\tip += MCOUNT_INSN_SIZE;\n\n\tcheck_stack(ip, &stack);\n\n out:\n\t__this_cpu_dec(disable_stack_tracer);\n\t/* prevent recursion in schedule */\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack",
          "args": [
            "ip",
            "&stack"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "check_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
          "lines": "76-197",
          "snippet": "void __weak\ncheck_stack(unsigned long ip, unsigned long *stack)\n{\n\tunsigned long this_size, flags; unsigned long *p, *top, *start;\n\tstatic int tracer_frame;\n\tint frame_size = READ_ONCE(tracer_frame);\n\tint i, x;\n\n\tthis_size = ((unsigned long)stack) & (THREAD_SIZE-1);\n\tthis_size = THREAD_SIZE - this_size;\n\t/* Remove the frame of the tracer */\n\tthis_size -= frame_size;\n\n\tif (this_size <= stack_trace_max_size)\n\t\treturn;\n\n\t/* we do not handle interrupt stacks yet */\n\tif (!object_is_on_stack(stack))\n\t\treturn;\n\n\t/* Can't do this from NMI context (can cause deadlocks) */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\t/* In case another CPU set the tracer_frame on us */\n\tif (unlikely(!frame_size))\n\t\tthis_size -= tracer_frame;\n\n\t/* a race could have already updated it */\n\tif (this_size <= stack_trace_max_size)\n\t\tgoto out;\n\n\tstack_trace_max_size = this_size;\n\n\tstack_trace_max.nr_entries = 0;\n\tstack_trace_max.skip = 0;\n\n\tsave_stack_trace(&stack_trace_max);\n\n\t/* Skip over the overhead of the stack tracer itself */\n\tfor (i = 0; i < stack_trace_max.nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ip)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Some archs may not have the passed in ip in the dump.\n\t * If that happens, we need to show everything.\n\t */\n\tif (i == stack_trace_max.nr_entries)\n\t\ti = 0;\n\n\t/*\n\t * Now find where in the stack these are.\n\t */\n\tx = 0;\n\tstart = stack;\n\ttop = (unsigned long *)\n\t\t(((unsigned long)start & ~(THREAD_SIZE-1)) + THREAD_SIZE);\n\n\t/*\n\t * Loop through all the entries. One of the entries may\n\t * for some reason be missed on the stack, so we may\n\t * have to account for them. If they are all there, this\n\t * loop will only happen once. This code only takes place\n\t * on a new max, so it is far from a fast path.\n\t */\n\twhile (i < stack_trace_max.nr_entries) {\n\t\tint found = 0;\n\n\t\tstack_trace_index[x] = this_size;\n\t\tp = start;\n\n\t\tfor (; p < top && i < stack_trace_max.nr_entries; p++) {\n\t\t\tif (stack_dump_trace[i] == ULONG_MAX)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * The READ_ONCE_NOCHECK is used to let KASAN know that\n\t\t\t * this is not a stack-out-of-bounds error.\n\t\t\t */\n\t\t\tif ((READ_ONCE_NOCHECK(*p)) == stack_dump_trace[i]) {\n\t\t\t\tstack_dump_trace[x] = stack_dump_trace[i++];\n\t\t\t\tthis_size = stack_trace_index[x++] =\n\t\t\t\t\t(top - p) * sizeof(unsigned long);\n\t\t\t\tfound = 1;\n\t\t\t\t/* Start the search from here */\n\t\t\t\tstart = p + 1;\n\t\t\t\t/*\n\t\t\t\t * We do not want to show the overhead\n\t\t\t\t * of the stack tracer stack in the\n\t\t\t\t * max stack. If we haven't figured\n\t\t\t\t * out what that is, then figure it out\n\t\t\t\t * now.\n\t\t\t\t */\n\t\t\t\tif (unlikely(!tracer_frame)) {\n\t\t\t\t\ttracer_frame = (p - stack) *\n\t\t\t\t\t\tsizeof(unsigned long);\n\t\t\t\t\tstack_trace_max_size -= tracer_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\ti++;\n\t}\n\n\tstack_trace_max.nr_entries = x;\n\tfor (; x < i; x++)\n\t\tstack_dump_trace[x] = ULONG_MAX;\n\n\tif (task_stack_end_corrupted(current)) {\n\t\tstack_trace_print();\n\t\tBUG();\n\t}\n\n out:\n\tarch_spin_unlock(&stack_trace_max_lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };",
            "unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
            "struct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};",
            "unsigned long stack_trace_max_size;",
            "arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };\nunsigned stack_trace_index[STACK_TRACE_ENTRIES];\nstruct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};\nunsigned long stack_trace_max_size;\narch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid __weak\ncheck_stack(unsigned long ip, unsigned long *stack)\n{\n\tunsigned long this_size, flags; unsigned long *p, *top, *start;\n\tstatic int tracer_frame;\n\tint frame_size = READ_ONCE(tracer_frame);\n\tint i, x;\n\n\tthis_size = ((unsigned long)stack) & (THREAD_SIZE-1);\n\tthis_size = THREAD_SIZE - this_size;\n\t/* Remove the frame of the tracer */\n\tthis_size -= frame_size;\n\n\tif (this_size <= stack_trace_max_size)\n\t\treturn;\n\n\t/* we do not handle interrupt stacks yet */\n\tif (!object_is_on_stack(stack))\n\t\treturn;\n\n\t/* Can't do this from NMI context (can cause deadlocks) */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\t/* In case another CPU set the tracer_frame on us */\n\tif (unlikely(!frame_size))\n\t\tthis_size -= tracer_frame;\n\n\t/* a race could have already updated it */\n\tif (this_size <= stack_trace_max_size)\n\t\tgoto out;\n\n\tstack_trace_max_size = this_size;\n\n\tstack_trace_max.nr_entries = 0;\n\tstack_trace_max.skip = 0;\n\n\tsave_stack_trace(&stack_trace_max);\n\n\t/* Skip over the overhead of the stack tracer itself */\n\tfor (i = 0; i < stack_trace_max.nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ip)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Some archs may not have the passed in ip in the dump.\n\t * If that happens, we need to show everything.\n\t */\n\tif (i == stack_trace_max.nr_entries)\n\t\ti = 0;\n\n\t/*\n\t * Now find where in the stack these are.\n\t */\n\tx = 0;\n\tstart = stack;\n\ttop = (unsigned long *)\n\t\t(((unsigned long)start & ~(THREAD_SIZE-1)) + THREAD_SIZE);\n\n\t/*\n\t * Loop through all the entries. One of the entries may\n\t * for some reason be missed on the stack, so we may\n\t * have to account for them. If they are all there, this\n\t * loop will only happen once. This code only takes place\n\t * on a new max, so it is far from a fast path.\n\t */\n\twhile (i < stack_trace_max.nr_entries) {\n\t\tint found = 0;\n\n\t\tstack_trace_index[x] = this_size;\n\t\tp = start;\n\n\t\tfor (; p < top && i < stack_trace_max.nr_entries; p++) {\n\t\t\tif (stack_dump_trace[i] == ULONG_MAX)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * The READ_ONCE_NOCHECK is used to let KASAN know that\n\t\t\t * this is not a stack-out-of-bounds error.\n\t\t\t */\n\t\t\tif ((READ_ONCE_NOCHECK(*p)) == stack_dump_trace[i]) {\n\t\t\t\tstack_dump_trace[x] = stack_dump_trace[i++];\n\t\t\t\tthis_size = stack_trace_index[x++] =\n\t\t\t\t\t(top - p) * sizeof(unsigned long);\n\t\t\t\tfound = 1;\n\t\t\t\t/* Start the search from here */\n\t\t\t\tstart = p + 1;\n\t\t\t\t/*\n\t\t\t\t * We do not want to show the overhead\n\t\t\t\t * of the stack tracer stack in the\n\t\t\t\t * max stack. If we haven't figured\n\t\t\t\t * out what that is, then figure it out\n\t\t\t\t * now.\n\t\t\t\t */\n\t\t\t\tif (unlikely(!tracer_frame)) {\n\t\t\t\t\ttracer_frame = (p - stack) *\n\t\t\t\t\t\tsizeof(unsigned long);\n\t\t\t\t\tstack_trace_max_size -= tracer_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\ti++;\n\t}\n\n\tstack_trace_max.nr_entries = x;\n\tfor (; x < i; x++)\n\t\tstack_dump_trace[x] = ULONG_MAX;\n\n\tif (task_stack_end_corrupted(current)) {\n\t\tstack_trace_print();\n\t\tBUG();\n\t}\n\n out:\n\tarch_spin_unlock(&stack_trace_max_lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "901-909",
          "snippet": "bool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic void\nstack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tunsigned long stack;\n\n\tpreempt_disable_notrace();\n\n\t/* no atomic needed, we only modify this variable by this cpu */\n\t__this_cpu_inc(disable_stack_tracer);\n\tif (__this_cpu_read(disable_stack_tracer) != 1)\n\t\tgoto out;\n\n\t/* If rcu is not watching, then save stack trace can fail */\n\tif (!rcu_is_watching())\n\t\tgoto out;\n\n\tip += MCOUNT_INSN_SIZE;\n\n\tcheck_stack(ip, &stack);\n\n out:\n\t__this_cpu_dec(disable_stack_tracer);\n\t/* prevent recursion in schedule */\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "check_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "76-197",
    "snippet": "void __weak\ncheck_stack(unsigned long ip, unsigned long *stack)\n{\n\tunsigned long this_size, flags; unsigned long *p, *top, *start;\n\tstatic int tracer_frame;\n\tint frame_size = READ_ONCE(tracer_frame);\n\tint i, x;\n\n\tthis_size = ((unsigned long)stack) & (THREAD_SIZE-1);\n\tthis_size = THREAD_SIZE - this_size;\n\t/* Remove the frame of the tracer */\n\tthis_size -= frame_size;\n\n\tif (this_size <= stack_trace_max_size)\n\t\treturn;\n\n\t/* we do not handle interrupt stacks yet */\n\tif (!object_is_on_stack(stack))\n\t\treturn;\n\n\t/* Can't do this from NMI context (can cause deadlocks) */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\t/* In case another CPU set the tracer_frame on us */\n\tif (unlikely(!frame_size))\n\t\tthis_size -= tracer_frame;\n\n\t/* a race could have already updated it */\n\tif (this_size <= stack_trace_max_size)\n\t\tgoto out;\n\n\tstack_trace_max_size = this_size;\n\n\tstack_trace_max.nr_entries = 0;\n\tstack_trace_max.skip = 0;\n\n\tsave_stack_trace(&stack_trace_max);\n\n\t/* Skip over the overhead of the stack tracer itself */\n\tfor (i = 0; i < stack_trace_max.nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ip)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Some archs may not have the passed in ip in the dump.\n\t * If that happens, we need to show everything.\n\t */\n\tif (i == stack_trace_max.nr_entries)\n\t\ti = 0;\n\n\t/*\n\t * Now find where in the stack these are.\n\t */\n\tx = 0;\n\tstart = stack;\n\ttop = (unsigned long *)\n\t\t(((unsigned long)start & ~(THREAD_SIZE-1)) + THREAD_SIZE);\n\n\t/*\n\t * Loop through all the entries. One of the entries may\n\t * for some reason be missed on the stack, so we may\n\t * have to account for them. If they are all there, this\n\t * loop will only happen once. This code only takes place\n\t * on a new max, so it is far from a fast path.\n\t */\n\twhile (i < stack_trace_max.nr_entries) {\n\t\tint found = 0;\n\n\t\tstack_trace_index[x] = this_size;\n\t\tp = start;\n\n\t\tfor (; p < top && i < stack_trace_max.nr_entries; p++) {\n\t\t\tif (stack_dump_trace[i] == ULONG_MAX)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * The READ_ONCE_NOCHECK is used to let KASAN know that\n\t\t\t * this is not a stack-out-of-bounds error.\n\t\t\t */\n\t\t\tif ((READ_ONCE_NOCHECK(*p)) == stack_dump_trace[i]) {\n\t\t\t\tstack_dump_trace[x] = stack_dump_trace[i++];\n\t\t\t\tthis_size = stack_trace_index[x++] =\n\t\t\t\t\t(top - p) * sizeof(unsigned long);\n\t\t\t\tfound = 1;\n\t\t\t\t/* Start the search from here */\n\t\t\t\tstart = p + 1;\n\t\t\t\t/*\n\t\t\t\t * We do not want to show the overhead\n\t\t\t\t * of the stack tracer stack in the\n\t\t\t\t * max stack. If we haven't figured\n\t\t\t\t * out what that is, then figure it out\n\t\t\t\t * now.\n\t\t\t\t */\n\t\t\t\tif (unlikely(!tracer_frame)) {\n\t\t\t\t\ttracer_frame = (p - stack) *\n\t\t\t\t\t\tsizeof(unsigned long);\n\t\t\t\t\tstack_trace_max_size -= tracer_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\ti++;\n\t}\n\n\tstack_trace_max.nr_entries = x;\n\tfor (; x < i; x++)\n\t\tstack_dump_trace[x] = ULONG_MAX;\n\n\tif (task_stack_end_corrupted(current)) {\n\t\tstack_trace_print();\n\t\tBUG();\n\t}\n\n out:\n\tarch_spin_unlock(&stack_trace_max_lock);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };",
      "unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
      "struct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};",
      "unsigned long stack_trace_max_size;",
      "arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_trace_print",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
          "lines": "45-66",
          "snippet": "void stack_trace_print(void)\n{\n\tlong i;\n\tint size;\n\n\tpr_emerg(\"        Depth    Size   Location    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_max.nr_entries);\n\n\tfor (i = 0; i < stack_trace_max.nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ULONG_MAX)\n\t\t\tbreak;\n\t\tif (i+1 == stack_trace_max.nr_entries ||\n\t\t\t\tstack_dump_trace[i+1] == ULONG_MAX)\n\t\t\tsize = stack_trace_index[i];\n\t\telse\n\t\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\t\tpr_emerg(\"%3ld) %8d   %5d   %pS\\n\", i, stack_trace_index[i],\n\t\t\t\tsize, (void *)stack_dump_trace[i]);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };",
            "unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
            "struct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };\nunsigned stack_trace_index[STACK_TRACE_ENTRIES];\nstruct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};\n\nvoid stack_trace_print(void)\n{\n\tlong i;\n\tint size;\n\n\tpr_emerg(\"        Depth    Size   Location    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_max.nr_entries);\n\n\tfor (i = 0; i < stack_trace_max.nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ULONG_MAX)\n\t\t\tbreak;\n\t\tif (i+1 == stack_trace_max.nr_entries ||\n\t\t\t\tstack_dump_trace[i+1] == ULONG_MAX)\n\t\t\tsize = stack_trace_index[i];\n\t\telse\n\t\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\t\tpr_emerg(\"%3ld) %8d   %5d   %pS\\n\", i, stack_trace_index[i],\n\t\t\t\tsize, (void *)stack_dump_trace[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_stack_end_corrupted",
          "args": [
            "current"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tracer_frame"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE_NOCHECK",
          "args": [
            "*p"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_stack_trace",
          "args": [
            "&stack_trace_max"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!frame_size"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_is_on_stack",
          "args": [
            "stack"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "tracer_frame"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };\nunsigned stack_trace_index[STACK_TRACE_ENTRIES];\nstruct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};\nunsigned long stack_trace_max_size;\narch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid __weak\ncheck_stack(unsigned long ip, unsigned long *stack)\n{\n\tunsigned long this_size, flags; unsigned long *p, *top, *start;\n\tstatic int tracer_frame;\n\tint frame_size = READ_ONCE(tracer_frame);\n\tint i, x;\n\n\tthis_size = ((unsigned long)stack) & (THREAD_SIZE-1);\n\tthis_size = THREAD_SIZE - this_size;\n\t/* Remove the frame of the tracer */\n\tthis_size -= frame_size;\n\n\tif (this_size <= stack_trace_max_size)\n\t\treturn;\n\n\t/* we do not handle interrupt stacks yet */\n\tif (!object_is_on_stack(stack))\n\t\treturn;\n\n\t/* Can't do this from NMI context (can cause deadlocks) */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\t/* In case another CPU set the tracer_frame on us */\n\tif (unlikely(!frame_size))\n\t\tthis_size -= tracer_frame;\n\n\t/* a race could have already updated it */\n\tif (this_size <= stack_trace_max_size)\n\t\tgoto out;\n\n\tstack_trace_max_size = this_size;\n\n\tstack_trace_max.nr_entries = 0;\n\tstack_trace_max.skip = 0;\n\n\tsave_stack_trace(&stack_trace_max);\n\n\t/* Skip over the overhead of the stack tracer itself */\n\tfor (i = 0; i < stack_trace_max.nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ip)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Some archs may not have the passed in ip in the dump.\n\t * If that happens, we need to show everything.\n\t */\n\tif (i == stack_trace_max.nr_entries)\n\t\ti = 0;\n\n\t/*\n\t * Now find where in the stack these are.\n\t */\n\tx = 0;\n\tstart = stack;\n\ttop = (unsigned long *)\n\t\t(((unsigned long)start & ~(THREAD_SIZE-1)) + THREAD_SIZE);\n\n\t/*\n\t * Loop through all the entries. One of the entries may\n\t * for some reason be missed on the stack, so we may\n\t * have to account for them. If they are all there, this\n\t * loop will only happen once. This code only takes place\n\t * on a new max, so it is far from a fast path.\n\t */\n\twhile (i < stack_trace_max.nr_entries) {\n\t\tint found = 0;\n\n\t\tstack_trace_index[x] = this_size;\n\t\tp = start;\n\n\t\tfor (; p < top && i < stack_trace_max.nr_entries; p++) {\n\t\t\tif (stack_dump_trace[i] == ULONG_MAX)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * The READ_ONCE_NOCHECK is used to let KASAN know that\n\t\t\t * this is not a stack-out-of-bounds error.\n\t\t\t */\n\t\t\tif ((READ_ONCE_NOCHECK(*p)) == stack_dump_trace[i]) {\n\t\t\t\tstack_dump_trace[x] = stack_dump_trace[i++];\n\t\t\t\tthis_size = stack_trace_index[x++] =\n\t\t\t\t\t(top - p) * sizeof(unsigned long);\n\t\t\t\tfound = 1;\n\t\t\t\t/* Start the search from here */\n\t\t\t\tstart = p + 1;\n\t\t\t\t/*\n\t\t\t\t * We do not want to show the overhead\n\t\t\t\t * of the stack tracer stack in the\n\t\t\t\t * max stack. If we haven't figured\n\t\t\t\t * out what that is, then figure it out\n\t\t\t\t * now.\n\t\t\t\t */\n\t\t\t\tif (unlikely(!tracer_frame)) {\n\t\t\t\t\ttracer_frame = (p - stack) *\n\t\t\t\t\t\tsizeof(unsigned long);\n\t\t\t\t\tstack_trace_max_size -= tracer_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\ti++;\n\t}\n\n\tstack_trace_max.nr_entries = x;\n\tfor (; x < i; x++)\n\t\tstack_dump_trace[x] = ULONG_MAX;\n\n\tif (task_stack_end_corrupted(current)) {\n\t\tstack_trace_print();\n\t\tBUG();\n\t}\n\n out:\n\tarch_spin_unlock(&stack_trace_max_lock);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "stack_trace_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stack.c",
    "lines": "45-66",
    "snippet": "void stack_trace_print(void)\n{\n\tlong i;\n\tint size;\n\n\tpr_emerg(\"        Depth    Size   Location    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_max.nr_entries);\n\n\tfor (i = 0; i < stack_trace_max.nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ULONG_MAX)\n\t\t\tbreak;\n\t\tif (i+1 == stack_trace_max.nr_entries ||\n\t\t\t\tstack_dump_trace[i+1] == ULONG_MAX)\n\t\t\tsize = stack_trace_index[i];\n\t\telse\n\t\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\t\tpr_emerg(\"%3ld) %8d   %5d   %pS\\n\", i, stack_trace_index[i],\n\t\t\t\tsize, (void *)stack_dump_trace[i]);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };",
      "unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
      "struct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"%3ld) %8d   %5d   %pS\\n\"",
            "i",
            "stack_trace_index[i]",
            "size",
            "(void *)stack_dump_trace[i]"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"        Depth    Size   Location    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\"",
            "stack_trace_max.nr_entries"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES+1] =\n\t { [0 ... (STACK_TRACE_ENTRIES)] = ULONG_MAX };\nunsigned stack_trace_index[STACK_TRACE_ENTRIES];\nstruct stack_trace stack_trace_max = {\n\t.max_entries\t\t= STACK_TRACE_ENTRIES - 1,\n\t.entries\t\t= &stack_dump_trace[0],\n};\n\nvoid stack_trace_print(void)\n{\n\tlong i;\n\tint size;\n\n\tpr_emerg(\"        Depth    Size   Location    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_max.nr_entries);\n\n\tfor (i = 0; i < stack_trace_max.nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ULONG_MAX)\n\t\t\tbreak;\n\t\tif (i+1 == stack_trace_max.nr_entries ||\n\t\t\t\tstack_dump_trace[i+1] == ULONG_MAX)\n\t\t\tsize = stack_trace_index[i];\n\t\telse\n\t\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\t\tpr_emerg(\"%3ld) %8d   %5d   %pS\\n\", i, stack_trace_index[i],\n\t\t\t\tsize, (void *)stack_dump_trace[i]);\n\t}\n}"
  }
]