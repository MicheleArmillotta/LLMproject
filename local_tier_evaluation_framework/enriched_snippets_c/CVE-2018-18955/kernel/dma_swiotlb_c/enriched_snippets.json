[
  {
    "function_name": "swiotlb_dma_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "864-868",
    "snippet": "int\nswiotlb_dma_supported(struct device *hwdev, u64 mask)\n{\n\treturn __phys_to_dma(hwdev, io_tlb_end - 1) <= mask;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static phys_addr_t io_tlb_start, io_tlb_end;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__phys_to_dma",
          "args": [
            "hwdev",
            "io_tlb_end - 1"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\n\nint\nswiotlb_dma_supported(struct device *hwdev, u64 mask)\n{\n\treturn __phys_to_dma(hwdev, io_tlb_end - 1) <= mask;\n}"
  },
  {
    "function_name": "swiotlb_sync_sg_for_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "851-856",
    "snippet": "void\nswiotlb_sync_sg_for_device(struct device *hwdev, struct scatterlist *sg,\n\t\t\t   int nelems, enum dma_data_direction dir)\n{\n\tswiotlb_sync_sg(hwdev, sg, nelems, dir, SYNC_FOR_DEVICE);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_sync_sg",
          "args": [
            "hwdev",
            "sg",
            "nelems",
            "dir",
            "SYNC_FOR_DEVICE"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_sync_sg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "831-842",
          "snippet": "static void\nswiotlb_sync_sg(struct device *hwdev, struct scatterlist *sgl,\n\t\tint nelems, enum dma_data_direction dir,\n\t\tenum dma_sync_target target)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nelems, i)\n\t\tswiotlb_sync_single(hwdev, sg->dma_address,\n\t\t\t\t    sg_dma_len(sg), dir, target);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void\nswiotlb_sync_sg(struct device *hwdev, struct scatterlist *sgl,\n\t\tint nelems, enum dma_data_direction dir,\n\t\tenum dma_sync_target target)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nelems, i)\n\t\tswiotlb_sync_single(hwdev, sg->dma_address,\n\t\t\t\t    sg_dma_len(sg), dir, target);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid\nswiotlb_sync_sg_for_device(struct device *hwdev, struct scatterlist *sg,\n\t\t\t   int nelems, enum dma_data_direction dir)\n{\n\tswiotlb_sync_sg(hwdev, sg, nelems, dir, SYNC_FOR_DEVICE);\n}"
  },
  {
    "function_name": "swiotlb_sync_sg_for_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "844-849",
    "snippet": "void\nswiotlb_sync_sg_for_cpu(struct device *hwdev, struct scatterlist *sg,\n\t\t\tint nelems, enum dma_data_direction dir)\n{\n\tswiotlb_sync_sg(hwdev, sg, nelems, dir, SYNC_FOR_CPU);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_sync_sg",
          "args": [
            "hwdev",
            "sg",
            "nelems",
            "dir",
            "SYNC_FOR_CPU"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_sync_sg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "831-842",
          "snippet": "static void\nswiotlb_sync_sg(struct device *hwdev, struct scatterlist *sgl,\n\t\tint nelems, enum dma_data_direction dir,\n\t\tenum dma_sync_target target)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nelems, i)\n\t\tswiotlb_sync_single(hwdev, sg->dma_address,\n\t\t\t\t    sg_dma_len(sg), dir, target);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void\nswiotlb_sync_sg(struct device *hwdev, struct scatterlist *sgl,\n\t\tint nelems, enum dma_data_direction dir,\n\t\tenum dma_sync_target target)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nelems, i)\n\t\tswiotlb_sync_single(hwdev, sg->dma_address,\n\t\t\t\t    sg_dma_len(sg), dir, target);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid\nswiotlb_sync_sg_for_cpu(struct device *hwdev, struct scatterlist *sg,\n\t\t\tint nelems, enum dma_data_direction dir)\n{\n\tswiotlb_sync_sg(hwdev, sg, nelems, dir, SYNC_FOR_CPU);\n}"
  },
  {
    "function_name": "swiotlb_sync_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "831-842",
    "snippet": "static void\nswiotlb_sync_sg(struct device *hwdev, struct scatterlist *sgl,\n\t\tint nelems, enum dma_data_direction dir,\n\t\tenum dma_sync_target target)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nelems, i)\n\t\tswiotlb_sync_single(hwdev, sg->dma_address,\n\t\t\t\t    sg_dma_len(sg), dir, target);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_sync_single",
          "args": [
            "hwdev",
            "sg->dma_address",
            "sg_dma_len(sg)",
            "dir",
            "target"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_sync_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "735-755",
          "snippet": "static void\nswiotlb_sync_single(struct device *hwdev, dma_addr_t dev_addr,\n\t\t    size_t size, enum dma_data_direction dir,\n\t\t    enum dma_sync_target target)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_CPU)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr))\n\t\tswiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_DEVICE)\n\t\tarch_sync_dma_for_device(hwdev, paddr, size, dir);\n\n\tif (!is_swiotlb_buffer(paddr) && dir == DMA_FROM_DEVICE)\n\t\tdma_mark_clean(phys_to_virt(paddr), size);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void\nswiotlb_sync_single(struct device *hwdev, dma_addr_t dev_addr,\n\t\t    size_t size, enum dma_data_direction dir,\n\t\t    enum dma_sync_target target)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_CPU)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr))\n\t\tswiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_DEVICE)\n\t\tarch_sync_dma_for_device(hwdev, paddr, size, dir);\n\n\tif (!is_swiotlb_buffer(paddr) && dir == DMA_FROM_DEVICE)\n\t\tdma_mark_clean(phys_to_virt(paddr), size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "sg"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nelems",
            "i"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void\nswiotlb_sync_sg(struct device *hwdev, struct scatterlist *sgl,\n\t\tint nelems, enum dma_data_direction dir,\n\t\tenum dma_sync_target target)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nelems, i)\n\t\tswiotlb_sync_single(hwdev, sg->dma_address,\n\t\t\t\t    sg_dma_len(sg), dir, target);\n}"
  },
  {
    "function_name": "swiotlb_unmap_sg_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "809-822",
    "snippet": "void\nswiotlb_unmap_sg_attrs(struct device *hwdev, struct scatterlist *sgl,\n\t\t       int nelems, enum dma_data_direction dir,\n\t\t       unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tfor_each_sg(sgl, sg, nelems, i)\n\t\tswiotlb_unmap_page(hwdev, sg->dma_address, sg_dma_len(sg), dir,\n\t\t\t     attrs);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_unmap_page",
          "args": [
            "hwdev",
            "sg->dma_address",
            "sg_dma_len(sg)",
            "dir",
            "attrs"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "696-723",
          "snippet": "void swiotlb_unmap_page(struct device *hwdev, dma_addr_t dev_addr,\n\t\t\tsize_t size, enum dma_data_direction dir,\n\t\t\tunsigned long attrs)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) &&\n\t    (attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr)) {\n\t\tswiotlb_tbl_unmap_single(hwdev, paddr, size, dir, attrs);\n\t\treturn;\n\t}\n\n\tif (dir != DMA_FROM_DEVICE)\n\t\treturn;\n\n\t/*\n\t * phys_to_virt doesn't work with hihgmem page but we could\n\t * call dma_mark_clean() with hihgmem page here. However, we\n\t * are fine since dma_mark_clean() is null on POWERPC. We can\n\t * make dma_mark_clean() take a physical address if necessary.\n\t */\n\tdma_mark_clean(phys_to_virt(paddr), size);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_unmap_page(struct device *hwdev, dma_addr_t dev_addr,\n\t\t\tsize_t size, enum dma_data_direction dir,\n\t\t\tunsigned long attrs)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) &&\n\t    (attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr)) {\n\t\tswiotlb_tbl_unmap_single(hwdev, paddr, size, dir, attrs);\n\t\treturn;\n\t}\n\n\tif (dir != DMA_FROM_DEVICE)\n\t\treturn;\n\n\t/*\n\t * phys_to_virt doesn't work with hihgmem page but we could\n\t * call dma_mark_clean() with hihgmem page here. However, we\n\t * are fine since dma_mark_clean() is null on POWERPC. We can\n\t * make dma_mark_clean() take a physical address if necessary.\n\t */\n\tdma_mark_clean(phys_to_virt(paddr), size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "sg"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nelems",
            "i"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dir == DMA_NONE"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid\nswiotlb_unmap_sg_attrs(struct device *hwdev, struct scatterlist *sgl,\n\t\t       int nelems, enum dma_data_direction dir,\n\t\t       unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tfor_each_sg(sgl, sg, nelems, i)\n\t\tswiotlb_unmap_page(hwdev, sg->dma_address, sg_dma_len(sg), dir,\n\t\t\t     attrs);\n}"
  },
  {
    "function_name": "swiotlb_map_sg_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "781-803",
    "snippet": "int\nswiotlb_map_sg_attrs(struct device *dev, struct scatterlist *sgl, int nelems,\n\t\t     enum dma_data_direction dir, unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nelems, i) {\n\t\tsg->dma_address = swiotlb_map_page(dev, sg_page(sg), sg->offset,\n\t\t\t\tsg->length, dir, attrs);\n\t\tif (sg->dma_address == DIRECT_MAPPING_ERROR)\n\t\t\tgoto out_error;\n\t\tsg_dma_len(sg) = sg->length;\n\t}\n\n\treturn nelems;\n\nout_error:\n\tswiotlb_unmap_sg_attrs(dev, sgl, i, dir,\n\t\t\tattrs | DMA_ATTR_SKIP_CPU_SYNC);\n\tsg_dma_len(sgl) = 0;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "sgl"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_unmap_sg_attrs",
          "args": [
            "dev",
            "sgl",
            "i",
            "dir",
            "attrs | DMA_ATTR_SKIP_CPU_SYNC"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_unmap_sg_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "809-822",
          "snippet": "void\nswiotlb_unmap_sg_attrs(struct device *hwdev, struct scatterlist *sgl,\n\t\t       int nelems, enum dma_data_direction dir,\n\t\t       unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tfor_each_sg(sgl, sg, nelems, i)\n\t\tswiotlb_unmap_page(hwdev, sg->dma_address, sg_dma_len(sg), dir,\n\t\t\t     attrs);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid\nswiotlb_unmap_sg_attrs(struct device *hwdev, struct scatterlist *sgl,\n\t\t       int nelems, enum dma_data_direction dir,\n\t\t       unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tfor_each_sg(sgl, sg, nelems, i)\n\t\tswiotlb_unmap_page(hwdev, sg->dma_address, sg_dma_len(sg), dir,\n\t\t\t     attrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "sg"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_map_page",
          "args": [
            "dev",
            "sg_page(sg)",
            "sg->offset",
            "sg->length",
            "dir",
            "attrs"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "661-686",
          "snippet": "dma_addr_t swiotlb_map_page(struct device *dev, struct page *page,\n\t\t\t    unsigned long offset, size_t size,\n\t\t\t    enum dma_data_direction dir,\n\t\t\t    unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dev_addr = phys_to_dma(dev, phys);\n\n\tBUG_ON(dir == DMA_NONE);\n\t/*\n\t * If the address happens to be in the device's DMA window,\n\t * we can safely return the device addr and not worry about bounce\n\t * buffering it.\n\t */\n\tif (!dma_capable(dev, dev_addr, size) ||\n\t    swiotlb_force == SWIOTLB_FORCE) {\n\t\ttrace_swiotlb_bounced(dev, dev_addr, size, swiotlb_force);\n\t\tdev_addr = swiotlb_bounce_page(dev, &phys, size, dir, attrs);\n\t}\n\n\tif (!dev_is_dma_coherent(dev) &&\n\t    (attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)\n\t\tarch_sync_dma_for_device(dev, phys, size, dir);\n\n\treturn dev_addr;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\n\ndma_addr_t swiotlb_map_page(struct device *dev, struct page *page,\n\t\t\t    unsigned long offset, size_t size,\n\t\t\t    enum dma_data_direction dir,\n\t\t\t    unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dev_addr = phys_to_dma(dev, phys);\n\n\tBUG_ON(dir == DMA_NONE);\n\t/*\n\t * If the address happens to be in the device's DMA window,\n\t * we can safely return the device addr and not worry about bounce\n\t * buffering it.\n\t */\n\tif (!dma_capable(dev, dev_addr, size) ||\n\t    swiotlb_force == SWIOTLB_FORCE) {\n\t\ttrace_swiotlb_bounced(dev, dev_addr, size, swiotlb_force);\n\t\tdev_addr = swiotlb_bounce_page(dev, &phys, size, dir, attrs);\n\t}\n\n\tif (!dev_is_dma_coherent(dev) &&\n\t    (attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)\n\t\tarch_sync_dma_for_device(dev, phys, size, dir);\n\n\treturn dev_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "sg"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nelems",
            "i"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nint\nswiotlb_map_sg_attrs(struct device *dev, struct scatterlist *sgl, int nelems,\n\t\t     enum dma_data_direction dir, unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nelems, i) {\n\t\tsg->dma_address = swiotlb_map_page(dev, sg_page(sg), sg->offset,\n\t\t\t\tsg->length, dir, attrs);\n\t\tif (sg->dma_address == DIRECT_MAPPING_ERROR)\n\t\t\tgoto out_error;\n\t\tsg_dma_len(sg) = sg->length;\n\t}\n\n\treturn nelems;\n\nout_error:\n\tswiotlb_unmap_sg_attrs(dev, sgl, i, dir,\n\t\t\tattrs | DMA_ATTR_SKIP_CPU_SYNC);\n\tsg_dma_len(sgl) = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "swiotlb_sync_single_for_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "764-769",
    "snippet": "void\nswiotlb_sync_single_for_device(struct device *hwdev, dma_addr_t dev_addr,\n\t\t\t       size_t size, enum dma_data_direction dir)\n{\n\tswiotlb_sync_single(hwdev, dev_addr, size, dir, SYNC_FOR_DEVICE);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_sync_single",
          "args": [
            "hwdev",
            "dev_addr",
            "size",
            "dir",
            "SYNC_FOR_DEVICE"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_sync_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "735-755",
          "snippet": "static void\nswiotlb_sync_single(struct device *hwdev, dma_addr_t dev_addr,\n\t\t    size_t size, enum dma_data_direction dir,\n\t\t    enum dma_sync_target target)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_CPU)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr))\n\t\tswiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_DEVICE)\n\t\tarch_sync_dma_for_device(hwdev, paddr, size, dir);\n\n\tif (!is_swiotlb_buffer(paddr) && dir == DMA_FROM_DEVICE)\n\t\tdma_mark_clean(phys_to_virt(paddr), size);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void\nswiotlb_sync_single(struct device *hwdev, dma_addr_t dev_addr,\n\t\t    size_t size, enum dma_data_direction dir,\n\t\t    enum dma_sync_target target)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_CPU)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr))\n\t\tswiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_DEVICE)\n\t\tarch_sync_dma_for_device(hwdev, paddr, size, dir);\n\n\tif (!is_swiotlb_buffer(paddr) && dir == DMA_FROM_DEVICE)\n\t\tdma_mark_clean(phys_to_virt(paddr), size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid\nswiotlb_sync_single_for_device(struct device *hwdev, dma_addr_t dev_addr,\n\t\t\t       size_t size, enum dma_data_direction dir)\n{\n\tswiotlb_sync_single(hwdev, dev_addr, size, dir, SYNC_FOR_DEVICE);\n}"
  },
  {
    "function_name": "swiotlb_sync_single_for_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "757-762",
    "snippet": "void\nswiotlb_sync_single_for_cpu(struct device *hwdev, dma_addr_t dev_addr,\n\t\t\t    size_t size, enum dma_data_direction dir)\n{\n\tswiotlb_sync_single(hwdev, dev_addr, size, dir, SYNC_FOR_CPU);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_sync_single",
          "args": [
            "hwdev",
            "dev_addr",
            "size",
            "dir",
            "SYNC_FOR_CPU"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_sync_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "735-755",
          "snippet": "static void\nswiotlb_sync_single(struct device *hwdev, dma_addr_t dev_addr,\n\t\t    size_t size, enum dma_data_direction dir,\n\t\t    enum dma_sync_target target)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_CPU)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr))\n\t\tswiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_DEVICE)\n\t\tarch_sync_dma_for_device(hwdev, paddr, size, dir);\n\n\tif (!is_swiotlb_buffer(paddr) && dir == DMA_FROM_DEVICE)\n\t\tdma_mark_clean(phys_to_virt(paddr), size);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void\nswiotlb_sync_single(struct device *hwdev, dma_addr_t dev_addr,\n\t\t    size_t size, enum dma_data_direction dir,\n\t\t    enum dma_sync_target target)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_CPU)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr))\n\t\tswiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_DEVICE)\n\t\tarch_sync_dma_for_device(hwdev, paddr, size, dir);\n\n\tif (!is_swiotlb_buffer(paddr) && dir == DMA_FROM_DEVICE)\n\t\tdma_mark_clean(phys_to_virt(paddr), size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid\nswiotlb_sync_single_for_cpu(struct device *hwdev, dma_addr_t dev_addr,\n\t\t\t    size_t size, enum dma_data_direction dir)\n{\n\tswiotlb_sync_single(hwdev, dev_addr, size, dir, SYNC_FOR_CPU);\n}"
  },
  {
    "function_name": "swiotlb_sync_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "735-755",
    "snippet": "static void\nswiotlb_sync_single(struct device *hwdev, dma_addr_t dev_addr,\n\t\t    size_t size, enum dma_data_direction dir,\n\t\t    enum dma_sync_target target)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_CPU)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr))\n\t\tswiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_DEVICE)\n\t\tarch_sync_dma_for_device(hwdev, paddr, size, dir);\n\n\tif (!is_swiotlb_buffer(paddr) && dir == DMA_FROM_DEVICE)\n\t\tdma_mark_clean(phys_to_virt(paddr), size);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_mark_clean",
          "args": [
            "phys_to_virt(paddr)",
            "size"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "paddr"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swiotlb_buffer",
          "args": [
            "paddr"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "is_swiotlb_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "386-389",
          "snippet": "static int is_swiotlb_buffer(phys_addr_t paddr)\n{\n\treturn paddr >= io_tlb_start && paddr < io_tlb_end;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static phys_addr_t io_tlb_start, io_tlb_end;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\n\nstatic int is_swiotlb_buffer(phys_addr_t paddr)\n{\n\treturn paddr >= io_tlb_start && paddr < io_tlb_end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_sync_dma_for_device",
          "args": [
            "hwdev",
            "paddr",
            "size",
            "dir"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "hwdev"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_tbl_sync_single",
          "args": [
            "hwdev",
            "paddr",
            "size",
            "dir",
            "target"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_tbl_sync_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "595-624",
          "snippet": "void swiotlb_tbl_sync_single(struct device *hwdev, phys_addr_t tlb_addr,\n\t\t\t     size_t size, enum dma_data_direction dir,\n\t\t\t     enum dma_sync_target target)\n{\n\tint index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = io_tlb_orig_addr[index];\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\torig_addr += (unsigned long)tlb_addr & ((1 << IO_TLB_SHIFT) - 1);\n\n\tswitch (target) {\n\tcase SYNC_FOR_CPU:\n\t\tif (likely(dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\t\tswiotlb_bounce(orig_addr, tlb_addr,\n\t\t\t\t       size, DMA_FROM_DEVICE);\n\t\telse\n\t\t\tBUG_ON(dir != DMA_TO_DEVICE);\n\t\tbreak;\n\tcase SYNC_FOR_DEVICE:\n\t\tif (likely(dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\t\tswiotlb_bounce(orig_addr, tlb_addr,\n\t\t\t\t       size, DMA_TO_DEVICE);\n\t\telse\n\t\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [
            "static phys_addr_t *io_tlb_orig_addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic phys_addr_t *io_tlb_orig_addr;\n\nvoid swiotlb_tbl_sync_single(struct device *hwdev, phys_addr_t tlb_addr,\n\t\t\t     size_t size, enum dma_data_direction dir,\n\t\t\t     enum dma_sync_target target)\n{\n\tint index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = io_tlb_orig_addr[index];\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\torig_addr += (unsigned long)tlb_addr & ((1 << IO_TLB_SHIFT) - 1);\n\n\tswitch (target) {\n\tcase SYNC_FOR_CPU:\n\t\tif (likely(dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\t\tswiotlb_bounce(orig_addr, tlb_addr,\n\t\t\t\t       size, DMA_FROM_DEVICE);\n\t\telse\n\t\t\tBUG_ON(dir != DMA_TO_DEVICE);\n\t\tbreak;\n\tcase SYNC_FOR_DEVICE:\n\t\tif (likely(dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\t\tswiotlb_bounce(orig_addr, tlb_addr,\n\t\t\t\t       size, DMA_TO_DEVICE);\n\t\telse\n\t\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_sync_dma_for_cpu",
          "args": [
            "hwdev",
            "paddr",
            "size",
            "dir"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "hwdev"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dir == DMA_NONE"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "hwdev",
            "dev_addr"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void\nswiotlb_sync_single(struct device *hwdev, dma_addr_t dev_addr,\n\t\t    size_t size, enum dma_data_direction dir,\n\t\t    enum dma_sync_target target)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_CPU)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr))\n\t\tswiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);\n\n\tif (!dev_is_dma_coherent(hwdev) && target == SYNC_FOR_DEVICE)\n\t\tarch_sync_dma_for_device(hwdev, paddr, size, dir);\n\n\tif (!is_swiotlb_buffer(paddr) && dir == DMA_FROM_DEVICE)\n\t\tdma_mark_clean(phys_to_virt(paddr), size);\n}"
  },
  {
    "function_name": "swiotlb_unmap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "696-723",
    "snippet": "void swiotlb_unmap_page(struct device *hwdev, dma_addr_t dev_addr,\n\t\t\tsize_t size, enum dma_data_direction dir,\n\t\t\tunsigned long attrs)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) &&\n\t    (attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr)) {\n\t\tswiotlb_tbl_unmap_single(hwdev, paddr, size, dir, attrs);\n\t\treturn;\n\t}\n\n\tif (dir != DMA_FROM_DEVICE)\n\t\treturn;\n\n\t/*\n\t * phys_to_virt doesn't work with hihgmem page but we could\n\t * call dma_mark_clean() with hihgmem page here. However, we\n\t * are fine since dma_mark_clean() is null on POWERPC. We can\n\t * make dma_mark_clean() take a physical address if necessary.\n\t */\n\tdma_mark_clean(phys_to_virt(paddr), size);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_mark_clean",
          "args": [
            "phys_to_virt(paddr)",
            "size"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "paddr"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_tbl_unmap_single",
          "args": [
            "hwdev",
            "paddr",
            "size",
            "dir",
            "attrs"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_tbl_unmap_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "550-593",
          "snippet": "void swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,\n\t\t\t      size_t size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long flags;\n\tint i, count, nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\tint index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = io_tlb_orig_addr[index];\n\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (orig_addr != INVALID_PHYS_ADDR &&\n\t    !(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    ((dir == DMA_FROM_DEVICE) || (dir == DMA_BIDIRECTIONAL)))\n\t\tswiotlb_bounce(orig_addr, tlb_addr, size, DMA_FROM_DEVICE);\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&io_tlb_lock, flags);\n\t{\n\t\tcount = ((index + nslots) < ALIGN(index + 1, IO_TLB_SEGSIZE) ?\n\t\t\t io_tlb_list[index + nslots] : 0);\n\t\t/*\n\t\t * Step 1: return the slots to the free list, merging the\n\t\t * slots with superceeding slots\n\t\t */\n\t\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\t\tio_tlb_list[i] = ++count;\n\t\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t\t}\n\t\t/*\n\t\t * Step 2: merge the returned slots with the preceding slots,\n\t\t * if available (non zero)\n\t\t */\n\t\tfor (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE -1) && io_tlb_list[i]; i--)\n\t\t\tio_tlb_list[i] = ++count;\n\t}\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [
            "static unsigned int *io_tlb_list;",
            "static phys_addr_t *io_tlb_orig_addr;",
            "static DEFINE_SPINLOCK(io_tlb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic unsigned int *io_tlb_list;\nstatic phys_addr_t *io_tlb_orig_addr;\nstatic DEFINE_SPINLOCK(io_tlb_lock);\n\nvoid swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,\n\t\t\t      size_t size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long flags;\n\tint i, count, nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\tint index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = io_tlb_orig_addr[index];\n\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (orig_addr != INVALID_PHYS_ADDR &&\n\t    !(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    ((dir == DMA_FROM_DEVICE) || (dir == DMA_BIDIRECTIONAL)))\n\t\tswiotlb_bounce(orig_addr, tlb_addr, size, DMA_FROM_DEVICE);\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&io_tlb_lock, flags);\n\t{\n\t\tcount = ((index + nslots) < ALIGN(index + 1, IO_TLB_SEGSIZE) ?\n\t\t\t io_tlb_list[index + nslots] : 0);\n\t\t/*\n\t\t * Step 1: return the slots to the free list, merging the\n\t\t * slots with superceeding slots\n\t\t */\n\t\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\t\tio_tlb_list[i] = ++count;\n\t\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t\t}\n\t\t/*\n\t\t * Step 2: merge the returned slots with the preceding slots,\n\t\t * if available (non zero)\n\t\t */\n\t\tfor (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE -1) && io_tlb_list[i]; i--)\n\t\t\tio_tlb_list[i] = ++count;\n\t}\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_swiotlb_buffer",
          "args": [
            "paddr"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "is_swiotlb_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "386-389",
          "snippet": "static int is_swiotlb_buffer(phys_addr_t paddr)\n{\n\treturn paddr >= io_tlb_start && paddr < io_tlb_end;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static phys_addr_t io_tlb_start, io_tlb_end;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\n\nstatic int is_swiotlb_buffer(phys_addr_t paddr)\n{\n\treturn paddr >= io_tlb_start && paddr < io_tlb_end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_sync_dma_for_cpu",
          "args": [
            "hwdev",
            "paddr",
            "size",
            "dir"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "hwdev"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dir == DMA_NONE"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "hwdev",
            "dev_addr"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_unmap_page(struct device *hwdev, dma_addr_t dev_addr,\n\t\t\tsize_t size, enum dma_data_direction dir,\n\t\t\tunsigned long attrs)\n{\n\tphys_addr_t paddr = dma_to_phys(hwdev, dev_addr);\n\n\tBUG_ON(dir == DMA_NONE);\n\n\tif (!dev_is_dma_coherent(hwdev) &&\n\t    (attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)\n\t\tarch_sync_dma_for_cpu(hwdev, paddr, size, dir);\n\n\tif (is_swiotlb_buffer(paddr)) {\n\t\tswiotlb_tbl_unmap_single(hwdev, paddr, size, dir, attrs);\n\t\treturn;\n\t}\n\n\tif (dir != DMA_FROM_DEVICE)\n\t\treturn;\n\n\t/*\n\t * phys_to_virt doesn't work with hihgmem page but we could\n\t * call dma_mark_clean() with hihgmem page here. However, we\n\t * are fine since dma_mark_clean() is null on POWERPC. We can\n\t * make dma_mark_clean() take a physical address if necessary.\n\t */\n\tdma_mark_clean(phys_to_virt(paddr), size);\n}"
  },
  {
    "function_name": "swiotlb_map_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "661-686",
    "snippet": "dma_addr_t swiotlb_map_page(struct device *dev, struct page *page,\n\t\t\t    unsigned long offset, size_t size,\n\t\t\t    enum dma_data_direction dir,\n\t\t\t    unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dev_addr = phys_to_dma(dev, phys);\n\n\tBUG_ON(dir == DMA_NONE);\n\t/*\n\t * If the address happens to be in the device's DMA window,\n\t * we can safely return the device addr and not worry about bounce\n\t * buffering it.\n\t */\n\tif (!dma_capable(dev, dev_addr, size) ||\n\t    swiotlb_force == SWIOTLB_FORCE) {\n\t\ttrace_swiotlb_bounced(dev, dev_addr, size, swiotlb_force);\n\t\tdev_addr = swiotlb_bounce_page(dev, &phys, size, dir, attrs);\n\t}\n\n\tif (!dev_is_dma_coherent(dev) &&\n\t    (attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)\n\t\tarch_sync_dma_for_device(dev, phys, size, dir);\n\n\treturn dev_addr;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_sync_dma_for_device",
          "args": [
            "dev",
            "phys",
            "size",
            "dir"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_bounce_page",
          "args": [
            "dev",
            "&phys",
            "size",
            "dir",
            "attrs"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_bounce_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "626-652",
          "snippet": "static dma_addr_t swiotlb_bounce_page(struct device *dev, phys_addr_t *phys,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tdma_addr_t dma_addr;\n\n\tif (unlikely(swiotlb_force == SWIOTLB_NO_FORCE)) {\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\"Cannot do DMA to address %pa\\n\", phys);\n\t\treturn DIRECT_MAPPING_ERROR;\n\t}\n\n\t/* Oh well, have to allocate and map a bounce buffer. */\n\t*phys = swiotlb_tbl_map_single(dev, __phys_to_dma(dev, io_tlb_start),\n\t\t\t*phys, size, dir, attrs);\n\tif (*phys == SWIOTLB_MAP_ERROR)\n\t\treturn DIRECT_MAPPING_ERROR;\n\n\t/* Ensure that the address returned is DMA'ble */\n\tdma_addr = __phys_to_dma(dev, *phys);\n\tif (unlikely(!dma_capable(dev, dma_addr, size))) {\n\t\tswiotlb_tbl_unmap_single(dev, *phys, size, dir,\n\t\t\tattrs | DMA_ATTR_SKIP_CPU_SYNC);\n\t\treturn DIRECT_MAPPING_ERROR;\n\t}\n\n\treturn dma_addr;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\n\nstatic dma_addr_t swiotlb_bounce_page(struct device *dev, phys_addr_t *phys,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tdma_addr_t dma_addr;\n\n\tif (unlikely(swiotlb_force == SWIOTLB_NO_FORCE)) {\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\"Cannot do DMA to address %pa\\n\", phys);\n\t\treturn DIRECT_MAPPING_ERROR;\n\t}\n\n\t/* Oh well, have to allocate and map a bounce buffer. */\n\t*phys = swiotlb_tbl_map_single(dev, __phys_to_dma(dev, io_tlb_start),\n\t\t\t*phys, size, dir, attrs);\n\tif (*phys == SWIOTLB_MAP_ERROR)\n\t\treturn DIRECT_MAPPING_ERROR;\n\n\t/* Ensure that the address returned is DMA'ble */\n\tdma_addr = __phys_to_dma(dev, *phys);\n\tif (unlikely(!dma_capable(dev, dma_addr, size))) {\n\t\tswiotlb_tbl_unmap_single(dev, *phys, size, dir,\n\t\t\tattrs | DMA_ATTR_SKIP_CPU_SYNC);\n\t\treturn DIRECT_MAPPING_ERROR;\n\t}\n\n\treturn dma_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_swiotlb_bounced",
          "args": [
            "dev",
            "dev_addr",
            "size",
            "swiotlb_force"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_capable",
          "args": [
            "dev",
            "dev_addr",
            "size"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dir == DMA_NONE"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma",
          "args": [
            "dev",
            "phys"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "56-62",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\n\ndma_addr_t swiotlb_map_page(struct device *dev, struct page *page,\n\t\t\t    unsigned long offset, size_t size,\n\t\t\t    enum dma_data_direction dir,\n\t\t\t    unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dev_addr = phys_to_dma(dev, phys);\n\n\tBUG_ON(dir == DMA_NONE);\n\t/*\n\t * If the address happens to be in the device's DMA window,\n\t * we can safely return the device addr and not worry about bounce\n\t * buffering it.\n\t */\n\tif (!dma_capable(dev, dev_addr, size) ||\n\t    swiotlb_force == SWIOTLB_FORCE) {\n\t\ttrace_swiotlb_bounced(dev, dev_addr, size, swiotlb_force);\n\t\tdev_addr = swiotlb_bounce_page(dev, &phys, size, dir, attrs);\n\t}\n\n\tif (!dev_is_dma_coherent(dev) &&\n\t    (attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)\n\t\tarch_sync_dma_for_device(dev, phys, size, dir);\n\n\treturn dev_addr;\n}"
  },
  {
    "function_name": "swiotlb_bounce_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "626-652",
    "snippet": "static dma_addr_t swiotlb_bounce_page(struct device *dev, phys_addr_t *phys,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tdma_addr_t dma_addr;\n\n\tif (unlikely(swiotlb_force == SWIOTLB_NO_FORCE)) {\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\"Cannot do DMA to address %pa\\n\", phys);\n\t\treturn DIRECT_MAPPING_ERROR;\n\t}\n\n\t/* Oh well, have to allocate and map a bounce buffer. */\n\t*phys = swiotlb_tbl_map_single(dev, __phys_to_dma(dev, io_tlb_start),\n\t\t\t*phys, size, dir, attrs);\n\tif (*phys == SWIOTLB_MAP_ERROR)\n\t\treturn DIRECT_MAPPING_ERROR;\n\n\t/* Ensure that the address returned is DMA'ble */\n\tdma_addr = __phys_to_dma(dev, *phys);\n\tif (unlikely(!dma_capable(dev, dma_addr, size))) {\n\t\tswiotlb_tbl_unmap_single(dev, *phys, size, dir,\n\t\t\tattrs | DMA_ATTR_SKIP_CPU_SYNC);\n\t\treturn DIRECT_MAPPING_ERROR;\n\t}\n\n\treturn dma_addr;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_tbl_unmap_single",
          "args": [
            "dev",
            "*phys",
            "size",
            "dir",
            "attrs | DMA_ATTR_SKIP_CPU_SYNC"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_tbl_unmap_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "550-593",
          "snippet": "void swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,\n\t\t\t      size_t size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long flags;\n\tint i, count, nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\tint index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = io_tlb_orig_addr[index];\n\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (orig_addr != INVALID_PHYS_ADDR &&\n\t    !(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    ((dir == DMA_FROM_DEVICE) || (dir == DMA_BIDIRECTIONAL)))\n\t\tswiotlb_bounce(orig_addr, tlb_addr, size, DMA_FROM_DEVICE);\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&io_tlb_lock, flags);\n\t{\n\t\tcount = ((index + nslots) < ALIGN(index + 1, IO_TLB_SEGSIZE) ?\n\t\t\t io_tlb_list[index + nslots] : 0);\n\t\t/*\n\t\t * Step 1: return the slots to the free list, merging the\n\t\t * slots with superceeding slots\n\t\t */\n\t\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\t\tio_tlb_list[i] = ++count;\n\t\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t\t}\n\t\t/*\n\t\t * Step 2: merge the returned slots with the preceding slots,\n\t\t * if available (non zero)\n\t\t */\n\t\tfor (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE -1) && io_tlb_list[i]; i--)\n\t\t\tio_tlb_list[i] = ++count;\n\t}\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [
            "static unsigned int *io_tlb_list;",
            "static phys_addr_t *io_tlb_orig_addr;",
            "static DEFINE_SPINLOCK(io_tlb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic unsigned int *io_tlb_list;\nstatic phys_addr_t *io_tlb_orig_addr;\nstatic DEFINE_SPINLOCK(io_tlb_lock);\n\nvoid swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,\n\t\t\t      size_t size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long flags;\n\tint i, count, nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\tint index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = io_tlb_orig_addr[index];\n\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (orig_addr != INVALID_PHYS_ADDR &&\n\t    !(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    ((dir == DMA_FROM_DEVICE) || (dir == DMA_BIDIRECTIONAL)))\n\t\tswiotlb_bounce(orig_addr, tlb_addr, size, DMA_FROM_DEVICE);\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&io_tlb_lock, flags);\n\t{\n\t\tcount = ((index + nslots) < ALIGN(index + 1, IO_TLB_SEGSIZE) ?\n\t\t\t io_tlb_list[index + nslots] : 0);\n\t\t/*\n\t\t * Step 1: return the slots to the free list, merging the\n\t\t * slots with superceeding slots\n\t\t */\n\t\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\t\tio_tlb_list[i] = ++count;\n\t\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t\t}\n\t\t/*\n\t\t * Step 2: merge the returned slots with the preceding slots,\n\t\t * if available (non zero)\n\t\t */\n\t\tfor (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE -1) && io_tlb_list[i]; i--)\n\t\t\tio_tlb_list[i] = ++count;\n\t}\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dma_capable(dev, dma_addr, size)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_capable",
          "args": [
            "dev",
            "dma_addr",
            "size"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__phys_to_dma",
          "args": [
            "dev",
            "*phys"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_tbl_map_single",
          "args": [
            "dev",
            "__phys_to_dma(dev, io_tlb_start)",
            "*phys",
            "size",
            "dir",
            "attrs"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_tbl_map_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "431-545",
          "snippet": "phys_addr_t swiotlb_tbl_map_single(struct device *hwdev,\n\t\t\t\t   dma_addr_t tbl_dma_addr,\n\t\t\t\t   phys_addr_t orig_addr, size_t size,\n\t\t\t\t   enum dma_data_direction dir,\n\t\t\t\t   unsigned long attrs)\n{\n\tunsigned long flags;\n\tphys_addr_t tlb_addr;\n\tunsigned int nslots, stride, index, wrap;\n\tint i;\n\tunsigned long mask;\n\tunsigned long offset_slots;\n\tunsigned long max_slots;\n\n\tif (no_iotlb_memory)\n\t\tpanic(\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\");\n\n\tif (mem_encrypt_active())\n\t\tpr_warn_once(\"%s is active and system is using DMA bounce buffers\\n\",\n\t\t\t     sme_active() ? \"SME\" : \"SEV\");\n\n\tmask = dma_get_seg_boundary(hwdev);\n\n\ttbl_dma_addr &= mask;\n\n\toffset_slots = ALIGN(tbl_dma_addr, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\n\t/*\n \t * Carefully handle integer overflow which can occur when mask == ~0UL.\n \t */\n\tmax_slots = mask + 1\n\t\t    ? ALIGN(mask + 1, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT\n\t\t    : 1UL << (BITS_PER_LONG - IO_TLB_SHIFT);\n\n\t/*\n\t * For mappings greater than or equal to a page, we limit the stride\n\t * (and hence alignment) to a page size.\n\t */\n\tnslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\tif (size >= PAGE_SIZE)\n\t\tstride = (1 << (PAGE_SHIFT - IO_TLB_SHIFT));\n\telse\n\t\tstride = 1;\n\n\tBUG_ON(!nslots);\n\n\t/*\n\t * Find suitable number of IO TLB entries size that will fit this\n\t * request and allocate a buffer from that IO TLB pool.\n\t */\n\tspin_lock_irqsave(&io_tlb_lock, flags);\n\tindex = ALIGN(io_tlb_index, stride);\n\tif (index >= io_tlb_nslabs)\n\t\tindex = 0;\n\twrap = index;\n\n\tdo {\n\t\twhile (iommu_is_span_boundary(index, nslots, offset_slots,\n\t\t\t\t\t      max_slots)) {\n\t\t\tindex += stride;\n\t\t\tif (index >= io_tlb_nslabs)\n\t\t\t\tindex = 0;\n\t\t\tif (index == wrap)\n\t\t\t\tgoto not_found;\n\t\t}\n\n\t\t/*\n\t\t * If we find a slot that indicates we have 'nslots' number of\n\t\t * contiguous buffers, we allocate the buffers from that slot\n\t\t * and mark the entries as '0' indicating unavailable.\n\t\t */\n\t\tif (io_tlb_list[index] >= nslots) {\n\t\t\tint count = 0;\n\n\t\t\tfor (i = index; i < (int) (index + nslots); i++)\n\t\t\t\tio_tlb_list[i] = 0;\n\t\t\tfor (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE - 1) && io_tlb_list[i]; i--)\n\t\t\t\tio_tlb_list[i] = ++count;\n\t\t\ttlb_addr = io_tlb_start + (index << IO_TLB_SHIFT);\n\n\t\t\t/*\n\t\t\t * Update the indices to avoid searching in the next\n\t\t\t * round.\n\t\t\t */\n\t\t\tio_tlb_index = ((index + nslots) < io_tlb_nslabs\n\t\t\t\t\t? (index + nslots) : 0);\n\n\t\t\tgoto found;\n\t\t}\n\t\tindex += stride;\n\t\tif (index >= io_tlb_nslabs)\n\t\t\tindex = 0;\n\t} while (index != wrap);\n\nnot_found:\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n\tif (!(attrs & DMA_ATTR_NO_WARN) && printk_ratelimit())\n\t\tdev_warn(hwdev, \"swiotlb buffer is full (sz: %zd bytes)\\n\", size);\n\treturn SWIOTLB_MAP_ERROR;\nfound:\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n\n\t/*\n\t * Save away the mapping from the original address to the DMA address.\n\t * This is needed when we sync the memory.  Then we sync the buffer if\n\t * needed.\n\t */\n\tfor (i = 0; i < nslots; i++)\n\t\tio_tlb_orig_addr[index+i] = orig_addr + (i << IO_TLB_SHIFT);\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(orig_addr, tlb_addr, size, DMA_TO_DEVICE);\n\n\treturn tlb_addr;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long io_tlb_nslabs;",
            "static unsigned int *io_tlb_list;",
            "static unsigned int io_tlb_index;",
            "static phys_addr_t *io_tlb_orig_addr;",
            "static DEFINE_SPINLOCK(io_tlb_lock);",
            "static bool no_iotlb_memory;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned long io_tlb_nslabs;\nstatic unsigned int *io_tlb_list;\nstatic unsigned int io_tlb_index;\nstatic phys_addr_t *io_tlb_orig_addr;\nstatic DEFINE_SPINLOCK(io_tlb_lock);\nstatic bool no_iotlb_memory;\n\nphys_addr_t swiotlb_tbl_map_single(struct device *hwdev,\n\t\t\t\t   dma_addr_t tbl_dma_addr,\n\t\t\t\t   phys_addr_t orig_addr, size_t size,\n\t\t\t\t   enum dma_data_direction dir,\n\t\t\t\t   unsigned long attrs)\n{\n\tunsigned long flags;\n\tphys_addr_t tlb_addr;\n\tunsigned int nslots, stride, index, wrap;\n\tint i;\n\tunsigned long mask;\n\tunsigned long offset_slots;\n\tunsigned long max_slots;\n\n\tif (no_iotlb_memory)\n\t\tpanic(\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\");\n\n\tif (mem_encrypt_active())\n\t\tpr_warn_once(\"%s is active and system is using DMA bounce buffers\\n\",\n\t\t\t     sme_active() ? \"SME\" : \"SEV\");\n\n\tmask = dma_get_seg_boundary(hwdev);\n\n\ttbl_dma_addr &= mask;\n\n\toffset_slots = ALIGN(tbl_dma_addr, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\n\t/*\n \t * Carefully handle integer overflow which can occur when mask == ~0UL.\n \t */\n\tmax_slots = mask + 1\n\t\t    ? ALIGN(mask + 1, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT\n\t\t    : 1UL << (BITS_PER_LONG - IO_TLB_SHIFT);\n\n\t/*\n\t * For mappings greater than or equal to a page, we limit the stride\n\t * (and hence alignment) to a page size.\n\t */\n\tnslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\tif (size >= PAGE_SIZE)\n\t\tstride = (1 << (PAGE_SHIFT - IO_TLB_SHIFT));\n\telse\n\t\tstride = 1;\n\n\tBUG_ON(!nslots);\n\n\t/*\n\t * Find suitable number of IO TLB entries size that will fit this\n\t * request and allocate a buffer from that IO TLB pool.\n\t */\n\tspin_lock_irqsave(&io_tlb_lock, flags);\n\tindex = ALIGN(io_tlb_index, stride);\n\tif (index >= io_tlb_nslabs)\n\t\tindex = 0;\n\twrap = index;\n\n\tdo {\n\t\twhile (iommu_is_span_boundary(index, nslots, offset_slots,\n\t\t\t\t\t      max_slots)) {\n\t\t\tindex += stride;\n\t\t\tif (index >= io_tlb_nslabs)\n\t\t\t\tindex = 0;\n\t\t\tif (index == wrap)\n\t\t\t\tgoto not_found;\n\t\t}\n\n\t\t/*\n\t\t * If we find a slot that indicates we have 'nslots' number of\n\t\t * contiguous buffers, we allocate the buffers from that slot\n\t\t * and mark the entries as '0' indicating unavailable.\n\t\t */\n\t\tif (io_tlb_list[index] >= nslots) {\n\t\t\tint count = 0;\n\n\t\t\tfor (i = index; i < (int) (index + nslots); i++)\n\t\t\t\tio_tlb_list[i] = 0;\n\t\t\tfor (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE - 1) && io_tlb_list[i]; i--)\n\t\t\t\tio_tlb_list[i] = ++count;\n\t\t\ttlb_addr = io_tlb_start + (index << IO_TLB_SHIFT);\n\n\t\t\t/*\n\t\t\t * Update the indices to avoid searching in the next\n\t\t\t * round.\n\t\t\t */\n\t\t\tio_tlb_index = ((index + nslots) < io_tlb_nslabs\n\t\t\t\t\t? (index + nslots) : 0);\n\n\t\t\tgoto found;\n\t\t}\n\t\tindex += stride;\n\t\tif (index >= io_tlb_nslabs)\n\t\t\tindex = 0;\n\t} while (index != wrap);\n\nnot_found:\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n\tif (!(attrs & DMA_ATTR_NO_WARN) && printk_ratelimit())\n\t\tdev_warn(hwdev, \"swiotlb buffer is full (sz: %zd bytes)\\n\", size);\n\treturn SWIOTLB_MAP_ERROR;\nfound:\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n\n\t/*\n\t * Save away the mapping from the original address to the DMA address.\n\t * This is needed when we sync the memory.  Then we sync the buffer if\n\t * needed.\n\t */\n\tfor (i = 0; i < nslots; i++)\n\t\tio_tlb_orig_addr[index+i] = orig_addr + (i << IO_TLB_SHIFT);\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(orig_addr, tlb_addr, size, DMA_TO_DEVICE);\n\n\treturn tlb_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__phys_to_dma",
          "args": [
            "dev",
            "io_tlb_start"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_warn_ratelimited",
          "args": [
            "dev",
            "\"Cannot do DMA to address %pa\\n\"",
            "phys"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "swiotlb_force == SWIOTLB_NO_FORCE"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\n\nstatic dma_addr_t swiotlb_bounce_page(struct device *dev, phys_addr_t *phys,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tdma_addr_t dma_addr;\n\n\tif (unlikely(swiotlb_force == SWIOTLB_NO_FORCE)) {\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\"Cannot do DMA to address %pa\\n\", phys);\n\t\treturn DIRECT_MAPPING_ERROR;\n\t}\n\n\t/* Oh well, have to allocate and map a bounce buffer. */\n\t*phys = swiotlb_tbl_map_single(dev, __phys_to_dma(dev, io_tlb_start),\n\t\t\t*phys, size, dir, attrs);\n\tif (*phys == SWIOTLB_MAP_ERROR)\n\t\treturn DIRECT_MAPPING_ERROR;\n\n\t/* Ensure that the address returned is DMA'ble */\n\tdma_addr = __phys_to_dma(dev, *phys);\n\tif (unlikely(!dma_capable(dev, dma_addr, size))) {\n\t\tswiotlb_tbl_unmap_single(dev, *phys, size, dir,\n\t\t\tattrs | DMA_ATTR_SKIP_CPU_SYNC);\n\t\treturn DIRECT_MAPPING_ERROR;\n\t}\n\n\treturn dma_addr;\n}"
  },
  {
    "function_name": "swiotlb_tbl_sync_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "595-624",
    "snippet": "void swiotlb_tbl_sync_single(struct device *hwdev, phys_addr_t tlb_addr,\n\t\t\t     size_t size, enum dma_data_direction dir,\n\t\t\t     enum dma_sync_target target)\n{\n\tint index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = io_tlb_orig_addr[index];\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\torig_addr += (unsigned long)tlb_addr & ((1 << IO_TLB_SHIFT) - 1);\n\n\tswitch (target) {\n\tcase SYNC_FOR_CPU:\n\t\tif (likely(dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\t\tswiotlb_bounce(orig_addr, tlb_addr,\n\t\t\t\t       size, DMA_FROM_DEVICE);\n\t\telse\n\t\t\tBUG_ON(dir != DMA_TO_DEVICE);\n\t\tbreak;\n\tcase SYNC_FOR_DEVICE:\n\t\tif (likely(dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\t\tswiotlb_bounce(orig_addr, tlb_addr,\n\t\t\t\t       size, DMA_TO_DEVICE);\n\t\telse\n\t\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
    ],
    "globals_used": [
      "static phys_addr_t *io_tlb_orig_addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dir != DMA_FROM_DEVICE"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_bounce",
          "args": [
            "orig_addr",
            "tlb_addr",
            "size",
            "DMA_TO_DEVICE"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_bounce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "394-429",
          "snippet": "static void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,\n\t\t\t   size_t size, enum dma_data_direction dir)\n{\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = phys_to_virt(tlb_addr);\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,\n\t\t\t   size_t size, enum dma_data_direction dir)\n{\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = phys_to_virt(tlb_addr);\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dir != DMA_TO_DEVICE"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic phys_addr_t *io_tlb_orig_addr;\n\nvoid swiotlb_tbl_sync_single(struct device *hwdev, phys_addr_t tlb_addr,\n\t\t\t     size_t size, enum dma_data_direction dir,\n\t\t\t     enum dma_sync_target target)\n{\n\tint index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = io_tlb_orig_addr[index];\n\n\tif (orig_addr == INVALID_PHYS_ADDR)\n\t\treturn;\n\torig_addr += (unsigned long)tlb_addr & ((1 << IO_TLB_SHIFT) - 1);\n\n\tswitch (target) {\n\tcase SYNC_FOR_CPU:\n\t\tif (likely(dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\t\tswiotlb_bounce(orig_addr, tlb_addr,\n\t\t\t\t       size, DMA_FROM_DEVICE);\n\t\telse\n\t\t\tBUG_ON(dir != DMA_TO_DEVICE);\n\t\tbreak;\n\tcase SYNC_FOR_DEVICE:\n\t\tif (likely(dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\t\tswiotlb_bounce(orig_addr, tlb_addr,\n\t\t\t\t       size, DMA_TO_DEVICE);\n\t\telse\n\t\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "swiotlb_tbl_unmap_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "550-593",
    "snippet": "void swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,\n\t\t\t      size_t size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long flags;\n\tint i, count, nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\tint index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = io_tlb_orig_addr[index];\n\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (orig_addr != INVALID_PHYS_ADDR &&\n\t    !(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    ((dir == DMA_FROM_DEVICE) || (dir == DMA_BIDIRECTIONAL)))\n\t\tswiotlb_bounce(orig_addr, tlb_addr, size, DMA_FROM_DEVICE);\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&io_tlb_lock, flags);\n\t{\n\t\tcount = ((index + nslots) < ALIGN(index + 1, IO_TLB_SEGSIZE) ?\n\t\t\t io_tlb_list[index + nslots] : 0);\n\t\t/*\n\t\t * Step 1: return the slots to the free list, merging the\n\t\t * slots with superceeding slots\n\t\t */\n\t\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\t\tio_tlb_list[i] = ++count;\n\t\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t\t}\n\t\t/*\n\t\t * Step 2: merge the returned slots with the preceding slots,\n\t\t * if available (non zero)\n\t\t */\n\t\tfor (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE -1) && io_tlb_list[i]; i--)\n\t\t\tio_tlb_list[i] = ++count;\n\t}\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
    ],
    "globals_used": [
      "static unsigned int *io_tlb_list;",
      "static phys_addr_t *io_tlb_orig_addr;",
      "static DEFINE_SPINLOCK(io_tlb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&io_tlb_lock",
            "flags"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OFFSET",
          "args": [
            "i",
            "IO_TLB_SEGSIZE"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "index + 1",
            "IO_TLB_SEGSIZE"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&io_tlb_lock",
            "flags"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_bounce",
          "args": [
            "orig_addr",
            "tlb_addr",
            "size",
            "DMA_FROM_DEVICE"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_bounce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "394-429",
          "snippet": "static void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,\n\t\t\t   size_t size, enum dma_data_direction dir)\n{\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = phys_to_virt(tlb_addr);\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,\n\t\t\t   size_t size, enum dma_data_direction dir)\n{\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = phys_to_virt(tlb_addr);\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "1 << IO_TLB_SHIFT"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic unsigned int *io_tlb_list;\nstatic phys_addr_t *io_tlb_orig_addr;\nstatic DEFINE_SPINLOCK(io_tlb_lock);\n\nvoid swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,\n\t\t\t      size_t size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long flags;\n\tint i, count, nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\tint index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;\n\tphys_addr_t orig_addr = io_tlb_orig_addr[index];\n\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (orig_addr != INVALID_PHYS_ADDR &&\n\t    !(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    ((dir == DMA_FROM_DEVICE) || (dir == DMA_BIDIRECTIONAL)))\n\t\tswiotlb_bounce(orig_addr, tlb_addr, size, DMA_FROM_DEVICE);\n\n\t/*\n\t * Return the buffer to the free list by setting the corresponding\n\t * entries to indicate the number of contiguous entries available.\n\t * While returning the entries to the free list, we merge the entries\n\t * with slots below and above the pool being returned.\n\t */\n\tspin_lock_irqsave(&io_tlb_lock, flags);\n\t{\n\t\tcount = ((index + nslots) < ALIGN(index + 1, IO_TLB_SEGSIZE) ?\n\t\t\t io_tlb_list[index + nslots] : 0);\n\t\t/*\n\t\t * Step 1: return the slots to the free list, merging the\n\t\t * slots with superceeding slots\n\t\t */\n\t\tfor (i = index + nslots - 1; i >= index; i--) {\n\t\t\tio_tlb_list[i] = ++count;\n\t\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t\t}\n\t\t/*\n\t\t * Step 2: merge the returned slots with the preceding slots,\n\t\t * if available (non zero)\n\t\t */\n\t\tfor (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE -1) && io_tlb_list[i]; i--)\n\t\t\tio_tlb_list[i] = ++count;\n\t}\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n}"
  },
  {
    "function_name": "swiotlb_tbl_map_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "431-545",
    "snippet": "phys_addr_t swiotlb_tbl_map_single(struct device *hwdev,\n\t\t\t\t   dma_addr_t tbl_dma_addr,\n\t\t\t\t   phys_addr_t orig_addr, size_t size,\n\t\t\t\t   enum dma_data_direction dir,\n\t\t\t\t   unsigned long attrs)\n{\n\tunsigned long flags;\n\tphys_addr_t tlb_addr;\n\tunsigned int nslots, stride, index, wrap;\n\tint i;\n\tunsigned long mask;\n\tunsigned long offset_slots;\n\tunsigned long max_slots;\n\n\tif (no_iotlb_memory)\n\t\tpanic(\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\");\n\n\tif (mem_encrypt_active())\n\t\tpr_warn_once(\"%s is active and system is using DMA bounce buffers\\n\",\n\t\t\t     sme_active() ? \"SME\" : \"SEV\");\n\n\tmask = dma_get_seg_boundary(hwdev);\n\n\ttbl_dma_addr &= mask;\n\n\toffset_slots = ALIGN(tbl_dma_addr, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\n\t/*\n \t * Carefully handle integer overflow which can occur when mask == ~0UL.\n \t */\n\tmax_slots = mask + 1\n\t\t    ? ALIGN(mask + 1, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT\n\t\t    : 1UL << (BITS_PER_LONG - IO_TLB_SHIFT);\n\n\t/*\n\t * For mappings greater than or equal to a page, we limit the stride\n\t * (and hence alignment) to a page size.\n\t */\n\tnslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\tif (size >= PAGE_SIZE)\n\t\tstride = (1 << (PAGE_SHIFT - IO_TLB_SHIFT));\n\telse\n\t\tstride = 1;\n\n\tBUG_ON(!nslots);\n\n\t/*\n\t * Find suitable number of IO TLB entries size that will fit this\n\t * request and allocate a buffer from that IO TLB pool.\n\t */\n\tspin_lock_irqsave(&io_tlb_lock, flags);\n\tindex = ALIGN(io_tlb_index, stride);\n\tif (index >= io_tlb_nslabs)\n\t\tindex = 0;\n\twrap = index;\n\n\tdo {\n\t\twhile (iommu_is_span_boundary(index, nslots, offset_slots,\n\t\t\t\t\t      max_slots)) {\n\t\t\tindex += stride;\n\t\t\tif (index >= io_tlb_nslabs)\n\t\t\t\tindex = 0;\n\t\t\tif (index == wrap)\n\t\t\t\tgoto not_found;\n\t\t}\n\n\t\t/*\n\t\t * If we find a slot that indicates we have 'nslots' number of\n\t\t * contiguous buffers, we allocate the buffers from that slot\n\t\t * and mark the entries as '0' indicating unavailable.\n\t\t */\n\t\tif (io_tlb_list[index] >= nslots) {\n\t\t\tint count = 0;\n\n\t\t\tfor (i = index; i < (int) (index + nslots); i++)\n\t\t\t\tio_tlb_list[i] = 0;\n\t\t\tfor (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE - 1) && io_tlb_list[i]; i--)\n\t\t\t\tio_tlb_list[i] = ++count;\n\t\t\ttlb_addr = io_tlb_start + (index << IO_TLB_SHIFT);\n\n\t\t\t/*\n\t\t\t * Update the indices to avoid searching in the next\n\t\t\t * round.\n\t\t\t */\n\t\t\tio_tlb_index = ((index + nslots) < io_tlb_nslabs\n\t\t\t\t\t? (index + nslots) : 0);\n\n\t\t\tgoto found;\n\t\t}\n\t\tindex += stride;\n\t\tif (index >= io_tlb_nslabs)\n\t\t\tindex = 0;\n\t} while (index != wrap);\n\nnot_found:\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n\tif (!(attrs & DMA_ATTR_NO_WARN) && printk_ratelimit())\n\t\tdev_warn(hwdev, \"swiotlb buffer is full (sz: %zd bytes)\\n\", size);\n\treturn SWIOTLB_MAP_ERROR;\nfound:\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n\n\t/*\n\t * Save away the mapping from the original address to the DMA address.\n\t * This is needed when we sync the memory.  Then we sync the buffer if\n\t * needed.\n\t */\n\tfor (i = 0; i < nslots; i++)\n\t\tio_tlb_orig_addr[index+i] = orig_addr + (i << IO_TLB_SHIFT);\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(orig_addr, tlb_addr, size, DMA_TO_DEVICE);\n\n\treturn tlb_addr;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long io_tlb_nslabs;",
      "static unsigned int *io_tlb_list;",
      "static unsigned int io_tlb_index;",
      "static phys_addr_t *io_tlb_orig_addr;",
      "static DEFINE_SPINLOCK(io_tlb_lock);",
      "static bool no_iotlb_memory;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_bounce",
          "args": [
            "orig_addr",
            "tlb_addr",
            "size",
            "DMA_TO_DEVICE"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_bounce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "394-429",
          "snippet": "static void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,\n\t\t\t   size_t size, enum dma_data_direction dir)\n{\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = phys_to_virt(tlb_addr);\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,\n\t\t\t   size_t size, enum dma_data_direction dir)\n{\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = phys_to_virt(tlb_addr);\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&io_tlb_lock",
            "flags"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_warn",
          "args": [
            "hwdev",
            "\"swiotlb buffer is full (sz: %zd bytes)\\n\"",
            "size"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OFFSET",
          "args": [
            "i",
            "IO_TLB_SEGSIZE"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_is_span_boundary",
          "args": [
            "index",
            "nslots",
            "offset_slots",
            "max_slots"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "io_tlb_index",
            "stride"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&io_tlb_lock",
            "flags"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!nslots"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "1 << IO_TLB_SHIFT"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "mask + 1",
            "1 << IO_TLB_SHIFT"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "tbl_dma_addr",
            "1 << IO_TLB_SHIFT"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_seg_boundary",
          "args": [
            "hwdev"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"%s is active and system is using DMA bounce buffers\\n\"",
            "sme_active() ? \"SME\" : \"SEV\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sme_active",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_encrypt_active",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\""
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_panic_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "181-185",
          "snippet": "static int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned long io_tlb_nslabs;\nstatic unsigned int *io_tlb_list;\nstatic unsigned int io_tlb_index;\nstatic phys_addr_t *io_tlb_orig_addr;\nstatic DEFINE_SPINLOCK(io_tlb_lock);\nstatic bool no_iotlb_memory;\n\nphys_addr_t swiotlb_tbl_map_single(struct device *hwdev,\n\t\t\t\t   dma_addr_t tbl_dma_addr,\n\t\t\t\t   phys_addr_t orig_addr, size_t size,\n\t\t\t\t   enum dma_data_direction dir,\n\t\t\t\t   unsigned long attrs)\n{\n\tunsigned long flags;\n\tphys_addr_t tlb_addr;\n\tunsigned int nslots, stride, index, wrap;\n\tint i;\n\tunsigned long mask;\n\tunsigned long offset_slots;\n\tunsigned long max_slots;\n\n\tif (no_iotlb_memory)\n\t\tpanic(\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\");\n\n\tif (mem_encrypt_active())\n\t\tpr_warn_once(\"%s is active and system is using DMA bounce buffers\\n\",\n\t\t\t     sme_active() ? \"SME\" : \"SEV\");\n\n\tmask = dma_get_seg_boundary(hwdev);\n\n\ttbl_dma_addr &= mask;\n\n\toffset_slots = ALIGN(tbl_dma_addr, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\n\t/*\n \t * Carefully handle integer overflow which can occur when mask == ~0UL.\n \t */\n\tmax_slots = mask + 1\n\t\t    ? ALIGN(mask + 1, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT\n\t\t    : 1UL << (BITS_PER_LONG - IO_TLB_SHIFT);\n\n\t/*\n\t * For mappings greater than or equal to a page, we limit the stride\n\t * (and hence alignment) to a page size.\n\t */\n\tnslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;\n\tif (size >= PAGE_SIZE)\n\t\tstride = (1 << (PAGE_SHIFT - IO_TLB_SHIFT));\n\telse\n\t\tstride = 1;\n\n\tBUG_ON(!nslots);\n\n\t/*\n\t * Find suitable number of IO TLB entries size that will fit this\n\t * request and allocate a buffer from that IO TLB pool.\n\t */\n\tspin_lock_irqsave(&io_tlb_lock, flags);\n\tindex = ALIGN(io_tlb_index, stride);\n\tif (index >= io_tlb_nslabs)\n\t\tindex = 0;\n\twrap = index;\n\n\tdo {\n\t\twhile (iommu_is_span_boundary(index, nslots, offset_slots,\n\t\t\t\t\t      max_slots)) {\n\t\t\tindex += stride;\n\t\t\tif (index >= io_tlb_nslabs)\n\t\t\t\tindex = 0;\n\t\t\tif (index == wrap)\n\t\t\t\tgoto not_found;\n\t\t}\n\n\t\t/*\n\t\t * If we find a slot that indicates we have 'nslots' number of\n\t\t * contiguous buffers, we allocate the buffers from that slot\n\t\t * and mark the entries as '0' indicating unavailable.\n\t\t */\n\t\tif (io_tlb_list[index] >= nslots) {\n\t\t\tint count = 0;\n\n\t\t\tfor (i = index; i < (int) (index + nslots); i++)\n\t\t\t\tio_tlb_list[i] = 0;\n\t\t\tfor (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE - 1) && io_tlb_list[i]; i--)\n\t\t\t\tio_tlb_list[i] = ++count;\n\t\t\ttlb_addr = io_tlb_start + (index << IO_TLB_SHIFT);\n\n\t\t\t/*\n\t\t\t * Update the indices to avoid searching in the next\n\t\t\t * round.\n\t\t\t */\n\t\t\tio_tlb_index = ((index + nslots) < io_tlb_nslabs\n\t\t\t\t\t? (index + nslots) : 0);\n\n\t\t\tgoto found;\n\t\t}\n\t\tindex += stride;\n\t\tif (index >= io_tlb_nslabs)\n\t\t\tindex = 0;\n\t} while (index != wrap);\n\nnot_found:\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n\tif (!(attrs & DMA_ATTR_NO_WARN) && printk_ratelimit())\n\t\tdev_warn(hwdev, \"swiotlb buffer is full (sz: %zd bytes)\\n\", size);\n\treturn SWIOTLB_MAP_ERROR;\nfound:\n\tspin_unlock_irqrestore(&io_tlb_lock, flags);\n\n\t/*\n\t * Save away the mapping from the original address to the DMA address.\n\t * This is needed when we sync the memory.  Then we sync the buffer if\n\t * needed.\n\t */\n\tfor (i = 0; i < nslots; i++)\n\t\tio_tlb_orig_addr[index+i] = orig_addr + (i << IO_TLB_SHIFT);\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(orig_addr, tlb_addr, size, DMA_TO_DEVICE);\n\n\treturn tlb_addr;\n}"
  },
  {
    "function_name": "swiotlb_bounce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "394-429",
    "snippet": "static void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,\n\t\t\t   size_t size, enum dma_data_direction dir)\n{\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = phys_to_virt(tlb_addr);\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "phys_to_virt(orig_addr)",
            "vaddr",
            "size"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "orig_addr"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "orig_addr"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "buffer"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_SIZE - offset",
            "size"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "tlb_addr"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "orig_addr"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,\n\t\t\t   size_t size, enum dma_data_direction dir)\n{\n\tunsigned long pfn = PFN_DOWN(orig_addr);\n\tunsigned char *vaddr = phys_to_virt(tlb_addr);\n\n\tif (PageHighMem(pfn_to_page(pfn))) {\n\t\t/* The buffer does not have a mapping.  Map it in and copy */\n\t\tunsigned int offset = orig_addr & ~PAGE_MASK;\n\t\tchar *buffer;\n\t\tunsigned int sz = 0;\n\t\tunsigned long flags;\n\n\t\twhile (size) {\n\t\t\tsz = min_t(size_t, PAGE_SIZE - offset, size);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuffer = kmap_atomic(pfn_to_page(pfn));\n\t\t\tif (dir == DMA_TO_DEVICE)\n\t\t\t\tmemcpy(vaddr, buffer + offset, sz);\n\t\t\telse\n\t\t\t\tmemcpy(buffer + offset, vaddr, sz);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\tsize -= sz;\n\t\t\tpfn++;\n\t\t\tvaddr += sz;\n\t\t\toffset = 0;\n\t\t}\n\t} else if (dir == DMA_TO_DEVICE) {\n\t\tmemcpy(vaddr, phys_to_virt(orig_addr), size);\n\t} else {\n\t\tmemcpy(phys_to_virt(orig_addr), vaddr, size);\n\t}\n}"
  },
  {
    "function_name": "is_swiotlb_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "386-389",
    "snippet": "static int is_swiotlb_buffer(phys_addr_t paddr)\n{\n\treturn paddr >= io_tlb_start && paddr < io_tlb_end;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static phys_addr_t io_tlb_start, io_tlb_end;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\n\nstatic int is_swiotlb_buffer(phys_addr_t paddr)\n{\n\treturn paddr >= io_tlb_start && paddr < io_tlb_end;\n}"
  },
  {
    "function_name": "swiotlb_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "362-384",
    "snippet": "void __init swiotlb_exit(void)\n{\n\tif (!io_tlb_orig_addr)\n\t\treturn;\n\n\tif (late_alloc) {\n\t\tfree_pages((unsigned long)io_tlb_orig_addr,\n\t\t\t   get_order(io_tlb_nslabs * sizeof(phys_addr_t)));\n\t\tfree_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *\n\t\t\t\t\t\t\t\t sizeof(int)));\n\t\tfree_pages((unsigned long)phys_to_virt(io_tlb_start),\n\t\t\t   get_order(io_tlb_nslabs << IO_TLB_SHIFT));\n\t} else {\n\t\tmemblock_free_late(__pa(io_tlb_orig_addr),\n\t\t\t\t   PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)));\n\t\tmemblock_free_late(__pa(io_tlb_list),\n\t\t\t\t   PAGE_ALIGN(io_tlb_nslabs * sizeof(int)));\n\t\tmemblock_free_late(io_tlb_start,\n\t\t\t\t   PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));\n\t}\n\tio_tlb_nslabs = 0;\n\tmax_segment = 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long io_tlb_nslabs;",
      "static unsigned int *io_tlb_list;",
      "unsigned int max_segment;",
      "static phys_addr_t *io_tlb_orig_addr;",
      "static int late_alloc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_free_late",
          "args": [
            "io_tlb_start",
            "PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "io_tlb_nslabs << IO_TLB_SHIFT"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_free_late",
          "args": [
            "__pa(io_tlb_list)",
            "PAGE_ALIGN(io_tlb_nslabs * sizeof(int))"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "io_tlb_nslabs * sizeof(int)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "io_tlb_list"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "864-875",
          "snippet": "static void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->node);\n#endif\n\n\tpadata_stop(pinst);\n\tpadata_free_pd(pinst->pd);\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tkfree(pinst);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->node);\n#endif\n\n\tpadata_stop(pinst);\n\tpadata_free_pd(pinst->pd);\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tkfree(pinst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_free_late",
          "args": [
            "__pa(io_tlb_orig_addr)",
            "PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t))"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "io_tlb_nslabs * sizeof(phys_addr_t)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)phys_to_virt(io_tlb_start)",
            "get_order(io_tlb_nslabs << IO_TLB_SHIFT)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "io_tlb_nslabs << IO_TLB_SHIFT"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "io_tlb_start"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)io_tlb_list",
            "get_order(io_tlb_nslabs *\n\t\t\t\t\t\t\t\t sizeof(int))"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "io_tlb_nslabs *\n\t\t\t\t\t\t\t\t sizeof(int)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)io_tlb_orig_addr",
            "get_order(io_tlb_nslabs * sizeof(phys_addr_t))"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "io_tlb_nslabs * sizeof(phys_addr_t)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned long io_tlb_nslabs;\nstatic unsigned int *io_tlb_list;\nunsigned int max_segment;\nstatic phys_addr_t *io_tlb_orig_addr;\nstatic int late_alloc;\n\nvoid __init swiotlb_exit(void)\n{\n\tif (!io_tlb_orig_addr)\n\t\treturn;\n\n\tif (late_alloc) {\n\t\tfree_pages((unsigned long)io_tlb_orig_addr,\n\t\t\t   get_order(io_tlb_nslabs * sizeof(phys_addr_t)));\n\t\tfree_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *\n\t\t\t\t\t\t\t\t sizeof(int)));\n\t\tfree_pages((unsigned long)phys_to_virt(io_tlb_start),\n\t\t\t   get_order(io_tlb_nslabs << IO_TLB_SHIFT));\n\t} else {\n\t\tmemblock_free_late(__pa(io_tlb_orig_addr),\n\t\t\t\t   PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)));\n\t\tmemblock_free_late(__pa(io_tlb_list),\n\t\t\t\t   PAGE_ALIGN(io_tlb_nslabs * sizeof(int)));\n\t\tmemblock_free_late(io_tlb_start,\n\t\t\t\t   PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));\n\t}\n\tio_tlb_nslabs = 0;\n\tmax_segment = 0;\n}"
  },
  {
    "function_name": "swiotlb_late_init_with_tbl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "305-360",
    "snippet": "int\nswiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)\n{\n\tunsigned long i, bytes;\n\n\tbytes = nslabs << IO_TLB_SHIFT;\n\n\tio_tlb_nslabs = nslabs;\n\tio_tlb_start = virt_to_phys(tlb);\n\tio_tlb_end = io_tlb_start + bytes;\n\n\tset_memory_decrypted((unsigned long)tlb, bytes >> PAGE_SHIFT);\n\tmemset(tlb, 0, bytes);\n\n\t/*\n\t * Allocate and initialize the free list array.  This array is used\n\t * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE\n\t * between io_tlb_start and io_tlb_end.\n\t */\n\tio_tlb_list = (unsigned int *)__get_free_pages(GFP_KERNEL,\n\t                              get_order(io_tlb_nslabs * sizeof(int)));\n\tif (!io_tlb_list)\n\t\tgoto cleanup3;\n\n\tio_tlb_orig_addr = (phys_addr_t *)\n\t\t__get_free_pages(GFP_KERNEL,\n\t\t\t\t get_order(io_tlb_nslabs *\n\t\t\t\t\t   sizeof(phys_addr_t)));\n\tif (!io_tlb_orig_addr)\n\t\tgoto cleanup4;\n\n\tfor (i = 0; i < io_tlb_nslabs; i++) {\n\t\tio_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);\n\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t}\n\tio_tlb_index = 0;\n\n\tswiotlb_print_info();\n\n\tlate_alloc = 1;\n\n\tswiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);\n\n\treturn 0;\n\ncleanup4:\n\tfree_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *\n\t                                                 sizeof(int)));\n\tio_tlb_list = NULL;\ncleanup3:\n\tio_tlb_end = 0;\n\tio_tlb_start = 0;\n\tio_tlb_nslabs = 0;\n\tmax_segment = 0;\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
    ],
    "globals_used": [
      "static phys_addr_t io_tlb_start, io_tlb_end;",
      "static unsigned long io_tlb_nslabs;",
      "static unsigned int *io_tlb_list;",
      "static unsigned int io_tlb_index;",
      "unsigned int max_segment;",
      "static phys_addr_t *io_tlb_orig_addr;",
      "static int late_alloc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)io_tlb_list",
            "get_order(io_tlb_nslabs *\n\t                                                 sizeof(int))"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "io_tlb_nslabs *\n\t                                                 sizeof(int)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_set_max_segment",
          "args": [
            "io_tlb_nslabs << IO_TLB_SHIFT"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_set_max_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "136-142",
          "snippet": "void swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;",
            "unsigned int max_segment;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nunsigned int max_segment;\n\nvoid swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_print_info",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_print_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "157-170",
          "snippet": "void swiotlb_print_info(void)\n{\n\tunsigned long bytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\tif (no_iotlb_memory) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %#010llx-%#010llx] (%luMB)\\n\",\n\t       (unsigned long long)io_tlb_start,\n\t       (unsigned long long)io_tlb_end,\n\t       bytes >> 20);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static phys_addr_t io_tlb_start, io_tlb_end;",
            "static unsigned long io_tlb_nslabs;",
            "static bool no_iotlb_memory;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\nstatic unsigned long io_tlb_nslabs;\nstatic bool no_iotlb_memory;\n\nvoid swiotlb_print_info(void)\n{\n\tunsigned long bytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\tif (no_iotlb_memory) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %#010llx-%#010llx] (%luMB)\\n\",\n\t       (unsigned long long)io_tlb_start,\n\t       (unsigned long long)io_tlb_end,\n\t       bytes >> 20);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OFFSET",
          "args": [
            "i",
            "IO_TLB_SEGSIZE"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_KERNEL",
            "get_order(io_tlb_nslabs *\n\t\t\t\t\t   sizeof(phys_addr_t))"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "io_tlb_nslabs *\n\t\t\t\t\t   sizeof(phys_addr_t)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_KERNEL",
            "get_order(io_tlb_nslabs * sizeof(int))"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "io_tlb_nslabs * sizeof(int)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tlb",
            "0",
            "bytes"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_decrypted",
          "args": [
            "(unsigned long)tlb",
            "bytes >> PAGE_SHIFT"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_phys",
          "args": [
            "tlb"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "perf_virt_to_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "6317-6347",
          "snippet": "static u64 perf_virt_to_phys(u64 virt)\n{\n\tu64 phys_addr = 0;\n\tstruct page *p = NULL;\n\n\tif (!virt)\n\t\treturn 0;\n\n\tif (virt >= TASK_SIZE) {\n\t\t/* If it's vmalloc()d memory, leave phys_addr as 0 */\n\t\tif (virt_addr_valid((void *)(uintptr_t)virt) &&\n\t\t    !(virt >= VMALLOC_START && virt < VMALLOC_END))\n\t\t\tphys_addr = (u64)virt_to_phys((void *)(uintptr_t)virt);\n\t} else {\n\t\t/*\n\t\t * Walking the pages tables for user address.\n\t\t * Interrupts are disabled, so it prevents any tear down\n\t\t * of the page tables.\n\t\t * Try IRQ-safe __get_user_pages_fast first.\n\t\t * If failed, leave phys_addr as 0.\n\t\t */\n\t\tif ((current->mm != NULL) &&\n\t\t    (__get_user_pages_fast(virt, 1, 0, &p) == 1))\n\t\t\tphys_addr = page_to_phys(p) + virt % PAGE_SIZE;\n\n\t\tif (p)\n\t\t\tput_page(p);\n\t}\n\n\treturn phys_addr;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\n\nstatic u64 perf_virt_to_phys(u64 virt)\n{\n\tu64 phys_addr = 0;\n\tstruct page *p = NULL;\n\n\tif (!virt)\n\t\treturn 0;\n\n\tif (virt >= TASK_SIZE) {\n\t\t/* If it's vmalloc()d memory, leave phys_addr as 0 */\n\t\tif (virt_addr_valid((void *)(uintptr_t)virt) &&\n\t\t    !(virt >= VMALLOC_START && virt < VMALLOC_END))\n\t\t\tphys_addr = (u64)virt_to_phys((void *)(uintptr_t)virt);\n\t} else {\n\t\t/*\n\t\t * Walking the pages tables for user address.\n\t\t * Interrupts are disabled, so it prevents any tear down\n\t\t * of the page tables.\n\t\t * Try IRQ-safe __get_user_pages_fast first.\n\t\t * If failed, leave phys_addr as 0.\n\t\t */\n\t\tif ((current->mm != NULL) &&\n\t\t    (__get_user_pages_fast(virt, 1, 0, &p) == 1))\n\t\t\tphys_addr = page_to_phys(p) + virt % PAGE_SIZE;\n\n\t\tif (p)\n\t\t\tput_page(p);\n\t}\n\n\treturn phys_addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\nstatic unsigned long io_tlb_nslabs;\nstatic unsigned int *io_tlb_list;\nstatic unsigned int io_tlb_index;\nunsigned int max_segment;\nstatic phys_addr_t *io_tlb_orig_addr;\nstatic int late_alloc;\n\nint\nswiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)\n{\n\tunsigned long i, bytes;\n\n\tbytes = nslabs << IO_TLB_SHIFT;\n\n\tio_tlb_nslabs = nslabs;\n\tio_tlb_start = virt_to_phys(tlb);\n\tio_tlb_end = io_tlb_start + bytes;\n\n\tset_memory_decrypted((unsigned long)tlb, bytes >> PAGE_SHIFT);\n\tmemset(tlb, 0, bytes);\n\n\t/*\n\t * Allocate and initialize the free list array.  This array is used\n\t * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE\n\t * between io_tlb_start and io_tlb_end.\n\t */\n\tio_tlb_list = (unsigned int *)__get_free_pages(GFP_KERNEL,\n\t                              get_order(io_tlb_nslabs * sizeof(int)));\n\tif (!io_tlb_list)\n\t\tgoto cleanup3;\n\n\tio_tlb_orig_addr = (phys_addr_t *)\n\t\t__get_free_pages(GFP_KERNEL,\n\t\t\t\t get_order(io_tlb_nslabs *\n\t\t\t\t\t   sizeof(phys_addr_t)));\n\tif (!io_tlb_orig_addr)\n\t\tgoto cleanup4;\n\n\tfor (i = 0; i < io_tlb_nslabs; i++) {\n\t\tio_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);\n\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t}\n\tio_tlb_index = 0;\n\n\tswiotlb_print_info();\n\n\tlate_alloc = 1;\n\n\tswiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);\n\n\treturn 0;\n\ncleanup4:\n\tfree_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *\n\t                                                 sizeof(int)));\n\tio_tlb_list = NULL;\ncleanup3:\n\tio_tlb_end = 0;\n\tio_tlb_start = 0;\n\tio_tlb_nslabs = 0;\n\tmax_segment = 0;\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "swiotlb_late_init_with_default_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "261-303",
    "snippet": "int\nswiotlb_late_init_with_default_size(size_t default_size)\n{\n\tunsigned long bytes, req_nslabs = io_tlb_nslabs;\n\tunsigned char *vstart = NULL;\n\tunsigned int order;\n\tint rc = 0;\n\n\tif (!io_tlb_nslabs) {\n\t\tio_tlb_nslabs = (default_size >> IO_TLB_SHIFT);\n\t\tio_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);\n\t}\n\n\t/*\n\t * Get IO TLB memory from the low pages\n\t */\n\torder = get_order(io_tlb_nslabs << IO_TLB_SHIFT);\n\tio_tlb_nslabs = SLABS_PER_PAGE << order;\n\tbytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\twhile ((SLABS_PER_PAGE << order) > IO_TLB_MIN_SLABS) {\n\t\tvstart = (void *)__get_free_pages(GFP_DMA | __GFP_NOWARN,\n\t\t\t\t\t\t  order);\n\t\tif (vstart)\n\t\t\tbreak;\n\t\torder--;\n\t}\n\n\tif (!vstart) {\n\t\tio_tlb_nslabs = req_nslabs;\n\t\treturn -ENOMEM;\n\t}\n\tif (order != get_order(bytes)) {\n\t\tpr_warn(\"only able to allocate %ld MB\\n\",\n\t\t\t(PAGE_SIZE << order) >> 20);\n\t\tio_tlb_nslabs = SLABS_PER_PAGE << order;\n\t}\n\trc = swiotlb_late_init_with_tbl(vstart, io_tlb_nslabs);\n\tif (rc)\n\t\tfree_pages((unsigned long)vstart, order);\n\n\treturn rc;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define IO_TLB_MIN_SLABS ((1<<20) >> IO_TLB_SHIFT)",
      "#define SLABS_PER_PAGE (1 << (PAGE_SHIFT - IO_TLB_SHIFT))"
    ],
    "globals_used": [
      "static unsigned long io_tlb_nslabs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)vstart",
            "order"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_late_init_with_tbl",
          "args": [
            "vstart",
            "io_tlb_nslabs"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_late_init_with_tbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "305-360",
          "snippet": "int\nswiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)\n{\n\tunsigned long i, bytes;\n\n\tbytes = nslabs << IO_TLB_SHIFT;\n\n\tio_tlb_nslabs = nslabs;\n\tio_tlb_start = virt_to_phys(tlb);\n\tio_tlb_end = io_tlb_start + bytes;\n\n\tset_memory_decrypted((unsigned long)tlb, bytes >> PAGE_SHIFT);\n\tmemset(tlb, 0, bytes);\n\n\t/*\n\t * Allocate and initialize the free list array.  This array is used\n\t * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE\n\t * between io_tlb_start and io_tlb_end.\n\t */\n\tio_tlb_list = (unsigned int *)__get_free_pages(GFP_KERNEL,\n\t                              get_order(io_tlb_nslabs * sizeof(int)));\n\tif (!io_tlb_list)\n\t\tgoto cleanup3;\n\n\tio_tlb_orig_addr = (phys_addr_t *)\n\t\t__get_free_pages(GFP_KERNEL,\n\t\t\t\t get_order(io_tlb_nslabs *\n\t\t\t\t\t   sizeof(phys_addr_t)));\n\tif (!io_tlb_orig_addr)\n\t\tgoto cleanup4;\n\n\tfor (i = 0; i < io_tlb_nslabs; i++) {\n\t\tio_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);\n\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t}\n\tio_tlb_index = 0;\n\n\tswiotlb_print_info();\n\n\tlate_alloc = 1;\n\n\tswiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);\n\n\treturn 0;\n\ncleanup4:\n\tfree_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *\n\t                                                 sizeof(int)));\n\tio_tlb_list = NULL;\ncleanup3:\n\tio_tlb_end = 0;\n\tio_tlb_start = 0;\n\tio_tlb_nslabs = 0;\n\tmax_segment = 0;\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [
            "static phys_addr_t io_tlb_start, io_tlb_end;",
            "static unsigned long io_tlb_nslabs;",
            "static unsigned int *io_tlb_list;",
            "static unsigned int io_tlb_index;",
            "unsigned int max_segment;",
            "static phys_addr_t *io_tlb_orig_addr;",
            "static int late_alloc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\nstatic unsigned long io_tlb_nslabs;\nstatic unsigned int *io_tlb_list;\nstatic unsigned int io_tlb_index;\nunsigned int max_segment;\nstatic phys_addr_t *io_tlb_orig_addr;\nstatic int late_alloc;\n\nint\nswiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)\n{\n\tunsigned long i, bytes;\n\n\tbytes = nslabs << IO_TLB_SHIFT;\n\n\tio_tlb_nslabs = nslabs;\n\tio_tlb_start = virt_to_phys(tlb);\n\tio_tlb_end = io_tlb_start + bytes;\n\n\tset_memory_decrypted((unsigned long)tlb, bytes >> PAGE_SHIFT);\n\tmemset(tlb, 0, bytes);\n\n\t/*\n\t * Allocate and initialize the free list array.  This array is used\n\t * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE\n\t * between io_tlb_start and io_tlb_end.\n\t */\n\tio_tlb_list = (unsigned int *)__get_free_pages(GFP_KERNEL,\n\t                              get_order(io_tlb_nslabs * sizeof(int)));\n\tif (!io_tlb_list)\n\t\tgoto cleanup3;\n\n\tio_tlb_orig_addr = (phys_addr_t *)\n\t\t__get_free_pages(GFP_KERNEL,\n\t\t\t\t get_order(io_tlb_nslabs *\n\t\t\t\t\t   sizeof(phys_addr_t)));\n\tif (!io_tlb_orig_addr)\n\t\tgoto cleanup4;\n\n\tfor (i = 0; i < io_tlb_nslabs; i++) {\n\t\tio_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);\n\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t}\n\tio_tlb_index = 0;\n\n\tswiotlb_print_info();\n\n\tlate_alloc = 1;\n\n\tswiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);\n\n\treturn 0;\n\ncleanup4:\n\tfree_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *\n\t                                                 sizeof(int)));\n\tio_tlb_list = NULL;\ncleanup3:\n\tio_tlb_end = 0;\n\tio_tlb_start = 0;\n\tio_tlb_nslabs = 0;\n\tmax_segment = 0;\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"only able to allocate %ld MB\\n\"",
            "(PAGE_SIZE << order) >> 20"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "bytes"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_DMA | __GFP_NOWARN",
            "order"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "io_tlb_nslabs << IO_TLB_SHIFT"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "io_tlb_nslabs",
            "IO_TLB_SEGSIZE"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define IO_TLB_MIN_SLABS ((1<<20) >> IO_TLB_SHIFT)\n#define SLABS_PER_PAGE (1 << (PAGE_SHIFT - IO_TLB_SHIFT))\n\nstatic unsigned long io_tlb_nslabs;\n\nint\nswiotlb_late_init_with_default_size(size_t default_size)\n{\n\tunsigned long bytes, req_nslabs = io_tlb_nslabs;\n\tunsigned char *vstart = NULL;\n\tunsigned int order;\n\tint rc = 0;\n\n\tif (!io_tlb_nslabs) {\n\t\tio_tlb_nslabs = (default_size >> IO_TLB_SHIFT);\n\t\tio_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);\n\t}\n\n\t/*\n\t * Get IO TLB memory from the low pages\n\t */\n\torder = get_order(io_tlb_nslabs << IO_TLB_SHIFT);\n\tio_tlb_nslabs = SLABS_PER_PAGE << order;\n\tbytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\twhile ((SLABS_PER_PAGE << order) > IO_TLB_MIN_SLABS) {\n\t\tvstart = (void *)__get_free_pages(GFP_DMA | __GFP_NOWARN,\n\t\t\t\t\t\t  order);\n\t\tif (vstart)\n\t\t\tbreak;\n\t\torder--;\n\t}\n\n\tif (!vstart) {\n\t\tio_tlb_nslabs = req_nslabs;\n\t\treturn -ENOMEM;\n\t}\n\tif (order != get_order(bytes)) {\n\t\tpr_warn(\"only able to allocate %ld MB\\n\",\n\t\t\t(PAGE_SIZE << order) >> 20);\n\t\tio_tlb_nslabs = SLABS_PER_PAGE << order;\n\t}\n\trc = swiotlb_late_init_with_tbl(vstart, io_tlb_nslabs);\n\tif (rc)\n\t\tfree_pages((unsigned long)vstart, order);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "swiotlb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "230-254",
    "snippet": "void  __init\nswiotlb_init(int verbose)\n{\n\tsize_t default_size = IO_TLB_DEFAULT_SIZE;\n\tunsigned char *vstart;\n\tunsigned long bytes;\n\n\tif (!io_tlb_nslabs) {\n\t\tio_tlb_nslabs = (default_size >> IO_TLB_SHIFT);\n\t\tio_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);\n\t}\n\n\tbytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\t/* Get IO TLB memory from the low pages */\n\tvstart = memblock_alloc_low_nopanic(PAGE_ALIGN(bytes), PAGE_SIZE);\n\tif (vstart && !swiotlb_init_with_tbl(vstart, io_tlb_nslabs, verbose))\n\t\treturn;\n\n\tif (io_tlb_start)\n\t\tmemblock_free_early(io_tlb_start,\n\t\t\t\t    PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));\n\tpr_warn(\"Cannot allocate buffer\");\n\tno_iotlb_memory = true;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define IO_TLB_DEFAULT_SIZE (64UL<<20)"
    ],
    "globals_used": [
      "static unsigned long io_tlb_nslabs;",
      "static bool no_iotlb_memory;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Cannot allocate buffer\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_free_early",
          "args": [
            "io_tlb_start",
            "PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "io_tlb_nslabs << IO_TLB_SHIFT"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_init_with_tbl",
          "args": [
            "vstart",
            "io_tlb_nslabs",
            "verbose"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_init_with_tbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "192-224",
          "snippet": "int __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)\n{\n\tunsigned long i, bytes;\n\n\tbytes = nslabs << IO_TLB_SHIFT;\n\n\tio_tlb_nslabs = nslabs;\n\tio_tlb_start = __pa(tlb);\n\tio_tlb_end = io_tlb_start + bytes;\n\n\t/*\n\t * Allocate and initialize the free list array.  This array is used\n\t * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE\n\t * between io_tlb_start and io_tlb_end.\n\t */\n\tio_tlb_list = memblock_alloc(\n\t\t\t\tPAGE_ALIGN(io_tlb_nslabs * sizeof(int)),\n\t\t\t\tPAGE_SIZE);\n\tio_tlb_orig_addr = memblock_alloc(\n\t\t\t\tPAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)),\n\t\t\t\tPAGE_SIZE);\n\tfor (i = 0; i < io_tlb_nslabs; i++) {\n\t\tio_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);\n\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t}\n\tio_tlb_index = 0;\n\n\tif (verbose)\n\t\tswiotlb_print_info();\n\n\tswiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [
            "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
          ],
          "globals_used": [
            "static phys_addr_t io_tlb_start, io_tlb_end;",
            "static unsigned long io_tlb_nslabs;",
            "static unsigned int *io_tlb_list;",
            "static unsigned int io_tlb_index;",
            "static phys_addr_t *io_tlb_orig_addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\nstatic unsigned long io_tlb_nslabs;\nstatic unsigned int *io_tlb_list;\nstatic unsigned int io_tlb_index;\nstatic phys_addr_t *io_tlb_orig_addr;\n\nint __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)\n{\n\tunsigned long i, bytes;\n\n\tbytes = nslabs << IO_TLB_SHIFT;\n\n\tio_tlb_nslabs = nslabs;\n\tio_tlb_start = __pa(tlb);\n\tio_tlb_end = io_tlb_start + bytes;\n\n\t/*\n\t * Allocate and initialize the free list array.  This array is used\n\t * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE\n\t * between io_tlb_start and io_tlb_end.\n\t */\n\tio_tlb_list = memblock_alloc(\n\t\t\t\tPAGE_ALIGN(io_tlb_nslabs * sizeof(int)),\n\t\t\t\tPAGE_SIZE);\n\tio_tlb_orig_addr = memblock_alloc(\n\t\t\t\tPAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)),\n\t\t\t\tPAGE_SIZE);\n\tfor (i = 0; i < io_tlb_nslabs; i++) {\n\t\tio_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);\n\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t}\n\tio_tlb_index = 0;\n\n\tif (verbose)\n\t\tswiotlb_print_info();\n\n\tswiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc_low_nopanic",
          "args": [
            "PAGE_ALIGN(bytes)",
            "PAGE_SIZE"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "bytes"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "io_tlb_nslabs",
            "IO_TLB_SEGSIZE"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define IO_TLB_DEFAULT_SIZE (64UL<<20)\n\nstatic unsigned long io_tlb_nslabs;\nstatic bool no_iotlb_memory;\n\nvoid  __init\nswiotlb_init(int verbose)\n{\n\tsize_t default_size = IO_TLB_DEFAULT_SIZE;\n\tunsigned char *vstart;\n\tunsigned long bytes;\n\n\tif (!io_tlb_nslabs) {\n\t\tio_tlb_nslabs = (default_size >> IO_TLB_SHIFT);\n\t\tio_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);\n\t}\n\n\tbytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\t/* Get IO TLB memory from the low pages */\n\tvstart = memblock_alloc_low_nopanic(PAGE_ALIGN(bytes), PAGE_SIZE);\n\tif (vstart && !swiotlb_init_with_tbl(vstart, io_tlb_nslabs, verbose))\n\t\treturn;\n\n\tif (io_tlb_start)\n\t\tmemblock_free_early(io_tlb_start,\n\t\t\t\t    PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));\n\tpr_warn(\"Cannot allocate buffer\");\n\tno_iotlb_memory = true;\n}"
  },
  {
    "function_name": "swiotlb_init_with_tbl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "192-224",
    "snippet": "int __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)\n{\n\tunsigned long i, bytes;\n\n\tbytes = nslabs << IO_TLB_SHIFT;\n\n\tio_tlb_nslabs = nslabs;\n\tio_tlb_start = __pa(tlb);\n\tio_tlb_end = io_tlb_start + bytes;\n\n\t/*\n\t * Allocate and initialize the free list array.  This array is used\n\t * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE\n\t * between io_tlb_start and io_tlb_end.\n\t */\n\tio_tlb_list = memblock_alloc(\n\t\t\t\tPAGE_ALIGN(io_tlb_nslabs * sizeof(int)),\n\t\t\t\tPAGE_SIZE);\n\tio_tlb_orig_addr = memblock_alloc(\n\t\t\t\tPAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)),\n\t\t\t\tPAGE_SIZE);\n\tfor (i = 0; i < io_tlb_nslabs; i++) {\n\t\tio_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);\n\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t}\n\tio_tlb_index = 0;\n\n\tif (verbose)\n\t\tswiotlb_print_info();\n\n\tswiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define INVALID_PHYS_ADDR (~(phys_addr_t)0)"
    ],
    "globals_used": [
      "static phys_addr_t io_tlb_start, io_tlb_end;",
      "static unsigned long io_tlb_nslabs;",
      "static unsigned int *io_tlb_list;",
      "static unsigned int io_tlb_index;",
      "static phys_addr_t *io_tlb_orig_addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_set_max_segment",
          "args": [
            "io_tlb_nslabs << IO_TLB_SHIFT"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_set_max_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "136-142",
          "snippet": "void swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;",
            "unsigned int max_segment;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nunsigned int max_segment;\n\nvoid swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_print_info",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_print_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
          "lines": "157-170",
          "snippet": "void swiotlb_print_info(void)\n{\n\tunsigned long bytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\tif (no_iotlb_memory) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %#010llx-%#010llx] (%luMB)\\n\",\n\t       (unsigned long long)io_tlb_start,\n\t       (unsigned long long)io_tlb_end,\n\t       bytes >> 20);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static phys_addr_t io_tlb_start, io_tlb_end;",
            "static unsigned long io_tlb_nslabs;",
            "static bool no_iotlb_memory;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\nstatic unsigned long io_tlb_nslabs;\nstatic bool no_iotlb_memory;\n\nvoid swiotlb_print_info(void)\n{\n\tunsigned long bytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\tif (no_iotlb_memory) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %#010llx-%#010llx] (%luMB)\\n\",\n\t       (unsigned long long)io_tlb_start,\n\t       (unsigned long long)io_tlb_end,\n\t       bytes >> 20);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OFFSET",
          "args": [
            "i",
            "IO_TLB_SEGSIZE"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t))",
            "PAGE_SIZE"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "io_tlb_nslabs * sizeof(phys_addr_t)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "PAGE_ALIGN(io_tlb_nslabs * sizeof(int))",
            "PAGE_SIZE"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "io_tlb_nslabs * sizeof(int)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "tlb"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "864-875",
          "snippet": "static void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->node);\n#endif\n\n\tpadata_stop(pinst);\n\tpadata_free_pd(pinst->pd);\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tkfree(pinst);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->node);\n#endif\n\n\tpadata_stop(pinst);\n\tpadata_free_pd(pinst->pd);\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tkfree(pinst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define INVALID_PHYS_ADDR (~(phys_addr_t)0)\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\nstatic unsigned long io_tlb_nslabs;\nstatic unsigned int *io_tlb_list;\nstatic unsigned int io_tlb_index;\nstatic phys_addr_t *io_tlb_orig_addr;\n\nint __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)\n{\n\tunsigned long i, bytes;\n\n\tbytes = nslabs << IO_TLB_SHIFT;\n\n\tio_tlb_nslabs = nslabs;\n\tio_tlb_start = __pa(tlb);\n\tio_tlb_end = io_tlb_start + bytes;\n\n\t/*\n\t * Allocate and initialize the free list array.  This array is used\n\t * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE\n\t * between io_tlb_start and io_tlb_end.\n\t */\n\tio_tlb_list = memblock_alloc(\n\t\t\t\tPAGE_ALIGN(io_tlb_nslabs * sizeof(int)),\n\t\t\t\tPAGE_SIZE);\n\tio_tlb_orig_addr = memblock_alloc(\n\t\t\t\tPAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)),\n\t\t\t\tPAGE_SIZE);\n\tfor (i = 0; i < io_tlb_nslabs; i++) {\n\t\tio_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);\n\t\tio_tlb_orig_addr[i] = INVALID_PHYS_ADDR;\n\t}\n\tio_tlb_index = 0;\n\n\tif (verbose)\n\t\tswiotlb_print_info();\n\n\tswiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);\n\treturn 0;\n}"
  },
  {
    "function_name": "swiotlb_update_mem_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "178-190",
    "snippet": "void __init swiotlb_update_mem_attributes(void)\n{\n\tvoid *vaddr;\n\tunsigned long bytes;\n\n\tif (no_iotlb_memory || late_alloc)\n\t\treturn;\n\n\tvaddr = phys_to_virt(io_tlb_start);\n\tbytes = PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT);\n\tset_memory_decrypted((unsigned long)vaddr, bytes >> PAGE_SHIFT);\n\tmemset(vaddr, 0, bytes);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long io_tlb_nslabs;",
      "static int late_alloc;",
      "static bool no_iotlb_memory;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vaddr",
            "0",
            "bytes"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_decrypted",
          "args": [
            "(unsigned long)vaddr",
            "bytes >> PAGE_SHIFT"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "io_tlb_nslabs << IO_TLB_SHIFT"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "io_tlb_start"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned long io_tlb_nslabs;\nstatic int late_alloc;\nstatic bool no_iotlb_memory;\n\nvoid __init swiotlb_update_mem_attributes(void)\n{\n\tvoid *vaddr;\n\tunsigned long bytes;\n\n\tif (no_iotlb_memory || late_alloc)\n\t\treturn;\n\n\tvaddr = phys_to_virt(io_tlb_start);\n\tbytes = PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT);\n\tset_memory_decrypted((unsigned long)vaddr, bytes >> PAGE_SHIFT);\n\tmemset(vaddr, 0, bytes);\n}"
  },
  {
    "function_name": "swiotlb_print_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "157-170",
    "snippet": "void swiotlb_print_info(void)\n{\n\tunsigned long bytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\tif (no_iotlb_memory) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %#010llx-%#010llx] (%luMB)\\n\",\n\t       (unsigned long long)io_tlb_start,\n\t       (unsigned long long)io_tlb_end,\n\t       bytes >> 20);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static phys_addr_t io_tlb_start, io_tlb_end;",
      "static unsigned long io_tlb_nslabs;",
      "static bool no_iotlb_memory;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mapped [mem %#010llx-%#010llx] (%luMB)\\n\"",
            "(unsigned long long)io_tlb_start",
            "(unsigned long long)io_tlb_end",
            "bytes >> 20"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"No low mem\\n\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic phys_addr_t io_tlb_start, io_tlb_end;\nstatic unsigned long io_tlb_nslabs;\nstatic bool no_iotlb_memory;\n\nvoid swiotlb_print_info(void)\n{\n\tunsigned long bytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\tif (no_iotlb_memory) {\n\t\tpr_warn(\"No low mem\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"mapped [mem %#010llx-%#010llx] (%luMB)\\n\",\n\t       (unsigned long long)io_tlb_start,\n\t       (unsigned long long)io_tlb_end,\n\t       bytes >> 20);\n}"
  },
  {
    "function_name": "swiotlb_size_or_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "146-153",
    "snippet": "unsigned long swiotlb_size_or_default(void)\n{\n\tunsigned long size;\n\n\tsize = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\treturn size ? size : (IO_TLB_DEFAULT_SIZE);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [
      "#define IO_TLB_DEFAULT_SIZE (64UL<<20)"
    ],
    "globals_used": [
      "static unsigned long io_tlb_nslabs;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\n#define IO_TLB_DEFAULT_SIZE (64UL<<20)\n\nstatic unsigned long io_tlb_nslabs;\n\nunsigned long swiotlb_size_or_default(void)\n{\n\tunsigned long size;\n\n\tsize = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\treturn size ? size : (IO_TLB_DEFAULT_SIZE);\n}"
  },
  {
    "function_name": "swiotlb_set_max_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "136-142",
    "snippet": "void swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;",
      "unsigned int max_segment;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "val",
            "PAGE_SIZE"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nunsigned int max_segment;\n\nvoid swiotlb_set_max_segment(unsigned int val)\n{\n\tif (swiotlb_force == SWIOTLB_FORCE)\n\t\tmax_segment = 1;\n\telse\n\t\tmax_segment = rounddown(val, PAGE_SIZE);\n}"
  },
  {
    "function_name": "swiotlb_max_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "130-133",
    "snippet": "unsigned int swiotlb_max_segment(void)\n{\n\treturn max_segment;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int max_segment;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nunsigned int max_segment;\n\nunsigned int swiotlb_max_segment(void)\n{\n\treturn max_segment;\n}"
  },
  {
    "function_name": "swiotlb_nr_tbl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "124-127",
    "snippet": "unsigned long swiotlb_nr_tbl(void)\n{\n\treturn io_tlb_nslabs;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long io_tlb_nslabs;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstatic unsigned long io_tlb_nslabs;\n\nunsigned long swiotlb_nr_tbl(void)\n{\n\treturn io_tlb_nslabs;\n}"
  },
  {
    "function_name": "setup_io_tlb_npages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/swiotlb.c",
    "lines": "103-121",
    "snippet": "static int __init\nsetup_io_tlb_npages(char *str)\n{\n\tif (isdigit(*str)) {\n\t\tio_tlb_nslabs = simple_strtoul(str, &str, 0);\n\t\t/* avoid tail segment of size < IO_TLB_SEGSIZE */\n\t\tio_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);\n\t}\n\tif (*str == ',')\n\t\t++str;\n\tif (!strcmp(str, \"force\")) {\n\t\tswiotlb_force = SWIOTLB_FORCE;\n\t} else if (!strcmp(str, \"noforce\")) {\n\t\tswiotlb_force = SWIOTLB_NO_FORCE;\n\t\tio_tlb_nslabs = 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/swiotlb.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <asm/dma.h>",
      "#include <asm/io.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/mem_encrypt.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/gfp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/pfn.h>",
      "#include <linux/swiotlb.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/cache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum swiotlb_force swiotlb_force;",
      "static unsigned long io_tlb_nslabs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"noforce\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"force\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "io_tlb_nslabs",
            "IO_TLB_SEGSIZE"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "&str",
            "0"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*str"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/set_memory.h>\n#include <linux/mem_encrypt.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\nstatic unsigned long io_tlb_nslabs;\n\nstatic int __init\nsetup_io_tlb_npages(char *str)\n{\n\tif (isdigit(*str)) {\n\t\tio_tlb_nslabs = simple_strtoul(str, &str, 0);\n\t\t/* avoid tail segment of size < IO_TLB_SEGSIZE */\n\t\tio_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);\n\t}\n\tif (*str == ',')\n\t\t++str;\n\tif (!strcmp(str, \"force\")) {\n\t\tswiotlb_force = SWIOTLB_FORCE;\n\t} else if (!strcmp(str, \"noforce\")) {\n\t\tswiotlb_force = SWIOTLB_NO_FORCE;\n\t\tio_tlb_nslabs = 1;\n\t}\n\n\treturn 0;\n}"
  }
]