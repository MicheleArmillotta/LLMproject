[
  {
    "function_name": "init_function_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "810-814",
    "snippet": "__init int init_function_trace(void)\n{\n\tinit_func_cmd_traceon();\n\treturn register_tracer(&function_trace);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&function_trace"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1591-1672",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_func_cmd_traceon",
          "args": [],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "init_func_cmd_traceon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "804-807",
          "snippet": "static inline int init_func_cmd_traceon(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic inline int init_func_cmd_traceon(void)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n__init int init_function_trace(void)\n{\n\tinit_func_cmd_traceon();\n\treturn register_tracer(&function_trace);\n}"
  },
  {
    "function_name": "init_func_cmd_traceon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "804-807",
    "snippet": "static inline int init_func_cmd_traceon(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic inline int init_func_cmd_traceon(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "init_func_cmd_traceon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "766-802",
    "snippet": "static int __init init_func_cmd_traceon(void)\n{\n\tint ret;\n\n\tret = register_ftrace_command(&ftrace_traceoff_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_ftrace_command(&ftrace_traceon_cmd);\n\tif (ret)\n\t\tgoto out_free_traceoff;\n\n\tret = register_ftrace_command(&ftrace_stacktrace_cmd);\n\tif (ret)\n\t\tgoto out_free_traceon;\n\n\tret = register_ftrace_command(&ftrace_dump_cmd);\n\tif (ret)\n\t\tgoto out_free_stacktrace;\n\n\tret = register_ftrace_command(&ftrace_cpudump_cmd);\n\tif (ret)\n\t\tgoto out_free_dump;\n\n\treturn 0;\n\n out_free_dump:\n\tunregister_ftrace_command(&ftrace_dump_cmd);\n out_free_stacktrace:\n\tunregister_ftrace_command(&ftrace_stacktrace_cmd);\n out_free_traceon:\n\tunregister_ftrace_command(&ftrace_traceon_cmd);\n out_free_traceoff:\n\tunregister_ftrace_command(&ftrace_traceoff_cmd);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_command",
          "args": [
            "&ftrace_traceoff_cmd"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4560-4577",
          "snippet": "__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int __init init_func_cmd_traceon(void)\n{\n\tint ret;\n\n\tret = register_ftrace_command(&ftrace_traceoff_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_ftrace_command(&ftrace_traceon_cmd);\n\tif (ret)\n\t\tgoto out_free_traceoff;\n\n\tret = register_ftrace_command(&ftrace_stacktrace_cmd);\n\tif (ret)\n\t\tgoto out_free_traceon;\n\n\tret = register_ftrace_command(&ftrace_dump_cmd);\n\tif (ret)\n\t\tgoto out_free_stacktrace;\n\n\tret = register_ftrace_command(&ftrace_cpudump_cmd);\n\tif (ret)\n\t\tgoto out_free_dump;\n\n\treturn 0;\n\n out_free_dump:\n\tunregister_ftrace_command(&ftrace_dump_cmd);\n out_free_stacktrace:\n\tunregister_ftrace_command(&ftrace_stacktrace_cmd);\n out_free_traceon:\n\tunregister_ftrace_command(&ftrace_traceon_cmd);\n out_free_traceoff:\n\tunregister_ftrace_command(&ftrace_traceoff_cmd);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_cpudump_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "725-739",
    "snippet": "static int\nftrace_cpudump_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = &cpudump_probe_ops;\n\n\t/* Only dump once. */\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_trace_probe_callback",
          "args": [
            "tr",
            "ops",
            "hash",
            "glob",
            "cmd",
            "\"1\"",
            "enable"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trace_probe_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "636-673",
          "snippet": "static int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_cpudump_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = &cpudump_probe_ops;\n\n\t/* Only dump once. */\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}"
  },
  {
    "function_name": "ftrace_dump_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "709-723",
    "snippet": "static int\nftrace_dump_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = &dump_probe_ops;\n\n\t/* Only dump once. */\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_trace_probe_callback",
          "args": [
            "tr",
            "ops",
            "hash",
            "glob",
            "cmd",
            "\"1\"",
            "enable"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trace_probe_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "636-673",
          "snippet": "static int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_dump_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = &dump_probe_ops;\n\n\t/* Only dump once. */\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}"
  },
  {
    "function_name": "ftrace_stacktrace_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "694-707",
    "snippet": "static int\nftrace_stacktrace_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = param ? &stacktrace_count_probe_ops : &stacktrace_probe_ops;\n\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_trace_probe_callback",
          "args": [
            "tr",
            "ops",
            "hash",
            "glob",
            "cmd",
            "param",
            "enable"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trace_probe_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "636-673",
          "snippet": "static int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_stacktrace_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tops = param ? &stacktrace_count_probe_ops : &stacktrace_probe_ops;\n\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}"
  },
  {
    "function_name": "ftrace_trace_onoff_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "675-692",
    "snippet": "static int\nftrace_trace_onoff_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t    char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\t/* we register both traceon and traceoff to this callback */\n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_probe_ops : &traceon_probe_ops;\n\telse\n\t\tops = param ? &traceoff_count_probe_ops : &traceoff_probe_ops;\n\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_trace_probe_callback",
          "args": [
            "tr",
            "ops",
            "hash",
            "glob",
            "cmd",
            "param",
            "enable"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trace_probe_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "636-673",
          "snippet": "static int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"traceon\""
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_onoff_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t    char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\t/* we register both traceon and traceoff to this callback */\n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_probe_ops : &traceon_probe_ops;\n\telse\n\t\tops = param ? &traceoff_count_probe_ops : &traceoff_probe_ops;\n\n\treturn ftrace_trace_probe_callback(tr, ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}"
  },
  {
    "function_name": "ftrace_trace_probe_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "636-673",
    "snippet": "static int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function_probe",
          "args": [
            "glob",
            "tr",
            "ops",
            "count"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_function_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4259-4391",
          "snippet": "int\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "number",
            "0",
            "(unsigned long *)&count"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "number"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\":\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function_probe_func",
          "args": [
            "glob+1",
            "tr",
            "ops"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function_probe_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4393-4520",
          "snippet": "int\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_sched();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_sched();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_trace_probe_callback(struct trace_array *tr,\n\t\t\t    struct ftrace_probe_ops *ops,\n\t\t\t    struct ftrace_hash *hash, char *glob,\n\t\t\t    char *cmd, char *param, int enable)\n{\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "ftrace_count_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "574-586",
    "snippet": "static void\nftrace_count_free(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\n\tif (!ip) {\n\t\tfree_ftrace_func_mapper(mapper, NULL);\n\t\treturn;\n\t}\n\n\tftrace_func_mapper_remove_ip(mapper, ip);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_func_mapper_remove_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_remove_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4176-4194",
          "snippet": "void *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_func_mapper",
          "args": [
            "mapper",
            "NULL"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_func_mapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4204-4223",
          "snippet": "void free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size = 1 << mapper->hash.size_bits;\n\tint i;\n\n\tif (free_func && mapper->hash.count) {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size = 1 << mapper->hash.size_bits;\n\tint i;\n\n\tif (free_func && mapper->hash.count) {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_count_free(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\n\tif (!ip) {\n\t\tfree_ftrace_func_mapper(mapper, NULL);\n\t\treturn;\n\t}\n\n\tftrace_func_mapper_remove_ip(mapper, ip);\n}"
  },
  {
    "function_name": "ftrace_count_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "558-572",
    "snippet": "static int\nftrace_count_init(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *init_data, void **data)\n{\n\tstruct ftrace_func_mapper *mapper = *data;\n\n\tif (!mapper) {\n\t\tmapper = allocate_ftrace_func_mapper();\n\t\tif (!mapper)\n\t\t\treturn -ENOMEM;\n\t\t*data = mapper;\n\t}\n\n\treturn ftrace_func_mapper_add_ip(mapper, ip, init_data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_func_mapper_add_ip",
          "args": [
            "mapper",
            "ip",
            "init_data"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_add_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4144-4164",
          "snippet": "int ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_ftrace_func_mapper",
          "args": [],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_ftrace_func_mapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4098-4109",
          "snippet": "struct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstruct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int\nftrace_count_init(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *init_data, void **data)\n{\n\tstruct ftrace_func_mapper *mapper = *data;\n\n\tif (!mapper) {\n\t\tmapper = allocate_ftrace_func_mapper();\n\t\tif (!mapper)\n\t\t\treturn -ENOMEM;\n\t\t*data = mapper;\n\t}\n\n\treturn ftrace_func_mapper_add_ip(mapper, ip, init_data);\n}"
  },
  {
    "function_name": "ftrace_cpudump_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "550-555",
    "snippet": "static int\nftrace_cpudump_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"cpudump\", m, ip, ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_probe_print",
          "args": [
            "\"cpudump\"",
            "m",
            "ip",
            "ops",
            "data"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_probe_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "500-519",
          "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_cpudump_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"cpudump\", m, ip, ops, data);\n}"
  },
  {
    "function_name": "ftrace_dump_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "543-548",
    "snippet": "static int\nftrace_dump_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"dump\", m, ip, ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_probe_print",
          "args": [
            "\"dump\"",
            "m",
            "ip",
            "ops",
            "data"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_probe_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "500-519",
          "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_dump_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"dump\", m, ip, ops, data);\n}"
  },
  {
    "function_name": "ftrace_stacktrace_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "536-541",
    "snippet": "static int\nftrace_stacktrace_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"stacktrace\", m, ip, ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_probe_print",
          "args": [
            "\"stacktrace\"",
            "m",
            "ip",
            "ops",
            "data"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_probe_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "500-519",
          "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_stacktrace_print(struct seq_file *m, unsigned long ip,\n\t\t\tstruct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"stacktrace\", m, ip, ops, data);\n}"
  },
  {
    "function_name": "ftrace_traceoff_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "529-534",
    "snippet": "static int\nftrace_traceoff_print(struct seq_file *m, unsigned long ip,\n\t\t\t struct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"traceoff\", m, ip, ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_probe_print",
          "args": [
            "\"traceoff\"",
            "m",
            "ip",
            "ops",
            "data"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_probe_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "500-519",
          "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_traceoff_print(struct seq_file *m, unsigned long ip,\n\t\t\t struct ftrace_probe_ops *ops, void *data)\n{\n\treturn ftrace_probe_print(\"traceoff\", m, ip, ops, data);\n}"
  },
  {
    "function_name": "ftrace_traceon_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "521-527",
    "snippet": "static int\nftrace_traceon_print(struct seq_file *m, unsigned long ip,\n\t\t     struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\treturn ftrace_probe_print(\"traceon\", m, ip, ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_probe_print",
          "args": [
            "\"traceon\"",
            "m",
            "ip",
            "ops",
            "data"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_probe_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "500-519",
          "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_traceon_print(struct seq_file *m, unsigned long ip,\n\t\t     struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\treturn ftrace_probe_print(\"traceon\", m, ip, ops, data);\n}"
  },
  {
    "function_name": "ftrace_probe_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "500-519",
    "snippet": "static int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\":unlimited\\n\""
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\":count=%ld\\n\"",
            "*count"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4122-4134",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int\nftrace_probe_print(const char *name, struct seq_file *m,\n\t\t   unsigned long ip, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:%s\", (void *)ip, name);\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_cpudump_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "491-498",
    "snippet": "static void\nftrace_cpudump_probe(unsigned long ip, unsigned long parent_ip,\n\t\t     struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\tif (update_count(ops, ip, data))\n\t\tftrace_dump(DUMP_ORIG);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_dump",
          "args": [
            "DUMP_ORIG"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8273-8383",
          "snippet": "void ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\tprintk_nmi_direct_enter();\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read the\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\t/* reset all but tr, trace, and overruns */\n\t\tmemset(&iter.seq, 0,\n\t\t       sizeof(struct trace_iterator) -\n\t\t       offsetof(struct trace_iterator, seq));\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\t\titer.pos = -1;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tprintk_nmi_direct_exit();\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\tprintk_nmi_direct_enter();\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read the\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\t/* reset all but tr, trace, and overruns */\n\t\tmemset(&iter.seq, 0,\n\t\t       sizeof(struct trace_iterator) -\n\t\t       offsetof(struct trace_iterator, seq));\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\t\titer.pos = -1;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tprintk_nmi_direct_exit();\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_count",
          "args": [
            "ops",
            "ip",
            "data"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "update_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "463-479",
          "snippet": "static int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_cpudump_probe(unsigned long ip, unsigned long parent_ip,\n\t\t     struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\tif (update_count(ops, ip, data))\n\t\tftrace_dump(DUMP_ORIG);\n}"
  },
  {
    "function_name": "ftrace_dump_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "481-488",
    "snippet": "static void\nftrace_dump_probe(unsigned long ip, unsigned long parent_ip,\n\t\t  struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t  void *data)\n{\n\tif (update_count(ops, ip, data))\n\t\tftrace_dump(DUMP_ALL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8273-8383",
          "snippet": "void ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\tprintk_nmi_direct_enter();\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read the\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\t/* reset all but tr, trace, and overruns */\n\t\tmemset(&iter.seq, 0,\n\t\t       sizeof(struct trace_iterator) -\n\t\t       offsetof(struct trace_iterator, seq));\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\t\titer.pos = -1;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tprintk_nmi_direct_exit();\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\tprintk_nmi_direct_enter();\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read the\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\t/* reset all but tr, trace, and overruns */\n\t\tmemset(&iter.seq, 0,\n\t\t       sizeof(struct trace_iterator) -\n\t\t       offsetof(struct trace_iterator, seq));\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\t\titer.pos = -1;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tprintk_nmi_direct_exit();\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_count",
          "args": [
            "ops",
            "ip",
            "data"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "update_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "463-479",
          "snippet": "static int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_dump_probe(unsigned long ip, unsigned long parent_ip,\n\t\t  struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t  void *data)\n{\n\tif (update_count(ops, ip, data))\n\t\tftrace_dump(DUMP_ALL);\n}"
  },
  {
    "function_name": "update_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "463-479",
    "snippet": "static int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4122-4134",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic int update_count(struct ftrace_probe_ops *ops, unsigned long ip,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\t\tif (*count <= 0)\n\t\t\treturn 0;\n\t\t(*count)--;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_stacktrace_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "421-461",
    "snippet": "static void\nftrace_stacktrace_count(unsigned long ip, unsigned long parent_ip,\n\t\t\tstruct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\tlong new_count;\n\n\tif (!tracing_is_on())\n\t\treturn;\n\n\t/* unlimited? */\n\tif (!mapper) {\n\t\ttrace_stack(tr);\n\t\treturn;\n\t}\n\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\t/*\n\t * Stack traces should only execute the number of times the\n\t * user specified in the counter.\n\t */\n\tdo {\n\t\told_count = *count;\n\n\t\tif (!old_count)\n\t\t\treturn;\n\n\t\tnew_count = old_count - 1;\n\t\tnew_count = cmpxchg(count, old_count, new_count);\n\t\tif (new_count == old_count)\n\t\t\ttrace_stack(tr);\n\n\t\tif (!tracing_is_on())\n\t\t\treturn;\n\n\t} while (new_count != old_count);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1101-1104",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_stack",
          "args": [
            "tr"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "trace_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "402-411",
          "snippet": "static __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned long flags;\n\tint pc;\n\n\tlocal_save_flags(flags);\n\tpc = preempt_count();\n\n\t__trace_stack(tr, flags, FTRACE_STACK_SKIP, pc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define FTRACE_STACK_SKIP 5",
            "#define FTRACE_STACK_SKIP 3"
          ],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define FTRACE_STACK_SKIP 5\n#define FTRACE_STACK_SKIP 3\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned long flags;\n\tint pc;\n\n\tlocal_save_flags(flags);\n\tpc = preempt_count();\n\n\t__trace_stack(tr, flags, FTRACE_STACK_SKIP, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "count",
            "old_count",
            "new_count"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4122-4134",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_stacktrace_count(unsigned long ip, unsigned long parent_ip,\n\t\t\tstruct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t\tvoid *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\tlong new_count;\n\n\tif (!tracing_is_on())\n\t\treturn;\n\n\t/* unlimited? */\n\tif (!mapper) {\n\t\ttrace_stack(tr);\n\t\treturn;\n\t}\n\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\t/*\n\t * Stack traces should only execute the number of times the\n\t * user specified in the counter.\n\t */\n\tdo {\n\t\told_count = *count;\n\n\t\tif (!old_count)\n\t\t\treturn;\n\n\t\tnew_count = old_count - 1;\n\t\tnew_count = cmpxchg(count, old_count, new_count);\n\t\tif (new_count == old_count)\n\t\t\ttrace_stack(tr);\n\n\t\tif (!tracing_is_on())\n\t\t\treturn;\n\n\t} while (new_count != old_count);\n}"
  },
  {
    "function_name": "ftrace_stacktrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "413-419",
    "snippet": "static void\nftrace_stacktrace(unsigned long ip, unsigned long parent_ip,\n\t\t  struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t  void *data)\n{\n\ttrace_stack(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_stack",
          "args": [
            "tr"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "trace_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "402-411",
          "snippet": "static __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned long flags;\n\tint pc;\n\n\tlocal_save_flags(flags);\n\tpc = preempt_count();\n\n\t__trace_stack(tr, flags, FTRACE_STACK_SKIP, pc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define FTRACE_STACK_SKIP 5",
            "#define FTRACE_STACK_SKIP 3"
          ],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define FTRACE_STACK_SKIP 5\n#define FTRACE_STACK_SKIP 3\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned long flags;\n\tint pc;\n\n\tlocal_save_flags(flags);\n\tpc = preempt_count();\n\n\t__trace_stack(tr, flags, FTRACE_STACK_SKIP, pc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_stacktrace(unsigned long ip, unsigned long parent_ip,\n\t\t  struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t  void *data)\n{\n\ttrace_stack(tr);\n}"
  },
  {
    "function_name": "trace_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "402-411",
    "snippet": "static __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned long flags;\n\tint pc;\n\n\tlocal_save_flags(flags);\n\tpc = preempt_count();\n\n\t__trace_stack(tr, flags, FTRACE_STACK_SKIP, pc);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [
      "#define FTRACE_STACK_SKIP 5",
      "#define FTRACE_STACK_SKIP 3"
    ],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_stack",
          "args": [
            "tr",
            "flags",
            "FTRACE_STACK_SKIP",
            "pc"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2686-2708",
          "snippet": "void __trace_stack(struct trace_array *tr, unsigned long flags, int skip,\n\t\t   int pc)\n{\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, flags, skip, pc, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, flags, skip, pc, NULL);\n\trcu_irq_exit_irqson();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid __trace_stack(struct trace_array *tr, unsigned long flags, int skip,\n\t\t   int pc)\n{\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, flags, skip, pc, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, flags, skip, pc, NULL);\n\trcu_irq_exit_irqson();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "flags"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define FTRACE_STACK_SKIP 5\n#define FTRACE_STACK_SKIP 3\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic __always_inline void trace_stack(struct trace_array *tr)\n{\n\tunsigned long flags;\n\tint pc;\n\n\tlocal_save_flags(flags);\n\tpc = preempt_count();\n\n\t__trace_stack(tr, flags, FTRACE_STACK_SKIP, pc);\n}"
  },
  {
    "function_name": "ftrace_traceoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "369-378",
    "snippet": "static void\nftrace_traceoff(unsigned long ip, unsigned long parent_ip,\n\t\tstruct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\tvoid *data)\n{\n\tif (!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\ttracer_tracing_off(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracer_tracing_off",
          "args": [
            "tr"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1048-1063",
          "snippet": "void tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\tring_buffer_record_off(tr->trace_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\tring_buffer_record_off(tr->trace_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_is_on",
          "args": [
            "tr"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_is_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1091-1096",
          "snippet": "bool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->trace_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->trace_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_traceoff(unsigned long ip, unsigned long parent_ip,\n\t\tstruct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\tvoid *data)\n{\n\tif (!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\ttracer_tracing_off(tr);\n}"
  },
  {
    "function_name": "ftrace_traceon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "358-367",
    "snippet": "static void\nftrace_traceon(unsigned long ip, unsigned long parent_ip,\n\t       struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t       void *data)\n{\n\tif (tracer_tracing_is_on(tr))\n\t\treturn;\n\n\ttracer_tracing_on(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracer_tracing_on",
          "args": [
            "tr"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "760-775",
          "snippet": "void tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\tring_buffer_record_on(tr->trace_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\tring_buffer_record_on(tr->trace_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_is_on",
          "args": [
            "tr"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_is_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1091-1096",
          "snippet": "bool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->trace_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->trace_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_traceon(unsigned long ip, unsigned long parent_ip,\n\t       struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t       void *data)\n{\n\tif (tracer_tracing_is_on(tr))\n\t\treturn;\n\n\ttracer_tracing_on(tr);\n}"
  },
  {
    "function_name": "ftrace_traceoff_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "350-356",
    "snippet": "static void\nftrace_traceoff_count(unsigned long ip, unsigned long parent_ip,\n\t\t      struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t      void *data)\n{\n\tupdate_traceon_count(ops, ip, tr, 0, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_traceon_count",
          "args": [
            "ops",
            "ip",
            "tr",
            "0",
            "data"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "update_traceon_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "281-340",
          "snippet": "static void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_traceoff_count(unsigned long ip, unsigned long parent_ip,\n\t\t      struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t      void *data)\n{\n\tupdate_traceon_count(ops, ip, tr, 0, data);\n}"
  },
  {
    "function_name": "ftrace_traceon_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "342-348",
    "snippet": "static void\nftrace_traceon_count(unsigned long ip, unsigned long parent_ip,\n\t\t     struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\tupdate_traceon_count(ops, ip, tr, 1, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_traceon_count",
          "args": [
            "ops",
            "ip",
            "tr",
            "1",
            "data"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "update_traceon_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "281-340",
          "snippet": "static void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void\nftrace_traceon_count(unsigned long ip, unsigned long parent_ip,\n\t\t     struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t     void *data)\n{\n\tupdate_traceon_count(ops, ip, tr, 1, data);\n}"
  },
  {
    "function_name": "update_traceon_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "281-340",
    "snippet": "static void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_tracing_off",
          "args": [
            "tr"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1048-1063",
          "snippet": "void tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\tring_buffer_record_off(tr->trace_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\tring_buffer_record_off(tr->trace_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_on",
          "args": [
            "tr"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "760-775",
          "snippet": "void tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\tring_buffer_record_on(tr->trace_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\tring_buffer_record_on(tr->trace_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_is_on",
          "args": [
            "tr"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_is_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1091-1096",
          "snippet": "bool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->trace_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->trace_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->trace_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4122-4134",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void update_traceon_count(struct ftrace_probe_ops *ops,\n\t\t\t\t unsigned long ip,\n\t\t\t\t struct trace_array *tr, bool on,\n\t\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count;\n\tlong old_count;\n\n\t/*\n\t * Tracing gets disabled (or enabled) once per count.\n\t * This function can be called at the same time on multiple CPUs.\n\t * It is fine if both disable (or enable) tracing, as disabling\n\t * (or enabling) the second time doesn't do anything as the\n\t * state of the tracer is already disabled (or enabled).\n\t * What needs to be synchronized in this case is that the count\n\t * only gets decremented once, even if the tracer is disabled\n\t * (or enabled) twice, as the second one is really a nop.\n\t *\n\t * The memory barriers guarantee that we only decrement the\n\t * counter once. First the count is read to a local variable\n\t * and a read barrier is used to make sure that it is loaded\n\t * before checking if the tracer is in the state we want.\n\t * If the tracer is not in the state we want, then the count\n\t * is guaranteed to be the old count.\n\t *\n\t * Next the tracer is set to the state we want (disabled or enabled)\n\t * then a write memory barrier is used to make sure that\n\t * the new state is visible before changing the counter by\n\t * one minus the old counter. This guarantees that another CPU\n\t * executing this code will see the new state before seeing\n\t * the new counter value, and would not do anything if the new\n\t * counter is seen.\n\t *\n\t * Note, there is no synchronization between this and a user\n\t * setting the tracing_on file. But we currently don't care\n\t * about that.\n\t */\n\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\told_count = *count;\n\n\tif (old_count <= 0)\n\t\treturn;\n\n\t/* Make sure we see count before checking tracing state */\n\tsmp_rmb();\n\n\tif (on == !!tracer_tracing_is_on(tr))\n\t\treturn;\n\n\tif (on)\n\t\ttracer_tracing_on(tr);\n\telse\n\t\ttracer_tracing_off(tr);\n\n\t/* Make sure tracing state is visible before updating count */\n\tsmp_wmb();\n\n\t*count = old_count - 1;\n}"
  },
  {
    "function_name": "func_set_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "235-264",
    "snippet": "static int\nfunc_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\tswitch (bit) {\n\tcase TRACE_FUNC_OPT_STACK:\n\t\t/* do nothing if already set */\n\t\tif (!!set == !!(func_flags.val & TRACE_FUNC_OPT_STACK))\n\t\t\tbreak;\n\n\t\t/* We can change this flag when not running. */\n\t\tif (tr->current_trace != &function_trace)\n\t\t\tbreak;\n\n\t\tunregister_ftrace_function(tr->ops);\n\n\t\tif (set) {\n\t\t\ttr->ops->func = function_stack_trace_call;\n\t\t\tregister_ftrace_function(tr->ops);\n\t\t} else {\n\t\t\ttr->ops->func = function_trace_call;\n\t\t\tregister_ftrace_function(tr->ops);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);",
      "static struct tracer_flags func_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\nstatic struct tracer_flags func_flags;\n\nstatic int\nfunc_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\tswitch (bit) {\n\tcase TRACE_FUNC_OPT_STACK:\n\t\t/* do nothing if already set */\n\t\tif (!!set == !!(func_flags.val & TRACE_FUNC_OPT_STACK))\n\t\t\tbreak;\n\n\t\t/* We can change this flag when not running. */\n\t\tif (tr->current_trace != &function_trace)\n\t\t\tbreak;\n\n\t\tunregister_ftrace_function(tr->ops);\n\n\t\tif (set) {\n\t\t\ttr->ops->func = function_stack_trace_call;\n\t\t\tregister_ftrace_function(tr->ops);\n\t\t} else {\n\t\t\ttr->ops->func = function_trace_call;\n\t\t\tregister_ftrace_function(tr->ops);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tracing_stop_function_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "227-231",
    "snippet": "static void tracing_stop_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tunregister_ftrace_function(tr->ops);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void tracing_stop_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tunregister_ftrace_function(tr->ops);\n}"
  },
  {
    "function_name": "tracing_start_function_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "220-225",
    "snippet": "static void tracing_start_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tregister_ftrace_function(tr->ops);\n\ttr->function_enabled = 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void tracing_start_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tregister_ftrace_function(tr->ops);\n\ttr->function_enabled = 1;\n}"
  },
  {
    "function_name": "function_stack_trace_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "175-206",
    "snippet": "static void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tint pc;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\t/*\n\t * Need to use raw, since this must be called before the\n\t * recursive protection is performed.\n\t */\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\n\tif (likely(disabled == 1)) {\n\t\tpc = preempt_count();\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n\t\t__trace_stack(tr, flags, STACK_SKIP, pc);\n\t}\n\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [
      "#define STACK_SKIP 3",
      "#define STACK_SKIP 2"
    ],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);",
      "static void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct pt_regs *pt_regs);",
      "static void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct pt_regs *pt_regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_stack",
          "args": [
            "tr",
            "flags",
            "STACK_SKIP",
            "pc"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2686-2708",
          "snippet": "void __trace_stack(struct trace_array *tr, unsigned long flags, int skip,\n\t\t   int pc)\n{\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, flags, skip, pc, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, flags, skip, pc, NULL);\n\trcu_irq_exit_irqson();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid __trace_stack(struct trace_array *tr, unsigned long flags, int skip,\n\t\t   int pc)\n{\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, flags, skip, pc, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, flags, skip, pc, NULL);\n\trcu_irq_exit_irqson();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "flags",
            "pc"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "trace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2550-2573",
          "snippet": "void\ntrace_function(struct trace_array *tr,\n\t       unsigned long ip, unsigned long parent_ip, unsigned long flags,\n\t       int pc)\n{\n\tstruct trace_event_call *call = &event_function;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_entry *entry;\n\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_FN, sizeof(*entry),\n\t\t\t\t\t    flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\tif (static_branch_unlikely(&ftrace_exports_enabled))\n\t\t\tftrace_exports(event);\n\t\t__buffer_unlock_commit(buffer, event);\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static DEFINE_STATIC_KEY_FALSE(ftrace_exports_enabled);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic DEFINE_STATIC_KEY_FALSE(ftrace_exports_enabled);\n\nvoid\ntrace_function(struct trace_array *tr,\n\t       unsigned long ip, unsigned long parent_ip, unsigned long flags,\n\t       int pc)\n{\n\tstruct trace_event_call *call = &event_function;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_entry *entry;\n\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_FN, sizeof(*entry),\n\t\t\t\t\t    flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\tif (static_branch_unlikely(&ftrace_exports_enabled))\n\t\t\tftrace_exports(event);\n\t\t__buffer_unlock_commit(buffer, event);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "disabled == 1"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&data->disabled"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->trace_buffer.data",
            "cpu"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tr->function_enabled"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\n#define STACK_SKIP 3\n#define STACK_SKIP 2\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\nstatic void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct pt_regs *pt_regs);\nstatic void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct pt_regs *pt_regs);\n\nstatic void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tint pc;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\t/*\n\t * Need to use raw, since this must be called before the\n\t * recursive protection is performed.\n\t */\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\n\tif (likely(disabled == 1)) {\n\t\tpc = preempt_count();\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n\t\t__trace_stack(tr, flags, STACK_SKIP, pc);\n\t}\n\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "function_trace_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "124-155",
    "snippet": "static void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tint bit;\n\tint cpu;\n\tint pc;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\tbit = trace_test_and_set_recursion(TRACE_FTRACE_START, TRACE_FTRACE_MAX);\n\tif (bit < 0)\n\t\tgoto out;\n\n\tcpu = smp_processor_id();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tif (!atomic_read(&data->disabled)) {\n\t\tlocal_save_flags(flags);\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n\t}\n\ttrace_clear_recursion(bit);\n\n out:\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);",
      "static void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct pt_regs *pt_regs);",
      "static void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct pt_regs *pt_regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_clear_recursion",
          "args": [
            "bit"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clear_recursion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "569-581",
          "snippet": "static __always_inline void trace_clear_recursion(int bit)\n{\n\tunsigned int val = current->trace_recursion;\n\n\tif (!bit)\n\t\treturn;\n\n\tbit = 1 << bit;\n\tval &= ~bit;\n\n\tbarrier();\n\tcurrent->trace_recursion = val;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline void trace_clear_recursion(int bit)\n{\n\tunsigned int val = current->trace_recursion;\n\n\tif (!bit)\n\t\treturn;\n\n\tbit = 1 << bit;\n\tval &= ~bit;\n\n\tbarrier();\n\tcurrent->trace_recursion = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "flags",
            "pc"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "trace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2550-2573",
          "snippet": "void\ntrace_function(struct trace_array *tr,\n\t       unsigned long ip, unsigned long parent_ip, unsigned long flags,\n\t       int pc)\n{\n\tstruct trace_event_call *call = &event_function;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_entry *entry;\n\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_FN, sizeof(*entry),\n\t\t\t\t\t    flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\tif (static_branch_unlikely(&ftrace_exports_enabled))\n\t\t\tftrace_exports(event);\n\t\t__buffer_unlock_commit(buffer, event);\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static DEFINE_STATIC_KEY_FALSE(ftrace_exports_enabled);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic DEFINE_STATIC_KEY_FALSE(ftrace_exports_enabled);\n\nvoid\ntrace_function(struct trace_array *tr,\n\t       unsigned long ip, unsigned long parent_ip, unsigned long flags,\n\t       int pc)\n{\n\tstruct trace_event_call *call = &event_function;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_entry *entry;\n\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_FN, sizeof(*entry),\n\t\t\t\t\t    flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\tif (static_branch_unlikely(&ftrace_exports_enabled))\n\t\t\tftrace_exports(event);\n\t\t__buffer_unlock_commit(buffer, event);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "flags"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->disabled"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->trace_buffer.data",
            "cpu"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_and_set_recursion",
          "args": [
            "TRACE_FTRACE_START",
            "TRACE_FTRACE_MAX"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_and_set_recursion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "549-567",
          "snippet": "static __always_inline int trace_test_and_set_recursion(int start, int max)\n{\n\tunsigned int val = current->trace_recursion;\n\tint bit;\n\n\t/* A previous recursion check was made */\n\tif ((val & TRACE_CONTEXT_MASK) > max)\n\t\treturn 0;\n\n\tbit = trace_get_context_bit() + start;\n\tif (unlikely(val & (1 << bit)))\n\t\treturn -1;\n\n\tval |= 1 << bit;\n\tcurrent->trace_recursion = val;\n\tbarrier();\n\n\treturn bit;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TRACE_CONTEXT_MASK\tTRACE_LIST_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\n#define TRACE_CONTEXT_MASK\tTRACE_LIST_MAX\n\nstatic __always_inline int trace_test_and_set_recursion(int start, int max)\n{\n\tunsigned int val = current->trace_recursion;\n\tint bit;\n\n\t/* A previous recursion check was made */\n\tif ((val & TRACE_CONTEXT_MASK) > max)\n\t\treturn 0;\n\n\tbit = trace_get_context_bit() + start;\n\tif (unlikely(val & (1 << bit)))\n\t\treturn -1;\n\n\tval |= 1 << bit;\n\tcurrent->trace_recursion = val;\n\tbarrier();\n\n\treturn bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tr->function_enabled"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\nstatic void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct pt_regs *pt_regs);\nstatic void\nfunction_stack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct pt_regs *pt_regs);\n\nstatic void\nfunction_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct trace_array *tr = op->private;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tint bit;\n\tint cpu;\n\tint pc;\n\n\tif (unlikely(!tr->function_enabled))\n\t\treturn;\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\tbit = trace_test_and_set_recursion(TRACE_FTRACE_START, TRACE_FTRACE_MAX);\n\tif (bit < 0)\n\t\tgoto out;\n\n\tcpu = smp_processor_id();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tif (!atomic_read(&data->disabled)) {\n\t\tlocal_save_flags(flags);\n\t\ttrace_function(tr, ip, parent_ip, flags, pc);\n\t}\n\ttrace_clear_recursion(bit);\n\n out:\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "function_trace_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "119-122",
    "snippet": "static void function_trace_start(struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_reset_online_cpus",
          "args": [
            "&tr->trace_buffer"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1690-1709",
          "snippet": "void tracing_reset_online_cpus(struct trace_buffer *buf)\n{\n\tstruct ring_buffer *buffer = buf->buffer;\n\tint cpu;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_sched();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tfor_each_online_cpu(cpu)\n\t\tring_buffer_reset_cpu(buffer, cpu);\n\n\tring_buffer_record_enable(buffer);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nvoid tracing_reset_online_cpus(struct trace_buffer *buf)\n{\n\tstruct ring_buffer *buffer = buf->buffer;\n\tint cpu;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_sched();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tfor_each_online_cpu(cpu)\n\t\tring_buffer_reset_cpu(buffer, cpu);\n\n\tring_buffer_record_enable(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void function_trace_start(struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n}"
  },
  {
    "function_name": "function_trace_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "112-117",
    "snippet": "static void function_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_function_trace(tr);\n\ttracing_stop_cmdline_record();\n\tftrace_reset_array_ops(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_reset_array_ops",
          "args": [
            "tr"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_reset_array_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6247-6250",
          "snippet": "void ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_cmdline_record",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_cmdline_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "134-137",
          "snippet": "void tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_function_trace",
          "args": [
            "tr"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_function_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "227-231",
          "snippet": "static void tracing_stop_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tunregister_ftrace_function(tr->ops);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void tracing_stop_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tunregister_ftrace_function(tr->ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void function_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_function_trace(tr);\n\ttracing_stop_cmdline_record();\n\tftrace_reset_array_ops(tr);\n}"
  },
  {
    "function_name": "function_trace_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "83-110",
    "snippet": "static int function_trace_init(struct trace_array *tr)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Instance trace_arrays get their ops allocated\n\t * at instance creation. Unless it failed\n\t * the allocation.\n\t */\n\tif (!tr->ops)\n\t\treturn -ENOMEM;\n\n\t/* Currently only the global instance can do stack tracing */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t    func_flags.val & TRACE_FUNC_OPT_STACK)\n\t\tfunc = function_stack_trace_call;\n\telse\n\t\tfunc = function_trace_call;\n\n\tftrace_init_array_ops(tr, func);\n\n\ttr->trace_buffer.cpu = get_cpu();\n\tput_cpu();\n\n\ttracing_start_cmdline_record();\n\ttracing_start_function_trace(tr);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);",
      "static struct tracer_flags func_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_start_function_trace",
          "args": [
            "tr"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_function_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "220-225",
          "snippet": "static void tracing_start_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tregister_ftrace_function(tr->ops);\n\ttr->function_enabled = 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic void tracing_start_function_trace(struct trace_array *tr)\n{\n\ttr->function_enabled = 0;\n\tregister_ftrace_function(tr->ops);\n\ttr->function_enabled = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start_cmdline_record",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_cmdline_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "129-132",
          "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_init_array_ops",
          "args": [
            "tr",
            "func"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_array_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6235-6245",
          "snippet": "void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\nstatic struct tracer_flags func_flags;\n\nstatic int function_trace_init(struct trace_array *tr)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Instance trace_arrays get their ops allocated\n\t * at instance creation. Unless it failed\n\t * the allocation.\n\t */\n\tif (!tr->ops)\n\t\treturn -ENOMEM;\n\n\t/* Currently only the global instance can do stack tracing */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t    func_flags.val & TRACE_FUNC_OPT_STACK)\n\t\tfunc = function_stack_trace_call;\n\telse\n\t\tfunc = function_trace_call;\n\n\tftrace_init_array_ops(tr, func);\n\n\ttr->trace_buffer.cpu = get_cpu();\n\tput_cpu();\n\n\ttracing_start_cmdline_record();\n\ttracing_start_function_trace(tr);\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_destroy_function_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "76-81",
    "snippet": "void ftrace_destroy_function_files(struct trace_array *tr)\n{\n\tftrace_destroy_filter_files(tr->ops);\n\tkfree(tr->ops);\n\ttr->ops = NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tr->ops"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_destroy_filter_files",
          "args": [
            "tr->ops"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_destroy_filter_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5457-5464",
          "snippet": "void ftrace_destroy_filter_files(struct ftrace_ops *ops)\n{\n\tmutex_lock(&ftrace_lock);\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED)\n\t\tftrace_shutdown(ops, 0);\n\tops->flags |= FTRACE_OPS_FL_DELETED;\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_destroy_filter_files(struct ftrace_ops *ops)\n{\n\tmutex_lock(&ftrace_lock);\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED)\n\t\tftrace_shutdown(ops, 0);\n\tops->flags |= FTRACE_OPS_FL_DELETED;\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nvoid ftrace_destroy_function_files(struct trace_array *tr)\n{\n\tftrace_destroy_filter_files(tr->ops);\n\tkfree(tr->ops);\n\ttr->ops = NULL;\n}"
  },
  {
    "function_name": "ftrace_create_function_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "55-74",
    "snippet": "int ftrace_create_function_files(struct trace_array *tr,\n\t\t\t\t struct dentry *parent)\n{\n\tint ret;\n\n\t/*\n\t * The top level array uses the \"global_ops\", and the files are\n\t * created on boot up.\n\t */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL)\n\t\treturn 0;\n\n\tret = allocate_ftrace_ops(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_create_filter_files(tr->ops, parent);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_create_filter_files",
          "args": [
            "tr->ops",
            "parent"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_create_filter_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5436-5445",
          "snippet": "void ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", 0644, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", 0644, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", 0644, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", 0644, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_ftrace_ops",
          "args": [
            "tr"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_ftrace_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
          "lines": "37-52",
          "snippet": "static int allocate_ftrace_ops(struct trace_array *tr)\n{\n\tstruct ftrace_ops *ops;\n\n\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\t/* Currently only the non stack verision is supported */\n\tops->func = function_trace_call;\n\tops->flags = FTRACE_OPS_FL_RECURSION_SAFE | FTRACE_OPS_FL_PID;\n\n\ttr->ops = ops;\n\tops->private = tr;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tracing_start_function_trace(struct trace_array *tr);",
            "static void tracing_stop_function_trace(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int allocate_ftrace_ops(struct trace_array *tr)\n{\n\tstruct ftrace_ops *ops;\n\n\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\t/* Currently only the non stack verision is supported */\n\tops->func = function_trace_call;\n\tops->flags = FTRACE_OPS_FL_RECURSION_SAFE | FTRACE_OPS_FL_PID;\n\n\ttr->ops = ops;\n\tops->private = tr;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nint ftrace_create_function_files(struct trace_array *tr,\n\t\t\t\t struct dentry *parent)\n{\n\tint ret;\n\n\t/*\n\t * The top level array uses the \"global_ops\", and the files are\n\t * created on boot up.\n\t */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL)\n\t\treturn 0;\n\n\tret = allocate_ftrace_ops(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_create_filter_files(tr->ops, parent);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "allocate_ftrace_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions.c",
    "lines": "37-52",
    "snippet": "static int allocate_ftrace_ops(struct trace_array *tr)\n{\n\tstruct ftrace_ops *ops;\n\n\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\t/* Currently only the non stack verision is supported */\n\tops->func = function_trace_call;\n\tops->flags = FTRACE_OPS_FL_RECURSION_SAFE | FTRACE_OPS_FL_PID;\n\n\ttr->ops = ops;\n\tops->private = tr;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ring_buffer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tracing_start_function_trace(struct trace_array *tr);",
      "static void tracing_stop_function_trace(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ops)",
            "GFP_KERNEL"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/ring_buffer.h>\n\nstatic void tracing_start_function_trace(struct trace_array *tr);\nstatic void tracing_stop_function_trace(struct trace_array *tr);\n\nstatic int allocate_ftrace_ops(struct trace_array *tr)\n{\n\tstruct ftrace_ops *ops;\n\n\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\t/* Currently only the non stack verision is supported */\n\tops->func = function_trace_call;\n\tops->flags = FTRACE_OPS_FL_RECURSION_SAFE | FTRACE_OPS_FL_PID;\n\n\ttr->ops = ops;\n\tops->private = tr;\n\treturn 0;\n}"
  }
]