[
  {
    "function_name": "crash_prepare_elf64_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "1130-1227",
    "snippet": "int crash_prepare_elf64_headers(struct crash_mem *mem, int kernel_map,\n\t\t\t  void **addr, unsigned long *sz)\n{\n\tElf64_Ehdr *ehdr;\n\tElf64_Phdr *phdr;\n\tunsigned long nr_cpus = num_possible_cpus(), nr_phdr, elf_sz;\n\tunsigned char *buf;\n\tunsigned int cpu, i;\n\tunsigned long long notes_addr;\n\tunsigned long mstart, mend;\n\n\t/* extra phdr for vmcoreinfo elf note */\n\tnr_phdr = nr_cpus + 1;\n\tnr_phdr += mem->nr_ranges;\n\n\t/*\n\t * kexec-tools creates an extra PT_LOAD phdr for kernel text mapping\n\t * area (for example, ffffffff80000000 - ffffffffa0000000 on x86_64).\n\t * I think this is required by tools like gdb. So same physical\n\t * memory will be mapped in two elf headers. One will contain kernel\n\t * text virtual addresses and other will have __va(physical) addresses.\n\t */\n\n\tnr_phdr++;\n\telf_sz = sizeof(Elf64_Ehdr) + nr_phdr * sizeof(Elf64_Phdr);\n\telf_sz = ALIGN(elf_sz, ELF_CORE_HEADER_ALIGN);\n\n\tbuf = vzalloc(elf_sz);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tehdr = (Elf64_Ehdr *)buf;\n\tphdr = (Elf64_Phdr *)(ehdr + 1);\n\tmemcpy(ehdr->e_ident, ELFMAG, SELFMAG);\n\tehdr->e_ident[EI_CLASS] = ELFCLASS64;\n\tehdr->e_ident[EI_DATA] = ELFDATA2LSB;\n\tehdr->e_ident[EI_VERSION] = EV_CURRENT;\n\tehdr->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(ehdr->e_ident + EI_PAD, 0, EI_NIDENT - EI_PAD);\n\tehdr->e_type = ET_CORE;\n\tehdr->e_machine = ELF_ARCH;\n\tehdr->e_version = EV_CURRENT;\n\tehdr->e_phoff = sizeof(Elf64_Ehdr);\n\tehdr->e_ehsize = sizeof(Elf64_Ehdr);\n\tehdr->e_phentsize = sizeof(Elf64_Phdr);\n\n\t/* Prepare one phdr of type PT_NOTE for each present cpu */\n\tfor_each_present_cpu(cpu) {\n\t\tphdr->p_type = PT_NOTE;\n\t\tnotes_addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpu));\n\t\tphdr->p_offset = phdr->p_paddr = notes_addr;\n\t\tphdr->p_filesz = phdr->p_memsz = sizeof(note_buf_t);\n\t\t(ehdr->e_phnum)++;\n\t\tphdr++;\n\t}\n\n\t/* Prepare one PT_NOTE header for vmcoreinfo */\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = phdr->p_paddr = paddr_vmcoreinfo_note();\n\tphdr->p_filesz = phdr->p_memsz = VMCOREINFO_NOTE_SIZE;\n\t(ehdr->e_phnum)++;\n\tphdr++;\n\n\t/* Prepare PT_LOAD type program header for kernel text region */\n\tif (kernel_map) {\n\t\tphdr->p_type = PT_LOAD;\n\t\tphdr->p_flags = PF_R|PF_W|PF_X;\n\t\tphdr->p_vaddr = (Elf64_Addr)_text;\n\t\tphdr->p_filesz = phdr->p_memsz = _end - _text;\n\t\tphdr->p_offset = phdr->p_paddr = __pa_symbol(_text);\n\t\tehdr->e_phnum++;\n\t\tphdr++;\n\t}\n\n\t/* Go through all the ranges in mem->ranges[] and prepare phdr */\n\tfor (i = 0; i < mem->nr_ranges; i++) {\n\t\tmstart = mem->ranges[i].start;\n\t\tmend = mem->ranges[i].end;\n\n\t\tphdr->p_type = PT_LOAD;\n\t\tphdr->p_flags = PF_R|PF_W|PF_X;\n\t\tphdr->p_offset  = mstart;\n\n\t\tphdr->p_paddr = mstart;\n\t\tphdr->p_vaddr = (unsigned long long) __va(mstart);\n\t\tphdr->p_filesz = phdr->p_memsz = mend - mstart + 1;\n\t\tphdr->p_align = 0;\n\t\tehdr->e_phnum++;\n\t\tphdr++;\n\t\tpr_debug(\"Crash PT_LOAD elf header. phdr=%p vaddr=0x%llx, paddr=0x%llx, sz=0x%llx e_phnum=%d p_offset=0x%llx\\n\",\n\t\t\tphdr, phdr->p_vaddr, phdr->p_paddr, phdr->p_filesz,\n\t\t\tehdr->e_phnum, phdr->p_offset);\n\t}\n\n\t*addr = buf;\n\t*sz = elf_sz;\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Crash PT_LOAD elf header. phdr=%p vaddr=0x%llx, paddr=0x%llx, sz=0x%llx e_phnum=%d p_offset=0x%llx\\n\"",
            "phdr",
            "phdr->p_vaddr",
            "phdr->p_paddr",
            "phdr->p_filesz",
            "ehdr->e_phnum",
            "phdr->p_offset"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "mstart"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "__var_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "152-155",
          "snippet": "wait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa_symbol",
          "args": [
            "_text"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paddr_vmcoreinfo_note",
          "args": [],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "paddr_vmcoreinfo_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/crash_core.c",
          "lines": "375-378",
          "snippet": "phys_addr_t __weak paddr_vmcoreinfo_note(void)\n{\n\treturn __pa(vmcoreinfo_note);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/crash_core.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32 *vmcoreinfo_note;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/crash_core.h>\n\nu32 *vmcoreinfo_note;\n\nphys_addr_t __weak paddr_vmcoreinfo_note(void)\n{\n\treturn __pa(vmcoreinfo_note);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr_to_phys",
          "args": [
            "per_cpu_ptr(crash_notes, cpu)"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "crash_notes",
            "cpu"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ehdr->e_ident + EI_PAD",
            "0",
            "EI_NIDENT - EI_PAD"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ehdr->e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "elf_sz"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "elf_sz",
            "ELF_CORE_HEADER_ALIGN"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint crash_prepare_elf64_headers(struct crash_mem *mem, int kernel_map,\n\t\t\t  void **addr, unsigned long *sz)\n{\n\tElf64_Ehdr *ehdr;\n\tElf64_Phdr *phdr;\n\tunsigned long nr_cpus = num_possible_cpus(), nr_phdr, elf_sz;\n\tunsigned char *buf;\n\tunsigned int cpu, i;\n\tunsigned long long notes_addr;\n\tunsigned long mstart, mend;\n\n\t/* extra phdr for vmcoreinfo elf note */\n\tnr_phdr = nr_cpus + 1;\n\tnr_phdr += mem->nr_ranges;\n\n\t/*\n\t * kexec-tools creates an extra PT_LOAD phdr for kernel text mapping\n\t * area (for example, ffffffff80000000 - ffffffffa0000000 on x86_64).\n\t * I think this is required by tools like gdb. So same physical\n\t * memory will be mapped in two elf headers. One will contain kernel\n\t * text virtual addresses and other will have __va(physical) addresses.\n\t */\n\n\tnr_phdr++;\n\telf_sz = sizeof(Elf64_Ehdr) + nr_phdr * sizeof(Elf64_Phdr);\n\telf_sz = ALIGN(elf_sz, ELF_CORE_HEADER_ALIGN);\n\n\tbuf = vzalloc(elf_sz);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tehdr = (Elf64_Ehdr *)buf;\n\tphdr = (Elf64_Phdr *)(ehdr + 1);\n\tmemcpy(ehdr->e_ident, ELFMAG, SELFMAG);\n\tehdr->e_ident[EI_CLASS] = ELFCLASS64;\n\tehdr->e_ident[EI_DATA] = ELFDATA2LSB;\n\tehdr->e_ident[EI_VERSION] = EV_CURRENT;\n\tehdr->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(ehdr->e_ident + EI_PAD, 0, EI_NIDENT - EI_PAD);\n\tehdr->e_type = ET_CORE;\n\tehdr->e_machine = ELF_ARCH;\n\tehdr->e_version = EV_CURRENT;\n\tehdr->e_phoff = sizeof(Elf64_Ehdr);\n\tehdr->e_ehsize = sizeof(Elf64_Ehdr);\n\tehdr->e_phentsize = sizeof(Elf64_Phdr);\n\n\t/* Prepare one phdr of type PT_NOTE for each present cpu */\n\tfor_each_present_cpu(cpu) {\n\t\tphdr->p_type = PT_NOTE;\n\t\tnotes_addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpu));\n\t\tphdr->p_offset = phdr->p_paddr = notes_addr;\n\t\tphdr->p_filesz = phdr->p_memsz = sizeof(note_buf_t);\n\t\t(ehdr->e_phnum)++;\n\t\tphdr++;\n\t}\n\n\t/* Prepare one PT_NOTE header for vmcoreinfo */\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = phdr->p_paddr = paddr_vmcoreinfo_note();\n\tphdr->p_filesz = phdr->p_memsz = VMCOREINFO_NOTE_SIZE;\n\t(ehdr->e_phnum)++;\n\tphdr++;\n\n\t/* Prepare PT_LOAD type program header for kernel text region */\n\tif (kernel_map) {\n\t\tphdr->p_type = PT_LOAD;\n\t\tphdr->p_flags = PF_R|PF_W|PF_X;\n\t\tphdr->p_vaddr = (Elf64_Addr)_text;\n\t\tphdr->p_filesz = phdr->p_memsz = _end - _text;\n\t\tphdr->p_offset = phdr->p_paddr = __pa_symbol(_text);\n\t\tehdr->e_phnum++;\n\t\tphdr++;\n\t}\n\n\t/* Go through all the ranges in mem->ranges[] and prepare phdr */\n\tfor (i = 0; i < mem->nr_ranges; i++) {\n\t\tmstart = mem->ranges[i].start;\n\t\tmend = mem->ranges[i].end;\n\n\t\tphdr->p_type = PT_LOAD;\n\t\tphdr->p_flags = PF_R|PF_W|PF_X;\n\t\tphdr->p_offset  = mstart;\n\n\t\tphdr->p_paddr = mstart;\n\t\tphdr->p_vaddr = (unsigned long long) __va(mstart);\n\t\tphdr->p_filesz = phdr->p_memsz = mend - mstart + 1;\n\t\tphdr->p_align = 0;\n\t\tehdr->e_phnum++;\n\t\tphdr++;\n\t\tpr_debug(\"Crash PT_LOAD elf header. phdr=%p vaddr=0x%llx, paddr=0x%llx, sz=0x%llx e_phnum=%d p_offset=0x%llx\\n\",\n\t\t\tphdr, phdr->p_vaddr, phdr->p_paddr, phdr->p_filesz,\n\t\t\tehdr->e_phnum, phdr->p_offset);\n\t}\n\n\t*addr = buf;\n\t*sz = elf_sz;\n\treturn 0;\n}"
  },
  {
    "function_name": "crash_exclude_mem_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "1059-1128",
    "snippet": "int crash_exclude_mem_range(struct crash_mem *mem,\n\t\t\t    unsigned long long mstart, unsigned long long mend)\n{\n\tint i, j;\n\tunsigned long long start, end;\n\tstruct crash_mem_range temp_range = {0, 0};\n\n\tfor (i = 0; i < mem->nr_ranges; i++) {\n\t\tstart = mem->ranges[i].start;\n\t\tend = mem->ranges[i].end;\n\n\t\tif (mstart > end || mend < start)\n\t\t\tcontinue;\n\n\t\t/* Truncate any area outside of range */\n\t\tif (mstart < start)\n\t\t\tmstart = start;\n\t\tif (mend > end)\n\t\t\tmend = end;\n\n\t\t/* Found completely overlapping range */\n\t\tif (mstart == start && mend == end) {\n\t\t\tmem->ranges[i].start = 0;\n\t\t\tmem->ranges[i].end = 0;\n\t\t\tif (i < mem->nr_ranges - 1) {\n\t\t\t\t/* Shift rest of the ranges to left */\n\t\t\t\tfor (j = i; j < mem->nr_ranges - 1; j++) {\n\t\t\t\t\tmem->ranges[j].start =\n\t\t\t\t\t\tmem->ranges[j+1].start;\n\t\t\t\t\tmem->ranges[j].end =\n\t\t\t\t\t\t\tmem->ranges[j+1].end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmem->nr_ranges--;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (mstart > start && mend < end) {\n\t\t\t/* Split original range */\n\t\t\tmem->ranges[i].end = mstart - 1;\n\t\t\ttemp_range.start = mend + 1;\n\t\t\ttemp_range.end = end;\n\t\t} else if (mstart != start)\n\t\t\tmem->ranges[i].end = mstart - 1;\n\t\telse\n\t\t\tmem->ranges[i].start = mend + 1;\n\t\tbreak;\n\t}\n\n\t/* If a split happened, add the split to array */\n\tif (!temp_range.end)\n\t\treturn 0;\n\n\t/* Split happened */\n\tif (i == mem->max_nr_ranges - 1)\n\t\treturn -ENOMEM;\n\n\t/* Location where new range should go */\n\tj = i + 1;\n\tif (j < mem->nr_ranges) {\n\t\t/* Move over all ranges one slot towards the end */\n\t\tfor (i = mem->nr_ranges - 1; i >= j; i--)\n\t\t\tmem->ranges[i + 1] = mem->ranges[i];\n\t}\n\n\tmem->ranges[j].start = temp_range.start;\n\tmem->ranges[j].end = temp_range.end;\n\tmem->nr_ranges++;\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint crash_exclude_mem_range(struct crash_mem *mem,\n\t\t\t    unsigned long long mstart, unsigned long long mend)\n{\n\tint i, j;\n\tunsigned long long start, end;\n\tstruct crash_mem_range temp_range = {0, 0};\n\n\tfor (i = 0; i < mem->nr_ranges; i++) {\n\t\tstart = mem->ranges[i].start;\n\t\tend = mem->ranges[i].end;\n\n\t\tif (mstart > end || mend < start)\n\t\t\tcontinue;\n\n\t\t/* Truncate any area outside of range */\n\t\tif (mstart < start)\n\t\t\tmstart = start;\n\t\tif (mend > end)\n\t\t\tmend = end;\n\n\t\t/* Found completely overlapping range */\n\t\tif (mstart == start && mend == end) {\n\t\t\tmem->ranges[i].start = 0;\n\t\t\tmem->ranges[i].end = 0;\n\t\t\tif (i < mem->nr_ranges - 1) {\n\t\t\t\t/* Shift rest of the ranges to left */\n\t\t\t\tfor (j = i; j < mem->nr_ranges - 1; j++) {\n\t\t\t\t\tmem->ranges[j].start =\n\t\t\t\t\t\tmem->ranges[j+1].start;\n\t\t\t\t\tmem->ranges[j].end =\n\t\t\t\t\t\t\tmem->ranges[j+1].end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmem->nr_ranges--;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (mstart > start && mend < end) {\n\t\t\t/* Split original range */\n\t\t\tmem->ranges[i].end = mstart - 1;\n\t\t\ttemp_range.start = mend + 1;\n\t\t\ttemp_range.end = end;\n\t\t} else if (mstart != start)\n\t\t\tmem->ranges[i].end = mstart - 1;\n\t\telse\n\t\t\tmem->ranges[i].start = mend + 1;\n\t\tbreak;\n\t}\n\n\t/* If a split happened, add the split to array */\n\tif (!temp_range.end)\n\t\treturn 0;\n\n\t/* Split happened */\n\tif (i == mem->max_nr_ranges - 1)\n\t\treturn -ENOMEM;\n\n\t/* Location where new range should go */\n\tj = i + 1;\n\tif (j < mem->nr_ranges) {\n\t\t/* Move over all ranges one slot towards the end */\n\t\tfor (i = mem->nr_ranges - 1; i >= j; i--)\n\t\t\tmem->ranges[i + 1] = mem->ranges[i];\n\t}\n\n\tmem->ranges[j].start = temp_range.start;\n\tmem->ranges[j].end = temp_range.end;\n\tmem->nr_ranges++;\n\treturn 0;\n}"
  },
  {
    "function_name": "kexec_purgatory_get_set_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "1022-1056",
    "snippet": "int kexec_purgatory_get_set_symbol(struct kimage *image, const char *name,\n\t\t\t\t   void *buf, unsigned int size, bool get_value)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Sym *sym;\n\tElf_Shdr *sec;\n\tchar *sym_buf;\n\n\tsym = kexec_purgatory_find_symbol(pi, name);\n\tif (!sym)\n\t\treturn -EINVAL;\n\n\tif (sym->st_size != size) {\n\t\tpr_err(\"symbol %s size mismatch: expected %lu actual %u\\n\",\n\t\t       name, (unsigned long)sym->st_size, size);\n\t\treturn -EINVAL;\n\t}\n\n\tsec = pi->sechdrs + sym->st_shndx;\n\n\tif (sec->sh_type == SHT_NOBITS) {\n\t\tpr_err(\"symbol %s is in a bss section. Cannot %s\\n\", name,\n\t\t       get_value ? \"get\" : \"set\");\n\t\treturn -EINVAL;\n\t}\n\n\tsym_buf = (char *)pi->purgatory_buf + sec->sh_offset + sym->st_value;\n\n\tif (get_value)\n\t\tmemcpy((void *)buf, sym_buf, size);\n\telse\n\t\tmemcpy((void *)sym_buf, buf, size);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)sym_buf",
            "buf",
            "size"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"symbol %s is in a bss section. Cannot %s\\n\"",
            "name",
            "get_value ? \"get\" : \"set\""
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"symbol %s size mismatch: expected %lu actual %u\\n\"",
            "name",
            "(unsigned long)sym->st_size",
            "size"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_purgatory_find_symbol",
          "args": [
            "pi",
            "name"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_purgatory_find_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "951-997",
          "snippet": "static const Elf_Sym *kexec_purgatory_find_symbol(struct purgatory_info *pi,\n\t\t\t\t\t\t  const char *name)\n{\n\tconst Elf_Shdr *sechdrs;\n\tconst Elf_Ehdr *ehdr;\n\tconst Elf_Sym *syms;\n\tconst char *strtab;\n\tint i, k;\n\n\tif (!pi->ehdr)\n\t\treturn NULL;\n\n\tehdr = pi->ehdr;\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\n\tfor (i = 0; i < ehdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type != SHT_SYMTAB)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_link >= ehdr->e_shnum)\n\t\t\t/* Invalid strtab section number */\n\t\t\tcontinue;\n\t\tstrtab = (void *)ehdr + sechdrs[sechdrs[i].sh_link].sh_offset;\n\t\tsyms = (void *)ehdr + sechdrs[i].sh_offset;\n\n\t\t/* Go through symbols for a match */\n\t\tfor (k = 0; k < sechdrs[i].sh_size/sizeof(Elf_Sym); k++) {\n\t\t\tif (ELF_ST_BIND(syms[k].st_info) != STB_GLOBAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(strtab + syms[k].st_name, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (syms[k].st_shndx == SHN_UNDEF ||\n\t\t\t    syms[k].st_shndx >= ehdr->e_shnum) {\n\t\t\t\tpr_debug(\"Symbol: %s has bad section index %d.\\n\",\n\t\t\t\t\t\tname, syms[k].st_shndx);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* Found the symbol we are looking for */\n\t\t\treturn &syms[k];\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic const Elf_Sym *kexec_purgatory_find_symbol(struct purgatory_info *pi,\n\t\t\t\t\t\t  const char *name)\n{\n\tconst Elf_Shdr *sechdrs;\n\tconst Elf_Ehdr *ehdr;\n\tconst Elf_Sym *syms;\n\tconst char *strtab;\n\tint i, k;\n\n\tif (!pi->ehdr)\n\t\treturn NULL;\n\n\tehdr = pi->ehdr;\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\n\tfor (i = 0; i < ehdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type != SHT_SYMTAB)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_link >= ehdr->e_shnum)\n\t\t\t/* Invalid strtab section number */\n\t\t\tcontinue;\n\t\tstrtab = (void *)ehdr + sechdrs[sechdrs[i].sh_link].sh_offset;\n\t\tsyms = (void *)ehdr + sechdrs[i].sh_offset;\n\n\t\t/* Go through symbols for a match */\n\t\tfor (k = 0; k < sechdrs[i].sh_size/sizeof(Elf_Sym); k++) {\n\t\t\tif (ELF_ST_BIND(syms[k].st_info) != STB_GLOBAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(strtab + syms[k].st_name, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (syms[k].st_shndx == SHN_UNDEF ||\n\t\t\t    syms[k].st_shndx >= ehdr->e_shnum) {\n\t\t\t\tpr_debug(\"Symbol: %s has bad section index %d.\\n\",\n\t\t\t\t\t\tname, syms[k].st_shndx);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* Found the symbol we are looking for */\n\t\t\treturn &syms[k];\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint kexec_purgatory_get_set_symbol(struct kimage *image, const char *name,\n\t\t\t\t   void *buf, unsigned int size, bool get_value)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Sym *sym;\n\tElf_Shdr *sec;\n\tchar *sym_buf;\n\n\tsym = kexec_purgatory_find_symbol(pi, name);\n\tif (!sym)\n\t\treturn -EINVAL;\n\n\tif (sym->st_size != size) {\n\t\tpr_err(\"symbol %s size mismatch: expected %lu actual %u\\n\",\n\t\t       name, (unsigned long)sym->st_size, size);\n\t\treturn -EINVAL;\n\t}\n\n\tsec = pi->sechdrs + sym->st_shndx;\n\n\tif (sec->sh_type == SHT_NOBITS) {\n\t\tpr_err(\"symbol %s is in a bss section. Cannot %s\\n\", name,\n\t\t       get_value ? \"get\" : \"set\");\n\t\treturn -EINVAL;\n\t}\n\n\tsym_buf = (char *)pi->purgatory_buf + sec->sh_offset + sym->st_value;\n\n\tif (get_value)\n\t\tmemcpy((void *)buf, sym_buf, size);\n\telse\n\t\tmemcpy((void *)sym_buf, buf, size);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kexec_purgatory_get_symbol_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "999-1016",
    "snippet": "void *kexec_purgatory_get_symbol_addr(struct kimage *image, const char *name)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Sym *sym;\n\tElf_Shdr *sechdr;\n\n\tsym = kexec_purgatory_find_symbol(pi, name);\n\tif (!sym)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsechdr = &pi->sechdrs[sym->st_shndx];\n\n\t/*\n\t * Returns the address where symbol will finally be loaded after\n\t * kexec_load_segment()\n\t */\n\treturn (void *)(sechdr->sh_addr + sym->st_value);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_purgatory_find_symbol",
          "args": [
            "pi",
            "name"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_purgatory_find_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "951-997",
          "snippet": "static const Elf_Sym *kexec_purgatory_find_symbol(struct purgatory_info *pi,\n\t\t\t\t\t\t  const char *name)\n{\n\tconst Elf_Shdr *sechdrs;\n\tconst Elf_Ehdr *ehdr;\n\tconst Elf_Sym *syms;\n\tconst char *strtab;\n\tint i, k;\n\n\tif (!pi->ehdr)\n\t\treturn NULL;\n\n\tehdr = pi->ehdr;\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\n\tfor (i = 0; i < ehdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type != SHT_SYMTAB)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_link >= ehdr->e_shnum)\n\t\t\t/* Invalid strtab section number */\n\t\t\tcontinue;\n\t\tstrtab = (void *)ehdr + sechdrs[sechdrs[i].sh_link].sh_offset;\n\t\tsyms = (void *)ehdr + sechdrs[i].sh_offset;\n\n\t\t/* Go through symbols for a match */\n\t\tfor (k = 0; k < sechdrs[i].sh_size/sizeof(Elf_Sym); k++) {\n\t\t\tif (ELF_ST_BIND(syms[k].st_info) != STB_GLOBAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(strtab + syms[k].st_name, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (syms[k].st_shndx == SHN_UNDEF ||\n\t\t\t    syms[k].st_shndx >= ehdr->e_shnum) {\n\t\t\t\tpr_debug(\"Symbol: %s has bad section index %d.\\n\",\n\t\t\t\t\t\tname, syms[k].st_shndx);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* Found the symbol we are looking for */\n\t\t\treturn &syms[k];\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic const Elf_Sym *kexec_purgatory_find_symbol(struct purgatory_info *pi,\n\t\t\t\t\t\t  const char *name)\n{\n\tconst Elf_Shdr *sechdrs;\n\tconst Elf_Ehdr *ehdr;\n\tconst Elf_Sym *syms;\n\tconst char *strtab;\n\tint i, k;\n\n\tif (!pi->ehdr)\n\t\treturn NULL;\n\n\tehdr = pi->ehdr;\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\n\tfor (i = 0; i < ehdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type != SHT_SYMTAB)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_link >= ehdr->e_shnum)\n\t\t\t/* Invalid strtab section number */\n\t\t\tcontinue;\n\t\tstrtab = (void *)ehdr + sechdrs[sechdrs[i].sh_link].sh_offset;\n\t\tsyms = (void *)ehdr + sechdrs[i].sh_offset;\n\n\t\t/* Go through symbols for a match */\n\t\tfor (k = 0; k < sechdrs[i].sh_size/sizeof(Elf_Sym); k++) {\n\t\t\tif (ELF_ST_BIND(syms[k].st_info) != STB_GLOBAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(strtab + syms[k].st_name, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (syms[k].st_shndx == SHN_UNDEF ||\n\t\t\t    syms[k].st_shndx >= ehdr->e_shnum) {\n\t\t\t\tpr_debug(\"Symbol: %s has bad section index %d.\\n\",\n\t\t\t\t\t\tname, syms[k].st_shndx);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* Found the symbol we are looking for */\n\t\t\treturn &syms[k];\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nvoid *kexec_purgatory_get_symbol_addr(struct kimage *image, const char *name)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Sym *sym;\n\tElf_Shdr *sechdr;\n\n\tsym = kexec_purgatory_find_symbol(pi, name);\n\tif (!sym)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsechdr = &pi->sechdrs[sym->st_shndx];\n\n\t/*\n\t * Returns the address where symbol will finally be loaded after\n\t * kexec_load_segment()\n\t */\n\treturn (void *)(sechdr->sh_addr + sym->st_value);\n}"
  },
  {
    "function_name": "kexec_purgatory_find_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "951-997",
    "snippet": "static const Elf_Sym *kexec_purgatory_find_symbol(struct purgatory_info *pi,\n\t\t\t\t\t\t  const char *name)\n{\n\tconst Elf_Shdr *sechdrs;\n\tconst Elf_Ehdr *ehdr;\n\tconst Elf_Sym *syms;\n\tconst char *strtab;\n\tint i, k;\n\n\tif (!pi->ehdr)\n\t\treturn NULL;\n\n\tehdr = pi->ehdr;\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\n\tfor (i = 0; i < ehdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type != SHT_SYMTAB)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_link >= ehdr->e_shnum)\n\t\t\t/* Invalid strtab section number */\n\t\t\tcontinue;\n\t\tstrtab = (void *)ehdr + sechdrs[sechdrs[i].sh_link].sh_offset;\n\t\tsyms = (void *)ehdr + sechdrs[i].sh_offset;\n\n\t\t/* Go through symbols for a match */\n\t\tfor (k = 0; k < sechdrs[i].sh_size/sizeof(Elf_Sym); k++) {\n\t\t\tif (ELF_ST_BIND(syms[k].st_info) != STB_GLOBAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(strtab + syms[k].st_name, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (syms[k].st_shndx == SHN_UNDEF ||\n\t\t\t    syms[k].st_shndx >= ehdr->e_shnum) {\n\t\t\t\tpr_debug(\"Symbol: %s has bad section index %d.\\n\",\n\t\t\t\t\t\tname, syms[k].st_shndx);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* Found the symbol we are looking for */\n\t\t\treturn &syms[k];\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Symbol: %s has bad section index %d.\\n\"",
            "name",
            "syms[k].st_shndx"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strtab + syms[k].st_name",
            "name"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_ST_BIND",
          "args": [
            "syms[k].st_info"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic const Elf_Sym *kexec_purgatory_find_symbol(struct purgatory_info *pi,\n\t\t\t\t\t\t  const char *name)\n{\n\tconst Elf_Shdr *sechdrs;\n\tconst Elf_Ehdr *ehdr;\n\tconst Elf_Sym *syms;\n\tconst char *strtab;\n\tint i, k;\n\n\tif (!pi->ehdr)\n\t\treturn NULL;\n\n\tehdr = pi->ehdr;\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\n\tfor (i = 0; i < ehdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type != SHT_SYMTAB)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_link >= ehdr->e_shnum)\n\t\t\t/* Invalid strtab section number */\n\t\t\tcontinue;\n\t\tstrtab = (void *)ehdr + sechdrs[sechdrs[i].sh_link].sh_offset;\n\t\tsyms = (void *)ehdr + sechdrs[i].sh_offset;\n\n\t\t/* Go through symbols for a match */\n\t\tfor (k = 0; k < sechdrs[i].sh_size/sizeof(Elf_Sym); k++) {\n\t\t\tif (ELF_ST_BIND(syms[k].st_info) != STB_GLOBAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(strtab + syms[k].st_name, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (syms[k].st_shndx == SHN_UNDEF ||\n\t\t\t    syms[k].st_shndx >= ehdr->e_shnum) {\n\t\t\t\tpr_debug(\"Symbol: %s has bad section index %d.\\n\",\n\t\t\t\t\t\tname, syms[k].st_shndx);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* Found the symbol we are looking for */\n\t\t\treturn &syms[k];\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "kexec_load_purgatory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "912-942",
    "snippet": "int kexec_load_purgatory(struct kimage *image, struct kexec_buf *kbuf)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tint ret;\n\n\tif (kexec_purgatory_size <= 0)\n\t\treturn -EINVAL;\n\n\tpi->ehdr = (const Elf_Ehdr *)kexec_purgatory;\n\n\tret = kexec_purgatory_setup_kbuf(pi, kbuf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kexec_purgatory_setup_sechdrs(pi, kbuf);\n\tif (ret)\n\t\tgoto out_free_kbuf;\n\n\tret = kexec_apply_relocations(image);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\nout_free_kbuf:\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "pi->purgatory_buf"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "pi->sechdrs"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_apply_relocations",
          "args": [
            "image"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_apply_relocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "841-899",
          "snippet": "static int kexec_apply_relocations(struct kimage *image)\n{\n\tint i, ret;\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Shdr *sechdrs;\n\n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tconst Elf_Shdr *relsec;\n\t\tconst Elf_Shdr *symtab;\n\t\tElf_Shdr *section;\n\n\t\trelsec = sechdrs + i;\n\n\t\tif (relsec->sh_type != SHT_RELA &&\n\t\t    relsec->sh_type != SHT_REL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For section of type SHT_RELA/SHT_REL,\n\t\t * ->sh_link contains section header index of associated\n\t\t * symbol table. And ->sh_info contains section header\n\t\t * index of section to which relocations apply.\n\t\t */\n\t\tif (relsec->sh_info >= pi->ehdr->e_shnum ||\n\t\t    relsec->sh_link >= pi->ehdr->e_shnum)\n\t\t\treturn -ENOEXEC;\n\n\t\tsection = pi->sechdrs + relsec->sh_info;\n\t\tsymtab = sechdrs + relsec->sh_link;\n\n\t\tif (!(section->sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * symtab->sh_link contain section header index of associated\n\t\t * string table.\n\t\t */\n\t\tif (symtab->sh_link >= pi->ehdr->e_shnum)\n\t\t\t/* Invalid section number? */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Respective architecture needs to provide support for applying\n\t\t * relocations of type SHT_RELA/SHT_REL.\n\t\t */\n\t\tif (relsec->sh_type == SHT_RELA)\n\t\t\tret = arch_kexec_apply_relocations_add(pi, section,\n\t\t\t\t\t\t\t       relsec, symtab);\n\t\telse if (relsec->sh_type == SHT_REL)\n\t\t\tret = arch_kexec_apply_relocations(pi, section,\n\t\t\t\t\t\t\t   relsec, symtab);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int kexec_apply_relocations(struct kimage *image)\n{\n\tint i, ret;\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Shdr *sechdrs;\n\n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tconst Elf_Shdr *relsec;\n\t\tconst Elf_Shdr *symtab;\n\t\tElf_Shdr *section;\n\n\t\trelsec = sechdrs + i;\n\n\t\tif (relsec->sh_type != SHT_RELA &&\n\t\t    relsec->sh_type != SHT_REL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For section of type SHT_RELA/SHT_REL,\n\t\t * ->sh_link contains section header index of associated\n\t\t * symbol table. And ->sh_info contains section header\n\t\t * index of section to which relocations apply.\n\t\t */\n\t\tif (relsec->sh_info >= pi->ehdr->e_shnum ||\n\t\t    relsec->sh_link >= pi->ehdr->e_shnum)\n\t\t\treturn -ENOEXEC;\n\n\t\tsection = pi->sechdrs + relsec->sh_info;\n\t\tsymtab = sechdrs + relsec->sh_link;\n\n\t\tif (!(section->sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * symtab->sh_link contain section header index of associated\n\t\t * string table.\n\t\t */\n\t\tif (symtab->sh_link >= pi->ehdr->e_shnum)\n\t\t\t/* Invalid section number? */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Respective architecture needs to provide support for applying\n\t\t * relocations of type SHT_RELA/SHT_REL.\n\t\t */\n\t\tif (relsec->sh_type == SHT_RELA)\n\t\t\tret = arch_kexec_apply_relocations_add(pi, section,\n\t\t\t\t\t\t\t       relsec, symtab);\n\t\telse if (relsec->sh_type == SHT_REL)\n\t\t\tret = arch_kexec_apply_relocations(pi, section,\n\t\t\t\t\t\t\t   relsec, symtab);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kexec_purgatory_setup_sechdrs",
          "args": [
            "pi",
            "kbuf"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_purgatory_setup_sechdrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "782-839",
          "snippet": "static int kexec_purgatory_setup_sechdrs(struct purgatory_info *pi,\n\t\t\t\t\t struct kexec_buf *kbuf)\n{\n\tunsigned long bss_addr;\n\tunsigned long offset;\n\tElf_Shdr *sechdrs;\n\tint i;\n\n\t/*\n\t * The section headers in kexec_purgatory are read-only. In order to\n\t * have them modifiable make a temporary copy.\n\t */\n\tsechdrs = vzalloc(array_size(sizeof(Elf_Shdr), pi->ehdr->e_shnum));\n\tif (!sechdrs)\n\t\treturn -ENOMEM;\n\tmemcpy(sechdrs, (void *)pi->ehdr + pi->ehdr->e_shoff,\n\t       pi->ehdr->e_shnum * sizeof(Elf_Shdr));\n\tpi->sechdrs = sechdrs;\n\n\toffset = 0;\n\tbss_addr = kbuf->mem + kbuf->bufsz;\n\tkbuf->image->start = pi->ehdr->e_entry;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tunsigned long align;\n\t\tvoid *src, *dst;\n\n\t\tif (!(sechdrs[i].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\talign = sechdrs[i].sh_addralign;\n\t\tif (sechdrs[i].sh_type == SHT_NOBITS) {\n\t\t\tbss_addr = ALIGN(bss_addr, align);\n\t\t\tsechdrs[i].sh_addr = bss_addr;\n\t\t\tbss_addr += sechdrs[i].sh_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\toffset = ALIGN(offset, align);\n\t\tif (sechdrs[i].sh_flags & SHF_EXECINSTR &&\n\t\t    pi->ehdr->e_entry >= sechdrs[i].sh_addr &&\n\t\t    pi->ehdr->e_entry < (sechdrs[i].sh_addr\n\t\t\t\t\t + sechdrs[i].sh_size)) {\n\t\t\tkbuf->image->start -= sechdrs[i].sh_addr;\n\t\t\tkbuf->image->start += kbuf->mem + offset;\n\t\t}\n\n\t\tsrc = (void *)pi->ehdr + sechdrs[i].sh_offset;\n\t\tdst = pi->purgatory_buf + offset;\n\t\tmemcpy(dst, src, sechdrs[i].sh_size);\n\n\t\tsechdrs[i].sh_addr = kbuf->mem + offset;\n\t\tsechdrs[i].sh_offset = offset;\n\t\toffset += sechdrs[i].sh_size;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int kexec_purgatory_setup_sechdrs(struct purgatory_info *pi,\n\t\t\t\t\t struct kexec_buf *kbuf)\n{\n\tunsigned long bss_addr;\n\tunsigned long offset;\n\tElf_Shdr *sechdrs;\n\tint i;\n\n\t/*\n\t * The section headers in kexec_purgatory are read-only. In order to\n\t * have them modifiable make a temporary copy.\n\t */\n\tsechdrs = vzalloc(array_size(sizeof(Elf_Shdr), pi->ehdr->e_shnum));\n\tif (!sechdrs)\n\t\treturn -ENOMEM;\n\tmemcpy(sechdrs, (void *)pi->ehdr + pi->ehdr->e_shoff,\n\t       pi->ehdr->e_shnum * sizeof(Elf_Shdr));\n\tpi->sechdrs = sechdrs;\n\n\toffset = 0;\n\tbss_addr = kbuf->mem + kbuf->bufsz;\n\tkbuf->image->start = pi->ehdr->e_entry;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tunsigned long align;\n\t\tvoid *src, *dst;\n\n\t\tif (!(sechdrs[i].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\talign = sechdrs[i].sh_addralign;\n\t\tif (sechdrs[i].sh_type == SHT_NOBITS) {\n\t\t\tbss_addr = ALIGN(bss_addr, align);\n\t\t\tsechdrs[i].sh_addr = bss_addr;\n\t\t\tbss_addr += sechdrs[i].sh_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\toffset = ALIGN(offset, align);\n\t\tif (sechdrs[i].sh_flags & SHF_EXECINSTR &&\n\t\t    pi->ehdr->e_entry >= sechdrs[i].sh_addr &&\n\t\t    pi->ehdr->e_entry < (sechdrs[i].sh_addr\n\t\t\t\t\t + sechdrs[i].sh_size)) {\n\t\t\tkbuf->image->start -= sechdrs[i].sh_addr;\n\t\t\tkbuf->image->start += kbuf->mem + offset;\n\t\t}\n\n\t\tsrc = (void *)pi->ehdr + sechdrs[i].sh_offset;\n\t\tdst = pi->purgatory_buf + offset;\n\t\tmemcpy(dst, src, sechdrs[i].sh_size);\n\n\t\tsechdrs[i].sh_addr = kbuf->mem + offset;\n\t\tsechdrs[i].sh_offset = offset;\n\t\toffset += sechdrs[i].sh_size;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kexec_purgatory_setup_kbuf",
          "args": [
            "pi",
            "kbuf"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_purgatory_setup_kbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "721-770",
          "snippet": "static int kexec_purgatory_setup_kbuf(struct purgatory_info *pi,\n\t\t\t\t      struct kexec_buf *kbuf)\n{\n\tconst Elf_Shdr *sechdrs;\n\tunsigned long bss_align;\n\tunsigned long bss_sz;\n\tunsigned long align;\n\tint i, ret;\n\n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\tkbuf->buf_align = bss_align = 1;\n\tkbuf->bufsz = bss_sz = 0;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tif (!(sechdrs[i].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\talign = sechdrs[i].sh_addralign;\n\t\tif (sechdrs[i].sh_type != SHT_NOBITS) {\n\t\t\tif (kbuf->buf_align < align)\n\t\t\t\tkbuf->buf_align = align;\n\t\t\tkbuf->bufsz = ALIGN(kbuf->bufsz, align);\n\t\t\tkbuf->bufsz += sechdrs[i].sh_size;\n\t\t} else {\n\t\t\tif (bss_align < align)\n\t\t\t\tbss_align = align;\n\t\t\tbss_sz = ALIGN(bss_sz, align);\n\t\t\tbss_sz += sechdrs[i].sh_size;\n\t\t}\n\t}\n\tkbuf->bufsz = ALIGN(kbuf->bufsz, bss_align);\n\tkbuf->memsz = kbuf->bufsz + bss_sz;\n\tif (kbuf->buf_align < bss_align)\n\t\tkbuf->buf_align = bss_align;\n\n\tkbuf->buffer = vzalloc(kbuf->bufsz);\n\tif (!kbuf->buffer)\n\t\treturn -ENOMEM;\n\tpi->purgatory_buf = kbuf->buffer;\n\n\tret = kexec_add_buffer(kbuf);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_purgatory_setup_kbuf(struct purgatory_info *pi,\n\t\t\t\t      struct kexec_buf *kbuf)\n{\n\tconst Elf_Shdr *sechdrs;\n\tunsigned long bss_align;\n\tunsigned long bss_sz;\n\tunsigned long align;\n\tint i, ret;\n\n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\tkbuf->buf_align = bss_align = 1;\n\tkbuf->bufsz = bss_sz = 0;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tif (!(sechdrs[i].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\talign = sechdrs[i].sh_addralign;\n\t\tif (sechdrs[i].sh_type != SHT_NOBITS) {\n\t\t\tif (kbuf->buf_align < align)\n\t\t\t\tkbuf->buf_align = align;\n\t\t\tkbuf->bufsz = ALIGN(kbuf->bufsz, align);\n\t\t\tkbuf->bufsz += sechdrs[i].sh_size;\n\t\t} else {\n\t\t\tif (bss_align < align)\n\t\t\t\tbss_align = align;\n\t\t\tbss_sz = ALIGN(bss_sz, align);\n\t\t\tbss_sz += sechdrs[i].sh_size;\n\t\t}\n\t}\n\tkbuf->bufsz = ALIGN(kbuf->bufsz, bss_align);\n\tkbuf->memsz = kbuf->bufsz + bss_sz;\n\tif (kbuf->buf_align < bss_align)\n\t\tkbuf->buf_align = bss_align;\n\n\tkbuf->buffer = vzalloc(kbuf->bufsz);\n\tif (!kbuf->buffer)\n\t\treturn -ENOMEM;\n\tpi->purgatory_buf = kbuf->buffer;\n\n\tret = kexec_add_buffer(kbuf);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint kexec_load_purgatory(struct kimage *image, struct kexec_buf *kbuf)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tint ret;\n\n\tif (kexec_purgatory_size <= 0)\n\t\treturn -EINVAL;\n\n\tpi->ehdr = (const Elf_Ehdr *)kexec_purgatory;\n\n\tret = kexec_purgatory_setup_kbuf(pi, kbuf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kexec_purgatory_setup_sechdrs(pi, kbuf);\n\tif (ret)\n\t\tgoto out_free_kbuf;\n\n\tret = kexec_apply_relocations(image);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\nout_free_kbuf:\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "kexec_apply_relocations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "841-899",
    "snippet": "static int kexec_apply_relocations(struct kimage *image)\n{\n\tint i, ret;\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Shdr *sechdrs;\n\n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tconst Elf_Shdr *relsec;\n\t\tconst Elf_Shdr *symtab;\n\t\tElf_Shdr *section;\n\n\t\trelsec = sechdrs + i;\n\n\t\tif (relsec->sh_type != SHT_RELA &&\n\t\t    relsec->sh_type != SHT_REL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For section of type SHT_RELA/SHT_REL,\n\t\t * ->sh_link contains section header index of associated\n\t\t * symbol table. And ->sh_info contains section header\n\t\t * index of section to which relocations apply.\n\t\t */\n\t\tif (relsec->sh_info >= pi->ehdr->e_shnum ||\n\t\t    relsec->sh_link >= pi->ehdr->e_shnum)\n\t\t\treturn -ENOEXEC;\n\n\t\tsection = pi->sechdrs + relsec->sh_info;\n\t\tsymtab = sechdrs + relsec->sh_link;\n\n\t\tif (!(section->sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * symtab->sh_link contain section header index of associated\n\t\t * string table.\n\t\t */\n\t\tif (symtab->sh_link >= pi->ehdr->e_shnum)\n\t\t\t/* Invalid section number? */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Respective architecture needs to provide support for applying\n\t\t * relocations of type SHT_RELA/SHT_REL.\n\t\t */\n\t\tif (relsec->sh_type == SHT_RELA)\n\t\t\tret = arch_kexec_apply_relocations_add(pi, section,\n\t\t\t\t\t\t\t       relsec, symtab);\n\t\telse if (relsec->sh_type == SHT_REL)\n\t\t\tret = arch_kexec_apply_relocations(pi, section,\n\t\t\t\t\t\t\t   relsec, symtab);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kexec_apply_relocations",
          "args": [
            "pi",
            "section",
            "relsec",
            "symtab"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kexec_apply_relocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "137-143",
          "snippet": "int __weak\narch_kexec_apply_relocations(struct purgatory_info *pi, Elf_Shdr *section,\n\t\t\t     const Elf_Shdr *relsec, const Elf_Shdr *symtab)\n{\n\tpr_err(\"REL relocation unsupported.\\n\");\n\treturn -ENOEXEC;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint __weak\narch_kexec_apply_relocations(struct purgatory_info *pi, Elf_Shdr *section,\n\t\t\t     const Elf_Shdr *relsec, const Elf_Shdr *symtab)\n{\n\tpr_err(\"REL relocation unsupported.\\n\");\n\treturn -ENOEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_kexec_apply_relocations_add",
          "args": [
            "pi",
            "section",
            "relsec",
            "symtab"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kexec_apply_relocations_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "120-126",
          "snippet": "int __weak\narch_kexec_apply_relocations_add(struct purgatory_info *pi, Elf_Shdr *section,\n\t\t\t\t const Elf_Shdr *relsec, const Elf_Shdr *symtab)\n{\n\tpr_err(\"RELA relocation unsupported.\\n\");\n\treturn -ENOEXEC;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint __weak\narch_kexec_apply_relocations_add(struct purgatory_info *pi, Elf_Shdr *section,\n\t\t\t\t const Elf_Shdr *relsec, const Elf_Shdr *symtab)\n{\n\tpr_err(\"RELA relocation unsupported.\\n\");\n\treturn -ENOEXEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int kexec_apply_relocations(struct kimage *image)\n{\n\tint i, ret;\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Shdr *sechdrs;\n\n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tconst Elf_Shdr *relsec;\n\t\tconst Elf_Shdr *symtab;\n\t\tElf_Shdr *section;\n\n\t\trelsec = sechdrs + i;\n\n\t\tif (relsec->sh_type != SHT_RELA &&\n\t\t    relsec->sh_type != SHT_REL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For section of type SHT_RELA/SHT_REL,\n\t\t * ->sh_link contains section header index of associated\n\t\t * symbol table. And ->sh_info contains section header\n\t\t * index of section to which relocations apply.\n\t\t */\n\t\tif (relsec->sh_info >= pi->ehdr->e_shnum ||\n\t\t    relsec->sh_link >= pi->ehdr->e_shnum)\n\t\t\treturn -ENOEXEC;\n\n\t\tsection = pi->sechdrs + relsec->sh_info;\n\t\tsymtab = sechdrs + relsec->sh_link;\n\n\t\tif (!(section->sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * symtab->sh_link contain section header index of associated\n\t\t * string table.\n\t\t */\n\t\tif (symtab->sh_link >= pi->ehdr->e_shnum)\n\t\t\t/* Invalid section number? */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Respective architecture needs to provide support for applying\n\t\t * relocations of type SHT_RELA/SHT_REL.\n\t\t */\n\t\tif (relsec->sh_type == SHT_RELA)\n\t\t\tret = arch_kexec_apply_relocations_add(pi, section,\n\t\t\t\t\t\t\t       relsec, symtab);\n\t\telse if (relsec->sh_type == SHT_REL)\n\t\t\tret = arch_kexec_apply_relocations(pi, section,\n\t\t\t\t\t\t\t   relsec, symtab);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kexec_purgatory_setup_sechdrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "782-839",
    "snippet": "static int kexec_purgatory_setup_sechdrs(struct purgatory_info *pi,\n\t\t\t\t\t struct kexec_buf *kbuf)\n{\n\tunsigned long bss_addr;\n\tunsigned long offset;\n\tElf_Shdr *sechdrs;\n\tint i;\n\n\t/*\n\t * The section headers in kexec_purgatory are read-only. In order to\n\t * have them modifiable make a temporary copy.\n\t */\n\tsechdrs = vzalloc(array_size(sizeof(Elf_Shdr), pi->ehdr->e_shnum));\n\tif (!sechdrs)\n\t\treturn -ENOMEM;\n\tmemcpy(sechdrs, (void *)pi->ehdr + pi->ehdr->e_shoff,\n\t       pi->ehdr->e_shnum * sizeof(Elf_Shdr));\n\tpi->sechdrs = sechdrs;\n\n\toffset = 0;\n\tbss_addr = kbuf->mem + kbuf->bufsz;\n\tkbuf->image->start = pi->ehdr->e_entry;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tunsigned long align;\n\t\tvoid *src, *dst;\n\n\t\tif (!(sechdrs[i].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\talign = sechdrs[i].sh_addralign;\n\t\tif (sechdrs[i].sh_type == SHT_NOBITS) {\n\t\t\tbss_addr = ALIGN(bss_addr, align);\n\t\t\tsechdrs[i].sh_addr = bss_addr;\n\t\t\tbss_addr += sechdrs[i].sh_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\toffset = ALIGN(offset, align);\n\t\tif (sechdrs[i].sh_flags & SHF_EXECINSTR &&\n\t\t    pi->ehdr->e_entry >= sechdrs[i].sh_addr &&\n\t\t    pi->ehdr->e_entry < (sechdrs[i].sh_addr\n\t\t\t\t\t + sechdrs[i].sh_size)) {\n\t\t\tkbuf->image->start -= sechdrs[i].sh_addr;\n\t\t\tkbuf->image->start += kbuf->mem + offset;\n\t\t}\n\n\t\tsrc = (void *)pi->ehdr + sechdrs[i].sh_offset;\n\t\tdst = pi->purgatory_buf + offset;\n\t\tmemcpy(dst, src, sechdrs[i].sh_size);\n\n\t\tsechdrs[i].sh_addr = kbuf->mem + offset;\n\t\tsechdrs[i].sh_offset = offset;\n\t\toffset += sechdrs[i].sh_size;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "sechdrs[i].sh_size"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "offset",
            "align"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "bss_addr",
            "align"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "array_size(sizeof(Elf_Shdr), pi->ehdr->e_shnum)"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "sizeof(Elf_Shdr)",
            "pi->ehdr->e_shnum"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int kexec_purgatory_setup_sechdrs(struct purgatory_info *pi,\n\t\t\t\t\t struct kexec_buf *kbuf)\n{\n\tunsigned long bss_addr;\n\tunsigned long offset;\n\tElf_Shdr *sechdrs;\n\tint i;\n\n\t/*\n\t * The section headers in kexec_purgatory are read-only. In order to\n\t * have them modifiable make a temporary copy.\n\t */\n\tsechdrs = vzalloc(array_size(sizeof(Elf_Shdr), pi->ehdr->e_shnum));\n\tif (!sechdrs)\n\t\treturn -ENOMEM;\n\tmemcpy(sechdrs, (void *)pi->ehdr + pi->ehdr->e_shoff,\n\t       pi->ehdr->e_shnum * sizeof(Elf_Shdr));\n\tpi->sechdrs = sechdrs;\n\n\toffset = 0;\n\tbss_addr = kbuf->mem + kbuf->bufsz;\n\tkbuf->image->start = pi->ehdr->e_entry;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tunsigned long align;\n\t\tvoid *src, *dst;\n\n\t\tif (!(sechdrs[i].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\talign = sechdrs[i].sh_addralign;\n\t\tif (sechdrs[i].sh_type == SHT_NOBITS) {\n\t\t\tbss_addr = ALIGN(bss_addr, align);\n\t\t\tsechdrs[i].sh_addr = bss_addr;\n\t\t\tbss_addr += sechdrs[i].sh_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\toffset = ALIGN(offset, align);\n\t\tif (sechdrs[i].sh_flags & SHF_EXECINSTR &&\n\t\t    pi->ehdr->e_entry >= sechdrs[i].sh_addr &&\n\t\t    pi->ehdr->e_entry < (sechdrs[i].sh_addr\n\t\t\t\t\t + sechdrs[i].sh_size)) {\n\t\t\tkbuf->image->start -= sechdrs[i].sh_addr;\n\t\t\tkbuf->image->start += kbuf->mem + offset;\n\t\t}\n\n\t\tsrc = (void *)pi->ehdr + sechdrs[i].sh_offset;\n\t\tdst = pi->purgatory_buf + offset;\n\t\tmemcpy(dst, src, sechdrs[i].sh_size);\n\n\t\tsechdrs[i].sh_addr = kbuf->mem + offset;\n\t\tsechdrs[i].sh_offset = offset;\n\t\toffset += sechdrs[i].sh_size;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kexec_purgatory_setup_kbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "721-770",
    "snippet": "static int kexec_purgatory_setup_kbuf(struct purgatory_info *pi,\n\t\t\t\t      struct kexec_buf *kbuf)\n{\n\tconst Elf_Shdr *sechdrs;\n\tunsigned long bss_align;\n\tunsigned long bss_sz;\n\tunsigned long align;\n\tint i, ret;\n\n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\tkbuf->buf_align = bss_align = 1;\n\tkbuf->bufsz = bss_sz = 0;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tif (!(sechdrs[i].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\talign = sechdrs[i].sh_addralign;\n\t\tif (sechdrs[i].sh_type != SHT_NOBITS) {\n\t\t\tif (kbuf->buf_align < align)\n\t\t\t\tkbuf->buf_align = align;\n\t\t\tkbuf->bufsz = ALIGN(kbuf->bufsz, align);\n\t\t\tkbuf->bufsz += sechdrs[i].sh_size;\n\t\t} else {\n\t\t\tif (bss_align < align)\n\t\t\t\tbss_align = align;\n\t\t\tbss_sz = ALIGN(bss_sz, align);\n\t\t\tbss_sz += sechdrs[i].sh_size;\n\t\t}\n\t}\n\tkbuf->bufsz = ALIGN(kbuf->bufsz, bss_align);\n\tkbuf->memsz = kbuf->bufsz + bss_sz;\n\tif (kbuf->buf_align < bss_align)\n\t\tkbuf->buf_align = bss_align;\n\n\tkbuf->buffer = vzalloc(kbuf->bufsz);\n\tif (!kbuf->buffer)\n\t\treturn -ENOMEM;\n\tpi->purgatory_buf = kbuf->buffer;\n\n\tret = kexec_add_buffer(kbuf);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "pi->purgatory_buf"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_add_buffer",
          "args": [
            "kbuf"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_add_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "550-592",
          "snippet": "int kexec_add_buffer(struct kexec_buf *kbuf)\n{\n\n\tstruct kexec_segment *ksegment;\n\tint ret;\n\n\t/* Currently adding segment this way is allowed only in file mode */\n\tif (!kbuf->image->file_mode)\n\t\treturn -EINVAL;\n\n\tif (kbuf->image->nr_segments >= KEXEC_SEGMENT_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Make sure we are not trying to add buffer after allocating\n\t * control pages. All segments need to be placed first before\n\t * any control pages are allocated. As control page allocation\n\t * logic goes through list of segments to make sure there are\n\t * no destination overlaps.\n\t */\n\tif (!list_empty(&kbuf->image->control_pages)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure minimum alignment needed for segments. */\n\tkbuf->memsz = ALIGN(kbuf->memsz, PAGE_SIZE);\n\tkbuf->buf_align = max(kbuf->buf_align, PAGE_SIZE);\n\n\t/* Walk the RAM ranges and allocate a suitable range for the buffer */\n\tret = kexec_locate_mem_hole(kbuf);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Found a suitable memory range */\n\tksegment = &kbuf->image->segment[kbuf->image->nr_segments];\n\tksegment->kbuf = kbuf->buffer;\n\tksegment->bufsz = kbuf->bufsz;\n\tksegment->mem = kbuf->mem;\n\tksegment->memsz = kbuf->memsz;\n\tkbuf->image->nr_segments++;\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint kexec_add_buffer(struct kexec_buf *kbuf)\n{\n\n\tstruct kexec_segment *ksegment;\n\tint ret;\n\n\t/* Currently adding segment this way is allowed only in file mode */\n\tif (!kbuf->image->file_mode)\n\t\treturn -EINVAL;\n\n\tif (kbuf->image->nr_segments >= KEXEC_SEGMENT_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Make sure we are not trying to add buffer after allocating\n\t * control pages. All segments need to be placed first before\n\t * any control pages are allocated. As control page allocation\n\t * logic goes through list of segments to make sure there are\n\t * no destination overlaps.\n\t */\n\tif (!list_empty(&kbuf->image->control_pages)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure minimum alignment needed for segments. */\n\tkbuf->memsz = ALIGN(kbuf->memsz, PAGE_SIZE);\n\tkbuf->buf_align = max(kbuf->buf_align, PAGE_SIZE);\n\n\t/* Walk the RAM ranges and allocate a suitable range for the buffer */\n\tret = kexec_locate_mem_hole(kbuf);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Found a suitable memory range */\n\tksegment = &kbuf->image->segment[kbuf->image->nr_segments];\n\tksegment->kbuf = kbuf->buffer;\n\tksegment->bufsz = kbuf->bufsz;\n\tksegment->mem = kbuf->mem;\n\tksegment->memsz = kbuf->memsz;\n\tkbuf->image->nr_segments++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "kbuf->bufsz"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "kbuf->bufsz",
            "bss_align"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "bss_sz",
            "align"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "kbuf->bufsz",
            "align"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_purgatory_setup_kbuf(struct purgatory_info *pi,\n\t\t\t\t      struct kexec_buf *kbuf)\n{\n\tconst Elf_Shdr *sechdrs;\n\tunsigned long bss_align;\n\tunsigned long bss_sz;\n\tunsigned long align;\n\tint i, ret;\n\n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\tkbuf->buf_align = bss_align = 1;\n\tkbuf->bufsz = bss_sz = 0;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tif (!(sechdrs[i].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\talign = sechdrs[i].sh_addralign;\n\t\tif (sechdrs[i].sh_type != SHT_NOBITS) {\n\t\t\tif (kbuf->buf_align < align)\n\t\t\t\tkbuf->buf_align = align;\n\t\t\tkbuf->bufsz = ALIGN(kbuf->bufsz, align);\n\t\t\tkbuf->bufsz += sechdrs[i].sh_size;\n\t\t} else {\n\t\t\tif (bss_align < align)\n\t\t\t\tbss_align = align;\n\t\t\tbss_sz = ALIGN(bss_sz, align);\n\t\t\tbss_sz += sechdrs[i].sh_size;\n\t\t}\n\t}\n\tkbuf->bufsz = ALIGN(kbuf->bufsz, bss_align);\n\tkbuf->memsz = kbuf->bufsz + bss_sz;\n\tif (kbuf->buf_align < bss_align)\n\t\tkbuf->buf_align = bss_align;\n\n\tkbuf->buffer = vzalloc(kbuf->bufsz);\n\tif (!kbuf->buffer)\n\t\treturn -ENOMEM;\n\tpi->purgatory_buf = kbuf->buffer;\n\n\tret = kexec_add_buffer(kbuf);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "kexec_calculate_store_digests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "595-708",
    "snippet": "static int kexec_calculate_store_digests(struct kimage *image)\n{\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *desc;\n\tint ret = 0, i, j, zero_buf_sz, sha_region_sz;\n\tsize_t desc_size, nullsz;\n\tchar *digest;\n\tvoid *zero_buf;\n\tstruct kexec_sha_region *sha_regions;\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_KEXEC_PURGATORY))\n\t\treturn 0;\n\n\tzero_buf = __va(page_to_pfn(ZERO_PAGE(0)) << PAGE_SHIFT);\n\tzero_buf_sz = PAGE_SIZE;\n\n\ttfm = crypto_alloc_shash(\"sha256\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out;\n\t}\n\n\tdesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\n\tdesc = kzalloc(desc_size, GFP_KERNEL);\n\tif (!desc) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_tfm;\n\t}\n\n\tsha_region_sz = KEXEC_SEGMENT_MAX * sizeof(struct kexec_sha_region);\n\tsha_regions = vzalloc(sha_region_sz);\n\tif (!sha_regions)\n\t\tgoto out_free_desc;\n\n\tdesc->tfm   = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0)\n\t\tgoto out_free_sha_regions;\n\n\tdigest = kzalloc(SHA256_DIGEST_SIZE, GFP_KERNEL);\n\tif (!digest) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_sha_regions;\n\t}\n\n\tfor (j = i = 0; i < image->nr_segments; i++) {\n\t\tstruct kexec_segment *ksegment;\n\n\t\tksegment = &image->segment[i];\n\t\t/*\n\t\t * Skip purgatory as it will be modified once we put digest\n\t\t * info in purgatory.\n\t\t */\n\t\tif (ksegment->kbuf == pi->purgatory_buf)\n\t\t\tcontinue;\n\n\t\tret = crypto_shash_update(desc, ksegment->kbuf,\n\t\t\t\t\t  ksegment->bufsz);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Assume rest of the buffer is filled with zero and\n\t\t * update digest accordingly.\n\t\t */\n\t\tnullsz = ksegment->memsz - ksegment->bufsz;\n\t\twhile (nullsz) {\n\t\t\tunsigned long bytes = nullsz;\n\n\t\t\tif (bytes > zero_buf_sz)\n\t\t\t\tbytes = zero_buf_sz;\n\t\t\tret = crypto_shash_update(desc, zero_buf, bytes);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tnullsz -= bytes;\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tsha_regions[j].start = ksegment->mem;\n\t\tsha_regions[j].len = ksegment->memsz;\n\t\tj++;\n\t}\n\n\tif (!ret) {\n\t\tret = crypto_shash_final(desc, digest);\n\t\tif (ret)\n\t\t\tgoto out_free_digest;\n\t\tret = kexec_purgatory_get_set_symbol(image, \"purgatory_sha_regions\",\n\t\t\t\t\t\t     sha_regions, sha_region_sz, 0);\n\t\tif (ret)\n\t\t\tgoto out_free_digest;\n\n\t\tret = kexec_purgatory_get_set_symbol(image, \"purgatory_sha256_digest\",\n\t\t\t\t\t\t     digest, SHA256_DIGEST_SIZE, 0);\n\t\tif (ret)\n\t\t\tgoto out_free_digest;\n\t}\n\nout_free_digest:\n\tkfree(digest);\nout_free_sha_regions:\n\tvfree(sha_regions);\nout_free_desc:\n\tkfree(desc);\nout_free_tfm:\n\tkfree(tfm);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tfm"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "sha_regions"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_purgatory_get_set_symbol",
          "args": [
            "image",
            "\"purgatory_sha256_digest\"",
            "digest",
            "SHA256_DIGEST_SIZE",
            "0"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_purgatory_get_set_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "1022-1056",
          "snippet": "int kexec_purgatory_get_set_symbol(struct kimage *image, const char *name,\n\t\t\t\t   void *buf, unsigned int size, bool get_value)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Sym *sym;\n\tElf_Shdr *sec;\n\tchar *sym_buf;\n\n\tsym = kexec_purgatory_find_symbol(pi, name);\n\tif (!sym)\n\t\treturn -EINVAL;\n\n\tif (sym->st_size != size) {\n\t\tpr_err(\"symbol %s size mismatch: expected %lu actual %u\\n\",\n\t\t       name, (unsigned long)sym->st_size, size);\n\t\treturn -EINVAL;\n\t}\n\n\tsec = pi->sechdrs + sym->st_shndx;\n\n\tif (sec->sh_type == SHT_NOBITS) {\n\t\tpr_err(\"symbol %s is in a bss section. Cannot %s\\n\", name,\n\t\t       get_value ? \"get\" : \"set\");\n\t\treturn -EINVAL;\n\t}\n\n\tsym_buf = (char *)pi->purgatory_buf + sec->sh_offset + sym->st_value;\n\n\tif (get_value)\n\t\tmemcpy((void *)buf, sym_buf, size);\n\telse\n\t\tmemcpy((void *)sym_buf, buf, size);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint kexec_purgatory_get_set_symbol(struct kimage *image, const char *name,\n\t\t\t\t   void *buf, unsigned int size, bool get_value)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Sym *sym;\n\tElf_Shdr *sec;\n\tchar *sym_buf;\n\n\tsym = kexec_purgatory_find_symbol(pi, name);\n\tif (!sym)\n\t\treturn -EINVAL;\n\n\tif (sym->st_size != size) {\n\t\tpr_err(\"symbol %s size mismatch: expected %lu actual %u\\n\",\n\t\t       name, (unsigned long)sym->st_size, size);\n\t\treturn -EINVAL;\n\t}\n\n\tsec = pi->sechdrs + sym->st_shndx;\n\n\tif (sec->sh_type == SHT_NOBITS) {\n\t\tpr_err(\"symbol %s is in a bss section. Cannot %s\\n\", name,\n\t\t       get_value ? \"get\" : \"set\");\n\t\treturn -EINVAL;\n\t}\n\n\tsym_buf = (char *)pi->purgatory_buf + sec->sh_offset + sym->st_value;\n\n\tif (get_value)\n\t\tmemcpy((void *)buf, sym_buf, size);\n\telse\n\t\tmemcpy((void *)sym_buf, buf, size);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "desc",
            "digest"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "desc",
            "zero_buf",
            "bytes"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "desc",
            "ksegment->kbuf",
            "ksegment->bufsz"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "SHA256_DIGEST_SIZE",
            "GFP_KERNEL"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "desc"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "sha_region_sz"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "desc_size",
            "GFP_KERNEL"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_descsize",
          "args": [
            "tfm"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "\"sha256\"",
            "0",
            "0"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "page_to_pfn(ZERO_PAGE(0)) << PAGE_SHIFT"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "__var_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "152-155",
          "snippet": "wait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "ZERO_PAGE(0)"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_KEXEC_PURGATORY"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int kexec_calculate_store_digests(struct kimage *image)\n{\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *desc;\n\tint ret = 0, i, j, zero_buf_sz, sha_region_sz;\n\tsize_t desc_size, nullsz;\n\tchar *digest;\n\tvoid *zero_buf;\n\tstruct kexec_sha_region *sha_regions;\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_KEXEC_PURGATORY))\n\t\treturn 0;\n\n\tzero_buf = __va(page_to_pfn(ZERO_PAGE(0)) << PAGE_SHIFT);\n\tzero_buf_sz = PAGE_SIZE;\n\n\ttfm = crypto_alloc_shash(\"sha256\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out;\n\t}\n\n\tdesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\n\tdesc = kzalloc(desc_size, GFP_KERNEL);\n\tif (!desc) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_tfm;\n\t}\n\n\tsha_region_sz = KEXEC_SEGMENT_MAX * sizeof(struct kexec_sha_region);\n\tsha_regions = vzalloc(sha_region_sz);\n\tif (!sha_regions)\n\t\tgoto out_free_desc;\n\n\tdesc->tfm   = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0)\n\t\tgoto out_free_sha_regions;\n\n\tdigest = kzalloc(SHA256_DIGEST_SIZE, GFP_KERNEL);\n\tif (!digest) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_sha_regions;\n\t}\n\n\tfor (j = i = 0; i < image->nr_segments; i++) {\n\t\tstruct kexec_segment *ksegment;\n\n\t\tksegment = &image->segment[i];\n\t\t/*\n\t\t * Skip purgatory as it will be modified once we put digest\n\t\t * info in purgatory.\n\t\t */\n\t\tif (ksegment->kbuf == pi->purgatory_buf)\n\t\t\tcontinue;\n\n\t\tret = crypto_shash_update(desc, ksegment->kbuf,\n\t\t\t\t\t  ksegment->bufsz);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Assume rest of the buffer is filled with zero and\n\t\t * update digest accordingly.\n\t\t */\n\t\tnullsz = ksegment->memsz - ksegment->bufsz;\n\t\twhile (nullsz) {\n\t\t\tunsigned long bytes = nullsz;\n\n\t\t\tif (bytes > zero_buf_sz)\n\t\t\t\tbytes = zero_buf_sz;\n\t\t\tret = crypto_shash_update(desc, zero_buf, bytes);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tnullsz -= bytes;\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tsha_regions[j].start = ksegment->mem;\n\t\tsha_regions[j].len = ksegment->memsz;\n\t\tj++;\n\t}\n\n\tif (!ret) {\n\t\tret = crypto_shash_final(desc, digest);\n\t\tif (ret)\n\t\t\tgoto out_free_digest;\n\t\tret = kexec_purgatory_get_set_symbol(image, \"purgatory_sha_regions\",\n\t\t\t\t\t\t     sha_regions, sha_region_sz, 0);\n\t\tif (ret)\n\t\t\tgoto out_free_digest;\n\n\t\tret = kexec_purgatory_get_set_symbol(image, \"purgatory_sha256_digest\",\n\t\t\t\t\t\t     digest, SHA256_DIGEST_SIZE, 0);\n\t\tif (ret)\n\t\t\tgoto out_free_digest;\n\t}\n\nout_free_digest:\n\tkfree(digest);\nout_free_sha_regions:\n\tvfree(sha_regions);\nout_free_desc:\n\tkfree(desc);\nout_free_tfm:\n\tkfree(tfm);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "kexec_add_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "550-592",
    "snippet": "int kexec_add_buffer(struct kexec_buf *kbuf)\n{\n\n\tstruct kexec_segment *ksegment;\n\tint ret;\n\n\t/* Currently adding segment this way is allowed only in file mode */\n\tif (!kbuf->image->file_mode)\n\t\treturn -EINVAL;\n\n\tif (kbuf->image->nr_segments >= KEXEC_SEGMENT_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Make sure we are not trying to add buffer after allocating\n\t * control pages. All segments need to be placed first before\n\t * any control pages are allocated. As control page allocation\n\t * logic goes through list of segments to make sure there are\n\t * no destination overlaps.\n\t */\n\tif (!list_empty(&kbuf->image->control_pages)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure minimum alignment needed for segments. */\n\tkbuf->memsz = ALIGN(kbuf->memsz, PAGE_SIZE);\n\tkbuf->buf_align = max(kbuf->buf_align, PAGE_SIZE);\n\n\t/* Walk the RAM ranges and allocate a suitable range for the buffer */\n\tret = kexec_locate_mem_hole(kbuf);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Found a suitable memory range */\n\tksegment = &kbuf->image->segment[kbuf->image->nr_segments];\n\tksegment->kbuf = kbuf->buffer;\n\tksegment->bufsz = kbuf->bufsz;\n\tksegment->mem = kbuf->mem;\n\tksegment->memsz = kbuf->memsz;\n\tkbuf->image->nr_segments++;\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kexec_locate_mem_hole",
          "args": [
            "kbuf"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_locate_mem_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "531-538",
          "snippet": "int kexec_locate_mem_hole(struct kexec_buf *kbuf)\n{\n\tint ret;\n\n\tret = arch_kexec_walk_mem(kbuf, locate_mem_hole_callback);\n\n\treturn ret == 1 ? 0 : -EADDRNOTAVAIL;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kexec_locate_mem_hole(struct kexec_buf *kbuf)\n{\n\tint ret;\n\n\tret = arch_kexec_walk_mem(kbuf, locate_mem_hole_callback);\n\n\treturn ret == 1 ? 0 : -EADDRNOTAVAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "kbuf->buf_align",
            "PAGE_SIZE"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "kbuf->memsz",
            "PAGE_SIZE"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&kbuf->image->control_pages"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint kexec_add_buffer(struct kexec_buf *kbuf)\n{\n\n\tstruct kexec_segment *ksegment;\n\tint ret;\n\n\t/* Currently adding segment this way is allowed only in file mode */\n\tif (!kbuf->image->file_mode)\n\t\treturn -EINVAL;\n\n\tif (kbuf->image->nr_segments >= KEXEC_SEGMENT_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Make sure we are not trying to add buffer after allocating\n\t * control pages. All segments need to be placed first before\n\t * any control pages are allocated. As control page allocation\n\t * logic goes through list of segments to make sure there are\n\t * no destination overlaps.\n\t */\n\tif (!list_empty(&kbuf->image->control_pages)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure minimum alignment needed for segments. */\n\tkbuf->memsz = ALIGN(kbuf->memsz, PAGE_SIZE);\n\tkbuf->buf_align = max(kbuf->buf_align, PAGE_SIZE);\n\n\t/* Walk the RAM ranges and allocate a suitable range for the buffer */\n\tret = kexec_locate_mem_hole(kbuf);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Found a suitable memory range */\n\tksegment = &kbuf->image->segment[kbuf->image->nr_segments];\n\tksegment->kbuf = kbuf->buffer;\n\tksegment->bufsz = kbuf->bufsz;\n\tksegment->mem = kbuf->mem;\n\tksegment->memsz = kbuf->memsz;\n\tkbuf->image->nr_segments++;\n\treturn 0;\n}"
  },
  {
    "function_name": "kexec_locate_mem_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "531-538",
    "snippet": "int kexec_locate_mem_hole(struct kexec_buf *kbuf)\n{\n\tint ret;\n\n\tret = arch_kexec_walk_mem(kbuf, locate_mem_hole_callback);\n\n\treturn ret == 1 ? 0 : -EADDRNOTAVAIL;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kexec_walk_mem",
          "args": [
            "kbuf",
            "locate_mem_hole_callback"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kexec_walk_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "511-521",
          "snippet": "int __weak arch_kexec_walk_mem(struct kexec_buf *kbuf,\n\t\t\t       int (*func)(struct resource *, void *))\n{\n\tif (kbuf->image->type == KEXEC_TYPE_CRASH)\n\t\treturn walk_iomem_res_desc(crashk_res.desc,\n\t\t\t\t\t   IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,\n\t\t\t\t\t   crashk_res.start, crashk_res.end,\n\t\t\t\t\t   kbuf, func);\n\telse\n\t\treturn walk_system_ram_res(0, ULONG_MAX, kbuf, func);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint __weak arch_kexec_walk_mem(struct kexec_buf *kbuf,\n\t\t\t       int (*func)(struct resource *, void *))\n{\n\tif (kbuf->image->type == KEXEC_TYPE_CRASH)\n\t\treturn walk_iomem_res_desc(crashk_res.desc,\n\t\t\t\t\t   IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,\n\t\t\t\t\t   crashk_res.start, crashk_res.end,\n\t\t\t\t\t   kbuf, func);\n\telse\n\t\treturn walk_system_ram_res(0, ULONG_MAX, kbuf, func);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kexec_locate_mem_hole(struct kexec_buf *kbuf)\n{\n\tint ret;\n\n\tret = arch_kexec_walk_mem(kbuf, locate_mem_hole_callback);\n\n\treturn ret == 1 ? 0 : -EADDRNOTAVAIL;\n}"
  },
  {
    "function_name": "arch_kexec_walk_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "511-521",
    "snippet": "int __weak arch_kexec_walk_mem(struct kexec_buf *kbuf,\n\t\t\t       int (*func)(struct resource *, void *))\n{\n\tif (kbuf->image->type == KEXEC_TYPE_CRASH)\n\t\treturn walk_iomem_res_desc(crashk_res.desc,\n\t\t\t\t\t   IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,\n\t\t\t\t\t   crashk_res.start, crashk_res.end,\n\t\t\t\t\t   kbuf, func);\n\telse\n\t\treturn walk_system_ram_res(0, ULONG_MAX, kbuf, func);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_system_ram_res",
          "args": [
            "0",
            "ULONG_MAX",
            "kbuf",
            "func"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "walk_system_ram_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "420-427",
          "snippet": "int walk_system_ram_res(u64 start, u64 end, void *arg,\n\t\t\tint (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, true,\n\t\t\t\t     arg, func);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_system_ram_res(u64 start, u64 end, void *arg,\n\t\t\tint (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, true,\n\t\t\t\t     arg, func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_iomem_res_desc",
          "args": [
            "crashk_res.desc",
            "IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY",
            "crashk_res.start",
            "crashk_res.end",
            "kbuf",
            "func"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "walk_iomem_res_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "406-410",
          "snippet": "int walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start,\n\t\tu64 end, void *arg, int (*func)(struct resource *, void *))\n{\n\treturn __walk_iomem_res_desc(start, end, flags, desc, false, arg, func);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start,\n\t\tu64 end, void *arg, int (*func)(struct resource *, void *))\n{\n\treturn __walk_iomem_res_desc(start, end, flags, desc, false, arg, func);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint __weak arch_kexec_walk_mem(struct kexec_buf *kbuf,\n\t\t\t       int (*func)(struct resource *, void *))\n{\n\tif (kbuf->image->type == KEXEC_TYPE_CRASH)\n\t\treturn walk_iomem_res_desc(crashk_res.desc,\n\t\t\t\t\t   IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,\n\t\t\t\t\t   crashk_res.start, crashk_res.end,\n\t\t\t\t\t   kbuf, func);\n\telse\n\t\treturn walk_system_ram_res(0, ULONG_MAX, kbuf, func);\n}"
  },
  {
    "function_name": "locate_mem_hole_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "480-500",
    "snippet": "static int locate_mem_hole_callback(struct resource *res, void *arg)\n{\n\tstruct kexec_buf *kbuf = (struct kexec_buf *)arg;\n\tu64 start = res->start, end = res->end;\n\tunsigned long sz = end - start + 1;\n\n\t/* Returning 0 will take to next memory range */\n\tif (sz < kbuf->memsz)\n\t\treturn 0;\n\n\tif (end < kbuf->buf_min || start > kbuf->buf_max)\n\t\treturn 0;\n\n\t/*\n\t * Allocate memory top down with-in ram range. Otherwise bottom up\n\t * allocation.\n\t */\n\tif (kbuf->top_down)\n\t\treturn locate_mem_hole_top_down(start, end, kbuf);\n\treturn locate_mem_hole_bottom_up(start, end, kbuf);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locate_mem_hole_bottom_up",
          "args": [
            "start",
            "end",
            "kbuf"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "locate_mem_hole_bottom_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "446-478",
          "snippet": "static int locate_mem_hole_bottom_up(unsigned long start, unsigned long end,\n\t\t\t\t     struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->image;\n\tunsigned long temp_start, temp_end;\n\n\ttemp_start = max(start, kbuf->buf_min);\n\n\tdo {\n\t\ttemp_start = ALIGN(temp_start, kbuf->buf_align);\n\t\ttemp_end = temp_start + kbuf->memsz - 1;\n\n\t\tif (temp_end > end || temp_end > kbuf->buf_max)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Make sure this does not conflict with any of existing\n\t\t * segments\n\t\t */\n\t\tif (kimage_is_destination_range(image, temp_start, temp_end)) {\n\t\t\ttemp_start = temp_start + PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We found a suitable memory range */\n\t\tbreak;\n\t} while (1);\n\n\t/* If we are here, we found a suitable memory range */\n\tkbuf->mem = temp_start;\n\n\t/* Success, stop navigating through remaining System RAM ranges */\n\treturn 1;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int locate_mem_hole_bottom_up(unsigned long start, unsigned long end,\n\t\t\t\t     struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->image;\n\tunsigned long temp_start, temp_end;\n\n\ttemp_start = max(start, kbuf->buf_min);\n\n\tdo {\n\t\ttemp_start = ALIGN(temp_start, kbuf->buf_align);\n\t\ttemp_end = temp_start + kbuf->memsz - 1;\n\n\t\tif (temp_end > end || temp_end > kbuf->buf_max)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Make sure this does not conflict with any of existing\n\t\t * segments\n\t\t */\n\t\tif (kimage_is_destination_range(image, temp_start, temp_end)) {\n\t\t\ttemp_start = temp_start + PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We found a suitable memory range */\n\t\tbreak;\n\t} while (1);\n\n\t/* If we are here, we found a suitable memory range */\n\tkbuf->mem = temp_start;\n\n\t/* Success, stop navigating through remaining System RAM ranges */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locate_mem_hole_top_down",
          "args": [
            "start",
            "end",
            "kbuf"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "locate_mem_hole_top_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "408-444",
          "snippet": "static int locate_mem_hole_top_down(unsigned long start, unsigned long end,\n\t\t\t\t    struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->image;\n\tunsigned long temp_start, temp_end;\n\n\ttemp_end = min(end, kbuf->buf_max);\n\ttemp_start = temp_end - kbuf->memsz;\n\n\tdo {\n\t\t/* align down start */\n\t\ttemp_start = temp_start & (~(kbuf->buf_align - 1));\n\n\t\tif (temp_start < start || temp_start < kbuf->buf_min)\n\t\t\treturn 0;\n\n\t\ttemp_end = temp_start + kbuf->memsz - 1;\n\n\t\t/*\n\t\t * Make sure this does not conflict with any of existing\n\t\t * segments\n\t\t */\n\t\tif (kimage_is_destination_range(image, temp_start, temp_end)) {\n\t\t\ttemp_start = temp_start - PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We found a suitable memory range */\n\t\tbreak;\n\t} while (1);\n\n\t/* If we are here, we found a suitable memory range */\n\tkbuf->mem = temp_start;\n\n\t/* Success, stop navigating through remaining System RAM ranges */\n\treturn 1;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int locate_mem_hole_top_down(unsigned long start, unsigned long end,\n\t\t\t\t    struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->image;\n\tunsigned long temp_start, temp_end;\n\n\ttemp_end = min(end, kbuf->buf_max);\n\ttemp_start = temp_end - kbuf->memsz;\n\n\tdo {\n\t\t/* align down start */\n\t\ttemp_start = temp_start & (~(kbuf->buf_align - 1));\n\n\t\tif (temp_start < start || temp_start < kbuf->buf_min)\n\t\t\treturn 0;\n\n\t\ttemp_end = temp_start + kbuf->memsz - 1;\n\n\t\t/*\n\t\t * Make sure this does not conflict with any of existing\n\t\t * segments\n\t\t */\n\t\tif (kimage_is_destination_range(image, temp_start, temp_end)) {\n\t\t\ttemp_start = temp_start - PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We found a suitable memory range */\n\t\tbreak;\n\t} while (1);\n\n\t/* If we are here, we found a suitable memory range */\n\tkbuf->mem = temp_start;\n\n\t/* Success, stop navigating through remaining System RAM ranges */\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int locate_mem_hole_callback(struct resource *res, void *arg)\n{\n\tstruct kexec_buf *kbuf = (struct kexec_buf *)arg;\n\tu64 start = res->start, end = res->end;\n\tunsigned long sz = end - start + 1;\n\n\t/* Returning 0 will take to next memory range */\n\tif (sz < kbuf->memsz)\n\t\treturn 0;\n\n\tif (end < kbuf->buf_min || start > kbuf->buf_max)\n\t\treturn 0;\n\n\t/*\n\t * Allocate memory top down with-in ram range. Otherwise bottom up\n\t * allocation.\n\t */\n\tif (kbuf->top_down)\n\t\treturn locate_mem_hole_top_down(start, end, kbuf);\n\treturn locate_mem_hole_bottom_up(start, end, kbuf);\n}"
  },
  {
    "function_name": "locate_mem_hole_bottom_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "446-478",
    "snippet": "static int locate_mem_hole_bottom_up(unsigned long start, unsigned long end,\n\t\t\t\t     struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->image;\n\tunsigned long temp_start, temp_end;\n\n\ttemp_start = max(start, kbuf->buf_min);\n\n\tdo {\n\t\ttemp_start = ALIGN(temp_start, kbuf->buf_align);\n\t\ttemp_end = temp_start + kbuf->memsz - 1;\n\n\t\tif (temp_end > end || temp_end > kbuf->buf_max)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Make sure this does not conflict with any of existing\n\t\t * segments\n\t\t */\n\t\tif (kimage_is_destination_range(image, temp_start, temp_end)) {\n\t\t\ttemp_start = temp_start + PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We found a suitable memory range */\n\t\tbreak;\n\t} while (1);\n\n\t/* If we are here, we found a suitable memory range */\n\tkbuf->mem = temp_start;\n\n\t/* Success, stop navigating through remaining System RAM ranges */\n\treturn 1;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_is_destination_range",
          "args": [
            "image",
            "temp_start",
            "temp_end"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_is_destination_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "282-298",
          "snippet": "int kimage_is_destination_range(struct kimage *image,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend = mstart + image->segment[i].memsz;\n\t\tif ((end > mstart) && (start < mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kimage_is_destination_range(struct kimage *image,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend = mstart + image->segment[i].memsz;\n\t\tif ((end > mstart) && (start < mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "temp_start",
            "kbuf->buf_align"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start",
            "kbuf->buf_min"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int locate_mem_hole_bottom_up(unsigned long start, unsigned long end,\n\t\t\t\t     struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->image;\n\tunsigned long temp_start, temp_end;\n\n\ttemp_start = max(start, kbuf->buf_min);\n\n\tdo {\n\t\ttemp_start = ALIGN(temp_start, kbuf->buf_align);\n\t\ttemp_end = temp_start + kbuf->memsz - 1;\n\n\t\tif (temp_end > end || temp_end > kbuf->buf_max)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Make sure this does not conflict with any of existing\n\t\t * segments\n\t\t */\n\t\tif (kimage_is_destination_range(image, temp_start, temp_end)) {\n\t\t\ttemp_start = temp_start + PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We found a suitable memory range */\n\t\tbreak;\n\t} while (1);\n\n\t/* If we are here, we found a suitable memory range */\n\tkbuf->mem = temp_start;\n\n\t/* Success, stop navigating through remaining System RAM ranges */\n\treturn 1;\n}"
  },
  {
    "function_name": "locate_mem_hole_top_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "408-444",
    "snippet": "static int locate_mem_hole_top_down(unsigned long start, unsigned long end,\n\t\t\t\t    struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->image;\n\tunsigned long temp_start, temp_end;\n\n\ttemp_end = min(end, kbuf->buf_max);\n\ttemp_start = temp_end - kbuf->memsz;\n\n\tdo {\n\t\t/* align down start */\n\t\ttemp_start = temp_start & (~(kbuf->buf_align - 1));\n\n\t\tif (temp_start < start || temp_start < kbuf->buf_min)\n\t\t\treturn 0;\n\n\t\ttemp_end = temp_start + kbuf->memsz - 1;\n\n\t\t/*\n\t\t * Make sure this does not conflict with any of existing\n\t\t * segments\n\t\t */\n\t\tif (kimage_is_destination_range(image, temp_start, temp_end)) {\n\t\t\ttemp_start = temp_start - PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We found a suitable memory range */\n\t\tbreak;\n\t} while (1);\n\n\t/* If we are here, we found a suitable memory range */\n\tkbuf->mem = temp_start;\n\n\t/* Success, stop navigating through remaining System RAM ranges */\n\treturn 1;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_is_destination_range",
          "args": [
            "image",
            "temp_start",
            "temp_end"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_is_destination_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "282-298",
          "snippet": "int kimage_is_destination_range(struct kimage *image,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend = mstart + image->segment[i].memsz;\n\t\tif ((end > mstart) && (start < mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kimage_is_destination_range(struct kimage *image,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend = mstart + image->segment[i].memsz;\n\t\tif ((end > mstart) && (start < mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "kbuf->buf_max"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int locate_mem_hole_top_down(unsigned long start, unsigned long end,\n\t\t\t\t    struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->image;\n\tunsigned long temp_start, temp_end;\n\n\ttemp_end = min(end, kbuf->buf_max);\n\ttemp_start = temp_end - kbuf->memsz;\n\n\tdo {\n\t\t/* align down start */\n\t\ttemp_start = temp_start & (~(kbuf->buf_align - 1));\n\n\t\tif (temp_start < start || temp_start < kbuf->buf_min)\n\t\t\treturn 0;\n\n\t\ttemp_end = temp_start + kbuf->memsz - 1;\n\n\t\t/*\n\t\t * Make sure this does not conflict with any of existing\n\t\t * segments\n\t\t */\n\t\tif (kimage_is_destination_range(image, temp_start, temp_end)) {\n\t\t\ttemp_start = temp_start - PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We found a suitable memory range */\n\t\tbreak;\n\t} while (1);\n\n\t/* If we are here, we found a suitable memory range */\n\tkbuf->mem = temp_start;\n\n\t/* Success, stop navigating through remaining System RAM ranges */\n\treturn 1;\n}"
  },
  {
    "function_name": "kimage_file_alloc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "261-316",
    "snippet": "static int\nkimage_file_alloc_init(struct kimage **rimage, int kernel_fd,\n\t\t       int initrd_fd, const char __user *cmdline_ptr,\n\t\t       unsigned long cmdline_len, unsigned long flags)\n{\n\tint ret;\n\tstruct kimage *image;\n\tbool kexec_on_panic = flags & KEXEC_FILE_ON_CRASH;\n\n\timage = do_kimage_alloc_init();\n\tif (!image)\n\t\treturn -ENOMEM;\n\n\timage->file_mode = 1;\n\n\tif (kexec_on_panic) {\n\t\t/* Enable special crash kernel control page alloc policy. */\n\t\timage->control_page = crashk_res.start;\n\t\timage->type = KEXEC_TYPE_CRASH;\n\t}\n\n\tret = kimage_file_prepare_segments(image, kernel_fd, initrd_fd,\n\t\t\t\t\t   cmdline_ptr, cmdline_len, flags);\n\tif (ret)\n\t\tgoto out_free_image;\n\n\tret = sanity_check_segment_list(image);\n\tif (ret)\n\t\tgoto out_free_post_load_bufs;\n\n\tret = -ENOMEM;\n\timage->control_code_page = kimage_alloc_control_pages(image,\n\t\t\t\t\t   get_order(KEXEC_CONTROL_PAGE_SIZE));\n\tif (!image->control_code_page) {\n\t\tpr_err(\"Could not allocate control_code_buffer\\n\");\n\t\tgoto out_free_post_load_bufs;\n\t}\n\n\tif (!kexec_on_panic) {\n\t\timage->swap_page = kimage_alloc_control_pages(image, 0);\n\t\tif (!image->swap_page) {\n\t\t\tpr_err(\"Could not allocate swap buffer\\n\");\n\t\t\tgoto out_free_control_pages;\n\t\t}\n\t}\n\n\t*rimage = image;\n\treturn 0;\nout_free_control_pages:\n\tkimage_free_page_list(&image->control_pages);\nout_free_post_load_bufs:\n\tkimage_file_post_load_cleanup(image);\nout_free_image:\n\tkfree(image);\n\treturn ret;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "image"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_file_post_load_cleanup",
          "args": [
            "image"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_file_post_load_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "150-179",
          "snippet": "void kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tvfree(image->kernel_buf);\n\timage->kernel_buf = NULL;\n\n\tvfree(image->initrd_buf);\n\timage->initrd_buf = NULL;\n\n\tkfree(image->cmdline_buf);\n\timage->cmdline_buf = NULL;\n\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\n\n\t/* See if architecture has anything to cleanup post load */\n\tarch_kimage_file_post_load_cleanup(image);\n\n\t/*\n\t * Above call should have called into bootloader to free up\n\t * any data stored in kimage->image_loader_data. It should\n\t * be ok now to free it up.\n\t */\n\tkfree(image->image_loader_data);\n\timage->image_loader_data = NULL;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nvoid kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tvfree(image->kernel_buf);\n\timage->kernel_buf = NULL;\n\n\tvfree(image->initrd_buf);\n\timage->initrd_buf = NULL;\n\n\tkfree(image->cmdline_buf);\n\timage->cmdline_buf = NULL;\n\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\n\n\t/* See if architecture has anything to cleanup post load */\n\tarch_kimage_file_post_load_cleanup(image);\n\n\t/*\n\t * Above call should have called into bootloader to free up\n\t * any data stored in kimage->image_loader_data. It should\n\t * be ok now to free it up.\n\t */\n\tkfree(image->image_loader_data);\n\timage->image_loader_data = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_free_page_list",
          "args": [
            "&image->control_pages"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "339-347",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Could not allocate swap buffer\\n\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_alloc_control_pages",
          "args": [
            "image",
            "0"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_control_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "482-497",
          "snippet": "struct page *kimage_alloc_control_pages(struct kimage *image,\n\t\t\t\t\t unsigned int order)\n{\n\tstruct page *pages = NULL;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tpages = kimage_alloc_normal_control_pages(image, order);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tpages = kimage_alloc_crash_control_pages(image, order);\n\t\tbreak;\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct page *kimage_alloc_control_pages(struct kimage *image,\n\t\t\t\t\t unsigned int order)\n{\n\tstruct page *pages = NULL;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tpages = kimage_alloc_normal_control_pages(image, order);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tpages = kimage_alloc_crash_control_pages(image, order);\n\t\tbreak;\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Could not allocate control_code_buffer\\n\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "KEXEC_CONTROL_PAGE_SIZE"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanity_check_segment_list",
          "args": [
            "image"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "sanity_check_segment_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "150-253",
          "snippet": "int sanity_check_segment_list(struct kimage *image)\n{\n\tint i;\n\tunsigned long nr_segments = image->nr_segments;\n\tunsigned long total_pages = 0;\n\n\t/*\n\t * Verify we have good destination addresses.  The caller is\n\t * responsible for making certain we don't attempt to load\n\t * the new image into invalid or reserved areas of RAM.  This\n\t * just verifies it is an address we can use.\n\t *\n\t * Since the kernel does everything in page size chunks ensure\n\t * the destination addresses are page aligned.  Too many\n\t * special cases crop of when we don't do this.  The most\n\t * insidious is getting overlapping destination addresses\n\t * simply because addresses are changed to page size\n\t * granularity.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tif (mstart > mend)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif ((mstart & ~PAGE_MASK) || (mend & ~PAGE_MASK))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif (mend >= KEXEC_DESTINATION_MEMORY_LIMIT)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Verify our destination addresses do not overlap.\n\t * If we alloed overlapping destination addresses\n\t * through very weird things can happen with no\n\t * easy explanation as one segment stops on another.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\t\tunsigned long j;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tunsigned long pstart, pend;\n\n\t\t\tpstart = image->segment[j].mem;\n\t\t\tpend   = pstart + image->segment[j].memsz;\n\t\t\t/* Do the segments overlap ? */\n\t\t\tif ((mend > pstart) && (mstart < pend))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Ensure our buffer sizes are strictly less than\n\t * our memory sizes.  This should always be the case,\n\t * and it is easier to check up front than to be surprised\n\t * later on.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (image->segment[i].bufsz > image->segment[i].memsz)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Verify that no more than half of memory will be consumed. If the\n\t * request from userspace is too large, a large amount of time will be\n\t * wasted allocating pages, which can cause a soft lockup.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (PAGE_COUNT(image->segment[i].memsz) > totalram_pages / 2)\n\t\t\treturn -EINVAL;\n\n\t\ttotal_pages += PAGE_COUNT(image->segment[i].memsz);\n\t}\n\n\tif (total_pages > totalram_pages / 2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Verify we have good destination addresses.  Normally\n\t * the caller is responsible for making certain we don't\n\t * attempt to load the new image into invalid or reserved\n\t * areas of RAM.  But crash kernels are preloaded into a\n\t * reserved area of ram.  We must ensure the addresses\n\t * are in the reserved area otherwise preloading the\n\t * kernel could corrupt things.\n\t */\n\n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\tfor (i = 0; i < nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->segment[i].mem;\n\t\t\tmend = mstart + image->segment[i].memsz - 1;\n\t\t\t/* Ensure we are within the crash kernel limits */\n\t\t\tif ((mstart < phys_to_boot_phys(crashk_res.start)) ||\n\t\t\t    (mend > phys_to_boot_phys(crashk_res.end)))\n\t\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};\n\nint sanity_check_segment_list(struct kimage *image)\n{\n\tint i;\n\tunsigned long nr_segments = image->nr_segments;\n\tunsigned long total_pages = 0;\n\n\t/*\n\t * Verify we have good destination addresses.  The caller is\n\t * responsible for making certain we don't attempt to load\n\t * the new image into invalid or reserved areas of RAM.  This\n\t * just verifies it is an address we can use.\n\t *\n\t * Since the kernel does everything in page size chunks ensure\n\t * the destination addresses are page aligned.  Too many\n\t * special cases crop of when we don't do this.  The most\n\t * insidious is getting overlapping destination addresses\n\t * simply because addresses are changed to page size\n\t * granularity.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tif (mstart > mend)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif ((mstart & ~PAGE_MASK) || (mend & ~PAGE_MASK))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif (mend >= KEXEC_DESTINATION_MEMORY_LIMIT)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Verify our destination addresses do not overlap.\n\t * If we alloed overlapping destination addresses\n\t * through very weird things can happen with no\n\t * easy explanation as one segment stops on another.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\t\tunsigned long j;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tunsigned long pstart, pend;\n\n\t\t\tpstart = image->segment[j].mem;\n\t\t\tpend   = pstart + image->segment[j].memsz;\n\t\t\t/* Do the segments overlap ? */\n\t\t\tif ((mend > pstart) && (mstart < pend))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Ensure our buffer sizes are strictly less than\n\t * our memory sizes.  This should always be the case,\n\t * and it is easier to check up front than to be surprised\n\t * later on.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (image->segment[i].bufsz > image->segment[i].memsz)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Verify that no more than half of memory will be consumed. If the\n\t * request from userspace is too large, a large amount of time will be\n\t * wasted allocating pages, which can cause a soft lockup.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (PAGE_COUNT(image->segment[i].memsz) > totalram_pages / 2)\n\t\t\treturn -EINVAL;\n\n\t\ttotal_pages += PAGE_COUNT(image->segment[i].memsz);\n\t}\n\n\tif (total_pages > totalram_pages / 2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Verify we have good destination addresses.  Normally\n\t * the caller is responsible for making certain we don't\n\t * attempt to load the new image into invalid or reserved\n\t * areas of RAM.  But crash kernels are preloaded into a\n\t * reserved area of ram.  We must ensure the addresses\n\t * are in the reserved area otherwise preloading the\n\t * kernel could corrupt things.\n\t */\n\n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\tfor (i = 0; i < nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->segment[i].mem;\n\t\t\tmend = mstart + image->segment[i].memsz - 1;\n\t\t\t/* Ensure we are within the crash kernel limits */\n\t\t\tif ((mstart < phys_to_boot_phys(crashk_res.start)) ||\n\t\t\t    (mend > phys_to_boot_phys(crashk_res.end)))\n\t\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_file_prepare_segments",
          "args": [
            "image",
            "kernel_fd",
            "initrd_fd",
            "cmdline_ptr",
            "cmdline_len",
            "flags"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_file_prepare_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "185-259",
          "snippet": "static int\nkimage_file_prepare_segments(struct kimage *image, int kernel_fd, int initrd_fd,\n\t\t\t     const char __user *cmdline_ptr,\n\t\t\t     unsigned long cmdline_len, unsigned flags)\n{\n\tint ret = 0;\n\tvoid *ldata;\n\tloff_t size;\n\n\tret = kernel_read_file_from_fd(kernel_fd, &image->kernel_buf,\n\t\t\t\t       &size, INT_MAX, READING_KEXEC_IMAGE);\n\tif (ret)\n\t\treturn ret;\n\timage->kernel_buf_len = size;\n\n\t/* IMA needs to pass the measurement list to the next kernel. */\n\tima_add_kexec_buffer(image);\n\n\t/* Call arch image probe handlers */\n\tret = arch_kexec_kernel_image_probe(image, image->kernel_buf,\n\t\t\t\t\t    image->kernel_buf_len);\n\tif (ret)\n\t\tgoto out;\n\n#ifdef CONFIG_KEXEC_VERIFY_SIG\n\tret = arch_kexec_kernel_verify_sig(image, image->kernel_buf,\n\t\t\t\t\t   image->kernel_buf_len);\n\tif (ret) {\n\t\tpr_debug(\"kernel signature verification failed.\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"kernel signature verification successful.\\n\");\n#endif\n\t/* It is possible that there no initramfs is being loaded */\n\tif (!(flags & KEXEC_FILE_NO_INITRAMFS)) {\n\t\tret = kernel_read_file_from_fd(initrd_fd, &image->initrd_buf,\n\t\t\t\t\t       &size, INT_MAX,\n\t\t\t\t\t       READING_KEXEC_INITRAMFS);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\timage->initrd_buf_len = size;\n\t}\n\n\tif (cmdline_len) {\n\t\timage->cmdline_buf = memdup_user(cmdline_ptr, cmdline_len);\n\t\tif (IS_ERR(image->cmdline_buf)) {\n\t\t\tret = PTR_ERR(image->cmdline_buf);\n\t\t\timage->cmdline_buf = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\timage->cmdline_buf_len = cmdline_len;\n\n\t\t/* command line should be a string with last byte null */\n\t\tif (image->cmdline_buf[cmdline_len - 1] != '\\0') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Call arch image load handlers */\n\tldata = arch_kexec_kernel_image_load(image);\n\n\tif (IS_ERR(ldata)) {\n\t\tret = PTR_ERR(ldata);\n\t\tgoto out;\n\t}\n\n\timage->image_loader_data = ldata;\nout:\n\t/* In case of error, free up all allocated memory in this function */\n\tif (ret)\n\t\tkimage_file_post_load_cleanup(image);\n\treturn ret;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int\nkimage_file_prepare_segments(struct kimage *image, int kernel_fd, int initrd_fd,\n\t\t\t     const char __user *cmdline_ptr,\n\t\t\t     unsigned long cmdline_len, unsigned flags)\n{\n\tint ret = 0;\n\tvoid *ldata;\n\tloff_t size;\n\n\tret = kernel_read_file_from_fd(kernel_fd, &image->kernel_buf,\n\t\t\t\t       &size, INT_MAX, READING_KEXEC_IMAGE);\n\tif (ret)\n\t\treturn ret;\n\timage->kernel_buf_len = size;\n\n\t/* IMA needs to pass the measurement list to the next kernel. */\n\tima_add_kexec_buffer(image);\n\n\t/* Call arch image probe handlers */\n\tret = arch_kexec_kernel_image_probe(image, image->kernel_buf,\n\t\t\t\t\t    image->kernel_buf_len);\n\tif (ret)\n\t\tgoto out;\n\n#ifdef CONFIG_KEXEC_VERIFY_SIG\n\tret = arch_kexec_kernel_verify_sig(image, image->kernel_buf,\n\t\t\t\t\t   image->kernel_buf_len);\n\tif (ret) {\n\t\tpr_debug(\"kernel signature verification failed.\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"kernel signature verification successful.\\n\");\n#endif\n\t/* It is possible that there no initramfs is being loaded */\n\tif (!(flags & KEXEC_FILE_NO_INITRAMFS)) {\n\t\tret = kernel_read_file_from_fd(initrd_fd, &image->initrd_buf,\n\t\t\t\t\t       &size, INT_MAX,\n\t\t\t\t\t       READING_KEXEC_INITRAMFS);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\timage->initrd_buf_len = size;\n\t}\n\n\tif (cmdline_len) {\n\t\timage->cmdline_buf = memdup_user(cmdline_ptr, cmdline_len);\n\t\tif (IS_ERR(image->cmdline_buf)) {\n\t\t\tret = PTR_ERR(image->cmdline_buf);\n\t\t\timage->cmdline_buf = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\timage->cmdline_buf_len = cmdline_len;\n\n\t\t/* command line should be a string with last byte null */\n\t\tif (image->cmdline_buf[cmdline_len - 1] != '\\0') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Call arch image load handlers */\n\tldata = arch_kexec_kernel_image_load(image);\n\n\tif (IS_ERR(ldata)) {\n\t\tret = PTR_ERR(ldata);\n\t\tgoto out;\n\t}\n\n\timage->image_loader_data = ldata;\nout:\n\t/* In case of error, free up all allocated memory in this function */\n\tif (ret)\n\t\tkimage_file_post_load_cleanup(image);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_kimage_alloc_init",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "do_kimage_alloc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "255-280",
          "snippet": "struct kimage *do_kimage_alloc_init(void)\n{\n\tstruct kimage *image;\n\n\t/* Allocate a controlling structure */\n\timage = kzalloc(sizeof(*image), GFP_KERNEL);\n\tif (!image)\n\t\treturn NULL;\n\n\timage->head = 0;\n\timage->entry = &image->head;\n\timage->last_entry = &image->head;\n\timage->control_page = ~0; /* By default this does not apply */\n\timage->type = KEXEC_TYPE_DEFAULT;\n\n\t/* Initialize the list of control pages */\n\tINIT_LIST_HEAD(&image->control_pages);\n\n\t/* Initialize the list of destination pages */\n\tINIT_LIST_HEAD(&image->dest_pages);\n\n\t/* Initialize the list of unusable pages */\n\tINIT_LIST_HEAD(&image->unusable_pages);\n\n\treturn image;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct kimage *do_kimage_alloc_init(void)\n{\n\tstruct kimage *image;\n\n\t/* Allocate a controlling structure */\n\timage = kzalloc(sizeof(*image), GFP_KERNEL);\n\tif (!image)\n\t\treturn NULL;\n\n\timage->head = 0;\n\timage->entry = &image->head;\n\timage->last_entry = &image->head;\n\timage->control_page = ~0; /* By default this does not apply */\n\timage->type = KEXEC_TYPE_DEFAULT;\n\n\t/* Initialize the list of control pages */\n\tINIT_LIST_HEAD(&image->control_pages);\n\n\t/* Initialize the list of destination pages */\n\tINIT_LIST_HEAD(&image->dest_pages);\n\n\t/* Initialize the list of unusable pages */\n\tINIT_LIST_HEAD(&image->unusable_pages);\n\n\treturn image;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int\nkimage_file_alloc_init(struct kimage **rimage, int kernel_fd,\n\t\t       int initrd_fd, const char __user *cmdline_ptr,\n\t\t       unsigned long cmdline_len, unsigned long flags)\n{\n\tint ret;\n\tstruct kimage *image;\n\tbool kexec_on_panic = flags & KEXEC_FILE_ON_CRASH;\n\n\timage = do_kimage_alloc_init();\n\tif (!image)\n\t\treturn -ENOMEM;\n\n\timage->file_mode = 1;\n\n\tif (kexec_on_panic) {\n\t\t/* Enable special crash kernel control page alloc policy. */\n\t\timage->control_page = crashk_res.start;\n\t\timage->type = KEXEC_TYPE_CRASH;\n\t}\n\n\tret = kimage_file_prepare_segments(image, kernel_fd, initrd_fd,\n\t\t\t\t\t   cmdline_ptr, cmdline_len, flags);\n\tif (ret)\n\t\tgoto out_free_image;\n\n\tret = sanity_check_segment_list(image);\n\tif (ret)\n\t\tgoto out_free_post_load_bufs;\n\n\tret = -ENOMEM;\n\timage->control_code_page = kimage_alloc_control_pages(image,\n\t\t\t\t\t   get_order(KEXEC_CONTROL_PAGE_SIZE));\n\tif (!image->control_code_page) {\n\t\tpr_err(\"Could not allocate control_code_buffer\\n\");\n\t\tgoto out_free_post_load_bufs;\n\t}\n\n\tif (!kexec_on_panic) {\n\t\timage->swap_page = kimage_alloc_control_pages(image, 0);\n\t\tif (!image->swap_page) {\n\t\t\tpr_err(\"Could not allocate swap buffer\\n\");\n\t\t\tgoto out_free_control_pages;\n\t\t}\n\t}\n\n\t*rimage = image;\n\treturn 0;\nout_free_control_pages:\n\tkimage_free_page_list(&image->control_pages);\nout_free_post_load_bufs:\n\tkimage_file_post_load_cleanup(image);\nout_free_image:\n\tkfree(image);\n\treturn ret;\n}"
  },
  {
    "function_name": "kimage_file_prepare_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "185-259",
    "snippet": "static int\nkimage_file_prepare_segments(struct kimage *image, int kernel_fd, int initrd_fd,\n\t\t\t     const char __user *cmdline_ptr,\n\t\t\t     unsigned long cmdline_len, unsigned flags)\n{\n\tint ret = 0;\n\tvoid *ldata;\n\tloff_t size;\n\n\tret = kernel_read_file_from_fd(kernel_fd, &image->kernel_buf,\n\t\t\t\t       &size, INT_MAX, READING_KEXEC_IMAGE);\n\tif (ret)\n\t\treturn ret;\n\timage->kernel_buf_len = size;\n\n\t/* IMA needs to pass the measurement list to the next kernel. */\n\tima_add_kexec_buffer(image);\n\n\t/* Call arch image probe handlers */\n\tret = arch_kexec_kernel_image_probe(image, image->kernel_buf,\n\t\t\t\t\t    image->kernel_buf_len);\n\tif (ret)\n\t\tgoto out;\n\n#ifdef CONFIG_KEXEC_VERIFY_SIG\n\tret = arch_kexec_kernel_verify_sig(image, image->kernel_buf,\n\t\t\t\t\t   image->kernel_buf_len);\n\tif (ret) {\n\t\tpr_debug(\"kernel signature verification failed.\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"kernel signature verification successful.\\n\");\n#endif\n\t/* It is possible that there no initramfs is being loaded */\n\tif (!(flags & KEXEC_FILE_NO_INITRAMFS)) {\n\t\tret = kernel_read_file_from_fd(initrd_fd, &image->initrd_buf,\n\t\t\t\t\t       &size, INT_MAX,\n\t\t\t\t\t       READING_KEXEC_INITRAMFS);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\timage->initrd_buf_len = size;\n\t}\n\n\tif (cmdline_len) {\n\t\timage->cmdline_buf = memdup_user(cmdline_ptr, cmdline_len);\n\t\tif (IS_ERR(image->cmdline_buf)) {\n\t\t\tret = PTR_ERR(image->cmdline_buf);\n\t\t\timage->cmdline_buf = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\timage->cmdline_buf_len = cmdline_len;\n\n\t\t/* command line should be a string with last byte null */\n\t\tif (image->cmdline_buf[cmdline_len - 1] != '\\0') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Call arch image load handlers */\n\tldata = arch_kexec_kernel_image_load(image);\n\n\tif (IS_ERR(ldata)) {\n\t\tret = PTR_ERR(ldata);\n\t\tgoto out;\n\t}\n\n\timage->image_loader_data = ldata;\nout:\n\t/* In case of error, free up all allocated memory in this function */\n\tif (ret)\n\t\tkimage_file_post_load_cleanup(image);\n\treturn ret;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_file_post_load_cleanup",
          "args": [
            "image"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_file_post_load_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "150-179",
          "snippet": "void kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tvfree(image->kernel_buf);\n\timage->kernel_buf = NULL;\n\n\tvfree(image->initrd_buf);\n\timage->initrd_buf = NULL;\n\n\tkfree(image->cmdline_buf);\n\timage->cmdline_buf = NULL;\n\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\n\n\t/* See if architecture has anything to cleanup post load */\n\tarch_kimage_file_post_load_cleanup(image);\n\n\t/*\n\t * Above call should have called into bootloader to free up\n\t * any data stored in kimage->image_loader_data. It should\n\t * be ok now to free it up.\n\t */\n\tkfree(image->image_loader_data);\n\timage->image_loader_data = NULL;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nvoid kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tvfree(image->kernel_buf);\n\timage->kernel_buf = NULL;\n\n\tvfree(image->initrd_buf);\n\timage->initrd_buf = NULL;\n\n\tkfree(image->cmdline_buf);\n\timage->cmdline_buf = NULL;\n\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\n\n\t/* See if architecture has anything to cleanup post load */\n\tarch_kimage_file_post_load_cleanup(image);\n\n\t/*\n\t * Above call should have called into bootloader to free up\n\t * any data stored in kimage->image_loader_data. It should\n\t * be ok now to free it up.\n\t */\n\tkfree(image->image_loader_data);\n\timage->image_loader_data = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ldata"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ldata"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kexec_kernel_image_load",
          "args": [
            "image"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kexec_kernel_image_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "74-77",
          "snippet": "void * __weak arch_kexec_kernel_image_load(struct kimage *image)\n{\n\treturn kexec_image_load_default(image);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nvoid * __weak arch_kexec_kernel_image_load(struct kimage *image)\n{\n\treturn kexec_image_load_default(image);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "image->cmdline_buf"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "image->cmdline_buf"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "cmdline_ptr",
            "cmdline_len"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read_file_from_fd",
          "args": [
            "initrd_fd",
            "&image->initrd_buf",
            "&size",
            "INT_MAX",
            "READING_KEXEC_INITRAMFS"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"kernel signature verification successful.\\n\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"kernel signature verification failed.\\n\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kexec_kernel_verify_sig",
          "args": [
            "image",
            "image->kernel_buf",
            "image->kernel_buf_len"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kexec_kernel_verify_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "104-108",
          "snippet": "int __weak arch_kexec_kernel_verify_sig(struct kimage *image, void *buf,\n\t\t\t\t\tunsigned long buf_len)\n{\n\treturn kexec_image_verify_sig_default(image, buf, buf_len);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint __weak arch_kexec_kernel_verify_sig(struct kimage *image, void *buf,\n\t\t\t\t\tunsigned long buf_len)\n{\n\treturn kexec_image_verify_sig_default(image, buf, buf_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_kexec_kernel_image_probe",
          "args": [
            "image",
            "image->kernel_buf",
            "image->kernel_buf_len"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kexec_kernel_image_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "57-61",
          "snippet": "int __weak arch_kexec_kernel_image_probe(struct kimage *image, void *buf,\n\t\t\t\t\t unsigned long buf_len)\n{\n\treturn kexec_image_probe_default(image, buf, buf_len);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint __weak arch_kexec_kernel_image_probe(struct kimage *image, void *buf,\n\t\t\t\t\t unsigned long buf_len)\n{\n\treturn kexec_image_probe_default(image, buf, buf_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_add_kexec_buffer",
          "args": [
            "image"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read_file_from_fd",
          "args": [
            "kernel_fd",
            "&image->kernel_buf",
            "&size",
            "INT_MAX",
            "READING_KEXEC_IMAGE"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int\nkimage_file_prepare_segments(struct kimage *image, int kernel_fd, int initrd_fd,\n\t\t\t     const char __user *cmdline_ptr,\n\t\t\t     unsigned long cmdline_len, unsigned flags)\n{\n\tint ret = 0;\n\tvoid *ldata;\n\tloff_t size;\n\n\tret = kernel_read_file_from_fd(kernel_fd, &image->kernel_buf,\n\t\t\t\t       &size, INT_MAX, READING_KEXEC_IMAGE);\n\tif (ret)\n\t\treturn ret;\n\timage->kernel_buf_len = size;\n\n\t/* IMA needs to pass the measurement list to the next kernel. */\n\tima_add_kexec_buffer(image);\n\n\t/* Call arch image probe handlers */\n\tret = arch_kexec_kernel_image_probe(image, image->kernel_buf,\n\t\t\t\t\t    image->kernel_buf_len);\n\tif (ret)\n\t\tgoto out;\n\n#ifdef CONFIG_KEXEC_VERIFY_SIG\n\tret = arch_kexec_kernel_verify_sig(image, image->kernel_buf,\n\t\t\t\t\t   image->kernel_buf_len);\n\tif (ret) {\n\t\tpr_debug(\"kernel signature verification failed.\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"kernel signature verification successful.\\n\");\n#endif\n\t/* It is possible that there no initramfs is being loaded */\n\tif (!(flags & KEXEC_FILE_NO_INITRAMFS)) {\n\t\tret = kernel_read_file_from_fd(initrd_fd, &image->initrd_buf,\n\t\t\t\t\t       &size, INT_MAX,\n\t\t\t\t\t       READING_KEXEC_INITRAMFS);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\timage->initrd_buf_len = size;\n\t}\n\n\tif (cmdline_len) {\n\t\timage->cmdline_buf = memdup_user(cmdline_ptr, cmdline_len);\n\t\tif (IS_ERR(image->cmdline_buf)) {\n\t\t\tret = PTR_ERR(image->cmdline_buf);\n\t\t\timage->cmdline_buf = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\timage->cmdline_buf_len = cmdline_len;\n\n\t\t/* command line should be a string with last byte null */\n\t\tif (image->cmdline_buf[cmdline_len - 1] != '\\0') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Call arch image load handlers */\n\tldata = arch_kexec_kernel_image_load(image);\n\n\tif (IS_ERR(ldata)) {\n\t\tret = PTR_ERR(ldata);\n\t\tgoto out;\n\t}\n\n\timage->image_loader_data = ldata;\nout:\n\t/* In case of error, free up all allocated memory in this function */\n\tif (ret)\n\t\tkimage_file_post_load_cleanup(image);\n\treturn ret;\n}"
  },
  {
    "function_name": "kimage_file_post_load_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "150-179",
    "snippet": "void kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tvfree(image->kernel_buf);\n\timage->kernel_buf = NULL;\n\n\tvfree(image->initrd_buf);\n\timage->initrd_buf = NULL;\n\n\tkfree(image->cmdline_buf);\n\timage->cmdline_buf = NULL;\n\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\n\n\t/* See if architecture has anything to cleanup post load */\n\tarch_kimage_file_post_load_cleanup(image);\n\n\t/*\n\t * Above call should have called into bootloader to free up\n\t * any data stored in kimage->image_loader_data. It should\n\t * be ok now to free it up.\n\t */\n\tkfree(image->image_loader_data);\n\timage->image_loader_data = NULL;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "image->image_loader_data"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_kimage_file_post_load_cleanup",
          "args": [
            "image"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kimage_file_post_load_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "87-90",
          "snippet": "int __weak arch_kimage_file_post_load_cleanup(struct kimage *image)\n{\n\treturn kexec_image_post_load_cleanup_default(image);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint __weak arch_kimage_file_post_load_cleanup(struct kimage *image)\n{\n\treturn kexec_image_post_load_cleanup_default(image);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "pi->sechdrs"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "pi->purgatory_buf"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "image->initrd_buf"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "image->kernel_buf"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nvoid kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tvfree(image->kernel_buf);\n\timage->kernel_buf = NULL;\n\n\tvfree(image->initrd_buf);\n\timage->initrd_buf = NULL;\n\n\tkfree(image->cmdline_buf);\n\timage->cmdline_buf = NULL;\n\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\n\n\t/* See if architecture has anything to cleanup post load */\n\tarch_kimage_file_post_load_cleanup(image);\n\n\t/*\n\t * Above call should have called into bootloader to free up\n\t * any data stored in kimage->image_loader_data. It should\n\t * be ok now to free it up.\n\t */\n\tkfree(image->image_loader_data);\n\timage->image_loader_data = NULL;\n}"
  },
  {
    "function_name": "arch_kexec_apply_relocations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "137-143",
    "snippet": "int __weak\narch_kexec_apply_relocations(struct purgatory_info *pi, Elf_Shdr *section,\n\t\t\t     const Elf_Shdr *relsec, const Elf_Shdr *symtab)\n{\n\tpr_err(\"REL relocation unsupported.\\n\");\n\treturn -ENOEXEC;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"REL relocation unsupported.\\n\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint __weak\narch_kexec_apply_relocations(struct purgatory_info *pi, Elf_Shdr *section,\n\t\t\t     const Elf_Shdr *relsec, const Elf_Shdr *symtab)\n{\n\tpr_err(\"REL relocation unsupported.\\n\");\n\treturn -ENOEXEC;\n}"
  },
  {
    "function_name": "arch_kexec_apply_relocations_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "120-126",
    "snippet": "int __weak\narch_kexec_apply_relocations_add(struct purgatory_info *pi, Elf_Shdr *section,\n\t\t\t\t const Elf_Shdr *relsec, const Elf_Shdr *symtab)\n{\n\tpr_err(\"RELA relocation unsupported.\\n\");\n\treturn -ENOEXEC;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"RELA relocation unsupported.\\n\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint __weak\narch_kexec_apply_relocations_add(struct purgatory_info *pi, Elf_Shdr *section,\n\t\t\t\t const Elf_Shdr *relsec, const Elf_Shdr *symtab)\n{\n\tpr_err(\"RELA relocation unsupported.\\n\");\n\treturn -ENOEXEC;\n}"
  },
  {
    "function_name": "arch_kexec_kernel_verify_sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "104-108",
    "snippet": "int __weak arch_kexec_kernel_verify_sig(struct kimage *image, void *buf,\n\t\t\t\t\tunsigned long buf_len)\n{\n\treturn kexec_image_verify_sig_default(image, buf, buf_len);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kexec_image_verify_sig_default",
          "args": [
            "image",
            "buf",
            "buf_len"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_image_verify_sig_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "93-102",
          "snippet": "static int kexec_image_verify_sig_default(struct kimage *image, void *buf,\n\t\t\t\t\t  unsigned long buf_len)\n{\n\tif (!image->fops || !image->fops->verify_sig) {\n\t\tpr_debug(\"kernel loader does not support signature verification.\\n\");\n\t\treturn -EKEYREJECTED;\n\t}\n\n\treturn image->fops->verify_sig(buf, buf_len);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int kexec_image_verify_sig_default(struct kimage *image, void *buf,\n\t\t\t\t\t  unsigned long buf_len)\n{\n\tif (!image->fops || !image->fops->verify_sig) {\n\t\tpr_debug(\"kernel loader does not support signature verification.\\n\");\n\t\treturn -EKEYREJECTED;\n\t}\n\n\treturn image->fops->verify_sig(buf, buf_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint __weak arch_kexec_kernel_verify_sig(struct kimage *image, void *buf,\n\t\t\t\t\tunsigned long buf_len)\n{\n\treturn kexec_image_verify_sig_default(image, buf, buf_len);\n}"
  },
  {
    "function_name": "kexec_image_verify_sig_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "93-102",
    "snippet": "static int kexec_image_verify_sig_default(struct kimage *image, void *buf,\n\t\t\t\t\t  unsigned long buf_len)\n{\n\tif (!image->fops || !image->fops->verify_sig) {\n\t\tpr_debug(\"kernel loader does not support signature verification.\\n\");\n\t\treturn -EKEYREJECTED;\n\t}\n\n\treturn image->fops->verify_sig(buf, buf_len);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "image->fops->verify_sig",
          "args": [
            "buf",
            "buf_len"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"kernel loader does not support signature verification.\\n\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int kexec_image_verify_sig_default(struct kimage *image, void *buf,\n\t\t\t\t\t  unsigned long buf_len)\n{\n\tif (!image->fops || !image->fops->verify_sig) {\n\t\tpr_debug(\"kernel loader does not support signature verification.\\n\");\n\t\treturn -EKEYREJECTED;\n\t}\n\n\treturn image->fops->verify_sig(buf, buf_len);\n}"
  },
  {
    "function_name": "arch_kimage_file_post_load_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "87-90",
    "snippet": "int __weak arch_kimage_file_post_load_cleanup(struct kimage *image)\n{\n\treturn kexec_image_post_load_cleanup_default(image);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kexec_image_post_load_cleanup_default",
          "args": [
            "image"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_image_post_load_cleanup_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "79-85",
          "snippet": "static int kexec_image_post_load_cleanup_default(struct kimage *image)\n{\n\tif (!image->fops || !image->fops->cleanup)\n\t\treturn 0;\n\n\treturn image->fops->cleanup(image->image_loader_data);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int kexec_image_post_load_cleanup_default(struct kimage *image)\n{\n\tif (!image->fops || !image->fops->cleanup)\n\t\treturn 0;\n\n\treturn image->fops->cleanup(image->image_loader_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint __weak arch_kimage_file_post_load_cleanup(struct kimage *image)\n{\n\treturn kexec_image_post_load_cleanup_default(image);\n}"
  },
  {
    "function_name": "kexec_image_post_load_cleanup_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "79-85",
    "snippet": "static int kexec_image_post_load_cleanup_default(struct kimage *image)\n{\n\tif (!image->fops || !image->fops->cleanup)\n\t\treturn 0;\n\n\treturn image->fops->cleanup(image->image_loader_data);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "image->fops->cleanup",
          "args": [
            "image->image_loader_data"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic int kexec_image_post_load_cleanup_default(struct kimage *image)\n{\n\tif (!image->fops || !image->fops->cleanup)\n\t\treturn 0;\n\n\treturn image->fops->cleanup(image->image_loader_data);\n}"
  },
  {
    "function_name": "arch_kexec_kernel_image_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "74-77",
    "snippet": "void * __weak arch_kexec_kernel_image_load(struct kimage *image)\n{\n\treturn kexec_image_load_default(image);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kexec_image_load_default",
          "args": [
            "image"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_image_load_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "63-72",
          "snippet": "static void *kexec_image_load_default(struct kimage *image)\n{\n\tif (!image->fops || !image->fops->load)\n\t\treturn ERR_PTR(-ENOEXEC);\n\n\treturn image->fops->load(image, image->kernel_buf,\n\t\t\t\t image->kernel_buf_len, image->initrd_buf,\n\t\t\t\t image->initrd_buf_len, image->cmdline_buf,\n\t\t\t\t image->cmdline_buf_len);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic void *kexec_image_load_default(struct kimage *image)\n{\n\tif (!image->fops || !image->fops->load)\n\t\treturn ERR_PTR(-ENOEXEC);\n\n\treturn image->fops->load(image, image->kernel_buf,\n\t\t\t\t image->kernel_buf_len, image->initrd_buf,\n\t\t\t\t image->initrd_buf_len, image->cmdline_buf,\n\t\t\t\t image->cmdline_buf_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nvoid * __weak arch_kexec_kernel_image_load(struct kimage *image)\n{\n\treturn kexec_image_load_default(image);\n}"
  },
  {
    "function_name": "kexec_image_load_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "63-72",
    "snippet": "static void *kexec_image_load_default(struct kimage *image)\n{\n\tif (!image->fops || !image->fops->load)\n\t\treturn ERR_PTR(-ENOEXEC);\n\n\treturn image->fops->load(image, image->kernel_buf,\n\t\t\t\t image->kernel_buf_len, image->initrd_buf,\n\t\t\t\t image->initrd_buf_len, image->cmdline_buf,\n\t\t\t\t image->cmdline_buf_len);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "image->fops->load",
          "args": [
            "image",
            "image->kernel_buf",
            "image->kernel_buf_len",
            "image->initrd_buf",
            "image->initrd_buf_len",
            "image->cmdline_buf",
            "image->cmdline_buf_len"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOEXEC"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nstatic void *kexec_image_load_default(struct kimage *image)\n{\n\tif (!image->fops || !image->fops->load)\n\t\treturn ERR_PTR(-ENOEXEC);\n\n\treturn image->fops->load(image, image->kernel_buf,\n\t\t\t\t image->kernel_buf_len, image->initrd_buf,\n\t\t\t\t image->initrd_buf_len, image->cmdline_buf,\n\t\t\t\t image->cmdline_buf_len);\n}"
  },
  {
    "function_name": "arch_kexec_kernel_image_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "57-61",
    "snippet": "int __weak arch_kexec_kernel_image_probe(struct kimage *image, void *buf,\n\t\t\t\t\t unsigned long buf_len)\n{\n\treturn kexec_image_probe_default(image, buf, buf_len);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kexec_image_probe_default",
          "args": [
            "image",
            "buf",
            "buf_len"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_image_probe_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
          "lines": "39-54",
          "snippet": "int kexec_image_probe_default(struct kimage *image, void *buf,\n\t\t\t      unsigned long buf_len)\n{\n\tconst struct kexec_file_ops * const *fops;\n\tint ret = -ENOEXEC;\n\n\tfor (fops = &kexec_file_loaders[0]; *fops && (*fops)->probe; ++fops) {\n\t\tret = (*fops)->probe(buf, buf_len);\n\t\tif (!ret) {\n\t\t\timage->fops = *fops;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint kexec_image_probe_default(struct kimage *image, void *buf,\n\t\t\t      unsigned long buf_len)\n{\n\tconst struct kexec_file_ops * const *fops;\n\tint ret = -ENOEXEC;\n\n\tfor (fops = &kexec_file_loaders[0]; *fops && (*fops)->probe; ++fops) {\n\t\tret = (*fops)->probe(buf, buf_len);\n\t\tif (!ret) {\n\t\t\timage->fops = *fops;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint __weak arch_kexec_kernel_image_probe(struct kimage *image, void *buf,\n\t\t\t\t\t unsigned long buf_len)\n{\n\treturn kexec_image_probe_default(image, buf, buf_len);\n}"
  },
  {
    "function_name": "kexec_image_probe_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "39-54",
    "snippet": "int kexec_image_probe_default(struct kimage *image, void *buf,\n\t\t\t      unsigned long buf_len)\n{\n\tconst struct kexec_file_ops * const *fops;\n\tint ret = -ENOEXEC;\n\n\tfor (fops = &kexec_file_loaders[0]; *fops && (*fops)->probe; ++fops) {\n\t\tret = (*fops)->probe(buf, buf_len);\n\t\tif (!ret) {\n\t\t\timage->fops = *fops;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "buf",
            "buf_len"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint kexec_image_probe_default(struct kimage *image, void *buf,\n\t\t\t      unsigned long buf_len)\n{\n\tconst struct kexec_file_ops * const *fops;\n\tint ret = -ENOEXEC;\n\n\tfor (fops = &kexec_file_loaders[0]; *fops && (*fops)->probe; ++fops) {\n\t\tret = (*fops)->probe(buf, buf_len);\n\t\tif (!ret) {\n\t\t\timage->fops = *fops;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kexec_file_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_file.c",
    "lines": "318-406",
    "snippet": "SYSCALL_DEFINE5(kexec_file_load, int, kernel_fd, int, initrd_fd,\n\t\tunsigned long, cmdline_len, const char __user *, cmdline_ptr,\n\t\tunsigned long, flags)\n{\n\tint ret = 0, i;\n\tstruct kimage **dest_image, *image;\n\n\t/* We only trust the superuser with rebooting the system. */\n\tif (!capable(CAP_SYS_BOOT) || kexec_load_disabled)\n\t\treturn -EPERM;\n\n\t/* Make sure we have a legal set of flags */\n\tif (flags != (flags & KEXEC_FILE_FLAGS))\n\t\treturn -EINVAL;\n\n\timage = NULL;\n\n\tif (!mutex_trylock(&kexec_mutex))\n\t\treturn -EBUSY;\n\n\tdest_image = &kexec_image;\n\tif (flags & KEXEC_FILE_ON_CRASH) {\n\t\tdest_image = &kexec_crash_image;\n\t\tif (kexec_crash_image)\n\t\t\tarch_kexec_unprotect_crashkres();\n\t}\n\n\tif (flags & KEXEC_FILE_UNLOAD)\n\t\tgoto exchange;\n\n\t/*\n\t * In case of crash, new kernel gets loaded in reserved region. It is\n\t * same memory where old crash kernel might be loaded. Free any\n\t * current crash dump kernel before we corrupt it.\n\t */\n\tif (flags & KEXEC_FILE_ON_CRASH)\n\t\tkimage_free(xchg(&kexec_crash_image, NULL));\n\n\tret = kimage_file_alloc_init(&image, kernel_fd, initrd_fd, cmdline_ptr,\n\t\t\t\t     cmdline_len, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tret = machine_kexec_prepare(image);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Some architecture(like S390) may touch the crash memory before\n\t * machine_kexec_prepare(), we must copy vmcoreinfo data after it.\n\t */\n\tret = kimage_crash_copy_vmcoreinfo(image);\n\tif (ret)\n\t\tgoto out;\n\n\tret = kexec_calculate_store_digests(image);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tstruct kexec_segment *ksegment;\n\n\t\tksegment = &image->segment[i];\n\t\tpr_debug(\"Loading segment %d: buf=0x%p bufsz=0x%zx mem=0x%lx memsz=0x%zx\\n\",\n\t\t\t i, ksegment->buf, ksegment->bufsz, ksegment->mem,\n\t\t\t ksegment->memsz);\n\n\t\tret = kimage_load_segment(image, &image->segment[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tkimage_terminate(image);\n\n\t/*\n\t * Free up any temporary buffers allocated which are not needed\n\t * after image has been loaded\n\t */\n\tkimage_file_post_load_cleanup(image);\nexchange:\n\timage = xchg(dest_image, image);\nout:\n\tif ((flags & KEXEC_FILE_ON_CRASH) && kexec_crash_image)\n\t\tarch_kexec_protect_crashkres();\n\n\tmutex_unlock(&kexec_mutex);\n\tkimage_free(image);\n\treturn ret;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kexec_calculate_store_digests(struct kimage *image);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nSYSCALL_DEFINE5(kexec_file_load, int, kernel_fd, int, initrd_fd,\n\t\tunsigned long, cmdline_len, const char __user *, cmdline_ptr,\n\t\tunsigned long, flags)\n{\n\tint ret = 0, i;\n\tstruct kimage **dest_image, *image;\n\n\t/* We only trust the superuser with rebooting the system. */\n\tif (!capable(CAP_SYS_BOOT) || kexec_load_disabled)\n\t\treturn -EPERM;\n\n\t/* Make sure we have a legal set of flags */\n\tif (flags != (flags & KEXEC_FILE_FLAGS))\n\t\treturn -EINVAL;\n\n\timage = NULL;\n\n\tif (!mutex_trylock(&kexec_mutex))\n\t\treturn -EBUSY;\n\n\tdest_image = &kexec_image;\n\tif (flags & KEXEC_FILE_ON_CRASH) {\n\t\tdest_image = &kexec_crash_image;\n\t\tif (kexec_crash_image)\n\t\t\tarch_kexec_unprotect_crashkres();\n\t}\n\n\tif (flags & KEXEC_FILE_UNLOAD)\n\t\tgoto exchange;\n\n\t/*\n\t * In case of crash, new kernel gets loaded in reserved region. It is\n\t * same memory where old crash kernel might be loaded. Free any\n\t * current crash dump kernel before we corrupt it.\n\t */\n\tif (flags & KEXEC_FILE_ON_CRASH)\n\t\tkimage_free(xchg(&kexec_crash_image, NULL));\n\n\tret = kimage_file_alloc_init(&image, kernel_fd, initrd_fd, cmdline_ptr,\n\t\t\t\t     cmdline_len, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tret = machine_kexec_prepare(image);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Some architecture(like S390) may touch the crash memory before\n\t * machine_kexec_prepare(), we must copy vmcoreinfo data after it.\n\t */\n\tret = kimage_crash_copy_vmcoreinfo(image);\n\tif (ret)\n\t\tgoto out;\n\n\tret = kexec_calculate_store_digests(image);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tstruct kexec_segment *ksegment;\n\n\t\tksegment = &image->segment[i];\n\t\tpr_debug(\"Loading segment %d: buf=0x%p bufsz=0x%zx mem=0x%lx memsz=0x%zx\\n\",\n\t\t\t i, ksegment->buf, ksegment->bufsz, ksegment->mem,\n\t\t\t ksegment->memsz);\n\n\t\tret = kimage_load_segment(image, &image->segment[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tkimage_terminate(image);\n\n\t/*\n\t * Free up any temporary buffers allocated which are not needed\n\t * after image has been loaded\n\t */\n\tkimage_file_post_load_cleanup(image);\nexchange:\n\timage = xchg(dest_image, image);\nout:\n\tif ((flags & KEXEC_FILE_ON_CRASH) && kexec_crash_image)\n\t\tarch_kexec_protect_crashkres();\n\n\tmutex_unlock(&kexec_mutex);\n\tkimage_free(image);\n\treturn ret;\n}"
  }
]