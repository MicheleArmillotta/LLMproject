[
  {
    "function_name": "audit_exe_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "556-569",
    "snippet": "int audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_mark_compare",
          "args": [
            "mark",
            "ino",
            "dev"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "69-74",
          "snippet": "int audit_mark_compare(struct audit_fsnotify_mark *mark, unsigned long ino, dev_t dev)\n{\n\tif (mark->ino == AUDIT_INO_UNSET)\n\t\treturn 0;\n\treturn (mark->ino == ino) && (mark->dev == dev);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_mark_compare(struct audit_fsnotify_mark *mark, unsigned long ino, dev_t dev)\n{\n\tif (mark->ino == AUDIT_INO_UNSET)\n\t\treturn 0;\n\treturn (mark->ino == ino) && (mark->dev == dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "exe_file"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "exe_file"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "exe_file"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_exe_file",
          "args": [
            "tsk"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_exe_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1143-1156",
          "snippet": "struct file *get_task_exe_file(struct task_struct *task)\n{\n\tstruct file *exe_file = NULL;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (!(task->flags & PF_KTHREAD))\n\t\t\texe_file = get_mm_exe_file(mm);\n\t}\n\ttask_unlock(task);\n\treturn exe_file;\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstruct file *get_task_exe_file(struct task_struct *task)\n{\n\tstruct file *exe_file = NULL;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (!(task->flags & PF_KTHREAD))\n\t\t\texe_file = get_mm_exe_file(mm);\n\t}\n\ttask_unlock(task);\n\treturn exe_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}"
  },
  {
    "function_name": "audit_dupe_exe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "537-554",
    "snippet": "int audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tchar *pathname;\n\n\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));\n\tif (IS_ERR(audit_mark)) {\n\t\tkfree(pathname);\n\t\treturn PTR_ERR(audit_mark);\n\t}\n\tnew->exe = audit_mark;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "audit_mark"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pathname"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "audit_mark"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_alloc_mark",
          "args": [
            "new",
            "pathname",
            "strlen(pathname)"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "83-121",
          "snippet": "struct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pathname, int len)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint ret;\n\n\tif (pathname[0] != '/' || pathname[len-1] == '/')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdentry = kern_path_locked(pathname, &path);\n\tif (IS_ERR(dentry))\n\t\treturn (void *)dentry; /* returning an error */\n\tinode = path.dentry->d_inode;\n\tinode_unlock(inode);\n\n\taudit_mark = kzalloc(sizeof(*audit_mark), GFP_KERNEL);\n\tif (unlikely(!audit_mark)) {\n\t\taudit_mark = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfsnotify_init_mark(&audit_mark->mark, audit_fsnotify_group);\n\taudit_mark->mark.mask = AUDIT_FS_EVENTS;\n\taudit_mark->path = pathname;\n\taudit_update_mark(audit_mark, dentry->d_inode);\n\taudit_mark->rule = krule;\n\n\tret = fsnotify_add_inode_mark(&audit_mark->mark, inode, true);\n\tif (ret < 0) {\n\t\tfsnotify_put_mark(&audit_mark->mark);\n\t\taudit_mark = ERR_PTR(ret);\n\t}\nout:\n\tdput(dentry);\n\tpath_put(&path);\n\treturn audit_mark;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AUDIT_FS_EVENTS (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\t FS_MOVE_SELF | FS_EVENT_ON_CHILD)"
          ],
          "globals_used": [
            "static struct fsnotify_group *audit_fsnotify_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\n#define AUDIT_FS_EVENTS (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\t FS_MOVE_SELF | FS_EVENT_ON_CHILD)\n\nstatic struct fsnotify_group *audit_fsnotify_group;\n\nstruct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pathname, int len)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint ret;\n\n\tif (pathname[0] != '/' || pathname[len-1] == '/')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdentry = kern_path_locked(pathname, &path);\n\tif (IS_ERR(dentry))\n\t\treturn (void *)dentry; /* returning an error */\n\tinode = path.dentry->d_inode;\n\tinode_unlock(inode);\n\n\taudit_mark = kzalloc(sizeof(*audit_mark), GFP_KERNEL);\n\tif (unlikely(!audit_mark)) {\n\t\taudit_mark = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfsnotify_init_mark(&audit_mark->mark, audit_fsnotify_group);\n\taudit_mark->mark.mask = AUDIT_FS_EVENTS;\n\taudit_mark->path = pathname;\n\taudit_update_mark(audit_mark, dentry->d_inode);\n\taudit_mark->rule = krule;\n\n\tret = fsnotify_add_inode_mark(&audit_mark->mark, inode, true);\n\tif (ret < 0) {\n\t\tfsnotify_put_mark(&audit_mark->mark);\n\t\taudit_mark = ERR_PTR(ret);\n\t}\nout:\n\tdput(dentry);\n\tpath_put(&path);\n\treturn audit_mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pathname"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "audit_mark_path(old->exe)",
            "GFP_KERNEL"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_mark_path",
          "args": [
            "old->exe"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "64-67",
          "snippet": "char *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tchar *pathname;\n\n\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));\n\tif (IS_ERR(audit_mark)) {\n\t\tkfree(pathname);\n\t\treturn PTR_ERR(audit_mark);\n\t}\n\tnew->exe = audit_mark;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_watch_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "526-534",
    "snippet": "static int __init audit_watch_init(void)\n{\n\taudit_watch_group = fsnotify_alloc_group(&audit_watch_fsnotify_ops);\n\tif (IS_ERR(audit_watch_group)) {\n\t\taudit_watch_group = NULL;\n\t\taudit_panic(\"cannot create audit fsnotify group\");\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;",
      "static const struct fsnotify_ops audit_watch_fsnotify_ops = {\n\t.handle_event = \taudit_watch_handle_event,\n\t.free_mark =\t\taudit_watch_free_mark,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"cannot create audit fsnotify group\""
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "310-323",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "audit_watch_group"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_alloc_group",
          "args": [
            "&audit_watch_fsnotify_ops"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\nstatic const struct fsnotify_ops audit_watch_fsnotify_ops = {\n\t.handle_event = \taudit_watch_handle_event,\n\t.free_mark =\t\taudit_watch_free_mark,\n};\n\nstatic int __init audit_watch_init(void)\n{\n\taudit_watch_group = fsnotify_alloc_group(&audit_watch_fsnotify_ops);\n\tif (IS_ERR(audit_watch_group)) {\n\t\taudit_watch_group = NULL;\n\t\taudit_panic(\"cannot create audit fsnotify group\");\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_watch_handle_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "484-519",
    "snippet": "static int audit_watch_handle_event(struct fsnotify_group *group,\n\t\t\t\t    struct inode *to_tell,\n\t\t\t\t    u32 mask, const void *data, int data_type,\n\t\t\t\t    const unsigned char *dname, u32 cookie,\n\t\t\t\t    struct fsnotify_iter_info *iter_info)\n{\n\tstruct fsnotify_mark *inode_mark = fsnotify_iter_inode_mark(iter_info);\n\tconst struct inode *inode;\n\tstruct audit_parent *parent;\n\n\tparent = container_of(inode_mark, struct audit_parent, mark);\n\n\tBUG_ON(group != audit_watch_group);\n\n\tswitch (data_type) {\n\tcase (FSNOTIFY_EVENT_PATH):\n\t\tinode = d_backing_inode(((const struct path *)data)->dentry);\n\t\tbreak;\n\tcase (FSNOTIFY_EVENT_INODE):\n\t\tinode = (const struct inode *)data;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tinode = NULL;\n\t\tbreak;\n\t}\n\n\tif (mask & (FS_CREATE|FS_MOVED_TO) && inode)\n\t\taudit_update_watch(parent, dname, inode->i_sb->s_dev, inode->i_ino, 0);\n\telse if (mask & (FS_DELETE|FS_MOVED_FROM))\n\t\taudit_update_watch(parent, dname, AUDIT_DEV_UNSET, AUDIT_INO_UNSET, 1);\n\telse if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF))\n\t\taudit_remove_parent_watches(parent);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_remove_parent_watches",
          "args": [
            "parent"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_parent_watches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "338-361",
          "snippet": "static void audit_remove_parent_watches(struct audit_parent *parent)\n{\n\tstruct audit_watch *w, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *e;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {\n\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {\n\t\t\te = container_of(r, struct audit_entry, rule);\n\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");\n\t\t\tif (e->rule.exe)\n\t\t\t\taudit_remove_mark(e->rule.exe);\n\t\t\tlist_del(&r->rlist);\n\t\t\tlist_del(&r->list);\n\t\t\tlist_del_rcu(&e->list);\n\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\t\t}\n\t\taudit_remove_watch(w);\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic void audit_remove_parent_watches(struct audit_parent *parent)\n{\n\tstruct audit_watch *w, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *e;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {\n\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {\n\t\t\te = container_of(r, struct audit_entry, rule);\n\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");\n\t\t\tif (e->rule.exe)\n\t\t\t\taudit_remove_mark(e->rule.exe);\n\t\t\tlist_del(&r->rlist);\n\t\t\tlist_del(&r->list);\n\t\t\tlist_del_rcu(&e->list);\n\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\t\t}\n\t\taudit_remove_watch(w);\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_update_watch",
          "args": [
            "parent",
            "dname",
            "AUDIT_DEV_UNSET",
            "AUDIT_INO_UNSET",
            "1"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "audit_update_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "259-335",
          "snippet": "static void audit_update_watch(struct audit_parent *parent,\n\t\t\t       const char *dname, dev_t dev,\n\t\t\t       unsigned long ino, unsigned invalidating)\n{\n\tstruct audit_watch *owatch, *nwatch, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *oentry, *nentry;\n\n\tmutex_lock(&audit_filter_mutex);\n\t/* Run all of the watches on this parent looking for the one that\n\t * matches the given dname */\n\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {\n\t\tif (audit_compare_dname_path(dname, owatch->path,\n\t\t\t\t\t     AUDIT_NAME_FULL))\n\t\t\tcontinue;\n\n\t\t/* If the update involves invalidating rules, do the inode-based\n\t\t * filtering now, so we don't omit records. */\n\t\tif (invalidating && !audit_dummy_context())\n\t\t\taudit_filter_inodes(current, audit_context());\n\n\t\t/* updating ino will likely change which audit_hash_list we\n\t\t * are on so we need a new watch for the new list */\n\t\tnwatch = audit_dupe_watch(owatch);\n\t\tif (IS_ERR(nwatch)) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\taudit_panic(\"error updating watch, skipping\");\n\t\t\treturn;\n\t\t}\n\t\tnwatch->dev = dev;\n\t\tnwatch->ino = ino;\n\n\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {\n\n\t\t\toentry = container_of(r, struct audit_entry, rule);\n\t\t\tlist_del(&oentry->rule.rlist);\n\t\t\tlist_del_rcu(&oentry->list);\n\n\t\t\tnentry = audit_dupe_rule(&oentry->rule);\n\t\t\tif (IS_ERR(nentry)) {\n\t\t\t\tlist_del(&oentry->rule.list);\n\t\t\t\taudit_panic(\"error updating watch, removing\");\n\t\t\t} else {\n\t\t\t\tint h = audit_hash_ino((u32)ino);\n\n\t\t\t\t/*\n\t\t\t\t * nentry->rule.watch == oentry->rule.watch so\n\t\t\t\t * we must drop that reference and set it to our\n\t\t\t\t * new watch.\n\t\t\t\t */\n\t\t\t\taudit_put_watch(nentry->rule.watch);\n\t\t\t\taudit_get_watch(nwatch);\n\t\t\t\tnentry->rule.watch = nwatch;\n\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);\n\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);\n\t\t\t\tlist_replace(&oentry->rule.list,\n\t\t\t\t\t     &nentry->rule.list);\n\t\t\t}\n\t\t\tif (oentry->rule.exe)\n\t\t\t\taudit_remove_mark(oentry->rule.exe);\n\n\t\t\taudit_watch_log_rule_change(r, owatch, \"updated_rules\");\n\n\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);\n\t\t}\n\n\t\taudit_remove_watch(owatch);\n\t\tgoto add_watch_to_parent; /* event applies to a single watch */\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n\nadd_watch_to_parent:\n\tlist_add(&nwatch->wlist, &parent->watches);\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_update_watch(struct audit_parent *parent,\n\t\t\t       const char *dname, dev_t dev,\n\t\t\t       unsigned long ino, unsigned invalidating)\n{\n\tstruct audit_watch *owatch, *nwatch, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *oentry, *nentry;\n\n\tmutex_lock(&audit_filter_mutex);\n\t/* Run all of the watches on this parent looking for the one that\n\t * matches the given dname */\n\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {\n\t\tif (audit_compare_dname_path(dname, owatch->path,\n\t\t\t\t\t     AUDIT_NAME_FULL))\n\t\t\tcontinue;\n\n\t\t/* If the update involves invalidating rules, do the inode-based\n\t\t * filtering now, so we don't omit records. */\n\t\tif (invalidating && !audit_dummy_context())\n\t\t\taudit_filter_inodes(current, audit_context());\n\n\t\t/* updating ino will likely change which audit_hash_list we\n\t\t * are on so we need a new watch for the new list */\n\t\tnwatch = audit_dupe_watch(owatch);\n\t\tif (IS_ERR(nwatch)) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\taudit_panic(\"error updating watch, skipping\");\n\t\t\treturn;\n\t\t}\n\t\tnwatch->dev = dev;\n\t\tnwatch->ino = ino;\n\n\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {\n\n\t\t\toentry = container_of(r, struct audit_entry, rule);\n\t\t\tlist_del(&oentry->rule.rlist);\n\t\t\tlist_del_rcu(&oentry->list);\n\n\t\t\tnentry = audit_dupe_rule(&oentry->rule);\n\t\t\tif (IS_ERR(nentry)) {\n\t\t\t\tlist_del(&oentry->rule.list);\n\t\t\t\taudit_panic(\"error updating watch, removing\");\n\t\t\t} else {\n\t\t\t\tint h = audit_hash_ino((u32)ino);\n\n\t\t\t\t/*\n\t\t\t\t * nentry->rule.watch == oentry->rule.watch so\n\t\t\t\t * we must drop that reference and set it to our\n\t\t\t\t * new watch.\n\t\t\t\t */\n\t\t\t\taudit_put_watch(nentry->rule.watch);\n\t\t\t\taudit_get_watch(nwatch);\n\t\t\t\tnentry->rule.watch = nwatch;\n\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);\n\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);\n\t\t\t\tlist_replace(&oentry->rule.list,\n\t\t\t\t\t     &nentry->rule.list);\n\t\t\t}\n\t\t\tif (oentry->rule.exe)\n\t\t\t\taudit_remove_mark(oentry->rule.exe);\n\n\t\t\taudit_watch_log_rule_change(r, owatch, \"updated_rules\");\n\n\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);\n\t\t}\n\n\t\taudit_remove_watch(owatch);\n\t\tgoto add_watch_to_parent; /* event applies to a single watch */\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n\nadd_watch_to_parent:\n\tlist_add(&nwatch->wlist, &parent->watches);\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "((const struct path *)data)->dentry"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "group != audit_watch_group"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode_mark",
            "structaudit_parent",
            "mark"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_iter_inode_mark",
          "args": [
            "iter_info"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic int audit_watch_handle_event(struct fsnotify_group *group,\n\t\t\t\t    struct inode *to_tell,\n\t\t\t\t    u32 mask, const void *data, int data_type,\n\t\t\t\t    const unsigned char *dname, u32 cookie,\n\t\t\t\t    struct fsnotify_iter_info *iter_info)\n{\n\tstruct fsnotify_mark *inode_mark = fsnotify_iter_inode_mark(iter_info);\n\tconst struct inode *inode;\n\tstruct audit_parent *parent;\n\n\tparent = container_of(inode_mark, struct audit_parent, mark);\n\n\tBUG_ON(group != audit_watch_group);\n\n\tswitch (data_type) {\n\tcase (FSNOTIFY_EVENT_PATH):\n\t\tinode = d_backing_inode(((const struct path *)data)->dentry);\n\t\tbreak;\n\tcase (FSNOTIFY_EVENT_INODE):\n\t\tinode = (const struct inode *)data;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tinode = NULL;\n\t\tbreak;\n\t}\n\n\tif (mask & (FS_CREATE|FS_MOVED_TO) && inode)\n\t\taudit_update_watch(parent, dname, inode->i_sb->s_dev, inode->i_ino, 0);\n\telse if (mask & (FS_DELETE|FS_MOVED_FROM))\n\t\taudit_update_watch(parent, dname, AUDIT_DEV_UNSET, AUDIT_INO_UNSET, 1);\n\telse if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF))\n\t\taudit_remove_parent_watches(parent);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_remove_watch_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "463-481",
    "snippet": "void audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_parent",
          "args": [
            "parent"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "91-95",
          "snippet": "static void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "&parent->mark",
            "audit_watch_group"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&parent->watches"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_watch",
          "args": [
            "watch"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_watch_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "463-481",
          "snippet": "void audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_parent",
          "args": [
            "parent"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "85-89",
          "snippet": "static void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&krule->rlist"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nvoid audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}"
  },
  {
    "function_name": "audit_add_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "416-461",
    "snippet": "int audit_add_watch(struct audit_krule *krule, struct list_head **list)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent;\n\tstruct path parent_path;\n\tint h, ret = 0;\n\n\t/*\n\t * When we will be calling audit_add_to_parent, krule->watch might have\n\t * been updated and watch might have been freed.\n\t * So we need to keep a reference of watch.\n\t */\n\taudit_get_watch(watch);\n\n\tmutex_unlock(&audit_filter_mutex);\n\n\t/* Avoid calling path_lookup under audit_filter_mutex. */\n\tret = audit_get_nd(watch, &parent_path);\n\n\t/* caller expects mutex locked */\n\tmutex_lock(&audit_filter_mutex);\n\n\tif (ret) {\n\t\taudit_put_watch(watch);\n\t\treturn ret;\n\t}\n\n\t/* either find an old parent or attach a new one */\n\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));\n\tif (!parent) {\n\t\tparent = audit_init_parent(&parent_path);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\taudit_add_to_parent(krule, parent);\n\n\th = audit_hash_ino((u32)watch->ino);\n\t*list = &audit_inode_hash[h];\nerror:\n\tpath_put(&parent_path);\n\taudit_put_watch(watch);\n\treturn ret;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_watch",
          "args": [
            "watch"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "118-126",
          "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&parent_path"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_hash_ino",
          "args": [
            "(u32)watch->ino"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "audit_hash_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.h",
          "lines": "227-230",
          "snippet": "static inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}",
          "includes": [
            "#include <linux/tty.h>",
            "#include <uapi/linux/mqueue.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/audit.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define AUDIT_INODE_BUCKETS\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tty.h>\n#include <uapi/linux/mqueue.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/fs.h>\n\n#define AUDIT_INODE_BUCKETS\t32\n\nstatic inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_add_to_parent",
          "args": [
            "krule",
            "parent"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "audit_add_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "381-412",
          "snippet": "static void audit_add_to_parent(struct audit_krule *krule,\n\t\t\t\tstruct audit_parent *parent)\n{\n\tstruct audit_watch *w, *watch = krule->watch;\n\tint watch_found = 0;\n\n\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));\n\n\tlist_for_each_entry(w, &parent->watches, wlist) {\n\t\tif (strcmp(watch->path, w->path))\n\t\t\tcontinue;\n\n\t\twatch_found = 1;\n\n\t\t/* put krule's ref to temporary watch */\n\t\taudit_put_watch(watch);\n\n\t\taudit_get_watch(w);\n\t\tkrule->watch = watch = w;\n\n\t\taudit_put_parent(parent);\n\t\tbreak;\n\t}\n\n\tif (!watch_found) {\n\t\twatch->parent = parent;\n\n\t\taudit_get_watch(watch);\n\t\tlist_add(&watch->wlist, &parent->watches);\n\t}\n\tlist_add(&krule->rlist, &watch->rules);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_add_to_parent(struct audit_krule *krule,\n\t\t\t\tstruct audit_parent *parent)\n{\n\tstruct audit_watch *w, *watch = krule->watch;\n\tint watch_found = 0;\n\n\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));\n\n\tlist_for_each_entry(w, &parent->watches, wlist) {\n\t\tif (strcmp(watch->path, w->path))\n\t\t\tcontinue;\n\n\t\twatch_found = 1;\n\n\t\t/* put krule's ref to temporary watch */\n\t\taudit_put_watch(watch);\n\n\t\taudit_get_watch(w);\n\t\tkrule->watch = watch = w;\n\n\t\taudit_put_parent(parent);\n\t\tbreak;\n\t}\n\n\tif (!watch_found) {\n\t\twatch->parent = parent;\n\n\t\taudit_get_watch(watch);\n\t\tlist_add(&watch->wlist, &parent->watches);\n\t}\n\tlist_add(&krule->rlist, &watch->rules);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "parent"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "parent"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_init_parent",
          "args": [
            "&parent_path"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "audit_init_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "149-170",
          "snippet": "static struct audit_parent *audit_init_parent(struct path *path)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct audit_parent *parent;\n\tint ret;\n\n\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\tif (unlikely(!parent))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&parent->watches);\n\n\tfsnotify_init_mark(&parent->mark, audit_watch_group);\n\tparent->mark.mask = AUDIT_FS_WATCH;\n\tret = fsnotify_add_inode_mark(&parent->mark, inode, 0);\n\tif (ret < 0) {\n\t\taudit_free_parent(parent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn parent;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\tFS_MOVE_SELF | FS_EVENT_ON_CHILD | FS_UNMOUNT)"
          ],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\n#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\tFS_MOVE_SELF | FS_EVENT_ON_CHILD | FS_UNMOUNT)\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic struct audit_parent *audit_init_parent(struct path *path)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct audit_parent *parent;\n\tint ret;\n\n\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\tif (unlikely(!parent))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&parent->watches);\n\n\tfsnotify_init_mark(&parent->mark, audit_watch_group);\n\tparent->mark.mask = AUDIT_FS_WATCH;\n\tret = fsnotify_add_inode_mark(&parent->mark, inode, 0);\n\tif (ret < 0) {\n\t\taudit_free_parent(parent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_find_parent",
          "args": [
            "d_backing_inode(parent_path.dentry)"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "audit_find_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "101-111",
          "snippet": "static inline struct audit_parent *audit_find_parent(struct inode *inode)\n{\n\tstruct audit_parent *parent = NULL;\n\tstruct fsnotify_mark *entry;\n\n\tentry = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_watch_group);\n\tif (entry)\n\t\tparent = container_of(entry, struct audit_parent, mark);\n\n\treturn parent;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic inline struct audit_parent *audit_find_parent(struct inode *inode)\n{\n\tstruct audit_parent *parent = NULL;\n\tstruct fsnotify_mark *entry;\n\n\tentry = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_watch_group);\n\tif (entry)\n\t\tparent = container_of(entry, struct audit_parent, mark);\n\n\treturn parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "parent_path.dentry"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_nd",
          "args": [
            "watch",
            "&parent_path"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_nd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "364-377",
          "snippet": "static int audit_get_nd(struct audit_watch *watch, struct path *parent)\n{\n\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tif (d_is_positive(d)) {\n\t\t/* update watch filter fields */\n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n\t}\n\tdput(d);\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic int audit_get_nd(struct audit_watch *watch, struct path *parent)\n{\n\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tif (d_is_positive(d)) {\n\t\t/* update watch filter fields */\n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n\t}\n\tdput(d);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_watch",
          "args": [
            "watch"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "113-116",
          "snippet": "void audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_add_watch(struct audit_krule *krule, struct list_head **list)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent;\n\tstruct path parent_path;\n\tint h, ret = 0;\n\n\t/*\n\t * When we will be calling audit_add_to_parent, krule->watch might have\n\t * been updated and watch might have been freed.\n\t * So we need to keep a reference of watch.\n\t */\n\taudit_get_watch(watch);\n\n\tmutex_unlock(&audit_filter_mutex);\n\n\t/* Avoid calling path_lookup under audit_filter_mutex. */\n\tret = audit_get_nd(watch, &parent_path);\n\n\t/* caller expects mutex locked */\n\tmutex_lock(&audit_filter_mutex);\n\n\tif (ret) {\n\t\taudit_put_watch(watch);\n\t\treturn ret;\n\t}\n\n\t/* either find an old parent or attach a new one */\n\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));\n\tif (!parent) {\n\t\tparent = audit_init_parent(&parent_path);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\taudit_add_to_parent(krule, parent);\n\n\th = audit_hash_ino((u32)watch->ino);\n\t*list = &audit_inode_hash[h];\nerror:\n\tpath_put(&parent_path);\n\taudit_put_watch(watch);\n\treturn ret;\n}"
  },
  {
    "function_name": "audit_add_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "381-412",
    "snippet": "static void audit_add_to_parent(struct audit_krule *krule,\n\t\t\t\tstruct audit_parent *parent)\n{\n\tstruct audit_watch *w, *watch = krule->watch;\n\tint watch_found = 0;\n\n\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));\n\n\tlist_for_each_entry(w, &parent->watches, wlist) {\n\t\tif (strcmp(watch->path, w->path))\n\t\t\tcontinue;\n\n\t\twatch_found = 1;\n\n\t\t/* put krule's ref to temporary watch */\n\t\taudit_put_watch(watch);\n\n\t\taudit_get_watch(w);\n\t\tkrule->watch = watch = w;\n\n\t\taudit_put_parent(parent);\n\t\tbreak;\n\t}\n\n\tif (!watch_found) {\n\t\twatch->parent = parent;\n\n\t\taudit_get_watch(watch);\n\t\tlist_add(&watch->wlist, &parent->watches);\n\t}\n\tlist_add(&krule->rlist, &watch->rules);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&krule->rlist",
            "&watch->rules"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_watch",
          "args": [
            "watch"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "113-116",
          "snippet": "void audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_parent",
          "args": [
            "parent"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "91-95",
          "snippet": "static void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_watch",
          "args": [
            "watch"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "118-126",
          "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "watch->path",
            "w->path"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "w",
            "&parent->watches",
            "wlist"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&audit_filter_mutex)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_add_to_parent(struct audit_krule *krule,\n\t\t\t\tstruct audit_parent *parent)\n{\n\tstruct audit_watch *w, *watch = krule->watch;\n\tint watch_found = 0;\n\n\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));\n\n\tlist_for_each_entry(w, &parent->watches, wlist) {\n\t\tif (strcmp(watch->path, w->path))\n\t\t\tcontinue;\n\n\t\twatch_found = 1;\n\n\t\t/* put krule's ref to temporary watch */\n\t\taudit_put_watch(watch);\n\n\t\taudit_get_watch(w);\n\t\tkrule->watch = watch = w;\n\n\t\taudit_put_parent(parent);\n\t\tbreak;\n\t}\n\n\tif (!watch_found) {\n\t\twatch->parent = parent;\n\n\t\taudit_get_watch(watch);\n\t\tlist_add(&watch->wlist, &parent->watches);\n\t}\n\tlist_add(&krule->rlist, &watch->rules);\n}"
  },
  {
    "function_name": "audit_get_nd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "364-377",
    "snippet": "static int audit_get_nd(struct audit_watch *watch, struct path *parent)\n{\n\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tif (d_is_positive(d)) {\n\t\t/* update watch filter fields */\n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n\t}\n\tdput(d);\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "d"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "d"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_positive",
          "args": [
            "d"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "d_backing_inode(parent->dentry)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "parent->dentry"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "d"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path_locked",
          "args": [
            "watch->path",
            "parent"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic int audit_get_nd(struct audit_watch *watch, struct path *parent)\n{\n\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tif (d_is_positive(d)) {\n\t\t/* update watch filter fields */\n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n\t}\n\tdput(d);\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_remove_parent_watches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "338-361",
    "snippet": "static void audit_remove_parent_watches(struct audit_parent *parent)\n{\n\tstruct audit_watch *w, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *e;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {\n\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {\n\t\t\te = container_of(r, struct audit_entry, rule);\n\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");\n\t\t\tif (e->rule.exe)\n\t\t\t\taudit_remove_mark(e->rule.exe);\n\t\t\tlist_del(&r->rlist);\n\t\t\tlist_del(&r->list);\n\t\t\tlist_del_rcu(&e->list);\n\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\t\t}\n\t\taudit_remove_watch(w);\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "&parent->mark",
            "audit_watch_group"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_watch",
          "args": [
            "w"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_watch_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "463-481",
          "snippet": "void audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nvoid audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&e->rcu",
            "audit_free_rule_rcu"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&e->list"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&r->list"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "e->rule.exe"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "149-154",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_watch_log_rule_change",
          "args": [
            "r",
            "w",
            "\"remove_rule\""
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "audit_watch_log_rule_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "239-256",
          "snippet": "static void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(NULL, GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"auid=%u ses=%u op=%s\",\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t audit_get_sessionid(current), op);\n\taudit_log_format(ab, \" path=\");\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(NULL, GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"auid=%u ses=%u op=%s\",\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t audit_get_sessionid(current), op);\n\taudit_log_format(ab, \" path=\");\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "r",
            "structaudit_entry",
            "rule"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "r",
            "nextr",
            "&w->rules",
            "rlist"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "w",
            "nextw",
            "&parent->watches",
            "wlist"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic void audit_remove_parent_watches(struct audit_parent *parent)\n{\n\tstruct audit_watch *w, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *e;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {\n\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {\n\t\t\te = container_of(r, struct audit_entry, rule);\n\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");\n\t\t\tif (e->rule.exe)\n\t\t\t\taudit_remove_mark(e->rule.exe);\n\t\t\tlist_del(&r->rlist);\n\t\t\tlist_del(&r->list);\n\t\t\tlist_del_rcu(&e->list);\n\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\t\t}\n\t\taudit_remove_watch(w);\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n}"
  },
  {
    "function_name": "audit_update_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "259-335",
    "snippet": "static void audit_update_watch(struct audit_parent *parent,\n\t\t\t       const char *dname, dev_t dev,\n\t\t\t       unsigned long ino, unsigned invalidating)\n{\n\tstruct audit_watch *owatch, *nwatch, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *oentry, *nentry;\n\n\tmutex_lock(&audit_filter_mutex);\n\t/* Run all of the watches on this parent looking for the one that\n\t * matches the given dname */\n\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {\n\t\tif (audit_compare_dname_path(dname, owatch->path,\n\t\t\t\t\t     AUDIT_NAME_FULL))\n\t\t\tcontinue;\n\n\t\t/* If the update involves invalidating rules, do the inode-based\n\t\t * filtering now, so we don't omit records. */\n\t\tif (invalidating && !audit_dummy_context())\n\t\t\taudit_filter_inodes(current, audit_context());\n\n\t\t/* updating ino will likely change which audit_hash_list we\n\t\t * are on so we need a new watch for the new list */\n\t\tnwatch = audit_dupe_watch(owatch);\n\t\tif (IS_ERR(nwatch)) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\taudit_panic(\"error updating watch, skipping\");\n\t\t\treturn;\n\t\t}\n\t\tnwatch->dev = dev;\n\t\tnwatch->ino = ino;\n\n\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {\n\n\t\t\toentry = container_of(r, struct audit_entry, rule);\n\t\t\tlist_del(&oentry->rule.rlist);\n\t\t\tlist_del_rcu(&oentry->list);\n\n\t\t\tnentry = audit_dupe_rule(&oentry->rule);\n\t\t\tif (IS_ERR(nentry)) {\n\t\t\t\tlist_del(&oentry->rule.list);\n\t\t\t\taudit_panic(\"error updating watch, removing\");\n\t\t\t} else {\n\t\t\t\tint h = audit_hash_ino((u32)ino);\n\n\t\t\t\t/*\n\t\t\t\t * nentry->rule.watch == oentry->rule.watch so\n\t\t\t\t * we must drop that reference and set it to our\n\t\t\t\t * new watch.\n\t\t\t\t */\n\t\t\t\taudit_put_watch(nentry->rule.watch);\n\t\t\t\taudit_get_watch(nwatch);\n\t\t\t\tnentry->rule.watch = nwatch;\n\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);\n\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);\n\t\t\t\tlist_replace(&oentry->rule.list,\n\t\t\t\t\t     &nentry->rule.list);\n\t\t\t}\n\t\t\tif (oentry->rule.exe)\n\t\t\t\taudit_remove_mark(oentry->rule.exe);\n\n\t\t\taudit_watch_log_rule_change(r, owatch, \"updated_rules\");\n\n\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);\n\t\t}\n\n\t\taudit_remove_watch(owatch);\n\t\tgoto add_watch_to_parent; /* event applies to a single watch */\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n\nadd_watch_to_parent:\n\tlist_add(&nwatch->wlist, &parent->watches);\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&nwatch->wlist",
            "&parent->watches"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_watch",
          "args": [
            "owatch"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_watch_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "463-481",
          "snippet": "void audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nvoid audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&oentry->rcu",
            "audit_free_rule_rcu"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_watch_log_rule_change",
          "args": [
            "r",
            "owatch",
            "\"updated_rules\""
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "audit_watch_log_rule_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "239-256",
          "snippet": "static void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(NULL, GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"auid=%u ses=%u op=%s\",\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t audit_get_sessionid(current), op);\n\taudit_log_format(ab, \" path=\");\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(NULL, GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"auid=%u ses=%u op=%s\",\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t audit_get_sessionid(current), op);\n\taudit_log_format(ab, \" path=\");\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "oentry->rule.exe"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "149-154",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace",
          "args": [
            "&oentry->rule.list",
            "&nentry->rule.list"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&nentry->list",
            "&audit_inode_hash[h]"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_watch",
          "args": [
            "nwatch"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "113-116",
          "snippet": "void audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_watch",
          "args": [
            "nentry->rule.watch"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "118-126",
          "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_hash_ino",
          "args": [
            "(u32)ino"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "audit_hash_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.h",
          "lines": "227-230",
          "snippet": "static inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}",
          "includes": [
            "#include <linux/tty.h>",
            "#include <uapi/linux/mqueue.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/audit.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define AUDIT_INODE_BUCKETS\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tty.h>\n#include <uapi/linux/mqueue.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/fs.h>\n\n#define AUDIT_INODE_BUCKETS\t32\n\nstatic inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"error updating watch, removing\""
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "310-323",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&oentry->rule.list"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nentry"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dupe_rule",
          "args": [
            "&oentry->rule"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "audit_dupe_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "800-876",
          "snippet": "struct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&oentry->list"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "r",
            "structaudit_entry",
            "rule"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "r",
            "nextr",
            "&owatch->rules",
            "rlist"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nwatch"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dupe_watch",
          "args": [
            "owatch"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "audit_dupe_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "215-237",
          "snippet": "static struct audit_watch *audit_dupe_watch(struct audit_watch *old)\n{\n\tchar *path;\n\tstruct audit_watch *new;\n\n\tpath = kstrdup(old->path, GFP_KERNEL);\n\tif (unlikely(!path))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = audit_init_watch(path);\n\tif (IS_ERR(new)) {\n\t\tkfree(path);\n\t\tgoto out;\n\t}\n\n\tnew->dev = old->dev;\n\tnew->ino = old->ino;\n\taudit_get_parent(old->parent);\n\tnew->parent = old->parent;\n\nout:\n\treturn new;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct audit_watch *audit_dupe_watch(struct audit_watch *old)\n{\n\tchar *path;\n\tstruct audit_watch *new;\n\n\tpath = kstrdup(old->path, GFP_KERNEL);\n\tif (unlikely(!path))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = audit_init_watch(path);\n\tif (IS_ERR(new)) {\n\t\tkfree(path);\n\t\tgoto out;\n\t}\n\n\tnew->dev = old->dev;\n\tnew->ino = old->ino;\n\taudit_get_parent(old->parent);\n\tnew->parent = old->parent;\n\nout:\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_inodes",
          "args": [
            "current",
            "audit_context()"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "823-837",
          "snippet": "void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dummy_context",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_compare_dname_path",
          "args": [
            "dname",
            "owatch->path",
            "AUDIT_NAME_FULL"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "audit_compare_dname_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1293-1310",
          "snippet": "int audit_compare_dname_path(const char *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = strlen(dname);\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname, dlen);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_compare_dname_path(const char *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = strlen(dname);\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname, dlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "owatch",
            "nextw",
            "&parent->watches",
            "wlist"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_update_watch(struct audit_parent *parent,\n\t\t\t       const char *dname, dev_t dev,\n\t\t\t       unsigned long ino, unsigned invalidating)\n{\n\tstruct audit_watch *owatch, *nwatch, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *oentry, *nentry;\n\n\tmutex_lock(&audit_filter_mutex);\n\t/* Run all of the watches on this parent looking for the one that\n\t * matches the given dname */\n\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {\n\t\tif (audit_compare_dname_path(dname, owatch->path,\n\t\t\t\t\t     AUDIT_NAME_FULL))\n\t\t\tcontinue;\n\n\t\t/* If the update involves invalidating rules, do the inode-based\n\t\t * filtering now, so we don't omit records. */\n\t\tif (invalidating && !audit_dummy_context())\n\t\t\taudit_filter_inodes(current, audit_context());\n\n\t\t/* updating ino will likely change which audit_hash_list we\n\t\t * are on so we need a new watch for the new list */\n\t\tnwatch = audit_dupe_watch(owatch);\n\t\tif (IS_ERR(nwatch)) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\taudit_panic(\"error updating watch, skipping\");\n\t\t\treturn;\n\t\t}\n\t\tnwatch->dev = dev;\n\t\tnwatch->ino = ino;\n\n\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {\n\n\t\t\toentry = container_of(r, struct audit_entry, rule);\n\t\t\tlist_del(&oentry->rule.rlist);\n\t\t\tlist_del_rcu(&oentry->list);\n\n\t\t\tnentry = audit_dupe_rule(&oentry->rule);\n\t\t\tif (IS_ERR(nentry)) {\n\t\t\t\tlist_del(&oentry->rule.list);\n\t\t\t\taudit_panic(\"error updating watch, removing\");\n\t\t\t} else {\n\t\t\t\tint h = audit_hash_ino((u32)ino);\n\n\t\t\t\t/*\n\t\t\t\t * nentry->rule.watch == oentry->rule.watch so\n\t\t\t\t * we must drop that reference and set it to our\n\t\t\t\t * new watch.\n\t\t\t\t */\n\t\t\t\taudit_put_watch(nentry->rule.watch);\n\t\t\t\taudit_get_watch(nwatch);\n\t\t\t\tnentry->rule.watch = nwatch;\n\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);\n\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);\n\t\t\t\tlist_replace(&oentry->rule.list,\n\t\t\t\t\t     &nentry->rule.list);\n\t\t\t}\n\t\t\tif (oentry->rule.exe)\n\t\t\t\taudit_remove_mark(oentry->rule.exe);\n\n\t\t\taudit_watch_log_rule_change(r, owatch, \"updated_rules\");\n\n\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);\n\t\t}\n\n\t\taudit_remove_watch(owatch);\n\t\tgoto add_watch_to_parent; /* event applies to a single watch */\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n\nadd_watch_to_parent:\n\tlist_add(&nwatch->wlist, &parent->watches);\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n}"
  },
  {
    "function_name": "audit_watch_log_rule_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "239-256",
    "snippet": "static void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(NULL, GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"auid=%u ses=%u op=%s\",\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t audit_get_sessionid(current), op);\n\taudit_log_format(ab, \" path=\");\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" list=%d res=1\"",
            "r->listnr"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_key",
          "args": [
            "ab",
            "r->filterkey"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2048-2055",
          "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "w->path"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2011-2014",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "audit_get_loginuid(current)"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "NULL",
            "GFP_NOFS",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(NULL, GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"auid=%u ses=%u op=%s\",\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t audit_get_sessionid(current), op);\n\taudit_log_format(ab, \" path=\");\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_dupe_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "215-237",
    "snippet": "static struct audit_watch *audit_dupe_watch(struct audit_watch *old)\n{\n\tchar *path;\n\tstruct audit_watch *new;\n\n\tpath = kstrdup(old->path, GFP_KERNEL);\n\tif (unlikely(!path))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = audit_init_watch(path);\n\tif (IS_ERR(new)) {\n\t\tkfree(path);\n\t\tgoto out;\n\t}\n\n\tnew->dev = old->dev;\n\tnew->ino = old->ino;\n\taudit_get_parent(old->parent);\n\tnew->parent = old->parent;\n\nout:\n\treturn new;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_get_parent",
          "args": [
            "old->parent"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "85-89",
          "snippet": "static void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_init_watch",
          "args": [
            "path"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "audit_init_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "173-188",
          "snippet": "static struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!path"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "old->path",
            "GFP_KERNEL"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct audit_watch *audit_dupe_watch(struct audit_watch *old)\n{\n\tchar *path;\n\tstruct audit_watch *new;\n\n\tpath = kstrdup(old->path, GFP_KERNEL);\n\tif (unlikely(!path))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = audit_init_watch(path);\n\tif (IS_ERR(new)) {\n\t\tkfree(path);\n\t\tgoto out;\n\t}\n\n\tnew->dev = old->dev;\n\tnew->ino = old->ino;\n\taudit_get_parent(old->parent);\n\tnew->parent = old->parent;\n\nout:\n\treturn new;\n}"
  },
  {
    "function_name": "audit_to_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "191-211",
    "snippet": "int audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)\n{\n\tstruct audit_watch *watch;\n\n\tif (!audit_watch_group)\n\t\treturn -EOPNOTSUPP;\n\n\tif (path[0] != '/' || path[len-1] == '/' ||\n\t    krule->listnr != AUDIT_FILTER_EXIT ||\n\t    op != Audit_equal ||\n\t    krule->inode_f || krule->watch || krule->tree)\n\t\treturn -EINVAL;\n\n\twatch = audit_init_watch(path);\n\tif (IS_ERR(watch))\n\t\treturn PTR_ERR(watch);\n\n\tkrule->watch = watch;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "watch"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "watch"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_init_watch",
          "args": [
            "path"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "audit_init_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "173-188",
          "snippet": "static struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nint audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)\n{\n\tstruct audit_watch *watch;\n\n\tif (!audit_watch_group)\n\t\treturn -EOPNOTSUPP;\n\n\tif (path[0] != '/' || path[len-1] == '/' ||\n\t    krule->listnr != AUDIT_FILTER_EXIT ||\n\t    op != Audit_equal ||\n\t    krule->inode_f || krule->watch || krule->tree)\n\t\treturn -EINVAL;\n\n\twatch = audit_init_watch(path);\n\tif (IS_ERR(watch))\n\t\treturn PTR_ERR(watch);\n\n\tkrule->watch = watch;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_init_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "173-188",
    "snippet": "static struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&watch->count",
            "1"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&watch->rules"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!watch"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*watch)",
            "GFP_KERNEL"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}"
  },
  {
    "function_name": "audit_init_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "149-170",
    "snippet": "static struct audit_parent *audit_init_parent(struct path *path)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct audit_parent *parent;\n\tint ret;\n\n\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\tif (unlikely(!parent))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&parent->watches);\n\n\tfsnotify_init_mark(&parent->mark, audit_watch_group);\n\tparent->mark.mask = AUDIT_FS_WATCH;\n\tret = fsnotify_add_inode_mark(&parent->mark, inode, 0);\n\tif (ret < 0) {\n\t\taudit_free_parent(parent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn parent;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\tFS_MOVE_SELF | FS_EVENT_ON_CHILD | FS_UNMOUNT)"
    ],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_free_parent",
          "args": [
            "parent"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "71-75",
          "snippet": "static void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_add_inode_mark",
          "args": [
            "&parent->mark",
            "inode",
            "0"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_init_mark",
          "args": [
            "&parent->mark",
            "audit_watch_group"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&parent->watches"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!parent"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*parent)",
            "GFP_KERNEL"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path->dentry"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\n#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\tFS_MOVE_SELF | FS_EVENT_ON_CHILD | FS_UNMOUNT)\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic struct audit_parent *audit_init_parent(struct path *path)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct audit_parent *parent;\n\tint ret;\n\n\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\tif (unlikely(!parent))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&parent->watches);\n\n\tfsnotify_init_mark(&parent->mark, audit_watch_group);\n\tparent->mark.mask = AUDIT_FS_WATCH;\n\tret = fsnotify_add_inode_mark(&parent->mark, inode, 0);\n\tif (ret < 0) {\n\t\taudit_free_parent(parent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn parent;\n}"
  },
  {
    "function_name": "audit_watch_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "141-146",
    "snippet": "int audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)\n{\n\treturn (watch->ino != AUDIT_INO_UNSET) &&\n\t\t(watch->ino == ino) &&\n\t\t(watch->dev == dev);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)\n{\n\treturn (watch->ino != AUDIT_INO_UNSET) &&\n\t\t(watch->ino == ino) &&\n\t\t(watch->dev == dev);\n}"
  },
  {
    "function_name": "audit_watch_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "136-139",
    "snippet": "char *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nchar *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}"
  },
  {
    "function_name": "audit_remove_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "128-134",
    "snippet": "static void audit_remove_watch(struct audit_watch *watch)\n{\n\tlist_del(&watch->wlist);\n\taudit_put_parent(watch->parent);\n\twatch->parent = NULL;\n\taudit_put_watch(watch); /* match initial get */\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_watch",
          "args": [
            "watch"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "118-126",
          "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_parent",
          "args": [
            "watch->parent"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "91-95",
          "snippet": "static void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&watch->wlist"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_remove_watch(struct audit_watch *watch)\n{\n\tlist_del(&watch->wlist);\n\taudit_put_parent(watch->parent);\n\twatch->parent = NULL;\n\taudit_put_watch(watch); /* match initial get */\n}"
  },
  {
    "function_name": "audit_put_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "118-126",
    "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "watch"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&watch->rules)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&watch->rules"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "watch->parent"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&watch->count"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
  },
  {
    "function_name": "audit_get_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "113-116",
    "snippet": "void audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&watch->count"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "50-53",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}"
  },
  {
    "function_name": "audit_find_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "101-111",
    "snippet": "static inline struct audit_parent *audit_find_parent(struct inode *inode)\n{\n\tstruct audit_parent *parent = NULL;\n\tstruct fsnotify_mark *entry;\n\n\tentry = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_watch_group);\n\tif (entry)\n\t\tparent = container_of(entry, struct audit_parent, mark);\n\n\treturn parent;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "entry",
            "structaudit_parent",
            "mark"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_find_mark",
          "args": [
            "&inode->i_fsnotify_marks",
            "audit_watch_group"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic inline struct audit_parent *audit_find_parent(struct inode *inode)\n{\n\tstruct audit_parent *parent = NULL;\n\tstruct fsnotify_mark *entry;\n\n\tentry = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_watch_group);\n\tif (entry)\n\t\tparent = container_of(entry, struct audit_parent, mark);\n\n\treturn parent;\n}"
  },
  {
    "function_name": "audit_put_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "91-95",
    "snippet": "static void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "&parent->mark"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "parent"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}"
  },
  {
    "function_name": "audit_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "85-89",
    "snippet": "static void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_get_mark",
          "args": [
            "&parent->mark"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "parent"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}"
  },
  {
    "function_name": "audit_watch_free_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "77-83",
    "snippet": "static void audit_watch_free_mark(struct fsnotify_mark *entry)\n{\n\tstruct audit_parent *parent;\n\n\tparent = container_of(entry, struct audit_parent, mark);\n\taudit_free_parent(parent);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_free_parent",
          "args": [
            "parent"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "71-75",
          "snippet": "static void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "entry",
            "structaudit_parent",
            "mark"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_watch_free_mark(struct fsnotify_mark *entry)\n{\n\tstruct audit_parent *parent;\n\n\tparent = container_of(entry, struct audit_parent, mark);\n\taudit_free_parent(parent);\n}"
  },
  {
    "function_name": "audit_free_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
    "lines": "71-75",
    "snippet": "static void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "parent"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&parent->watches)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&parent->watches"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}"
  }
]