[
  {
    "function_name": "wait_bit_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "243-249",
    "snippet": "void __init wait_bit_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < WAIT_TABLE_SIZE; i++)\n\t\tinit_waitqueue_head(bit_wait_table + i);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define WAIT_TABLE_SIZE (1 << WAIT_TABLE_BITS)"
    ],
    "globals_used": [
      "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "bit_wait_table + i"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_SIZE (1 << WAIT_TABLE_BITS)\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nvoid __init wait_bit_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < WAIT_TABLE_SIZE; i++)\n\t\tinit_waitqueue_head(bit_wait_table + i);\n}"
  },
  {
    "function_name": "bit_wait_io_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "229-240",
    "snippet": "__sched int bit_wait_io_timeout(struct wait_bit_key *word, int mode)\n{\n\tunsigned long now = READ_ONCE(jiffies);\n\n\tif (time_after_eq(now, word->timeout))\n\t\treturn -EAGAIN;\n\tio_schedule_timeout(word->timeout - now);\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "mode",
            "current"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule_timeout",
          "args": [
            "word->timeout - now"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5119-5129",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "now",
            "word->timeout"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n__sched int bit_wait_io_timeout(struct wait_bit_key *word, int mode)\n{\n\tunsigned long now = READ_ONCE(jiffies);\n\n\tif (time_after_eq(now, word->timeout))\n\t\treturn -EAGAIN;\n\tio_schedule_timeout(word->timeout - now);\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bit_wait_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "215-226",
    "snippet": "__sched int bit_wait_timeout(struct wait_bit_key *word, int mode)\n{\n\tunsigned long now = READ_ONCE(jiffies);\n\n\tif (time_after_eq(now, word->timeout))\n\t\treturn -EAGAIN;\n\tschedule_timeout(word->timeout - now);\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "mode",
            "current"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "word->timeout - now"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5119-5129",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "now",
            "word->timeout"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n__sched int bit_wait_timeout(struct wait_bit_key *word, int mode)\n{\n\tunsigned long now = READ_ONCE(jiffies);\n\n\tif (time_after_eq(now, word->timeout))\n\t\treturn -EAGAIN;\n\tschedule_timeout(word->timeout - now);\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bit_wait_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "205-212",
    "snippet": "__sched int bit_wait_io(struct wait_bit_key *word, int mode)\n{\n\tio_schedule();\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "mode",
            "current"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5132-5139",
          "snippet": "void io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n__sched int bit_wait_io(struct wait_bit_key *word, int mode)\n{\n\tio_schedule();\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bit_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "195-202",
    "snippet": "__sched int bit_wait(struct wait_bit_key *word, int mode)\n{\n\tschedule();\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "mode",
            "current"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5132-5139",
          "snippet": "void io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n__sched int bit_wait(struct wait_bit_key *word, int mode)\n{\n\tschedule();\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wake_up_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "189-192",
    "snippet": "void wake_up_var(void *var)\n{\n\t__wake_up_bit(__var_waitqueue(var), var, -1);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_bit",
          "args": [
            "__var_waitqueue(var)",
            "var",
            "-1"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "120-126",
          "snippet": "void __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit)\n{\n\tstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);\n\n\tif (waitqueue_active(wq_head))\n\t\t__wake_up(wq_head, TASK_NORMAL, 1, &key);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit)\n{\n\tstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);\n\n\tif (waitqueue_active(wq_head))\n\t\t__wake_up(wq_head, TASK_NORMAL, 1, &key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__var_waitqueue",
          "args": [
            "var"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__var_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "152-155",
          "snippet": "wait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid wake_up_var(void *var)\n{\n\t__wake_up_bit(__var_waitqueue(var), var, -1);\n}"
  },
  {
    "function_name": "init_wait_var_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "173-186",
    "snippet": "void init_wait_var_entry(struct wait_bit_queue_entry *wbq_entry, void *var, int flags)\n{\n\t*wbq_entry = (struct wait_bit_queue_entry){\n\t\t.key = {\n\t\t\t.flags\t= (var),\n\t\t\t.bit_nr = -1,\n\t\t},\n\t\t.wq_entry = {\n\t\t\t.private = current,\n\t\t\t.func\t = var_wake_function,\n\t\t\t.entry\t = LIST_HEAD_INIT(wbq_entry->wq_entry.entry),\n\t\t},\n\t};\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_HEAD_INIT",
          "args": [
            "wbq_entry->wq_entry.entry"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid init_wait_var_entry(struct wait_bit_queue_entry *wbq_entry, void *var, int flags)\n{\n\t*wbq_entry = (struct wait_bit_queue_entry){\n\t\t.key = {\n\t\t\t.flags\t= (var),\n\t\t\t.bit_nr = -1,\n\t\t},\n\t\t.wq_entry = {\n\t\t\t.private = current,\n\t\t\t.func\t = var_wake_function,\n\t\t\t.entry\t = LIST_HEAD_INIT(wbq_entry->wq_entry.entry),\n\t\t},\n\t};\n}"
  },
  {
    "function_name": "var_wake_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "158-171",
    "snippet": "static int\nvar_wake_function(struct wait_queue_entry *wq_entry, unsigned int mode,\n\t\t  int sync, void *arg)\n{\n\tstruct wait_bit_key *key = arg;\n\tstruct wait_bit_queue_entry *wbq_entry =\n\t\tcontainer_of(wq_entry, struct wait_bit_queue_entry, wq_entry);\n\n\tif (wbq_entry->key.flags != key->flags ||\n\t    wbq_entry->key.bit_nr != key->bit_nr)\n\t\treturn 0;\n\n\treturn autoremove_wake_function(wq_entry, mode, sync, key);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autoremove_wake_function",
          "args": [
            "wq_entry",
            "mode",
            "sync",
            "key"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "autoremove_wake_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "373-381",
          "snippet": "int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init(&wq_entry->entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init(&wq_entry->entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wq_entry",
            "structwait_bit_queue_entry",
            "wq_entry"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int\nvar_wake_function(struct wait_queue_entry *wq_entry, unsigned int mode,\n\t\t  int sync, void *arg)\n{\n\tstruct wait_bit_key *key = arg;\n\tstruct wait_bit_queue_entry *wbq_entry =\n\t\tcontainer_of(wq_entry, struct wait_bit_queue_entry, wq_entry);\n\n\tif (wbq_entry->key.flags != key->flags ||\n\t    wbq_entry->key.bit_nr != key->bit_nr)\n\t\treturn 0;\n\n\treturn autoremove_wake_function(wq_entry, mode, sync, key);\n}"
  },
  {
    "function_name": "__var_waitqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "152-155",
    "snippet": "wait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define WAIT_TABLE_BITS 8"
    ],
    "globals_used": [
      "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "p",
            "WAIT_TABLE_BITS"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}"
  },
  {
    "function_name": "wake_up_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "146-149",
    "snippet": "void wake_up_bit(void *word, int bit)\n{\n\t__wake_up_bit(bit_waitqueue(word, bit), word, bit);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_bit",
          "args": [
            "bit_waitqueue(word, bit)",
            "word",
            "bit"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "120-126",
          "snippet": "void __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit)\n{\n\tstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);\n\n\tif (waitqueue_active(wq_head))\n\t\t__wake_up(wq_head, TASK_NORMAL, 1, &key);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit)\n{\n\tstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);\n\n\tif (waitqueue_active(wq_head))\n\t\t__wake_up(wq_head, TASK_NORMAL, 1, &key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "word",
            "bit"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "bit_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "11-17",
          "snippet": "wait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid wake_up_bit(void *word, int bit)\n{\n\t__wake_up_bit(bit_waitqueue(word, bit), word, bit);\n}"
  },
  {
    "function_name": "__wake_up_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "120-126",
    "snippet": "void __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit)\n{\n\tstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);\n\n\tif (waitqueue_active(wq_head))\n\t\t__wake_up(wq_head, TASK_NORMAL, 1, &key);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up",
          "args": [
            "wq_head",
            "TASK_NORMAL",
            "1",
            "&key"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_sync_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "188-200",
          "snippet": "void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\tint wake_flags = 1; /* XXX WF_SYNC */\n\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\tif (unlikely(nr_exclusive != 1))\n\t\twake_flags = 0;\n\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\tint wake_flags = 1; /* XXX WF_SYNC */\n\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\tif (unlikely(nr_exclusive != 1))\n\t\twake_flags = 0;\n\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "wq_head"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__WAIT_BIT_KEY_INITIALIZER",
          "args": [
            "word",
            "bit"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit)\n{\n\tstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);\n\n\tif (waitqueue_active(wq_head))\n\t\t__wake_up(wq_head, TASK_NORMAL, 1, &key);\n}"
  },
  {
    "function_name": "out_of_line_wait_on_bit_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "110-117",
    "snippet": "int __sched out_of_line_wait_on_bit_lock(void *word, int bit,\n\t\t\t\t\t wait_bit_action_f *action, unsigned mode)\n{\n\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\n\tDEFINE_WAIT_BIT(wq_entry, word, bit);\n\n\treturn __wait_on_bit_lock(wq_head, &wq_entry, action, mode);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wait_on_bit_lock",
          "args": [
            "wq_head",
            "&wq_entry",
            "action",
            "mode"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_bit_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "80-107",
          "snippet": "int __sched\n__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t\t\twait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tret = action(&wbq_entry->key, mode);\n\t\t\t/*\n\t\t\t * See the comment in prepare_to_wait_event().\n\t\t\t * finish_wait() does not necessarily takes wwq_head->lock,\n\t\t\t * but test_and_set_bit() implies mb() which pairs with\n\t\t\t * smp_mb__after_atomic() before wake_up_page().\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t}\n\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tif (!ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t\treturn 0;\n\t\t} else if (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint __sched\n__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t\t\twait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tret = action(&wbq_entry->key, mode);\n\t\t\t/*\n\t\t\t * See the comment in prepare_to_wait_event().\n\t\t\t * finish_wait() does not necessarily takes wwq_head->lock,\n\t\t\t * but test_and_set_bit() implies mb() which pairs with\n\t\t\t * smp_mb__after_atomic() before wake_up_page().\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t}\n\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tif (!ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t\treturn 0;\n\t\t} else if (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wq_entry",
            "word",
            "bit"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "word",
            "bit"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "bit_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "11-17",
          "snippet": "wait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint __sched out_of_line_wait_on_bit_lock(void *word, int bit,\n\t\t\t\t\t wait_bit_action_f *action, unsigned mode)\n{\n\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\n\tDEFINE_WAIT_BIT(wq_entry, word, bit);\n\n\treturn __wait_on_bit_lock(wq_head, &wq_entry, action, mode);\n}"
  },
  {
    "function_name": "__wait_on_bit_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "80-107",
    "snippet": "int __sched\n__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t\t\twait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tret = action(&wbq_entry->key, mode);\n\t\t\t/*\n\t\t\t * See the comment in prepare_to_wait_event().\n\t\t\t * finish_wait() does not necessarily takes wwq_head->lock,\n\t\t\t * but test_and_set_bit() implies mb() which pairs with\n\t\t\t * smp_mb__after_atomic() before wake_up_page().\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t}\n\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tif (!ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t\treturn 0;\n\t\t} else if (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq_head",
            "&wbq_entry->wq_entry"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "finish_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "347-370",
          "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "wbq_entry->key.bit_nr",
            "wbq_entry->key.flags"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "action",
          "args": [
            "&wbq_entry->key",
            "mode"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_actions_logged_from_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/seccomp.c",
          "lines": "1192-1207",
          "snippet": "static bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/tracehook.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "wbq_entry->key.bit_nr",
            "wbq_entry->key.flags"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait_exclusive",
          "args": [
            "wq_head",
            "&wbq_entry->wq_entry",
            "mode"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_wait_exclusive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "238-249",
          "snippet": "void\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint __sched\n__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t\t\twait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tret = action(&wbq_entry->key, mode);\n\t\t\t/*\n\t\t\t * See the comment in prepare_to_wait_event().\n\t\t\t * finish_wait() does not necessarily takes wwq_head->lock,\n\t\t\t * but test_and_set_bit() implies mb() which pairs with\n\t\t\t * smp_mb__after_atomic() before wake_up_page().\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t}\n\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tif (!ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t\treturn 0;\n\t\t} else if (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "out_of_line_wait_on_bit_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "67-77",
    "snippet": "int __sched out_of_line_wait_on_bit_timeout(\n\tvoid *word, int bit, wait_bit_action_f *action,\n\tunsigned mode, unsigned long timeout)\n{\n\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\n\tDEFINE_WAIT_BIT(wq_entry, word, bit);\n\n\twq_entry.key.timeout = jiffies + timeout;\n\n\treturn __wait_on_bit(wq_head, &wq_entry, action, mode);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wait_on_bit",
          "args": [
            "wq_head",
            "&wq_entry",
            "action",
            "mode"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_bit_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "80-107",
          "snippet": "int __sched\n__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t\t\twait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tret = action(&wbq_entry->key, mode);\n\t\t\t/*\n\t\t\t * See the comment in prepare_to_wait_event().\n\t\t\t * finish_wait() does not necessarily takes wwq_head->lock,\n\t\t\t * but test_and_set_bit() implies mb() which pairs with\n\t\t\t * smp_mb__after_atomic() before wake_up_page().\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t}\n\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tif (!ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t\treturn 0;\n\t\t} else if (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint __sched\n__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t\t\twait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tret = action(&wbq_entry->key, mode);\n\t\t\t/*\n\t\t\t * See the comment in prepare_to_wait_event().\n\t\t\t * finish_wait() does not necessarily takes wwq_head->lock,\n\t\t\t * but test_and_set_bit() implies mb() which pairs with\n\t\t\t * smp_mb__after_atomic() before wake_up_page().\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t}\n\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tif (!ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t\treturn 0;\n\t\t} else if (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wq_entry",
            "word",
            "bit"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "word",
            "bit"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "bit_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "11-17",
          "snippet": "wait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint __sched out_of_line_wait_on_bit_timeout(\n\tvoid *word, int bit, wait_bit_action_f *action,\n\tunsigned mode, unsigned long timeout)\n{\n\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\n\tDEFINE_WAIT_BIT(wq_entry, word, bit);\n\n\twq_entry.key.timeout = jiffies + timeout;\n\n\treturn __wait_on_bit(wq_head, &wq_entry, action, mode);\n}"
  },
  {
    "function_name": "out_of_line_wait_on_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "57-64",
    "snippet": "int __sched out_of_line_wait_on_bit(void *word, int bit,\n\t\t\t\t    wait_bit_action_f *action, unsigned mode)\n{\n\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\n\tDEFINE_WAIT_BIT(wq_entry, word, bit);\n\n\treturn __wait_on_bit(wq_head, &wq_entry, action, mode);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wait_on_bit",
          "args": [
            "wq_head",
            "&wq_entry",
            "action",
            "mode"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_bit_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "80-107",
          "snippet": "int __sched\n__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t\t\twait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tret = action(&wbq_entry->key, mode);\n\t\t\t/*\n\t\t\t * See the comment in prepare_to_wait_event().\n\t\t\t * finish_wait() does not necessarily takes wwq_head->lock,\n\t\t\t * but test_and_set_bit() implies mb() which pairs with\n\t\t\t * smp_mb__after_atomic() before wake_up_page().\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t}\n\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tif (!ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t\treturn 0;\n\t\t} else if (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint __sched\n__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t\t\twait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tret = action(&wbq_entry->key, mode);\n\t\t\t/*\n\t\t\t * See the comment in prepare_to_wait_event().\n\t\t\t * finish_wait() does not necessarily takes wwq_head->lock,\n\t\t\t * but test_and_set_bit() implies mb() which pairs with\n\t\t\t * smp_mb__after_atomic() before wake_up_page().\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t}\n\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tif (!ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t\treturn 0;\n\t\t} else if (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wq_entry",
            "word",
            "bit"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "word",
            "bit"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "bit_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "11-17",
          "snippet": "wait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint __sched out_of_line_wait_on_bit(void *word, int bit,\n\t\t\t\t    wait_bit_action_f *action, unsigned mode)\n{\n\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\n\tDEFINE_WAIT_BIT(wq_entry, word, bit);\n\n\treturn __wait_on_bit(wq_head, &wq_entry, action, mode);\n}"
  },
  {
    "function_name": "__wait_on_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "39-54",
    "snippet": "int __sched\n__wait_on_bit(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t      wait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tdo {\n\t\tprepare_to_wait(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags))\n\t\t\tret = (*action)(&wbq_entry->key, mode);\n\t} while (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags) && !ret);\n\n\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq_head",
            "&wbq_entry->wq_entry"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "finish_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "347-370",
          "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "wbq_entry->key.bit_nr",
            "wbq_entry->key.flags"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&wbq_entry->key",
            "mode"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wq_head",
            "&wbq_entry->wq_entry",
            "mode"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_wait_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "261-294",
          "snippet": "long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (unlikely(signal_pending_state(state, current))) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (unlikely(signal_pending_state(state, current))) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint __sched\n__wait_on_bit(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t      wait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tdo {\n\t\tprepare_to_wait(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags))\n\t\t\tret = (*action)(&wbq_entry->key, mode);\n\t} while (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags) && !ret);\n\n\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wake_bit_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "20-31",
    "snippet": "int wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *arg)\n{\n\tstruct wait_bit_key *key = arg;\n\tstruct wait_bit_queue_entry *wait_bit = container_of(wq_entry, struct wait_bit_queue_entry, wq_entry);\n\n\tif (wait_bit->key.flags != key->flags ||\n\t\t\twait_bit->key.bit_nr != key->bit_nr ||\n\t\t\ttest_bit(key->bit_nr, key->flags))\n\t\treturn 0;\n\n\treturn autoremove_wake_function(wq_entry, mode, sync, key);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autoremove_wake_function",
          "args": [
            "wq_entry",
            "mode",
            "sync",
            "key"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "autoremove_wake_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "373-381",
          "snippet": "int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init(&wq_entry->entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init(&wq_entry->entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "key->bit_nr",
            "key->flags"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wq_entry",
            "structwait_bit_queue_entry",
            "wq_entry"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *arg)\n{\n\tstruct wait_bit_key *key = arg;\n\tstruct wait_bit_queue_entry *wait_bit = container_of(wq_entry, struct wait_bit_queue_entry, wq_entry);\n\n\tif (wait_bit->key.flags != key->flags ||\n\t\t\twait_bit->key.bit_nr != key->bit_nr ||\n\t\t\ttest_bit(key->bit_nr, key->flags))\n\t\treturn 0;\n\n\treturn autoremove_wake_function(wq_entry, mode, sync, key);\n}"
  },
  {
    "function_name": "bit_waitqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
    "lines": "11-17",
    "snippet": "wait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define WAIT_TABLE_BITS 8"
    ],
    "globals_used": [
      "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_long",
          "args": [
            "val",
            "WAIT_TABLE_BITS"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}"
  }
]