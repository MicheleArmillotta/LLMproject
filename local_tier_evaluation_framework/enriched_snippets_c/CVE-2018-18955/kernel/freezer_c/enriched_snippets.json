[
  {
    "function_name": "set_freezable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
    "lines": "166-180",
    "snippet": "bool set_freezable(void)\n{\n\tmight_sleep();\n\n\t/*\n\t * Modify flags while holding freezer_lock.  This ensures the\n\t * freezer notices that we aren't frozen yet or the freezing\n\t * condition is visible to try_to_freeze() below.\n\t */\n\tspin_lock_irq(&freezer_lock);\n\tcurrent->flags &= ~PF_NOFREEZE;\n\tspin_unlock_irq(&freezer_lock);\n\n\treturn try_to_freeze();\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(freezer_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&freezer_lock"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&freezer_lock"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nbool set_freezable(void)\n{\n\tmight_sleep();\n\n\t/*\n\t * Modify flags while holding freezer_lock.  This ensures the\n\t * freezer notices that we aren't frozen yet or the freezing\n\t * condition is visible to try_to_freeze() below.\n\t */\n\tspin_lock_irq(&freezer_lock);\n\tcurrent->flags &= ~PF_NOFREEZE;\n\tspin_unlock_irq(&freezer_lock);\n\n\treturn try_to_freeze();\n}"
  },
  {
    "function_name": "__thaw_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
    "lines": "151-159",
    "snippet": "void __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (frozen(p))\n\t\twake_up_process(p);\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(freezer_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&freezer_lock",
            "flags"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "p"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "frozen",
          "args": [
            "p"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "update_if_frozen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/freezer.c",
          "lines": "244-289",
          "snippet": "static void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(freezer_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&freezer_lock",
            "flags"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nvoid __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (frozen(p))\n\t\twake_up_process(p);\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}"
  },
  {
    "function_name": "freeze_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
    "lines": "120-149",
    "snippet": "bool freeze_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t/*\n\t * This check can race with freezer_do_not_count, but worst case that\n\t * will result in an extra wakeup being sent to the task.  It does not\n\t * race with freezer_count(), the barriers in freezer_count() and\n\t * freezer_should_skip() ensure that either freezer_count() sees\n\t * freezing == true in try_to_freeze() and freezes, or\n\t * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task\n\t * normally.\n\t */\n\tif (freezer_should_skip(p))\n\t\treturn false;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (!freezing(p) || frozen(p)) {\n\t\tspin_unlock_irqrestore(&freezer_lock, flags);\n\t\treturn false;\n\t}\n\n\tif (!(p->flags & PF_KTHREAD))\n\t\tfake_signal_wake_up(p);\n\telse\n\t\twake_up_state(p, TASK_INTERRUPTIBLE);\n\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n\treturn true;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(freezer_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&freezer_lock",
            "flags"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "p",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fake_signal_wake_up",
          "args": [
            "p"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "fake_signal_wake_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
          "lines": "99-107",
          "snippet": "static void fake_signal_wake_up(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tsignal_wake_up(p, 0);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic void fake_signal_wake_up(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tsignal_wake_up(p, 0);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "frozen",
          "args": [
            "p"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "update_if_frozen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/freezer.c",
          "lines": "244-289",
          "snippet": "static void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(freezer_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "p"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "freezing_slow_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
          "lines": "42-57",
          "snippet": "bool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool pm_freezing;",
            "bool pm_nosig_freezing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nbool pm_freezing;\nbool pm_nosig_freezing;\n\nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&freezer_lock",
            "flags"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezer_should_skip",
          "args": [
            "p"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nbool freeze_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t/*\n\t * This check can race with freezer_do_not_count, but worst case that\n\t * will result in an extra wakeup being sent to the task.  It does not\n\t * race with freezer_count(), the barriers in freezer_count() and\n\t * freezer_should_skip() ensure that either freezer_count() sees\n\t * freezing == true in try_to_freeze() and freezes, or\n\t * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task\n\t * normally.\n\t */\n\tif (freezer_should_skip(p))\n\t\treturn false;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (!freezing(p) || frozen(p)) {\n\t\tspin_unlock_irqrestore(&freezer_lock, flags);\n\t\treturn false;\n\t}\n\n\tif (!(p->flags & PF_KTHREAD))\n\t\tfake_signal_wake_up(p);\n\telse\n\t\twake_up_state(p, TASK_INTERRUPTIBLE);\n\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n\treturn true;\n}"
  },
  {
    "function_name": "fake_signal_wake_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
    "lines": "99-107",
    "snippet": "static void fake_signal_wake_up(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tsignal_wake_up(p, 0);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "p",
            "0"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic void fake_signal_wake_up(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tsignal_wake_up(p, 0);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n}"
  },
  {
    "function_name": "__refrigerator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
    "lines": "61-96",
    "snippet": "bool __refrigerator(bool check_kthr_stop)\n{\n\t/* Hmm, should we be allowed to suspend when there are realtime\n\t   processes around? */\n\tbool was_frozen = false;\n\tlong save = current->state;\n\n\tpr_debug(\"%s entered refrigerator\\n\", current->comm);\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\tspin_lock_irq(&freezer_lock);\n\t\tcurrent->flags |= PF_FROZEN;\n\t\tif (!freezing(current) ||\n\t\t    (check_kthr_stop && kthread_should_stop()))\n\t\t\tcurrent->flags &= ~PF_FROZEN;\n\t\tspin_unlock_irq(&freezer_lock);\n\n\t\tif (!(current->flags & PF_FROZEN))\n\t\t\tbreak;\n\t\twas_frozen = true;\n\t\tschedule();\n\t}\n\n\tpr_debug(\"%s left refrigerator\\n\", current->comm);\n\n\t/*\n\t * Restore saved task state before returning.  The mb'd version\n\t * needs to be used; otherwise, it might silently break\n\t * synchronization which depends on ordered task state change.\n\t */\n\tset_current_state(save);\n\n\treturn was_frozen;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(freezer_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "save"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s left refrigerator\\n\"",
            "current->comm"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&freezer_lock"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "freezing_slow_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
          "lines": "42-57",
          "snippet": "bool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool pm_freezing;",
            "bool pm_nosig_freezing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nbool pm_freezing;\nbool pm_nosig_freezing;\n\nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&freezer_lock"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s entered refrigerator\\n\"",
            "current->comm"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nbool __refrigerator(bool check_kthr_stop)\n{\n\t/* Hmm, should we be allowed to suspend when there are realtime\n\t   processes around? */\n\tbool was_frozen = false;\n\tlong save = current->state;\n\n\tpr_debug(\"%s entered refrigerator\\n\", current->comm);\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\tspin_lock_irq(&freezer_lock);\n\t\tcurrent->flags |= PF_FROZEN;\n\t\tif (!freezing(current) ||\n\t\t    (check_kthr_stop && kthread_should_stop()))\n\t\t\tcurrent->flags &= ~PF_FROZEN;\n\t\tspin_unlock_irq(&freezer_lock);\n\n\t\tif (!(current->flags & PF_FROZEN))\n\t\t\tbreak;\n\t\twas_frozen = true;\n\t\tschedule();\n\t}\n\n\tpr_debug(\"%s left refrigerator\\n\", current->comm);\n\n\t/*\n\t * Restore saved task state before returning.  The mb'd version\n\t * needs to be used; otherwise, it might silently break\n\t * synchronization which depends on ordered task state change.\n\t */\n\tset_current_state(save);\n\n\treturn was_frozen;\n}"
  },
  {
    "function_name": "freezing_slow_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
    "lines": "42-57",
    "snippet": "bool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool pm_freezing;",
      "bool pm_nosig_freezing;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_freezing",
          "args": [
            "p"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_freezing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/freezer.c",
          "lines": "65-74",
          "snippet": "bool cgroup_freezing(struct task_struct *task)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = task_freezer(task)->state & CGROUP_FREEZING;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nbool cgroup_freezing(struct task_struct *task)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = task_freezer(task)->state & CGROUP_FREEZING;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_tsk_thread_flag",
          "args": [
            "p",
            "TIF_MEMDIE"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nbool pm_freezing;\nbool pm_nosig_freezing;\n\nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}"
  }
]