[
  {
    "function_name": "trace_selftest_startup_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "1155-1183",
    "snippet": "int\ntrace_selftest_startup_branch(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long count;\n\tint ret;\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1808-1843",
          "snippet": "void tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->trace_buffer",
            "&count"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1882-1908",
          "snippet": "void tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1965-1972",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5158-5162",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_branch(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long count;\n\tint ret;\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_startup_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "1077-1151",
    "snippet": "int\ntrace_selftest_startup_wakeup(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tstruct task_struct *p;\n\tstruct wakeup_test_data data;\n\tunsigned long count;\n\tint ret;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tinit_completion(&data.is_ready);\n\n\t/* create a -deadline thread */\n\tp = kthread_run(trace_wakeup_test_thread, &data, \"ftrace-test\");\n\tif (IS_ERR(p)) {\n\t\tprintk(KERN_CONT \"Failed to create ftrace wakeup test thread \");\n\t\treturn -1;\n\t}\n\n\t/* make sure the thread is running at -deadline policy */\n\twait_for_completion(&data.is_ready);\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\n\twhile (p->on_rq) {\n\t\t/*\n\t\t * Sleep to make sure the -deadline thread is asleep too.\n\t\t * On virtual machines we can't rely on timings,\n\t\t * but we want to make sure this test still works.\n\t\t */\n\t\tmsleep(100);\n\t}\n\n\tinit_completion(&data.is_ready);\n\n\tdata.go = 1;\n\t/* memory barrier is in the wake_up_process() */\n\n\twake_up_process(p);\n\n\t/* Wait for the task to wake up */\n\twait_for_completion(&data.is_ready);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->trace_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\n\n\ttrace->reset(tr);\n\ttracing_start();\n\n\ttr->max_latency = save_max;\n\n\t/* kill the thread */\n\tkthread_stop(p);\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "p"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "538-556",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = k->exit_code;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = k->exit_code;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1808-1843",
          "snippet": "void tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->max_buffer",
            "&count"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1882-1908",
          "snippet": "void tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&data.is_ready"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "p"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&data.is_ready"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1965-1972",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5158-5162",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "trace_wakeup_test_thread",
            "&data",
            "\"ftrace-test\""
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&data.is_ready"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_wakeup(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tstruct task_struct *p;\n\tstruct wakeup_test_data data;\n\tunsigned long count;\n\tint ret;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tinit_completion(&data.is_ready);\n\n\t/* create a -deadline thread */\n\tp = kthread_run(trace_wakeup_test_thread, &data, \"ftrace-test\");\n\tif (IS_ERR(p)) {\n\t\tprintk(KERN_CONT \"Failed to create ftrace wakeup test thread \");\n\t\treturn -1;\n\t}\n\n\t/* make sure the thread is running at -deadline policy */\n\twait_for_completion(&data.is_ready);\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\n\twhile (p->on_rq) {\n\t\t/*\n\t\t * Sleep to make sure the -deadline thread is asleep too.\n\t\t * On virtual machines we can't rely on timings,\n\t\t * but we want to make sure this test still works.\n\t\t */\n\t\tmsleep(100);\n\t}\n\n\tinit_completion(&data.is_ready);\n\n\tdata.go = 1;\n\t/* memory barrier is in the wake_up_process() */\n\n\twake_up_process(p);\n\n\t/* Wait for the task to wake up */\n\twait_for_completion(&data.is_ready);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->trace_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\n\n\ttrace->reset(tr);\n\ttracing_start();\n\n\ttr->max_latency = save_max;\n\n\t/* kill the thread */\n\tkthread_stop(p);\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_wakeup_test_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "1040-1076",
    "snippet": "static int trace_wakeup_test_thread(void *data)\n{\n\t/* Make this a -deadline thread */\n\tstatic const struct sched_attr attr = {\n\t\t.sched_policy = SCHED_DEADLINE,\n\t\t.sched_runtime = 100000ULL,\n\t\t.sched_deadline = 10000000ULL,\n\t\t.sched_period = 10000000ULL\n\t};\n\tstruct wakeup_test_data *x = data;\n\n\tsched_setattr(current, &attr);\n\n\t/* Make it know we have a new prio */\n\tcomplete(&x->is_ready);\n\n\t/* now go to sleep and let the test wake us up */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!x->go) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\tcomplete(&x->is_ready);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t/* we are awake, now wait to disappear */\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&x->is_ready"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_setattr",
          "args": [
            "current",
            "&attr"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setattr_nocheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4398-4401",
          "snippet": "int sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, false, true);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, false, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_wakeup_test_thread(void *data)\n{\n\t/* Make this a -deadline thread */\n\tstatic const struct sched_attr attr = {\n\t\t.sched_policy = SCHED_DEADLINE,\n\t\t.sched_runtime = 100000ULL,\n\t\t.sched_deadline = 10000000ULL,\n\t\t.sched_period = 10000000ULL\n\t};\n\tstruct wakeup_test_data *x = data;\n\n\tsched_setattr(current, &attr);\n\n\t/* Make it know we have a new prio */\n\tcomplete(&x->is_ready);\n\n\t/* now go to sleep and let the test wake us up */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!x->go) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\tcomplete(&x->is_ready);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t/* we are awake, now wait to disappear */\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_selftest_startup_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "1025-1030",
    "snippet": "int\ntrace_selftest_startup_nop(struct tracer *trace, struct trace_array *tr)\n{\n\t/* What could possibly go wrong? */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_nop(struct tracer *trace, struct trace_array *tr)\n{\n\t/* What could possibly go wrong? */\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_selftest_startup_preemptirqsoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "924-1021",
    "snippet": "int\ntrace_selftest_startup_preemptirqsoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/*\n\t * Now that the big kernel lock is no longer preemptable,\n\t * and this is called with the BKL held, it will always\n\t * fail. If preemption is already disabled, simply\n\t * pass the test. When the BKL is removed, or becomes\n\t * preemptible again, we will once again test this,\n\t * so keep it in.\n\t */\n\tif (preempt_count()) {\n\t\tprintk(KERN_CONT \"can not test ... force \");\n\t\treturn 0;\n\t}\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out_no_start;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\n\t/* disable preemption and interrupts for a bit */\n\tpreempt_disable();\n\tlocal_irq_disable();\n\tudelay(100);\n\tpreempt_enable();\n\t/* reverse the order of preempt vs irqs */\n\tlocal_irq_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max irqs/preempt off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->trace_buffer, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_test_buffer(&tr->max_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* do the test by disabling interrupts first this time */\n\ttr->max_latency = 0;\n\ttracing_start();\n\ttrace->start(tr);\n\n\tpreempt_disable();\n\tlocal_irq_disable();\n\tudelay(100);\n\tpreempt_enable();\n\t/* reverse the order of preempt vs irqs */\n\tlocal_irq_enable();\n\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->trace_buffer, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_test_buffer(&tr->max_buffer, &count);\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\ttracing_start();\nout_no_start:\n\ttrace->reset(tr);\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1808-1843",
          "snippet": "void tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->max_buffer",
            "&count"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1882-1908",
          "snippet": "void tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->stop",
          "args": [
            "tr"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "100"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->start",
          "args": [
            "tr"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace->stop",
          "args": [
            "tr"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "100"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5158-5162",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_preemptirqsoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/*\n\t * Now that the big kernel lock is no longer preemptable,\n\t * and this is called with the BKL held, it will always\n\t * fail. If preemption is already disabled, simply\n\t * pass the test. When the BKL is removed, or becomes\n\t * preemptible again, we will once again test this,\n\t * so keep it in.\n\t */\n\tif (preempt_count()) {\n\t\tprintk(KERN_CONT \"can not test ... force \");\n\t\treturn 0;\n\t}\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out_no_start;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\n\t/* disable preemption and interrupts for a bit */\n\tpreempt_disable();\n\tlocal_irq_disable();\n\tudelay(100);\n\tpreempt_enable();\n\t/* reverse the order of preempt vs irqs */\n\tlocal_irq_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max irqs/preempt off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->trace_buffer, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_test_buffer(&tr->max_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* do the test by disabling interrupts first this time */\n\ttr->max_latency = 0;\n\ttracing_start();\n\ttrace->start(tr);\n\n\tpreempt_disable();\n\tlocal_irq_disable();\n\tudelay(100);\n\tpreempt_enable();\n\t/* reverse the order of preempt vs irqs */\n\tlocal_irq_enable();\n\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->trace_buffer, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_test_buffer(&tr->max_buffer, &count);\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\ttracing_start();\nout_no_start:\n\ttrace->reset(tr);\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_startup_preemptoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "862-920",
    "snippet": "int\ntrace_selftest_startup_preemptoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/*\n\t * Now that the big kernel lock is no longer preemptable,\n\t * and this is called with the BKL held, it will always\n\t * fail. If preemption is already disabled, simply\n\t * pass the test. When the BKL is removed, or becomes\n\t * preemptible again, we will once again test this,\n\t * so keep it in.\n\t */\n\tif (preempt_count()) {\n\t\tprintk(KERN_CONT \"can not test ... force \");\n\t\treturn 0;\n\t}\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\t/* disable preemption for a bit */\n\tpreempt_disable();\n\tudelay(100);\n\tpreempt_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max preempt off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->trace_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1808-1843",
          "snippet": "void tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->max_buffer",
            "&count"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1882-1908",
          "snippet": "void tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->stop",
          "args": [
            "tr"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "100"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5158-5162",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_preemptoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/*\n\t * Now that the big kernel lock is no longer preemptable,\n\t * and this is called with the BKL held, it will always\n\t * fail. If preemption is already disabled, simply\n\t * pass the test. When the BKL is removed, or becomes\n\t * preemptible again, we will once again test this,\n\t * so keep it in.\n\t */\n\tif (preempt_count()) {\n\t\tprintk(KERN_CONT \"can not test ... force \");\n\t\treturn 0;\n\t}\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\t/* disable preemption for a bit */\n\tpreempt_disable();\n\tudelay(100);\n\tpreempt_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max preempt off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->trace_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_startup_irqsoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "813-858",
    "snippet": "int\ntrace_selftest_startup_irqsoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\t/* disable interrupts for a bit */\n\tlocal_irq_disable();\n\tudelay(100);\n\tlocal_irq_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max irqs off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->trace_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1808-1843",
          "snippet": "void tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->max_buffer",
            "&count"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1882-1908",
          "snippet": "void tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->stop",
          "args": [
            "tr"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "100"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5158-5162",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_irqsoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\t/* disable interrupts for a bit */\n\tlocal_irq_disable();\n\tudelay(100);\n\tlocal_irq_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max irqs off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->trace_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_startup_function_graph",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "748-808",
    "snippet": "__init int\ntrace_selftest_startup_function_graph(struct tracer *trace,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tint ret;\n\tunsigned long count;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (ftrace_filter_param) {\n\t\tprintk(KERN_CONT \" ... kernel command line filter set: force PASS ... \");\n\t\treturn 0;\n\t}\n#endif\n\n\t/*\n\t * Simulate the init() callback but we attach a watchdog callback\n\t * to detect and recover from possible hangs\n\t */\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\tset_graph_array(tr);\n\tret = register_ftrace_graph(&trace_graph_return,\n\t\t\t\t    &trace_graph_entry_watchdog);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\ttracing_start_cmdline_record();\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* Have we just recovered from a hang? */\n\tif (graph_hang_thresh > GRAPH_MAX_FUNC_TEST) {\n\t\ttracing_selftest_disabled = true;\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\ttracing_stop();\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Don't test dynamic tracing, the function tracer already did */\n\nout:\n\t/* Stop it if we failed */\n\tif (ret)\n\t\tftrace_graph_stop();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [
      "#define GRAPH_MAX_FUNC_TEST\t100000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_graph_stop",
          "args": [],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "41-44",
          "snippet": "void ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kill_ftrace_graph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic bool kill_ftrace_graph;\n\nvoid ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1808-1843",
          "snippet": "void tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->trace_buffer",
            "&count"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1882-1908",
          "snippet": "void tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1965-1972",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start_cmdline_record",
          "args": [],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_cmdline_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "129-132",
          "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_graph",
          "args": [
            "&trace_graph_return",
            "&trace_graph_entry_watchdog"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_graph",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6962-7000",
          "snippet": "int register_ftrace_graph(trace_func_graph_ret_t retfunc,\n\t\t\ttrace_func_graph_ent_t entryfunc)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* we currently allow only one tracer registered at a time */\n\tif (ftrace_graph_active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tregister_pm_notifier(&ftrace_suspend_notifier);\n\n\tftrace_graph_active++;\n\tret = start_graph_tracing();\n\tif (ret) {\n\t\tftrace_graph_active--;\n\t\tgoto out;\n\t}\n\n\tftrace_graph_return = retfunc;\n\n\t/*\n\t * Update the indirect function to the entryfunc, and the\n\t * function that gets called to the entry_test first. Then\n\t * call the update fgraph entry function to determine if\n\t * the entryfunc should be called directly or not.\n\t */\n\t__ftrace_graph_entry = entryfunc;\n\tftrace_graph_entry = ftrace_graph_entry_test;\n\tupdate_function_graph_func();\n\n\tret = ftrace_startup(&graph_ops, FTRACE_START_FUNC_RET);\nout:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nint register_ftrace_graph(trace_func_graph_ret_t retfunc,\n\t\t\ttrace_func_graph_ent_t entryfunc)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* we currently allow only one tracer registered at a time */\n\tif (ftrace_graph_active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tregister_pm_notifier(&ftrace_suspend_notifier);\n\n\tftrace_graph_active++;\n\tret = start_graph_tracing();\n\tif (ret) {\n\t\tftrace_graph_active--;\n\t\tgoto out;\n\t}\n\n\tftrace_graph_return = retfunc;\n\n\t/*\n\t * Update the indirect function to the entryfunc, and the\n\t * function that gets called to the entry_test first. Then\n\t * call the update fgraph entry function to determine if\n\t * the entryfunc should be called directly or not.\n\t */\n\t__ftrace_graph_entry = entryfunc;\n\tftrace_graph_entry = ftrace_graph_entry_test;\n\tupdate_function_graph_func();\n\n\tret = ftrace_startup(&graph_ops, FTRACE_START_FUNC_RET);\nout:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_graph_array",
          "args": [
            "tr"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "set_graph_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "497-504",
          "snippet": "void set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array *graph_array;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\n\nvoid set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_reset_online_cpus",
          "args": [
            "&tr->trace_buffer"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1690-1709",
          "snippet": "void tracing_reset_online_cpus(struct trace_buffer *buf)\n{\n\tstruct ring_buffer *buffer = buf->buffer;\n\tint cpu;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_sched();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tfor_each_online_cpu(cpu)\n\t\tring_buffer_reset_cpu(buffer, cpu);\n\n\tring_buffer_record_enable(buffer);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nvoid tracing_reset_online_cpus(struct trace_buffer *buf)\n{\n\tstruct ring_buffer *buffer = buf->buffer;\n\tint cpu;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_sched();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tfor_each_online_cpu(cpu)\n\t\tring_buffer_reset_cpu(buffer, cpu);\n\n\tring_buffer_record_enable(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\n#define GRAPH_MAX_FUNC_TEST\t100000000\n\n__init int\ntrace_selftest_startup_function_graph(struct tracer *trace,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tint ret;\n\tunsigned long count;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (ftrace_filter_param) {\n\t\tprintk(KERN_CONT \" ... kernel command line filter set: force PASS ... \");\n\t\treturn 0;\n\t}\n#endif\n\n\t/*\n\t * Simulate the init() callback but we attach a watchdog callback\n\t * to detect and recover from possible hangs\n\t */\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\tset_graph_array(tr);\n\tret = register_ftrace_graph(&trace_graph_return,\n\t\t\t\t    &trace_graph_entry_watchdog);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\ttracing_start_cmdline_record();\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* Have we just recovered from a hang? */\n\tif (graph_hang_thresh > GRAPH_MAX_FUNC_TEST) {\n\t\ttracing_selftest_disabled = true;\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\ttracing_stop();\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Don't test dynamic tracing, the function tracer already did */\n\nout:\n\t/* Stop it if we failed */\n\tif (ret)\n\t\tftrace_graph_stop();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_graph_entry_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "727-742",
    "snippet": "static int trace_graph_entry_watchdog(struct ftrace_graph_ent *trace)\n{\n\t/* This is harmlessly racy, we want to approximately detect a hang */\n\tif (unlikely(++graph_hang_thresh > GRAPH_MAX_FUNC_TEST)) {\n\t\tftrace_graph_stop();\n\t\tprintk(KERN_WARNING \"BUG: Function graph tracer hang!\\n\");\n\t\tif (ftrace_dump_on_oops) {\n\t\t\tftrace_dump(DUMP_ALL);\n\t\t\t/* ftrace_dump() disables tracing */\n\t\t\ttracing_on();\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn trace_graph_entry(trace);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [
      "#define GRAPH_MAX_FUNC_TEST\t100000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_graph_entry",
          "args": [
            "trace"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "trace_graph_entry_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "727-742",
          "snippet": "static int trace_graph_entry_watchdog(struct ftrace_graph_ent *trace)\n{\n\t/* This is harmlessly racy, we want to approximately detect a hang */\n\tif (unlikely(++graph_hang_thresh > GRAPH_MAX_FUNC_TEST)) {\n\t\tftrace_graph_stop();\n\t\tprintk(KERN_WARNING \"BUG: Function graph tracer hang!\\n\");\n\t\tif (ftrace_dump_on_oops) {\n\t\t\tftrace_dump(DUMP_ALL);\n\t\t\t/* ftrace_dump() disables tracing */\n\t\t\ttracing_on();\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn trace_graph_entry(trace);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "tracing_on",
          "args": [],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "783-786",
          "snippet": "void tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8273-8383",
          "snippet": "void ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\tprintk_nmi_direct_enter();\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read the\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\t/* reset all but tr, trace, and overruns */\n\t\tmemset(&iter.seq, 0,\n\t\t       sizeof(struct trace_iterator) -\n\t\t       offsetof(struct trace_iterator, seq));\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\t\titer.pos = -1;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tprintk_nmi_direct_exit();\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\tprintk_nmi_direct_enter();\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read the\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\t/* reset all but tr, trace, and overruns */\n\t\tmemset(&iter.seq, 0,\n\t\t       sizeof(struct trace_iterator) -\n\t\t       offsetof(struct trace_iterator, seq));\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\t\titer.pos = -1;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tprintk_nmi_direct_exit();\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"BUG: Function graph tracer hang!\\n\""
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_stop",
          "args": [],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "41-44",
          "snippet": "void ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kill_ftrace_graph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic bool kill_ftrace_graph;\n\nvoid ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "++graph_hang_thresh > GRAPH_MAX_FUNC_TEST"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\n#define GRAPH_MAX_FUNC_TEST\t100000000\n\nstatic int trace_graph_entry_watchdog(struct ftrace_graph_ent *trace)\n{\n\t/* This is harmlessly racy, we want to approximately detect a hang */\n\tif (unlikely(++graph_hang_thresh > GRAPH_MAX_FUNC_TEST)) {\n\t\tftrace_graph_stop();\n\t\tprintk(KERN_WARNING \"BUG: Function graph tracer hang!\\n\");\n\t\tif (ftrace_dump_on_oops) {\n\t\t\tftrace_dump(DUMP_ALL);\n\t\t\t/* ftrace_dump() disables tracing */\n\t\t\ttracing_on();\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn trace_graph_entry(trace);\n}"
  },
  {
    "function_name": "trace_selftest_startup_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "652-715",
    "snippet": "__init int\ntrace_selftest_startup_function(struct tracer *trace, struct trace_array *tr)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (ftrace_filter_param) {\n\t\tprintk(KERN_CONT \" ... kernel command line filter set: force PASS ... \");\n\t\treturn 0;\n\t}\n#endif\n\n\t/* make sure msleep has been recorded */\n\tmsleep(1);\n\n\t/* start the tracing */\n\tftrace_enabled = 1;\n\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tret = trace_selftest_startup_dynamic_tracing(trace, tr,\n\t\t\t\t\t\t     DYN_FTRACE_TEST_NAME);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_selftest_function_recursion();\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_selftest_function_regs();\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* kill ftrace totally if we failed */\n\tif (ret)\n\t\tftrace_kill();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_kill",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6649-6654",
          "snippet": "void ftrace_kill(void)\n{\n\tftrace_disabled = 1;\n\tftrace_enabled = 0;\n\tftrace_trace_function = ftrace_stub;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static int ftrace_disabled",
            "ftrace_func_t ftrace_trace_function"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic int ftrace_disabled;\nftrace_func_t ftrace_trace_function;\n\nvoid ftrace_kill(void)\n{\n\tftrace_disabled = 1;\n\tftrace_enabled = 0;\n\tftrace_trace_function = ftrace_stub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_selftest_function_regs",
          "args": [],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "trace_selftest_function_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "562-645",
          "snippet": "static int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_selftest_function_recursion",
          "args": [],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "trace_selftest_function_recursion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "458-534",
          "snippet": "static int\ntrace_selftest_function_recursion(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion: \");\n\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_rec_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_rec_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_rec_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 1) {\n\t\tpr_cont(\"*callback not called once (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\ttrace_selftest_recursion_cnt = 1;\n\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion safe: \");\n\n\tret = ftrace_set_filter(&test_recsafe_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_recsafe_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_recsafe_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called expected 2 times (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int\ntrace_selftest_function_recursion(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion: \");\n\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_rec_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_rec_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_rec_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 1) {\n\t\tpr_cont(\"*callback not called once (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\ttrace_selftest_recursion_cnt = 1;\n\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion safe: \");\n\n\tret = ftrace_set_filter(&test_recsafe_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_recsafe_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_recsafe_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called expected 2 times (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_selftest_startup_dynamic_tracing",
          "args": [
            "trace",
            "tr",
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "trace_selftest_startup_dynamic_tracing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "325-414",
          "snippet": "static int trace_selftest_startup_dynamic_tracing(struct tracer *trace,\n\t\t\t\t\t\t  struct trace_array *tr,\n\t\t\t\t\t\t  int (*func)(void))\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tchar *func_name;\n\tint ret;\n\n\t/* The ftrace test PASSED */\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace: \");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* passed in by parameter to fool gcc from optimizing */\n\tfunc();\n\n\t/*\n\t * Some archs *cough*PowerPC*cough* add characters to the\n\t * start of the function names. We simply put a '*' to\n\t * accommodate them.\n\t */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\n\t/* filter only on our function */\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t/* enable tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* we should have nothing in the buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (count) {\n\t\tret = -1;\n\t\tprintk(KERN_CONT \".. filter did not filter .. \");\n\t\tgoto out;\n\t}\n\n\t/* call our function again */\n\tfunc();\n\n\t/* sleep again */\n\tmsleep(100);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttracing_start();\n\n\t/* we should only have one item */\n\tif (!ret && count != 1) {\n\t\ttrace->reset(tr);\n\t\tprintk(KERN_CONT \".. filter failed count=%ld ..\", count);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Test the ops with global tracing running */\n\tret = trace_selftest_ops(tr, 1);\n\ttrace->reset(tr);\n\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* Enable tracing on all functions again */\n\tftrace_set_global_filter(NULL, 0, 1);\n\n\t/* Test the ops with global tracing off */\n\tif (!ret)\n\t\tret = trace_selftest_ops(tr, 2);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_selftest_startup_dynamic_tracing(struct tracer *trace,\n\t\t\t\t\t\t  struct trace_array *tr,\n\t\t\t\t\t\t  int (*func)(void))\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tchar *func_name;\n\tint ret;\n\n\t/* The ftrace test PASSED */\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace: \");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* passed in by parameter to fool gcc from optimizing */\n\tfunc();\n\n\t/*\n\t * Some archs *cough*PowerPC*cough* add characters to the\n\t * start of the function names. We simply put a '*' to\n\t * accommodate them.\n\t */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\n\t/* filter only on our function */\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t/* enable tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* we should have nothing in the buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (count) {\n\t\tret = -1;\n\t\tprintk(KERN_CONT \".. filter did not filter .. \");\n\t\tgoto out;\n\t}\n\n\t/* call our function again */\n\tfunc();\n\n\t/* sleep again */\n\tmsleep(100);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttracing_start();\n\n\t/* we should only have one item */\n\tif (!ret && count != 1) {\n\t\ttrace->reset(tr);\n\t\tprintk(KERN_CONT \".. filter failed count=%ld ..\", count);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Test the ops with global tracing running */\n\tret = trace_selftest_ops(tr, 1);\n\ttrace->reset(tr);\n\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* Enable tracing on all functions again */\n\tftrace_set_global_filter(NULL, 0, 1);\n\n\t/* Test the ops with global tracing off */\n\tif (!ret)\n\t\tret = trace_selftest_ops(tr, 2);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1808-1843",
          "snippet": "void tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->trace_buffer",
            "&count"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1882-1908",
          "snippet": "void tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1965-1972",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5158-5162",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\n__init int\ntrace_selftest_startup_function(struct tracer *trace, struct trace_array *tr)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (ftrace_filter_param) {\n\t\tprintk(KERN_CONT \" ... kernel command line filter set: force PASS ... \");\n\t\treturn 0;\n\t}\n#endif\n\n\t/* make sure msleep has been recorded */\n\tmsleep(1);\n\n\t/* start the tracing */\n\tftrace_enabled = 1;\n\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tret = trace_selftest_startup_dynamic_tracing(trace, tr,\n\t\t\t\t\t\t     DYN_FTRACE_TEST_NAME);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_selftest_function_recursion();\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_selftest_function_regs();\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* kill ftrace totally if we failed */\n\tif (ret)\n\t\tftrace_kill();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_function_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "562-645",
    "snippet": "static int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"*callback received NULL regs* \""
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&test_regs_probe"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter",
          "args": [
            "&test_regs_probe",
            "func_name",
            "len",
            "1"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4796-4801",
          "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_name"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing ftrace regs%s: \"",
            "!supported ? \"(no arch support)\" : \"\""
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_test_regs_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "546-555",
    "snippet": "static void trace_selftest_test_regs_func(unsigned long ip,\n\t\t\t\t\t  unsigned long pip,\n\t\t\t\t\t  struct ftrace_ops *op,\n\t\t\t\t\t  struct pt_regs *pt_regs)\n{\n\tif (pt_regs)\n\t\ttrace_selftest_regs_stat = TRACE_SELFTEST_REGS_FOUND;\n\telse\n\t\ttrace_selftest_regs_stat = TRACE_SELFTEST_REGS_NOT_FOUND;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_regs_func(unsigned long ip,\n\t\t\t\t\t  unsigned long pip,\n\t\t\t\t\t  struct ftrace_ops *op,\n\t\t\t\t\t  struct pt_regs *pt_regs)\n{\n\tif (pt_regs)\n\t\ttrace_selftest_regs_stat = TRACE_SELFTEST_REGS_FOUND;\n\telse\n\t\ttrace_selftest_regs_stat = TRACE_SELFTEST_REGS_NOT_FOUND;\n}"
  },
  {
    "function_name": "trace_selftest_function_recursion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "458-534",
    "snippet": "static int\ntrace_selftest_function_recursion(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion: \");\n\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_rec_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_rec_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_rec_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 1) {\n\t\tpr_cont(\"*callback not called once (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\ttrace_selftest_recursion_cnt = 1;\n\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion safe: \");\n\n\tret = ftrace_set_filter(&test_recsafe_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_recsafe_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_recsafe_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called expected 2 times (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"*callback not called expected 2 times (%d)* \"",
            "trace_selftest_recursion_cnt"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&test_recsafe_probe"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"*could not register callback* \""
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter",
          "args": [
            "&test_recsafe_probe",
            "func_name",
            "len",
            "1"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4796-4801",
          "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing ftrace recursion safe: \""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_name"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing ftrace recursion: \""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int\ntrace_selftest_function_recursion(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion: \");\n\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_rec_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_rec_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_rec_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 1) {\n\t\tpr_cont(\"*callback not called once (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\ttrace_selftest_recursion_cnt = 1;\n\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion safe: \");\n\n\tret = ftrace_set_filter(&test_recsafe_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_recsafe_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_recsafe_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called expected 2 times (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_test_recursion_safe_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "432-447",
    "snippet": "static void trace_selftest_test_recursion_safe_func(unsigned long ip,\n\t\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t\t    struct pt_regs *pt_regs)\n{\n\t/*\n\t * We said we would provide our own recursion. By calling\n\t * this function again, we should recurse back into this function\n\t * and count again. But this only happens if the arch supports\n\t * all of ftrace features and nothing else is using the function\n\t * tracing utility.\n\t */\n\tif (trace_selftest_recursion_cnt++)\n\t\treturn;\n\tDYN_FTRACE_TEST_NAME();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_recursion_safe_func(unsigned long ip,\n\t\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t\t    struct pt_regs *pt_regs)\n{\n\t/*\n\t * We said we would provide our own recursion. By calling\n\t * this function again, we should recurse back into this function\n\t * and count again. But this only happens if the arch supports\n\t * all of ftrace features and nothing else is using the function\n\t * tracing utility.\n\t */\n\tif (trace_selftest_recursion_cnt++)\n\t\treturn;\n\tDYN_FTRACE_TEST_NAME();\n}"
  },
  {
    "function_name": "trace_selftest_test_recursion_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "417-430",
    "snippet": "static void trace_selftest_test_recursion_func(unsigned long ip,\n\t\t\t\t\t       unsigned long pip,\n\t\t\t\t\t       struct ftrace_ops *op,\n\t\t\t\t\t       struct pt_regs *pt_regs)\n{\n\t/*\n\t * This function is registered without the recursion safe flag.\n\t * The ftrace infrastructure should provide the recursion\n\t * protection. If not, this will crash the kernel!\n\t */\n\tif (trace_selftest_recursion_cnt++ > 10)\n\t\treturn;\n\tDYN_FTRACE_TEST_NAME();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_recursion_func(unsigned long ip,\n\t\t\t\t\t       unsigned long pip,\n\t\t\t\t\t       struct ftrace_ops *op,\n\t\t\t\t\t       struct pt_regs *pt_regs)\n{\n\t/*\n\t * This function is registered without the recursion safe flag.\n\t * The ftrace infrastructure should provide the recursion\n\t * protection. If not, this will crash the kernel!\n\t */\n\tif (trace_selftest_recursion_cnt++ > 10)\n\t\treturn;\n\tDYN_FTRACE_TEST_NAME();\n}"
  },
  {
    "function_name": "trace_selftest_startup_dynamic_tracing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "325-414",
    "snippet": "static int trace_selftest_startup_dynamic_tracing(struct tracer *trace,\n\t\t\t\t\t\t  struct trace_array *tr,\n\t\t\t\t\t\t  int (*func)(void))\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tchar *func_name;\n\tint ret;\n\n\t/* The ftrace test PASSED */\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace: \");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* passed in by parameter to fool gcc from optimizing */\n\tfunc();\n\n\t/*\n\t * Some archs *cough*PowerPC*cough* add characters to the\n\t * start of the function names. We simply put a '*' to\n\t * accommodate them.\n\t */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\n\t/* filter only on our function */\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t/* enable tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* we should have nothing in the buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (count) {\n\t\tret = -1;\n\t\tprintk(KERN_CONT \".. filter did not filter .. \");\n\t\tgoto out;\n\t}\n\n\t/* call our function again */\n\tfunc();\n\n\t/* sleep again */\n\tmsleep(100);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttracing_start();\n\n\t/* we should only have one item */\n\tif (!ret && count != 1) {\n\t\ttrace->reset(tr);\n\t\tprintk(KERN_CONT \".. filter failed count=%ld ..\", count);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Test the ops with global tracing running */\n\tret = trace_selftest_ops(tr, 1);\n\ttrace->reset(tr);\n\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* Enable tracing on all functions again */\n\tftrace_set_global_filter(NULL, 0, 1);\n\n\t/* Test the ops with global tracing off */\n\tif (!ret)\n\t\tret = trace_selftest_ops(tr, 2);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_selftest_ops",
          "args": [
            "tr",
            "2"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "trace_selftest_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "185-322",
          "snippet": "static int trace_selftest_ops(struct trace_array *tr, int cnt)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tstruct ftrace_ops *dyn_ops;\n\tchar *func1_name;\n\tchar *func2_name;\n\tint len1;\n\tint len2;\n\tint ret = -1;\n\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace ops #%d: \", cnt);\n\n\tftrace_enabled = 1;\n\treset_counts();\n\n\t/* Handle PPC64 '.' name */\n\tfunc1_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tfunc2_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME2);\n\tlen1 = strlen(func1_name);\n\tlen2 = strlen(func2_name);\n\n\t/*\n\t * Probe 1 will trace function 1.\n\t * Probe 2 will trace function 2.\n\t * Probe 3 will trace functions 1 and 2.\n\t */\n\tftrace_set_filter(&test_probe1, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe2, func2_name, len2, 1);\n\tftrace_set_filter(&test_probe3, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe3, func2_name, len2, 0);\n\n\tregister_ftrace_function(&test_probe1);\n\tregister_ftrace_function(&test_probe2);\n\tregister_ftrace_function(&test_probe3);\n\t/* First time we are running with main function */\n\tif (cnt > 1) {\n\t\tftrace_init_array_ops(tr, trace_selftest_test_global_func);\n\t\tregister_ftrace_function(tr->ops);\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 0)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 1)\n\t\tgoto out;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 2)\n\t\tgoto out;\n\n\t/* Add a dynamic probe */\n\tdyn_ops = kzalloc(sizeof(*dyn_ops), GFP_KERNEL);\n\tif (!dyn_ops) {\n\t\tprintk(\"MEMORY ERROR \");\n\t\tgoto out;\n\t}\n\n\tdyn_ops->func = trace_selftest_test_dyn_func;\n\n\tregister_ftrace_function(dyn_ops);\n\n\ttrace_selftest_test_global_cnt = 0;\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 3)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\n\tret = 0;\n out_free:\n\tunregister_ftrace_function(dyn_ops);\n\tkfree(dyn_ops);\n\n out:\n\t/* Purposely unregister in the same order */\n\tunregister_ftrace_function(&test_probe1);\n\tunregister_ftrace_function(&test_probe2);\n\tunregister_ftrace_function(&test_probe3);\n\tif (cnt > 1)\n\t\tunregister_ftrace_function(tr->ops);\n\tftrace_reset_array_ops(tr);\n\n\t/* Make sure everything is off */\n\treset_counts();\n\tDYN_FTRACE_TEST_NAME();\n\tDYN_FTRACE_TEST_NAME();\n\n\tif (trace_selftest_test_probe1_cnt ||\n\t    trace_selftest_test_probe2_cnt ||\n\t    trace_selftest_test_probe3_cnt ||\n\t    trace_selftest_test_global_cnt ||\n\t    trace_selftest_test_dyn_cnt)\n\t\tret = -1;\n\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_selftest_ops(struct trace_array *tr, int cnt)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tstruct ftrace_ops *dyn_ops;\n\tchar *func1_name;\n\tchar *func2_name;\n\tint len1;\n\tint len2;\n\tint ret = -1;\n\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace ops #%d: \", cnt);\n\n\tftrace_enabled = 1;\n\treset_counts();\n\n\t/* Handle PPC64 '.' name */\n\tfunc1_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tfunc2_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME2);\n\tlen1 = strlen(func1_name);\n\tlen2 = strlen(func2_name);\n\n\t/*\n\t * Probe 1 will trace function 1.\n\t * Probe 2 will trace function 2.\n\t * Probe 3 will trace functions 1 and 2.\n\t */\n\tftrace_set_filter(&test_probe1, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe2, func2_name, len2, 1);\n\tftrace_set_filter(&test_probe3, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe3, func2_name, len2, 0);\n\n\tregister_ftrace_function(&test_probe1);\n\tregister_ftrace_function(&test_probe2);\n\tregister_ftrace_function(&test_probe3);\n\t/* First time we are running with main function */\n\tif (cnt > 1) {\n\t\tftrace_init_array_ops(tr, trace_selftest_test_global_func);\n\t\tregister_ftrace_function(tr->ops);\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 0)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 1)\n\t\tgoto out;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 2)\n\t\tgoto out;\n\n\t/* Add a dynamic probe */\n\tdyn_ops = kzalloc(sizeof(*dyn_ops), GFP_KERNEL);\n\tif (!dyn_ops) {\n\t\tprintk(\"MEMORY ERROR \");\n\t\tgoto out;\n\t}\n\n\tdyn_ops->func = trace_selftest_test_dyn_func;\n\n\tregister_ftrace_function(dyn_ops);\n\n\ttrace_selftest_test_global_cnt = 0;\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 3)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\n\tret = 0;\n out_free:\n\tunregister_ftrace_function(dyn_ops);\n\tkfree(dyn_ops);\n\n out:\n\t/* Purposely unregister in the same order */\n\tunregister_ftrace_function(&test_probe1);\n\tunregister_ftrace_function(&test_probe2);\n\tunregister_ftrace_function(&test_probe3);\n\tif (cnt > 1)\n\t\tunregister_ftrace_function(tr->ops);\n\tftrace_reset_array_ops(tr);\n\n\t/* Make sure everything is off */\n\treset_counts();\n\tDYN_FTRACE_TEST_NAME();\n\tDYN_FTRACE_TEST_NAME();\n\n\tif (trace_selftest_test_probe1_cnt ||\n\t    trace_selftest_test_probe2_cnt ||\n\t    trace_selftest_test_probe3_cnt ||\n\t    trace_selftest_test_global_cnt ||\n\t    trace_selftest_test_dyn_cnt)\n\t\tret = -1;\n\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_global_filter",
          "args": [
            "NULL",
            "0",
            "1"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_global_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4831-4834",
          "snippet": "void ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ftrace_ops global_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops global_ops;\n\nvoid ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. filter failed count=%ld ..\"",
            "count"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1808-1843",
          "snippet": "void tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->trace_buffer",
            "&count"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1882-1908",
          "snippet": "void tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1965-1972",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "trace_selftest_function_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "562-645",
          "snippet": "static int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. filter did not filter .. \""
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5158-5162",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_name"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing dynamic ftrace: \""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_selftest_startup_dynamic_tracing(struct tracer *trace,\n\t\t\t\t\t\t  struct trace_array *tr,\n\t\t\t\t\t\t  int (*func)(void))\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tchar *func_name;\n\tint ret;\n\n\t/* The ftrace test PASSED */\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace: \");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* passed in by parameter to fool gcc from optimizing */\n\tfunc();\n\n\t/*\n\t * Some archs *cough*PowerPC*cough* add characters to the\n\t * start of the function names. We simply put a '*' to\n\t * accommodate them.\n\t */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\n\t/* filter only on our function */\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t/* enable tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* we should have nothing in the buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (count) {\n\t\tret = -1;\n\t\tprintk(KERN_CONT \".. filter did not filter .. \");\n\t\tgoto out;\n\t}\n\n\t/* call our function again */\n\tfunc();\n\n\t/* sleep again */\n\tmsleep(100);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->trace_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttracing_start();\n\n\t/* we should only have one item */\n\tif (!ret && count != 1) {\n\t\ttrace->reset(tr);\n\t\tprintk(KERN_CONT \".. filter failed count=%ld ..\", count);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Test the ops with global tracing running */\n\tret = trace_selftest_ops(tr, 1);\n\ttrace->reset(tr);\n\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* Enable tracing on all functions again */\n\tftrace_set_global_filter(NULL, 0, 1);\n\n\t/* Test the ops with global tracing off */\n\tif (!ret)\n\t\tret = trace_selftest_ops(tr, 2);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "185-322",
    "snippet": "static int trace_selftest_ops(struct trace_array *tr, int cnt)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tstruct ftrace_ops *dyn_ops;\n\tchar *func1_name;\n\tchar *func2_name;\n\tint len1;\n\tint len2;\n\tint ret = -1;\n\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace ops #%d: \", cnt);\n\n\tftrace_enabled = 1;\n\treset_counts();\n\n\t/* Handle PPC64 '.' name */\n\tfunc1_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tfunc2_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME2);\n\tlen1 = strlen(func1_name);\n\tlen2 = strlen(func2_name);\n\n\t/*\n\t * Probe 1 will trace function 1.\n\t * Probe 2 will trace function 2.\n\t * Probe 3 will trace functions 1 and 2.\n\t */\n\tftrace_set_filter(&test_probe1, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe2, func2_name, len2, 1);\n\tftrace_set_filter(&test_probe3, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe3, func2_name, len2, 0);\n\n\tregister_ftrace_function(&test_probe1);\n\tregister_ftrace_function(&test_probe2);\n\tregister_ftrace_function(&test_probe3);\n\t/* First time we are running with main function */\n\tif (cnt > 1) {\n\t\tftrace_init_array_ops(tr, trace_selftest_test_global_func);\n\t\tregister_ftrace_function(tr->ops);\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 0)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 1)\n\t\tgoto out;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 2)\n\t\tgoto out;\n\n\t/* Add a dynamic probe */\n\tdyn_ops = kzalloc(sizeof(*dyn_ops), GFP_KERNEL);\n\tif (!dyn_ops) {\n\t\tprintk(\"MEMORY ERROR \");\n\t\tgoto out;\n\t}\n\n\tdyn_ops->func = trace_selftest_test_dyn_func;\n\n\tregister_ftrace_function(dyn_ops);\n\n\ttrace_selftest_test_global_cnt = 0;\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 3)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\n\tret = 0;\n out_free:\n\tunregister_ftrace_function(dyn_ops);\n\tkfree(dyn_ops);\n\n out:\n\t/* Purposely unregister in the same order */\n\tunregister_ftrace_function(&test_probe1);\n\tunregister_ftrace_function(&test_probe2);\n\tunregister_ftrace_function(&test_probe3);\n\tif (cnt > 1)\n\t\tunregister_ftrace_function(tr->ops);\n\tftrace_reset_array_ops(tr);\n\n\t/* Make sure everything is off */\n\treset_counts();\n\tDYN_FTRACE_TEST_NAME();\n\tDYN_FTRACE_TEST_NAME();\n\n\tif (trace_selftest_test_probe1_cnt ||\n\t    trace_selftest_test_probe2_cnt ||\n\t    trace_selftest_test_probe3_cnt ||\n\t    trace_selftest_test_global_cnt ||\n\t    trace_selftest_test_dyn_cnt)\n\t\tret = -1;\n\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_counts",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "reset_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "176-183",
          "snippet": "static void reset_counts(void)\n{\n\ttrace_selftest_test_probe1_cnt = 0;\n\ttrace_selftest_test_probe2_cnt = 0;\n\ttrace_selftest_test_probe3_cnt = 0;\n\ttrace_selftest_test_global_cnt = 0;\n\ttrace_selftest_test_dyn_cnt = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void reset_counts(void)\n{\n\ttrace_selftest_test_probe1_cnt = 0;\n\ttrace_selftest_test_probe2_cnt = 0;\n\ttrace_selftest_test_probe3_cnt = 0;\n\ttrace_selftest_test_global_cnt = 0;\n\ttrace_selftest_test_dyn_cnt = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_reset_array_ops",
          "args": [
            "tr"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_reset_array_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6247-6250",
          "snippet": "void ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dyn_ops"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_counts",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "print_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "166-174",
          "snippet": "static void print_counts(void)\n{\n\tprintk(\"(%d %d %d %d %d) \",\n\t       trace_selftest_test_probe1_cnt,\n\t       trace_selftest_test_probe2_cnt,\n\t       trace_selftest_test_probe3_cnt,\n\t       trace_selftest_test_global_cnt,\n\t       trace_selftest_test_dyn_cnt);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void print_counts(void)\n{\n\tprintk(\"(%d %d %d %d %d) \",\n\t       trace_selftest_test_probe1_cnt,\n\t       trace_selftest_test_probe2_cnt,\n\t       trace_selftest_test_probe3_cnt,\n\t       trace_selftest_test_global_cnt,\n\t       trace_selftest_test_dyn_cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"MEMORY ERROR \""
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dyn_ops)",
            "GFP_KERNEL"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_init_array_ops",
          "args": [
            "tr",
            "trace_selftest_test_global_func"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_array_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6235-6245",
          "snippet": "void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter",
          "args": [
            "&test_probe3",
            "func2_name",
            "len2",
            "0"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4796-4801",
          "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func2_name"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME2"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing dynamic ftrace ops #%d: \"",
            "cnt"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_selftest_ops(struct trace_array *tr, int cnt)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tstruct ftrace_ops *dyn_ops;\n\tchar *func1_name;\n\tchar *func2_name;\n\tint len1;\n\tint len2;\n\tint ret = -1;\n\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace ops #%d: \", cnt);\n\n\tftrace_enabled = 1;\n\treset_counts();\n\n\t/* Handle PPC64 '.' name */\n\tfunc1_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tfunc2_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME2);\n\tlen1 = strlen(func1_name);\n\tlen2 = strlen(func2_name);\n\n\t/*\n\t * Probe 1 will trace function 1.\n\t * Probe 2 will trace function 2.\n\t * Probe 3 will trace functions 1 and 2.\n\t */\n\tftrace_set_filter(&test_probe1, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe2, func2_name, len2, 1);\n\tftrace_set_filter(&test_probe3, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe3, func2_name, len2, 0);\n\n\tregister_ftrace_function(&test_probe1);\n\tregister_ftrace_function(&test_probe2);\n\tregister_ftrace_function(&test_probe3);\n\t/* First time we are running with main function */\n\tif (cnt > 1) {\n\t\tftrace_init_array_ops(tr, trace_selftest_test_global_func);\n\t\tregister_ftrace_function(tr->ops);\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 0)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 1)\n\t\tgoto out;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 2)\n\t\tgoto out;\n\n\t/* Add a dynamic probe */\n\tdyn_ops = kzalloc(sizeof(*dyn_ops), GFP_KERNEL);\n\tif (!dyn_ops) {\n\t\tprintk(\"MEMORY ERROR \");\n\t\tgoto out;\n\t}\n\n\tdyn_ops->func = trace_selftest_test_dyn_func;\n\n\tregister_ftrace_function(dyn_ops);\n\n\ttrace_selftest_test_global_cnt = 0;\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 3)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\n\tret = 0;\n out_free:\n\tunregister_ftrace_function(dyn_ops);\n\tkfree(dyn_ops);\n\n out:\n\t/* Purposely unregister in the same order */\n\tunregister_ftrace_function(&test_probe1);\n\tunregister_ftrace_function(&test_probe2);\n\tunregister_ftrace_function(&test_probe3);\n\tif (cnt > 1)\n\t\tunregister_ftrace_function(tr->ops);\n\tftrace_reset_array_ops(tr);\n\n\t/* Make sure everything is off */\n\treset_counts();\n\tDYN_FTRACE_TEST_NAME();\n\tDYN_FTRACE_TEST_NAME();\n\n\tif (trace_selftest_test_probe1_cnt ||\n\t    trace_selftest_test_probe2_cnt ||\n\t    trace_selftest_test_probe3_cnt ||\n\t    trace_selftest_test_global_cnt ||\n\t    trace_selftest_test_dyn_cnt)\n\t\tret = -1;\n\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "reset_counts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "176-183",
    "snippet": "static void reset_counts(void)\n{\n\ttrace_selftest_test_probe1_cnt = 0;\n\ttrace_selftest_test_probe2_cnt = 0;\n\ttrace_selftest_test_probe3_cnt = 0;\n\ttrace_selftest_test_global_cnt = 0;\n\ttrace_selftest_test_dyn_cnt = 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void reset_counts(void)\n{\n\ttrace_selftest_test_probe1_cnt = 0;\n\ttrace_selftest_test_probe2_cnt = 0;\n\ttrace_selftest_test_probe3_cnt = 0;\n\ttrace_selftest_test_global_cnt = 0;\n\ttrace_selftest_test_dyn_cnt = 0;\n}"
  },
  {
    "function_name": "print_counts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "166-174",
    "snippet": "static void print_counts(void)\n{\n\tprintk(\"(%d %d %d %d %d) \",\n\t       trace_selftest_test_probe1_cnt,\n\t       trace_selftest_test_probe2_cnt,\n\t       trace_selftest_test_probe3_cnt,\n\t       trace_selftest_test_global_cnt,\n\t       trace_selftest_test_dyn_cnt);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"(%d %d %d %d %d) \"",
            "trace_selftest_test_probe1_cnt",
            "trace_selftest_test_probe2_cnt",
            "trace_selftest_test_probe3_cnt",
            "trace_selftest_test_global_cnt",
            "trace_selftest_test_dyn_cnt"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "229-241",
          "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void print_counts(void)\n{\n\tprintk(\"(%d %d %d %d %d) \",\n\t       trace_selftest_test_probe1_cnt,\n\t       trace_selftest_test_probe2_cnt,\n\t       trace_selftest_test_probe3_cnt,\n\t       trace_selftest_test_global_cnt,\n\t       trace_selftest_test_dyn_cnt);\n}"
  },
  {
    "function_name": "trace_selftest_test_dyn_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "143-149",
    "snippet": "static void trace_selftest_test_dyn_func(unsigned long ip,\n\t\t\t\t\t unsigned long pip,\n\t\t\t\t\t struct ftrace_ops *op,\n\t\t\t\t\t struct pt_regs *pt_regs)\n{\n\ttrace_selftest_test_dyn_cnt++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_dyn_func(unsigned long ip,\n\t\t\t\t\t unsigned long pip,\n\t\t\t\t\t struct ftrace_ops *op,\n\t\t\t\t\t struct pt_regs *pt_regs)\n{\n\ttrace_selftest_test_dyn_cnt++;\n}"
  },
  {
    "function_name": "trace_selftest_test_global_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "134-140",
    "snippet": "static void trace_selftest_test_global_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct pt_regs *pt_regs)\n{\n\ttrace_selftest_test_global_cnt++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_global_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct pt_regs *pt_regs)\n{\n\ttrace_selftest_test_global_cnt++;\n}"
  },
  {
    "function_name": "trace_selftest_test_probe3_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "125-131",
    "snippet": "static void trace_selftest_test_probe3_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct pt_regs *pt_regs)\n{\n\ttrace_selftest_test_probe3_cnt++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_probe3_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct pt_regs *pt_regs)\n{\n\ttrace_selftest_test_probe3_cnt++;\n}"
  },
  {
    "function_name": "trace_selftest_test_probe2_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "116-122",
    "snippet": "static void trace_selftest_test_probe2_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct pt_regs *pt_regs)\n{\n\ttrace_selftest_test_probe2_cnt++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_probe2_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct pt_regs *pt_regs)\n{\n\ttrace_selftest_test_probe2_cnt++;\n}"
  },
  {
    "function_name": "trace_selftest_test_probe1_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "107-113",
    "snippet": "static void trace_selftest_test_probe1_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct pt_regs *pt_regs)\n{\n\ttrace_selftest_test_probe1_cnt++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_probe1_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct pt_regs *pt_regs)\n{\n\ttrace_selftest_test_probe1_cnt++;\n}"
  },
  {
    "function_name": "warn_failed_init_tracer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "97-101",
    "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\"",
            "trace->name",
            "init_ret"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "229-241",
          "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
  },
  {
    "function_name": "trace_test_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "63-95",
    "snippet": "static int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&buf->tr->max_lock"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_on",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "783-786",
          "snippet": "void tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_test_buffer_cpu",
          "args": [
            "buf",
            "cpu"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "26-57",
          "snippet": "static int trace_test_buffer_cpu(struct trace_buffer *buf, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_entry *entry;\n\tunsigned int loops = 0;\n\n\twhile ((event = ring_buffer_consume(buf->buffer, cpu, NULL, NULL))) {\n\t\tentry = ring_buffer_event_data(event);\n\n\t\t/*\n\t\t * The ring buffer is a size of trace_buf_size, if\n\t\t * we loop more than the size, there's something wrong\n\t\t * with the ring buffer.\n\t\t */\n\t\tif (loops++ > trace_buf_size) {\n\t\t\tprintk(KERN_CONT \".. bad ring buffer \");\n\t\t\tgoto failed;\n\t\t}\n\t\tif (!trace_valid_entry(entry)) {\n\t\t\tprintk(KERN_CONT \".. invalid entry %d \",\n\t\t\t\tentry->type);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\n failed:\n\t/* disable tracing */\n\ttracing_disabled = 1;\n\tprintk(KERN_CONT \".. corrupted trace buffer .. \");\n\treturn -1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_test_buffer_cpu(struct trace_buffer *buf, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_entry *entry;\n\tunsigned int loops = 0;\n\n\twhile ((event = ring_buffer_consume(buf->buffer, cpu, NULL, NULL))) {\n\t\tentry = ring_buffer_event_data(event);\n\n\t\t/*\n\t\t * The ring buffer is a size of trace_buf_size, if\n\t\t * we loop more than the size, there's something wrong\n\t\t * with the ring buffer.\n\t\t */\n\t\tif (loops++ > trace_buf_size) {\n\t\t\tprintk(KERN_CONT \".. bad ring buffer \");\n\t\t\tgoto failed;\n\t\t}\n\t\tif (!trace_valid_entry(entry)) {\n\t\t\tprintk(KERN_CONT \".. invalid entry %d \",\n\t\t\t\tentry->type);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\n failed:\n\t/* disable tracing */\n\ttracing_disabled = 1;\n\tprintk(KERN_CONT \".. corrupted trace buffer .. \");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_off",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1073-1076",
          "snippet": "void tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_entries",
          "args": [
            "buf->buffer"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "3465-3478",
          "snippet": "unsigned long ring_buffer_entries(struct ring_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long entries = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tentries += rb_num_of_entries(cpu_buffer);\n\t}\n\n\treturn entries;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nunsigned long ring_buffer_entries(struct ring_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long entries = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tentries += rb_num_of_entries(cpu_buffer);\n\t}\n\n\treturn entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&buf->tr->max_lock"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct trace_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_test_buffer_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "26-57",
    "snippet": "static int trace_test_buffer_cpu(struct trace_buffer *buf, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_entry *entry;\n\tunsigned int loops = 0;\n\n\twhile ((event = ring_buffer_consume(buf->buffer, cpu, NULL, NULL))) {\n\t\tentry = ring_buffer_event_data(event);\n\n\t\t/*\n\t\t * The ring buffer is a size of trace_buf_size, if\n\t\t * we loop more than the size, there's something wrong\n\t\t * with the ring buffer.\n\t\t */\n\t\tif (loops++ > trace_buf_size) {\n\t\t\tprintk(KERN_CONT \".. bad ring buffer \");\n\t\t\tgoto failed;\n\t\t}\n\t\tif (!trace_valid_entry(entry)) {\n\t\t\tprintk(KERN_CONT \".. invalid entry %d \",\n\t\t\t\tentry->type);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\n failed:\n\t/* disable tracing */\n\ttracing_disabled = 1;\n\tprintk(KERN_CONT \".. corrupted trace buffer .. \");\n\treturn -1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. corrupted trace buffer .. \""
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. invalid entry %d \"",
            "entry->type"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_valid_entry",
          "args": [
            "entry"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "trace_valid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
          "lines": "10-24",
          "snippet": "static inline int trace_valid_entry(struct trace_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase TRACE_FN:\n\tcase TRACE_CTX:\n\tcase TRACE_WAKE:\n\tcase TRACE_STACK:\n\tcase TRACE_PRINT:\n\tcase TRACE_BRANCH:\n\tcase TRACE_GRAPH_ENT:\n\tcase TRACE_GRAPH_RET:\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline int trace_valid_entry(struct trace_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase TRACE_FN:\n\tcase TRACE_CTX:\n\tcase TRACE_WAKE:\n\tcase TRACE_STACK:\n\tcase TRACE_PRINT:\n\tcase TRACE_BRANCH:\n\tcase TRACE_GRAPH_ENT:\n\tcase TRACE_GRAPH_RET:\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_consume",
          "args": [
            "buf->buffer",
            "cpu",
            "NULL",
            "NULL"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_consume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "4101-4137",
          "snippet": "struct ring_buffer_event *\nring_buffer_consume(struct ring_buffer *buffer, int cpu, u64 *ts,\n\t\t    unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event = NULL;\n\tunsigned long flags;\n\tbool dolock;\n\n again:\n\t/* might be called in atomic */\n\tpreempt_disable();\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event) {\n\t\tcpu_buffer->lost_events = 0;\n\t\trb_advance_reader(cpu_buffer);\n\t}\n\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n out:\n\tpreempt_enable();\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_consume(struct ring_buffer *buffer, int cpu, u64 *ts,\n\t\t    unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event = NULL;\n\tunsigned long flags;\n\tbool dolock;\n\n again:\n\t/* might be called in atomic */\n\tpreempt_disable();\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event) {\n\t\tcpu_buffer->lost_events = 0;\n\t\trb_advance_reader(cpu_buffer);\n\t}\n\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n out:\n\tpreempt_enable();\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_test_buffer_cpu(struct trace_buffer *buf, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_entry *entry;\n\tunsigned int loops = 0;\n\n\twhile ((event = ring_buffer_consume(buf->buffer, cpu, NULL, NULL))) {\n\t\tentry = ring_buffer_event_data(event);\n\n\t\t/*\n\t\t * The ring buffer is a size of trace_buf_size, if\n\t\t * we loop more than the size, there's something wrong\n\t\t * with the ring buffer.\n\t\t */\n\t\tif (loops++ > trace_buf_size) {\n\t\t\tprintk(KERN_CONT \".. bad ring buffer \");\n\t\t\tgoto failed;\n\t\t}\n\t\tif (!trace_valid_entry(entry)) {\n\t\t\tprintk(KERN_CONT \".. invalid entry %d \",\n\t\t\t\tentry->type);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\n failed:\n\t/* disable tracing */\n\ttracing_disabled = 1;\n\tprintk(KERN_CONT \".. corrupted trace buffer .. \");\n\treturn -1;\n}"
  },
  {
    "function_name": "trace_valid_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_selftest.c",
    "lines": "10-24",
    "snippet": "static inline int trace_valid_entry(struct trace_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase TRACE_FN:\n\tcase TRACE_CTX:\n\tcase TRACE_WAKE:\n\tcase TRACE_STACK:\n\tcase TRACE_PRINT:\n\tcase TRACE_BRANCH:\n\tcase TRACE_GRAPH_ENT:\n\tcase TRACE_GRAPH_RET:\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline int trace_valid_entry(struct trace_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase TRACE_FN:\n\tcase TRACE_CTX:\n\tcase TRACE_WAKE:\n\tcase TRACE_STACK:\n\tcase TRACE_PRINT:\n\tcase TRACE_BRANCH:\n\tcase TRACE_GRAPH_ENT:\n\tcase TRACE_GRAPH_RET:\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  }
]