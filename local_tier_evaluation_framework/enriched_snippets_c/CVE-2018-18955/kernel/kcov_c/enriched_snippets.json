[
  {
    "function_name": "kcov_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "440-452",
    "snippet": "static int __init kcov_init(void)\n{\n\t/*\n\t * The kcov debugfs file won't ever get removed and thus,\n\t * there is no need to protect it against removal races. The\n\t * use of debugfs_create_file_unsafe() is actually safe here.\n\t */\n\tif (!debugfs_create_file_unsafe(\"kcov\", 0600, NULL, NULL, &kcov_fops)) {\n\t\tpr_err(\"failed to create kcov in debugfs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations kcov_fops = {\n\t.open\t\t= kcov_open,\n\t.unlocked_ioctl\t= kcov_ioctl,\n\t.compat_ioctl\t= kcov_ioctl,\n\t.mmap\t\t= kcov_mmap,\n\t.release        = kcov_close,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to create kcov in debugfs\\n\""
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"kcov\"",
            "0600",
            "NULL",
            "NULL",
            "&kcov_fops"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic const struct file_operations kcov_fops = {\n\t.open\t\t= kcov_open,\n\t.unlocked_ioctl\t= kcov_ioctl,\n\t.compat_ioctl\t= kcov_ioctl,\n\t.mmap\t\t= kcov_mmap,\n\t.release        = kcov_close,\n};\n\nstatic int __init kcov_init(void)\n{\n\t/*\n\t * The kcov debugfs file won't ever get removed and thus,\n\t * there is no need to protect it against removal races. The\n\t * use of debugfs_create_file_unsafe() is actually safe here.\n\t */\n\tif (!debugfs_create_file_unsafe(\"kcov\", 0600, NULL, NULL, &kcov_fops)) {\n\t\tpr_err(\"failed to create kcov in debugfs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kcov_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "420-430",
    "snippet": "static long kcov_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tstruct kcov *kcov;\n\tint res;\n\n\tkcov = filep->private_data;\n\tspin_lock(&kcov->lock);\n\tres = kcov_ioctl_locked(kcov, cmd, arg);\n\tspin_unlock(&kcov->lock);\n\treturn res;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kcov->lock"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_ioctl_locked",
          "args": [
            "kcov",
            "cmd",
            "arg"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_ioctl_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "342-418",
          "snippet": "static int kcov_ioctl_locked(struct kcov *kcov, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct task_struct *t;\n\tunsigned long size, unused;\n\n\tswitch (cmd) {\n\tcase KCOV_INIT_TRACE:\n\t\t/*\n\t\t * Enable kcov in trace mode and setup buffer size.\n\t\t * Must happen before anything else.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_DISABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * Size must be at least 2 to hold current position and one PC.\n\t\t * Later we allocate size * sizeof(unsigned long) memory,\n\t\t * that must not overflow.\n\t\t */\n\t\tsize = arg;\n\t\tif (size < 2 || size > INT_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->size = size;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\treturn 0;\n\tcase KCOV_ENABLE:\n\t\t/*\n\t\t * Enable coverage for the current task.\n\t\t * At this point user must have been enabled trace mode,\n\t\t * and mmapped the file. Coverage collection is disabled only\n\t\t * at task exit or voluntary by KCOV_DISABLE. After that it can\n\t\t * be enabled for another task.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tif (arg == KCOV_TRACE_PC)\n\t\t\tkcov->mode = KCOV_MODE_TRACE_PC;\n\t\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\t\tkcov->mode = KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tkcov_fault_in_area(kcov);\n\t\t/* Cache in task struct for performance. */\n\t\tt->kcov_size = kcov->size;\n\t\tt->kcov_area = kcov->area;\n\t\t/* See comment in check_kcov_mode(). */\n\t\tbarrier();\n\t\tWRITE_ONCE(t->kcov_mode, kcov->mode);\n\t\tt->kcov = kcov;\n\t\tkcov->t = t;\n\t\t/* This is put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tcase KCOV_DISABLE:\n\t\t/* Disable coverage for the current task. */\n\t\tunused = arg;\n\t\tif (unused != 0 || current->kcov != kcov)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (WARN_ON(kcov->t != t))\n\t\t\treturn -EINVAL;\n\t\tkcov_task_init(t);\n\t\tkcov->t = NULL;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\tkcov_put(kcov);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_ioctl_locked(struct kcov *kcov, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct task_struct *t;\n\tunsigned long size, unused;\n\n\tswitch (cmd) {\n\tcase KCOV_INIT_TRACE:\n\t\t/*\n\t\t * Enable kcov in trace mode and setup buffer size.\n\t\t * Must happen before anything else.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_DISABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * Size must be at least 2 to hold current position and one PC.\n\t\t * Later we allocate size * sizeof(unsigned long) memory,\n\t\t * that must not overflow.\n\t\t */\n\t\tsize = arg;\n\t\tif (size < 2 || size > INT_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->size = size;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\treturn 0;\n\tcase KCOV_ENABLE:\n\t\t/*\n\t\t * Enable coverage for the current task.\n\t\t * At this point user must have been enabled trace mode,\n\t\t * and mmapped the file. Coverage collection is disabled only\n\t\t * at task exit or voluntary by KCOV_DISABLE. After that it can\n\t\t * be enabled for another task.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tif (arg == KCOV_TRACE_PC)\n\t\t\tkcov->mode = KCOV_MODE_TRACE_PC;\n\t\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\t\tkcov->mode = KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tkcov_fault_in_area(kcov);\n\t\t/* Cache in task struct for performance. */\n\t\tt->kcov_size = kcov->size;\n\t\tt->kcov_area = kcov->area;\n\t\t/* See comment in check_kcov_mode(). */\n\t\tbarrier();\n\t\tWRITE_ONCE(t->kcov_mode, kcov->mode);\n\t\tt->kcov = kcov;\n\t\tkcov->t = t;\n\t\t/* This is put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tcase KCOV_DISABLE:\n\t\t/* Disable coverage for the current task. */\n\t\tunused = arg;\n\t\tif (unused != 0 || current->kcov != kcov)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (WARN_ON(kcov->t != t))\n\t\t\treturn -EINVAL;\n\t\tkcov_task_init(t);\n\t\tkcov->t = NULL;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\tkcov_put(kcov);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kcov->lock"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic long kcov_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tstruct kcov *kcov;\n\tint res;\n\n\tkcov = filep->private_data;\n\tspin_lock(&kcov->lock);\n\tres = kcov_ioctl_locked(kcov, cmd, arg);\n\tspin_unlock(&kcov->lock);\n\treturn res;\n}"
  },
  {
    "function_name": "kcov_ioctl_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "342-418",
    "snippet": "static int kcov_ioctl_locked(struct kcov *kcov, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct task_struct *t;\n\tunsigned long size, unused;\n\n\tswitch (cmd) {\n\tcase KCOV_INIT_TRACE:\n\t\t/*\n\t\t * Enable kcov in trace mode and setup buffer size.\n\t\t * Must happen before anything else.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_DISABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * Size must be at least 2 to hold current position and one PC.\n\t\t * Later we allocate size * sizeof(unsigned long) memory,\n\t\t * that must not overflow.\n\t\t */\n\t\tsize = arg;\n\t\tif (size < 2 || size > INT_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->size = size;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\treturn 0;\n\tcase KCOV_ENABLE:\n\t\t/*\n\t\t * Enable coverage for the current task.\n\t\t * At this point user must have been enabled trace mode,\n\t\t * and mmapped the file. Coverage collection is disabled only\n\t\t * at task exit or voluntary by KCOV_DISABLE. After that it can\n\t\t * be enabled for another task.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tif (arg == KCOV_TRACE_PC)\n\t\t\tkcov->mode = KCOV_MODE_TRACE_PC;\n\t\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\t\tkcov->mode = KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tkcov_fault_in_area(kcov);\n\t\t/* Cache in task struct for performance. */\n\t\tt->kcov_size = kcov->size;\n\t\tt->kcov_area = kcov->area;\n\t\t/* See comment in check_kcov_mode(). */\n\t\tbarrier();\n\t\tWRITE_ONCE(t->kcov_mode, kcov->mode);\n\t\tt->kcov = kcov;\n\t\tkcov->t = t;\n\t\t/* This is put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tcase KCOV_DISABLE:\n\t\t/* Disable coverage for the current task. */\n\t\tunused = arg;\n\t\tif (unused != 0 || current->kcov != kcov)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (WARN_ON(kcov->t != t))\n\t\t\treturn -EINVAL;\n\t\tkcov_task_init(t);\n\t\tkcov->t = NULL;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\tkcov_put(kcov);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_put",
          "args": [
            "kcov"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "234-240",
          "snippet": "static void kcov_put(struct kcov *kcov)\n{\n\tif (atomic_dec_and_test(&kcov->refcount)) {\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (atomic_dec_and_test(&kcov->refcount)) {\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_task_init",
          "args": [
            "t"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "242-249",
          "snippet": "void kcov_task_init(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n\tt->kcov = NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid kcov_task_init(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n\tt->kcov = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kcov->t != t"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcov_get",
          "args": [
            "kcov"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "229-232",
          "snippet": "static void kcov_get(struct kcov *kcov)\n{\n\tatomic_inc(&kcov->refcount);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_get(struct kcov *kcov)\n{\n\tatomic_inc(&kcov->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "t->kcov_mode",
            "kcov->mode"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_fault_in_area",
          "args": [
            "kcov"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_fault_in_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "332-340",
          "snippet": "static void kcov_fault_in_area(struct kcov *kcov)\n{\n\tunsigned long stride = PAGE_SIZE / sizeof(unsigned long);\n\tunsigned long *area = kcov->area;\n\tunsigned long offset;\n\n\tfor (offset = 0; offset < kcov->size; offset += stride)\n\t\tREAD_ONCE(area[offset]);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_fault_in_area(struct kcov *kcov)\n{\n\tunsigned long stride = PAGE_SIZE / sizeof(unsigned long);\n\tunsigned long *area = kcov->area;\n\tunsigned long offset;\n\n\tfor (offset = 0; offset < kcov->size; offset += stride)\n\t\tREAD_ONCE(area[offset]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_ioctl_locked(struct kcov *kcov, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct task_struct *t;\n\tunsigned long size, unused;\n\n\tswitch (cmd) {\n\tcase KCOV_INIT_TRACE:\n\t\t/*\n\t\t * Enable kcov in trace mode and setup buffer size.\n\t\t * Must happen before anything else.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_DISABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * Size must be at least 2 to hold current position and one PC.\n\t\t * Later we allocate size * sizeof(unsigned long) memory,\n\t\t * that must not overflow.\n\t\t */\n\t\tsize = arg;\n\t\tif (size < 2 || size > INT_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->size = size;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\treturn 0;\n\tcase KCOV_ENABLE:\n\t\t/*\n\t\t * Enable coverage for the current task.\n\t\t * At this point user must have been enabled trace mode,\n\t\t * and mmapped the file. Coverage collection is disabled only\n\t\t * at task exit or voluntary by KCOV_DISABLE. After that it can\n\t\t * be enabled for another task.\n\t\t */\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tif (arg == KCOV_TRACE_PC)\n\t\t\tkcov->mode = KCOV_MODE_TRACE_PC;\n\t\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\t\tkcov->mode = KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tkcov_fault_in_area(kcov);\n\t\t/* Cache in task struct for performance. */\n\t\tt->kcov_size = kcov->size;\n\t\tt->kcov_area = kcov->area;\n\t\t/* See comment in check_kcov_mode(). */\n\t\tbarrier();\n\t\tWRITE_ONCE(t->kcov_mode, kcov->mode);\n\t\tt->kcov = kcov;\n\t\tkcov->t = t;\n\t\t/* This is put either in kcov_task_exit() or in KCOV_DISABLE. */\n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tcase KCOV_DISABLE:\n\t\t/* Disable coverage for the current task. */\n\t\tunused = arg;\n\t\tif (unused != 0 || current->kcov != kcov)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (WARN_ON(kcov->t != t))\n\t\t\treturn -EINVAL;\n\t\tkcov_task_init(t);\n\t\tkcov->t = NULL;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\tkcov_put(kcov);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "kcov_fault_in_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "332-340",
    "snippet": "static void kcov_fault_in_area(struct kcov *kcov)\n{\n\tunsigned long stride = PAGE_SIZE / sizeof(unsigned long);\n\tunsigned long *area = kcov->area;\n\tunsigned long offset;\n\n\tfor (offset = 0; offset < kcov->size; offset += stride)\n\t\tREAD_ONCE(area[offset]);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "area[offset]"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_fault_in_area(struct kcov *kcov)\n{\n\tunsigned long stride = PAGE_SIZE / sizeof(unsigned long);\n\tunsigned long *area = kcov->area;\n\tunsigned long offset;\n\n\tfor (offset = 0; offset < kcov->size; offset += stride)\n\t\tREAD_ONCE(area[offset]);\n}"
  },
  {
    "function_name": "kcov_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "321-325",
    "snippet": "static int kcov_close(struct inode *inode, struct file *filep)\n{\n\tkcov_put(filep->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_put",
          "args": [
            "filep->private_data"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "234-240",
          "snippet": "static void kcov_put(struct kcov *kcov)\n{\n\tif (atomic_dec_and_test(&kcov->refcount)) {\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (atomic_dec_and_test(&kcov->refcount)) {\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_close(struct inode *inode, struct file *filep)\n{\n\tkcov_put(filep->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "kcov_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "307-319",
    "snippet": "static int kcov_open(struct inode *inode, struct file *filep)\n{\n\tstruct kcov *kcov;\n\n\tkcov = kzalloc(sizeof(*kcov), GFP_KERNEL);\n\tif (!kcov)\n\t\treturn -ENOMEM;\n\tkcov->mode = KCOV_MODE_DISABLED;\n\tatomic_set(&kcov->refcount, 1);\n\tspin_lock_init(&kcov->lock);\n\tfilep->private_data = kcov;\n\treturn nonseekable_open(inode, filep);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nonseekable_open",
          "args": [
            "inode",
            "filep"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&kcov->lock"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kcov->refcount",
            "1"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*kcov)",
            "GFP_KERNEL"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_open(struct inode *inode, struct file *filep)\n{\n\tstruct kcov *kcov;\n\n\tkcov = kzalloc(sizeof(*kcov), GFP_KERNEL);\n\tif (!kcov)\n\t\treturn -ENOMEM;\n\tkcov->mode = KCOV_MODE_DISABLED;\n\tatomic_set(&kcov->refcount, 1);\n\tspin_lock_init(&kcov->lock);\n\tfilep->private_data = kcov;\n\treturn nonseekable_open(inode, filep);\n}"
  },
  {
    "function_name": "kcov_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "271-305",
    "snippet": "static int kcov_mmap(struct file *filep, struct vm_area_struct *vma)\n{\n\tint res = 0;\n\tvoid *area;\n\tstruct kcov *kcov = vma->vm_file->private_data;\n\tunsigned long size, off;\n\tstruct page *page;\n\n\tarea = vmalloc_user(vma->vm_end - vma->vm_start);\n\tif (!area)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&kcov->lock);\n\tsize = kcov->size * sizeof(unsigned long);\n\tif (kcov->mode != KCOV_MODE_INIT || vma->vm_pgoff != 0 ||\n\t    vma->vm_end - vma->vm_start != size) {\n\t\tres = -EINVAL;\n\t\tgoto exit;\n\t}\n\tif (!kcov->area) {\n\t\tkcov->area = area;\n\t\tvma->vm_flags |= VM_DONTEXPAND;\n\t\tspin_unlock(&kcov->lock);\n\t\tfor (off = 0; off < size; off += PAGE_SIZE) {\n\t\t\tpage = vmalloc_to_page(kcov->area + off);\n\t\t\tif (vm_insert_page(vma, vma->vm_start + off, page))\n\t\t\t\tWARN_ONCE(1, \"vm_insert_page() failed\");\n\t\t}\n\t\treturn 0;\n\t}\nexit:\n\tspin_unlock(&kcov->lock);\n\tvfree(area);\n\treturn res;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "area"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kcov->lock"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"vm_insert_page() failed\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_insert_page",
          "args": [
            "vma",
            "vma->vm_start + off",
            "page"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "kcov->area + off"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kcov->lock"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc_user",
          "args": [
            "vma->vm_end - vma->vm_start"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic int kcov_mmap(struct file *filep, struct vm_area_struct *vma)\n{\n\tint res = 0;\n\tvoid *area;\n\tstruct kcov *kcov = vma->vm_file->private_data;\n\tunsigned long size, off;\n\tstruct page *page;\n\n\tarea = vmalloc_user(vma->vm_end - vma->vm_start);\n\tif (!area)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&kcov->lock);\n\tsize = kcov->size * sizeof(unsigned long);\n\tif (kcov->mode != KCOV_MODE_INIT || vma->vm_pgoff != 0 ||\n\t    vma->vm_end - vma->vm_start != size) {\n\t\tres = -EINVAL;\n\t\tgoto exit;\n\t}\n\tif (!kcov->area) {\n\t\tkcov->area = area;\n\t\tvma->vm_flags |= VM_DONTEXPAND;\n\t\tspin_unlock(&kcov->lock);\n\t\tfor (off = 0; off < size; off += PAGE_SIZE) {\n\t\t\tpage = vmalloc_to_page(kcov->area + off);\n\t\t\tif (vm_insert_page(vma, vma->vm_start + off, page))\n\t\t\t\tWARN_ONCE(1, \"vm_insert_page() failed\");\n\t\t}\n\t\treturn 0;\n\t}\nexit:\n\tspin_unlock(&kcov->lock);\n\tvfree(area);\n\treturn res;\n}"
  },
  {
    "function_name": "kcov_task_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "251-269",
    "snippet": "void kcov_task_exit(struct task_struct *t)\n{\n\tstruct kcov *kcov;\n\n\tkcov = t->kcov;\n\tif (kcov == NULL)\n\t\treturn;\n\tspin_lock(&kcov->lock);\n\tif (WARN_ON(kcov->t != t)) {\n\t\tspin_unlock(&kcov->lock);\n\t\treturn;\n\t}\n\t/* Just to not leave dangling references behind. */\n\tkcov_task_init(t);\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tspin_unlock(&kcov->lock);\n\tkcov_put(kcov);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcov_put",
          "args": [
            "kcov"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "234-240",
          "snippet": "static void kcov_put(struct kcov *kcov)\n{\n\tif (atomic_dec_and_test(&kcov->refcount)) {\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (atomic_dec_and_test(&kcov->refcount)) {\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kcov->lock"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_task_init",
          "args": [
            "t"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "242-249",
          "snippet": "void kcov_task_init(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n\tt->kcov = NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid kcov_task_init(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n\tt->kcov = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kcov->t != t"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kcov->lock"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid kcov_task_exit(struct task_struct *t)\n{\n\tstruct kcov *kcov;\n\n\tkcov = t->kcov;\n\tif (kcov == NULL)\n\t\treturn;\n\tspin_lock(&kcov->lock);\n\tif (WARN_ON(kcov->t != t)) {\n\t\tspin_unlock(&kcov->lock);\n\t\treturn;\n\t}\n\t/* Just to not leave dangling references behind. */\n\tkcov_task_init(t);\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tspin_unlock(&kcov->lock);\n\tkcov_put(kcov);\n}"
  },
  {
    "function_name": "kcov_task_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "242-249",
    "snippet": "void kcov_task_init(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n\tt->kcov = NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "t->kcov_mode",
            "KCOV_MODE_DISABLED"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid kcov_task_init(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n\tt->kcov = NULL;\n}"
  },
  {
    "function_name": "kcov_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "234-240",
    "snippet": "static void kcov_put(struct kcov *kcov)\n{\n\tif (atomic_dec_and_test(&kcov->refcount)) {\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kcov"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "kcov->area"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&kcov->refcount"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (atomic_dec_and_test(&kcov->refcount)) {\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}"
  },
  {
    "function_name": "kcov_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "229-232",
    "snippet": "static void kcov_get(struct kcov *kcov)\n{\n\tatomic_inc(&kcov->refcount);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&kcov->refcount"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic void kcov_get(struct kcov *kcov)\n{\n\tatomic_inc(&kcov->refcount);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "200-225",
    "snippet": "void notrace __sanitizer_cov_trace_switch(u64 val, u64 *cases)\n{\n\tu64 i;\n\tu64 count = cases[0];\n\tu64 size = cases[1];\n\tu64 type = KCOV_CMP_CONST;\n\n\tswitch (size) {\n\tcase 8:\n\t\ttype |= KCOV_CMP_SIZE(0);\n\t\tbreak;\n\tcase 16:\n\t\ttype |= KCOV_CMP_SIZE(1);\n\t\tbreak;\n\tcase 32:\n\t\ttype |= KCOV_CMP_SIZE(2);\n\t\tbreak;\n\tcase 64:\n\t\ttype |= KCOV_CMP_SIZE(3);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tfor (i = 0; i < count; i++)\n\t\twrite_comp_data(type, cases[i + 2], val, _RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "type",
            "cases[i + 2]",
            "val",
            "_RET_IP_"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "115-146",
          "snippet": "static void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "3"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "2"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "1"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "0"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_switch(u64 val, u64 *cases)\n{\n\tu64 i;\n\tu64 count = cases[0];\n\tu64 size = cases[1];\n\tu64 type = KCOV_CMP_CONST;\n\n\tswitch (size) {\n\tcase 8:\n\t\ttype |= KCOV_CMP_SIZE(0);\n\t\tbreak;\n\tcase 16:\n\t\ttype |= KCOV_CMP_SIZE(1);\n\t\tbreak;\n\tcase 32:\n\t\ttype |= KCOV_CMP_SIZE(2);\n\t\tbreak;\n\tcase 64:\n\t\ttype |= KCOV_CMP_SIZE(3);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tfor (i = 0; i < count; i++)\n\t\twrite_comp_data(type, cases[i + 2], val, _RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_const_cmp8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "193-197",
    "snippet": "void notrace __sanitizer_cov_trace_const_cmp8(u64 arg1, u64 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(3) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(3) | KCOV_CMP_CONST",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "115-146",
          "snippet": "static void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "3"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_const_cmp8(u64 arg1, u64 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(3) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_const_cmp4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "186-190",
    "snippet": "void notrace __sanitizer_cov_trace_const_cmp4(u32 arg1, u32 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(2) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(2) | KCOV_CMP_CONST",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "115-146",
          "snippet": "static void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "2"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_const_cmp4(u32 arg1, u32 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(2) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_const_cmp2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "179-183",
    "snippet": "void notrace __sanitizer_cov_trace_const_cmp2(u16 arg1, u16 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(1) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(1) | KCOV_CMP_CONST",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "115-146",
          "snippet": "static void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "1"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_const_cmp2(u16 arg1, u16 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(1) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_const_cmp1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "172-176",
    "snippet": "void notrace __sanitizer_cov_trace_const_cmp1(u8 arg1, u8 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(0) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(0) | KCOV_CMP_CONST",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "115-146",
          "snippet": "static void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "0"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_const_cmp1(u8 arg1, u8 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(0) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_cmp8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "166-169",
    "snippet": "void notrace __sanitizer_cov_trace_cmp8(u64 arg1, u64 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(3), arg1, arg2, _RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(3)",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "115-146",
          "snippet": "static void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "3"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_cmp8(u64 arg1, u64 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(3), arg1, arg2, _RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_cmp4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "160-163",
    "snippet": "void notrace __sanitizer_cov_trace_cmp4(u32 arg1, u32 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(2), arg1, arg2, _RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(2)",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "115-146",
          "snippet": "static void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "2"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_cmp4(u32 arg1, u32 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(2), arg1, arg2, _RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_cmp2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "154-157",
    "snippet": "void notrace __sanitizer_cov_trace_cmp2(u16 arg1, u16 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(1), arg1, arg2, _RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(1)",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "115-146",
          "snippet": "static void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "1"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_cmp2(u16 arg1, u16 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(1), arg1, arg2, _RET_IP_);\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_cmp1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "148-151",
    "snippet": "void notrace __sanitizer_cov_trace_cmp1(u8 arg1, u8 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(0), arg1, arg2, _RET_IP_);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_comp_data",
          "args": [
            "KCOV_CMP_SIZE(0)",
            "arg1",
            "arg2",
            "_RET_IP_"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "write_comp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "115-146",
          "snippet": "static void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define KCOV_WORDS_PER_CMP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCOV_CMP_SIZE",
          "args": [
            "0"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_cmp1(u8 arg1, u8 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(0), arg1, arg2, _RET_IP_);\n}"
  },
  {
    "function_name": "write_comp_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "115-146",
    "snippet": "static void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define KCOV_WORDS_PER_CMP 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "area[0]",
            "count + 1"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "end_pos <= max_pos"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "area[0]"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalize_ip",
          "args": [
            "ip"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "canonicalize_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "81-87",
          "snippet": "static unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_kcov_mode",
          "args": [
            "KCOV_MODE_TRACE_CMP",
            "t"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "check_kcov_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "59-79",
          "snippet": "static bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts.\n\t */\n\tif (!in_task())\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_ioctl_locked().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts.\n\t */\n\tif (!in_task())\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_ioctl_locked().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\n#define KCOV_WORDS_PER_CMP 4\n\nstatic void write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t/*\n\t * We write all comparison arguments and types as u64.\n\t * The buffer was allocated for t->kcov_size unsigned longs.\n\t */\n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t/* Every record is KCOV_WORDS_PER_CMP 64-bit words. */\n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t\tWRITE_ONCE(area[0], count + 1);\n\t}\n}"
  },
  {
    "function_name": "__sanitizer_cov_trace_pc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "93-111",
    "snippet": "void notrace __sanitizer_cov_trace_pc(void)\n{\n\tstruct task_struct *t;\n\tunsigned long *area;\n\tunsigned long ip = canonicalize_ip(_RET_IP_);\n\tunsigned long pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_PC, t))\n\t\treturn;\n\n\tarea = t->kcov_area;\n\t/* The first 64-bit word is the number of subsequent PCs. */\n\tpos = READ_ONCE(area[0]) + 1;\n\tif (likely(pos < t->kcov_size)) {\n\t\tarea[pos] = ip;\n\t\tWRITE_ONCE(area[0], pos);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "area[0]",
            "pos"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pos < t->kcov_size"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "area[0]"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_kcov_mode",
          "args": [
            "KCOV_MODE_TRACE_PC",
            "t"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "check_kcov_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "59-79",
          "snippet": "static bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts.\n\t */\n\tif (!in_task())\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_ioctl_locked().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts.\n\t */\n\tif (!in_task())\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_ioctl_locked().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "canonicalize_ip",
          "args": [
            "_RET_IP_"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "canonicalize_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
          "lines": "81-87",
          "snippet": "static unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid notrace __sanitizer_cov_trace_pc(void)\n{\n\tstruct task_struct *t;\n\tunsigned long *area;\n\tunsigned long ip = canonicalize_ip(_RET_IP_);\n\tunsigned long pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_PC, t))\n\t\treturn;\n\n\tarea = t->kcov_area;\n\t/* The first 64-bit word is the number of subsequent PCs. */\n\tpos = READ_ONCE(area[0]) + 1;\n\tif (likely(pos < t->kcov_size)) {\n\t\tarea[pos] = ip;\n\t\tWRITE_ONCE(area[0], pos);\n\t}\n}"
  },
  {
    "function_name": "canonicalize_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "81-87",
    "snippet": "static unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kaslr_offset",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}"
  },
  {
    "function_name": "check_kcov_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcov.c",
    "lines": "59-79",
    "snippet": "static bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts.\n\t */\n\tif (!in_task())\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_ioctl_locked().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/kcov.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/types.h>",
      "#include <linux/export.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->kcov_mode"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nstatic bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t/*\n\t * We are interested in code coverage as a function of a syscall inputs,\n\t * so we ignore code executed in interrupts.\n\t */\n\tif (!in_task())\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t/*\n\t * There is some code that runs in interrupts but for which\n\t * in_interrupt() returns false (e.g. preempt_schedule_irq()).\n\t * READ_ONCE()/barrier() effectively provides load-acquire wrt\n\t * interrupts, there are paired barrier()/WRITE_ONCE() in\n\t * kcov_ioctl_locked().\n\t */\n\tbarrier();\n\treturn mode == needed_mode;\n}"
  }
]