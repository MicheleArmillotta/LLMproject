[
  {
    "function_name": "kdb_restore_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "923-927",
    "snippet": "void kdb_restore_flags(void)\n{\n\tBUG_ON(kdb_flags_index <= 0);\n\tkdb_flags = kdb_flags_stack[--kdb_flags_index];\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_flags_stack[4], kdb_flags_index;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "kdb_flags_index <= 0"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic int kdb_flags_stack[4], kdb_flags_index;\n\nvoid kdb_restore_flags(void)\n{\n\tBUG_ON(kdb_flags_index <= 0);\n\tkdb_flags = kdb_flags_stack[--kdb_flags_index];\n}"
  },
  {
    "function_name": "kdb_save_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "917-921",
    "snippet": "void kdb_save_flags(void)\n{\n\tBUG_ON(kdb_flags_index >= ARRAY_SIZE(kdb_flags_stack));\n\tkdb_flags_stack[kdb_flags_index++] = kdb_flags;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_flags_stack[4], kdb_flags_index;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "kdb_flags_index >= ARRAY_SIZE(kdb_flags_stack)"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "kdb_flags_stack"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic int kdb_flags_stack[4], kdb_flags_index;\n\nvoid kdb_save_flags(void)\n{\n\tBUG_ON(kdb_flags_index >= ARRAY_SIZE(kdb_flags_stack));\n\tkdb_flags_stack[kdb_flags_index++] = kdb_flags;\n}"
  },
  {
    "function_name": "debug_kusage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "862-909",
    "snippet": "void debug_kusage(void)\n{\n\tstruct debug_alloc_header *h_free, *h_used;\n#ifdef\tCONFIG_IA64\n\t/* FIXME: using dah for ia64 unwind always results in a memory leak.\n\t * Fix that memory leak first, then set debug_kusage_one_time = 1 for\n\t * all architectures.\n\t */\n\tstatic int debug_kusage_one_time;\n#else\n\tstatic int debug_kusage_one_time = 1;\n#endif\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\n\t}\n\th_free = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first == 0 &&\n\t    (h_free->size == sizeof(debug_alloc_pool_aligned) - dah_overhead ||\n\t     dah_first_call))\n\t\tgoto out;\n\tif (!debug_kusage_one_time)\n\t\tgoto out;\n\tdebug_kusage_one_time = 0;\n\tkdb_printf(\"%s: debug_kmalloc memory leak dah_first %d\\n\",\n\t\t   __func__, dah_first);\n\tif (dah_first) {\n\t\th_used = (struct debug_alloc_header *)debug_alloc_pool;\n\t\tkdb_printf(\"%s: h_used %p size %d\\n\", __func__, h_used,\n\t\t\t   h_used->size);\n\t}\n\tdo {\n\t\th_used = (struct debug_alloc_header *)\n\t\t\t  ((char *)h_free + dah_overhead + h_free->size);\n\t\tkdb_printf(\"%s: h_used %p size %d caller %p\\n\",\n\t\t\t   __func__, h_used, h_used->size, h_used->caller);\n\t\th_free = (struct debug_alloc_header *)\n\t\t\t  (debug_alloc_pool + h_free->next);\n\t} while (h_free->next);\n\th_used = (struct debug_alloc_header *)\n\t\t  ((char *)h_free + dah_overhead + h_free->size);\n\tif ((char *)h_used - debug_alloc_pool !=\n\t    sizeof(debug_alloc_pool_aligned))\n\t\tkdb_printf(\"%s: h_used %p size %d caller %p\\n\",\n\t\t\t   __func__, h_used, h_used->size, h_used->caller);\nout:\n\tspin_unlock(&dap_lock);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [
      "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)"
    ],
    "globals_used": [
      "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
      "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
      "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
      "static DEFINE_SPINLOCK(dap_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dap_lock"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%s: h_used %p size %d caller %p\\n\"",
            "__func__",
            "h_used",
            "h_used->size",
            "h_used->caller"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release",
          "args": [
            "dap_lock"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "241-262",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dap_lock",
          "args": [],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "get_dap_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "722-743",
          "snippet": "static int get_dap_lock(void)\n\t__acquires(dap_lock)\n{\n\tstatic int dap_locked = -1;\n\tint count;\n\tif (dap_locked == smp_processor_id())\n\t\tcount = 1;\n\telse\n\t\tcount = 1000;\n\twhile (1) {\n\t\tif (spin_trylock(&dap_lock)) {\n\t\t\tdap_locked = -1;\n\t\t\treturn 1;\n\t\t}\n\t\tif (!count--)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\tdap_locked = smp_processor_id();\n\t__acquire(dap_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic DEFINE_SPINLOCK(dap_lock);\n\nstatic int get_dap_lock(void)\n\t__acquires(dap_lock)\n{\n\tstatic int dap_locked = -1;\n\tint count;\n\tif (dap_locked == smp_processor_id())\n\t\tcount = 1;\n\telse\n\t\tcount = 1000;\n\twhile (1) {\n\t\tif (spin_trylock(&dap_lock)) {\n\t\t\tdap_locked = -1;\n\t\t\treturn 1;\n\t\t}\n\t\tif (!count--)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\tdap_locked = smp_processor_id();\n\t__acquire(dap_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid debug_kusage(void)\n{\n\tstruct debug_alloc_header *h_free, *h_used;\n#ifdef\tCONFIG_IA64\n\t/* FIXME: using dah for ia64 unwind always results in a memory leak.\n\t * Fix that memory leak first, then set debug_kusage_one_time = 1 for\n\t * all architectures.\n\t */\n\tstatic int debug_kusage_one_time;\n#else\n\tstatic int debug_kusage_one_time = 1;\n#endif\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\n\t}\n\th_free = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first == 0 &&\n\t    (h_free->size == sizeof(debug_alloc_pool_aligned) - dah_overhead ||\n\t     dah_first_call))\n\t\tgoto out;\n\tif (!debug_kusage_one_time)\n\t\tgoto out;\n\tdebug_kusage_one_time = 0;\n\tkdb_printf(\"%s: debug_kmalloc memory leak dah_first %d\\n\",\n\t\t   __func__, dah_first);\n\tif (dah_first) {\n\t\th_used = (struct debug_alloc_header *)debug_alloc_pool;\n\t\tkdb_printf(\"%s: h_used %p size %d\\n\", __func__, h_used,\n\t\t\t   h_used->size);\n\t}\n\tdo {\n\t\th_used = (struct debug_alloc_header *)\n\t\t\t  ((char *)h_free + dah_overhead + h_free->size);\n\t\tkdb_printf(\"%s: h_used %p size %d caller %p\\n\",\n\t\t\t   __func__, h_used, h_used->size, h_used->caller);\n\t\th_free = (struct debug_alloc_header *)\n\t\t\t  (debug_alloc_pool + h_free->next);\n\t} while (h_free->next);\n\th_used = (struct debug_alloc_header *)\n\t\t  ((char *)h_free + dah_overhead + h_free->size);\n\tif ((char *)h_used - debug_alloc_pool !=\n\t    sizeof(debug_alloc_pool_aligned))\n\t\tkdb_printf(\"%s: h_used %p size %d caller %p\\n\",\n\t\t\t   __func__, h_used, h_used->size, h_used->caller);\nout:\n\tspin_unlock(&dap_lock);\n}"
  },
  {
    "function_name": "debug_kfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "803-860",
    "snippet": "void debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [
      "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)"
    ],
    "globals_used": [
      "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
      "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
      "static DEFINE_SPINLOCK(dap_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dap_lock"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "next",
            "POISON_FREE",
            "dah_overhead - 1"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "h",
            "POISON_FREE",
            "dah_overhead - 1"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "POISON_FREE",
            "h->size - 1"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__release",
          "args": [
            "dap_lock"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "241-262",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dap_lock",
          "args": [],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "get_dap_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "722-743",
          "snippet": "static int get_dap_lock(void)\n\t__acquires(dap_lock)\n{\n\tstatic int dap_locked = -1;\n\tint count;\n\tif (dap_locked == smp_processor_id())\n\t\tcount = 1;\n\telse\n\t\tcount = 1000;\n\twhile (1) {\n\t\tif (spin_trylock(&dap_lock)) {\n\t\t\tdap_locked = -1;\n\t\t\treturn 1;\n\t\t}\n\t\tif (!count--)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\tdap_locked = smp_processor_id();\n\t__acquire(dap_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic DEFINE_SPINLOCK(dap_lock);\n\nstatic int get_dap_lock(void)\n\t__acquires(dap_lock)\n{\n\tstatic int dap_locked = -1;\n\tint count;\n\tif (dap_locked == smp_processor_id())\n\t\tcount = 1;\n\telse\n\t\tcount = 1000;\n\twhile (1) {\n\t\tif (spin_trylock(&dap_lock)) {\n\t\t\tdap_locked = -1;\n\t\t\treturn 1;\n\t\t}\n\t\tif (!count--)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\tdap_locked = smp_processor_id();\n\t__acquire(dap_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "803-860",
          "snippet": "void debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}"
  },
  {
    "function_name": "debug_kmalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "745-801",
    "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [
      "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
      "#define dah_align 8"
    ],
    "globals_used": [
      "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
      "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
      "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
      "static DEFINE_SPINLOCK(dap_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dap_lock"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "POISON_INUSE",
            "best->size - 1"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "dah_used",
            "dah_used_max"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "dah_align"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__release",
          "args": [
            "dap_lock"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "241-262",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dap_lock",
          "args": [],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "get_dap_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "722-743",
          "snippet": "static int get_dap_lock(void)\n\t__acquires(dap_lock)\n{\n\tstatic int dap_locked = -1;\n\tint count;\n\tif (dap_locked == smp_processor_id())\n\t\tcount = 1;\n\telse\n\t\tcount = 1000;\n\twhile (1) {\n\t\tif (spin_trylock(&dap_lock)) {\n\t\t\tdap_locked = -1;\n\t\t\treturn 1;\n\t\t}\n\t\tif (!count--)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\tdap_locked = smp_processor_id();\n\t__acquire(dap_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic DEFINE_SPINLOCK(dap_lock);\n\nstatic int get_dap_lock(void)\n\t__acquires(dap_lock)\n{\n\tstatic int dap_locked = -1;\n\tint count;\n\tif (dap_locked == smp_processor_id())\n\t\tcount = 1;\n\telse\n\t\tcount = 1000;\n\twhile (1) {\n\t\tif (spin_trylock(&dap_lock)) {\n\t\t\tdap_locked = -1;\n\t\t\treturn 1;\n\t\t}\n\t\tif (!count--)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\tdap_locked = smp_processor_id();\n\t__acquire(dap_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
  },
  {
    "function_name": "get_dap_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "722-743",
    "snippet": "static int get_dap_lock(void)\n\t__acquires(dap_lock)\n{\n\tstatic int dap_locked = -1;\n\tint count;\n\tif (dap_locked == smp_processor_id())\n\t\tcount = 1;\n\telse\n\t\tcount = 1000;\n\twhile (1) {\n\t\tif (spin_trylock(&dap_lock)) {\n\t\t\tdap_locked = -1;\n\t\t\treturn 1;\n\t\t}\n\t\tif (!count--)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\tdap_locked = smp_processor_id();\n\t__acquire(dap_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(dap_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__acquire",
          "args": [
            "dap_lock"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1000"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&dap_lock"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "134-137",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "dap_lock"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic DEFINE_SPINLOCK(dap_lock);\n\nstatic int get_dap_lock(void)\n\t__acquires(dap_lock)\n{\n\tstatic int dap_locked = -1;\n\tint count;\n\tif (dap_locked == smp_processor_id())\n\t\tcount = 1;\n\telse\n\t\tcount = 1000;\n\twhile (1) {\n\t\tif (spin_trylock(&dap_lock)) {\n\t\t\tdap_locked = -1;\n\t\t\treturn 1;\n\t\t}\n\t\tif (!count--)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\tdap_locked = smp_processor_id();\n\t__acquire(dap_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_print_nameval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "674-683",
    "snippet": "void kdb_print_nameval(const char *name, unsigned long val)\n{\n\tkdb_symtab_t symtab;\n\tkdb_printf(\"  %-11.11s \", name);\n\tif (kdbnearsym(val, &symtab))\n\t\tkdb_symbol_print(val, &symtab,\n\t\t\t\t KDB_SP_VALUE|KDB_SP_SYMSIZE|KDB_SP_NEWLINE);\n\telse\n\t\tkdb_printf(\"0x%lx\\n\", val);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"0x%lx\\n\"",
            "val"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_symbol_print",
          "args": [
            "val",
            "&symtab",
            "KDB_SP_VALUE|KDB_SP_SYMSIZE|KDB_SP_NEWLINE"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_symbol_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "258-294",
          "snippet": "void kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nvoid kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbnearsym",
          "args": [
            "val",
            "&symtab"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "kdbnearsym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "82-159",
          "snippet": "int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\tchar *knt1 = NULL;\n\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx, symtab=%p\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), knt1);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (ret) {\n\t\tint i;\n\t\t/* Another 2.6 kallsyms \"feature\".  Sometimes the sym_name is\n\t\t * set but the buffer passed into kallsyms_lookup is not used,\n\t\t * so it contains garbage.  The caller has to work out which\n\t\t * buffer needs to be saved.\n\t\t *\n\t\t * What was Rusty smoking when he wrote that code?\n\t\t */\n\t\tif (symtab->sym_name != knt1) {\n\t\t\tstrncpy(knt1, symtab->sym_name, knt1_size);\n\t\t\tknt1[knt1_size-1] = '\\0';\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(kdb_name_table)) {\n\t\t\tdebug_kfree(kdb_name_table[0]);\n\t\t\tmemmove(kdb_name_table, kdb_name_table+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1));\n\t\t} else {\n\t\t\tdebug_kfree(knt1);\n\t\t\tknt1 = kdb_name_table[i];\n\t\t\tmemmove(kdb_name_table+i, kdb_name_table+i+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1));\n\t\t}\n\t\ti = ARRAY_SIZE(kdb_name_table) - 1;\n\t\tkdb_name_table[i] = knt1;\n\t\tsymtab->sym_name = kdb_name_table[i];\n\t\tknt1 = NULL;\n\t}\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\", ret,\n\t\t   symtab->sym_start, symtab->mod_name, symtab->sym_name,\n\t\t   symtab->sym_name);\n\nout:\n\tdebug_kfree(knt1);\n\treturn ret;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define knt1_size 128\t\t/* must be >= kallsyms table size */"
          ],
          "globals_used": [
            "static char *kdb_name_table[100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\nstatic char *kdb_name_table[100];\n\nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\tchar *knt1 = NULL;\n\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx, symtab=%p\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), knt1);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (ret) {\n\t\tint i;\n\t\t/* Another 2.6 kallsyms \"feature\".  Sometimes the sym_name is\n\t\t * set but the buffer passed into kallsyms_lookup is not used,\n\t\t * so it contains garbage.  The caller has to work out which\n\t\t * buffer needs to be saved.\n\t\t *\n\t\t * What was Rusty smoking when he wrote that code?\n\t\t */\n\t\tif (symtab->sym_name != knt1) {\n\t\t\tstrncpy(knt1, symtab->sym_name, knt1_size);\n\t\t\tknt1[knt1_size-1] = '\\0';\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(kdb_name_table)) {\n\t\t\tdebug_kfree(kdb_name_table[0]);\n\t\t\tmemmove(kdb_name_table, kdb_name_table+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1));\n\t\t} else {\n\t\t\tdebug_kfree(knt1);\n\t\t\tknt1 = kdb_name_table[i];\n\t\t\tmemmove(kdb_name_table+i, kdb_name_table+i+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1));\n\t\t}\n\t\ti = ARRAY_SIZE(kdb_name_table) - 1;\n\t\tkdb_name_table[i] = knt1;\n\t\tsymtab->sym_name = kdb_name_table[i];\n\t\tknt1 = NULL;\n\t}\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\", ret,\n\t\t   symtab->sym_start, symtab->mod_name, symtab->sym_name,\n\t\t   symtab->sym_name);\n\nout:\n\tdebug_kfree(knt1);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nvoid kdb_print_nameval(const char *name, unsigned long val)\n{\n\tkdb_symtab_t symtab;\n\tkdb_printf(\"  %-11.11s \", name);\n\tif (kdbnearsym(val, &symtab))\n\t\tkdb_symbol_print(val, &symtab,\n\t\t\t\t KDB_SP_VALUE|KDB_SP_SYMSIZE|KDB_SP_NEWLINE);\n\telse\n\t\tkdb_printf(\"0x%lx\\n\", val);\n}"
  },
  {
    "function_name": "kdb_task_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "661-665",
    "snippet": "unsigned long kdb_task_state(const struct task_struct *p, unsigned long mask)\n{\n\tchar state[] = { kdb_task_state_char(p), '\\0' };\n\treturn (mask & kdb_task_state_string(state)) != 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_task_state_string",
          "args": [
            "state"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "561-612",
          "snippet": "unsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"PS\");\n\t\tif (!s)\n\t\t\ts = \"DRSTCZEU\";\t/* default value for ps */\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'D':\n\t\t\tres |= TASK_UNINTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tres |= RUNNING;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tres |= TASK_INTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres |= TASK_STOPPED;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres |= TASK_TRACED;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tres |= EXIT_ZOMBIE << 16;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tres |= EXIT_DEAD << 16;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tres |= UNRUNNABLE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tres |= IDLE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tres |= DAEMON;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tres = ~0UL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define DAEMON\t\t(1UL << (8*sizeof(unsigned long) - 4))",
            "#define IDLE\t\t(1UL << (8*sizeof(unsigned long) - 3))",
            "#define RUNNING\t\t(1UL << (8*sizeof(unsigned long) - 2))",
            "#define UNRUNNABLE\t(1UL << (8*sizeof(unsigned long) - 1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define DAEMON\t\t(1UL << (8*sizeof(unsigned long) - 4))\n#define IDLE\t\t(1UL << (8*sizeof(unsigned long) - 3))\n#define RUNNING\t\t(1UL << (8*sizeof(unsigned long) - 2))\n#define UNRUNNABLE\t(1UL << (8*sizeof(unsigned long) - 1))\n\nunsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"PS\");\n\t\tif (!s)\n\t\t\ts = \"DRSTCZEU\";\t/* default value for ps */\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'D':\n\t\t\tres |= TASK_UNINTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tres |= RUNNING;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tres |= TASK_INTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres |= TASK_STOPPED;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres |= TASK_TRACED;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tres |= EXIT_ZOMBIE << 16;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tres |= EXIT_DEAD << 16;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tres |= UNRUNNABLE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tres |= IDLE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tres |= DAEMON;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tres = ~0UL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_task_state_char",
          "args": [
            "p"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "621-650",
          "snippet": "char kdb_task_state_char (const struct task_struct *p)\n{\n\tint cpu;\n\tchar state;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tcpu = kdb_process_cpu(p);\n\tstate = (p->state == 0) ? 'R' :\n\t\t(p->state < 0) ? 'U' :\n\t\t(p->state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p->state & TASK_STOPPED) ? 'T' :\n\t\t(p->state & TASK_TRACED) ? 'C' :\n\t\t(p->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(p->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p->state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && state == 'S') {\n\t\tstate = 'M';\t/* sleeping system daemon */\n\t}\n\treturn state;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tint cpu;\n\tchar state;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tcpu = kdb_process_cpu(p);\n\tstate = (p->state == 0) ? 'R' :\n\t\t(p->state < 0) ? 'U' :\n\t\t(p->state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p->state & TASK_STOPPED) ? 'T' :\n\t\t(p->state & TASK_TRACED) ? 'C' :\n\t\t(p->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(p->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p->state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && state == 'S') {\n\t\tstate = 'M';\t/* sleeping system daemon */\n\t}\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nunsigned long kdb_task_state(const struct task_struct *p, unsigned long mask)\n{\n\tchar state[] = { kdb_task_state_char(p), '\\0' };\n\treturn (mask & kdb_task_state_string(state)) != 0;\n}"
  },
  {
    "function_name": "kdb_task_state_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "621-650",
    "snippet": "char kdb_task_state_char (const struct task_struct *p)\n{\n\tint cpu;\n\tchar state;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tcpu = kdb_process_cpu(p);\n\tstate = (p->state == 0) ? 'R' :\n\t\t(p->state < 0) ? 'U' :\n\t\t(p->state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p->state & TASK_STOPPED) ? 'T' :\n\t\t(p->state & TASK_TRACED) ? 'C' :\n\t\t(p->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(p->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p->state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && state == 'S') {\n\t\tstate = 'M';\t/* sleeping system daemon */\n\t}\n\treturn state;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_task_has_cpu",
          "args": [
            "p"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "p"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_process_cpu",
          "args": [
            "p"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&tmp",
            "(char *)p",
            "sizeof(unsigned long)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tint cpu;\n\tchar state;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tcpu = kdb_process_cpu(p);\n\tstate = (p->state == 0) ? 'R' :\n\t\t(p->state < 0) ? 'U' :\n\t\t(p->state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p->state & TASK_STOPPED) ? 'T' :\n\t\t(p->state & TASK_TRACED) ? 'C' :\n\t\t(p->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(p->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p->state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && state == 'S') {\n\t\tstate = 'M';\t/* sleeping system daemon */\n\t}\n\treturn state;\n}"
  },
  {
    "function_name": "kdb_task_state_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "561-612",
    "snippet": "unsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"PS\");\n\t\tif (!s)\n\t\t\ts = \"DRSTCZEU\";\t/* default value for ps */\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'D':\n\t\t\tres |= TASK_UNINTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tres |= RUNNING;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tres |= TASK_INTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres |= TASK_STOPPED;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres |= TASK_TRACED;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tres |= EXIT_ZOMBIE << 16;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tres |= EXIT_DEAD << 16;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tres |= UNRUNNABLE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tres |= IDLE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tres |= DAEMON;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tres = ~0UL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [
      "#define DAEMON\t\t(1UL << (8*sizeof(unsigned long) - 4))",
      "#define IDLE\t\t(1UL << (8*sizeof(unsigned long) - 3))",
      "#define RUNNING\t\t(1UL << (8*sizeof(unsigned long) - 2))",
      "#define UNRUNNABLE\t(1UL << (8*sizeof(unsigned long) - 1))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%s: unknown flag '%c' ignored\\n\"",
            "__func__",
            "*s"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetenv",
          "args": [
            "\"PS\""
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "229-249",
          "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define DAEMON\t\t(1UL << (8*sizeof(unsigned long) - 4))\n#define IDLE\t\t(1UL << (8*sizeof(unsigned long) - 3))\n#define RUNNING\t\t(1UL << (8*sizeof(unsigned long) - 2))\n#define UNRUNNABLE\t(1UL << (8*sizeof(unsigned long) - 1))\n\nunsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"PS\");\n\t\tif (!s)\n\t\t\ts = \"DRSTCZEU\";\t/* default value for ps */\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'D':\n\t\t\tres |= TASK_UNINTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tres |= RUNNING;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tres |= TASK_INTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres |= TASK_STOPPED;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres |= TASK_TRACED;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tres |= EXIT_ZOMBIE << 16;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tres |= EXIT_DEAD << 16;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tres |= UNRUNNABLE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tres |= IDLE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tres |= DAEMON;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tres = ~0UL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "kdb_putword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "502-534",
    "snippet": "int kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_putword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"kdb_putword: bad width %ld\\n\"",
            "(long) size"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_putarea",
          "args": [
            "addr",
            "w8"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_putarea",
          "args": [
            "addr",
            "w4"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_putarea",
          "args": [
            "addr",
            "w2"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_putarea",
          "args": [
            "addr",
            "w1"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_putword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}"
  },
  {
    "function_name": "kdb_getword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "453-490",
    "snippet": "int kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"kdb_getword: bad width %ld\\n\"",
            "(long) size"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "w8",
            "addr"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "w4",
            "addr"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "w2",
            "addr"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "w1",
            "addr"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}"
  },
  {
    "function_name": "kdb_getphysword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "403-441",
    "snippet": "int kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getphysword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"kdb_getphysword: bad width %ld\\n\"",
            "(long) size"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getphys",
          "args": [
            "&w8",
            "addr",
            "sizeof(w8)"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getphysword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "403-441",
          "snippet": "int kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getphysword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getphysword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}"
  },
  {
    "function_name": "kdb_getphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "377-392",
    "snippet": "static int kdb_getphys(void *res, unsigned long addr, size_t size)\n{\n\tunsigned long pfn;\n\tvoid *vaddr;\n\tstruct page *page;\n\n\tpfn = (addr >> PAGE_SHIFT);\n\tif (!pfn_valid(pfn))\n\t\treturn 1;\n\tpage = pfn_to_page(pfn);\n\tvaddr = kmap_atomic(page);\n\tmemcpy(res, vaddr + (addr & (PAGE_SIZE - 1)), size);\n\tkunmap_atomic(vaddr);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "vaddr"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res",
            "vaddr + (addr & (PAGE_SIZE - 1))",
            "size"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic int kdb_getphys(void *res, unsigned long addr, size_t size)\n{\n\tunsigned long pfn;\n\tvoid *vaddr;\n\tstruct page *page;\n\n\tpfn = (addr >> PAGE_SHIFT);\n\tif (!pfn_valid(pfn))\n\t\treturn 1;\n\tpage = pfn_to_page(pfn);\n\tvaddr = kmap_atomic(page);\n\tmemcpy(res, vaddr + (addr & (PAGE_SIZE - 1)), size);\n\tkunmap_atomic(vaddr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_putarea_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "351-364",
    "snippet": "int kdb_putarea_size(unsigned long addr, void *res, size_t size)\n{\n\tint ret = probe_kernel_read((char *)addr, (char *)res, size);\n\tif (ret) {\n\t\tif (!KDB_STATE(SUPPRESS)) {\n\t\t\tkdb_printf(\"kdb_putarea: Bad address 0x%lx\\n\", addr);\n\t\t\tKDB_STATE_SET(SUPPRESS);\n\t\t}\n\t\tret = KDB_BADADDR;\n\t} else {\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SUPPRESS"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "SUPPRESS"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"kdb_putarea: Bad address 0x%lx\\n\"",
            "addr"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "SUPPRESS"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "(char *)addr",
            "(char *)res",
            "size"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_putarea_size(unsigned long addr, void *res, size_t size)\n{\n\tint ret = probe_kernel_read((char *)addr, (char *)res, size);\n\tif (ret) {\n\t\tif (!KDB_STATE(SUPPRESS)) {\n\t\t\tkdb_printf(\"kdb_putarea: Bad address 0x%lx\\n\", addr);\n\t\t\tKDB_STATE_SET(SUPPRESS);\n\t\t}\n\t\tret = KDB_BADADDR;\n\t} else {\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "kdb_getarea_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "326-339",
    "snippet": "int kdb_getarea_size(void *res, unsigned long addr, size_t size)\n{\n\tint ret = probe_kernel_read((char *)res, (char *)addr, size);\n\tif (ret) {\n\t\tif (!KDB_STATE(SUPPRESS)) {\n\t\t\tkdb_printf(\"kdb_getarea: Bad address 0x%lx\\n\", addr);\n\t\t\tKDB_STATE_SET(SUPPRESS);\n\t\t}\n\t\tret = KDB_BADADDR;\n\t} else {\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SUPPRESS"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "SUPPRESS"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"kdb_getarea: Bad address 0x%lx\\n\"",
            "addr"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "SUPPRESS"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "(char *)res",
            "(char *)addr",
            "size"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_getarea_size(void *res, unsigned long addr, size_t size)\n{\n\tint ret = probe_kernel_read((char *)res, (char *)addr, size);\n\tif (ret) {\n\t\tif (!KDB_STATE(SUPPRESS)) {\n\t\t\tkdb_printf(\"kdb_getarea: Bad address 0x%lx\\n\", addr);\n\t\t\tKDB_STATE_SET(SUPPRESS);\n\t\t}\n\t\tret = KDB_BADADDR;\n\t} else {\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "kdb_strdup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "307-314",
    "snippet": "char *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "s",
            "str"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "n",
            "type"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nchar *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}"
  },
  {
    "function_name": "kdb_symbol_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "258-294",
    "snippet": "void kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "symtab_p2->mod_name",
            "\"kernel\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbnearsym",
          "args": [
            "addr",
            "symtab_p2"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "kdbnearsym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "82-159",
          "snippet": "int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\tchar *knt1 = NULL;\n\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx, symtab=%p\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), knt1);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (ret) {\n\t\tint i;\n\t\t/* Another 2.6 kallsyms \"feature\".  Sometimes the sym_name is\n\t\t * set but the buffer passed into kallsyms_lookup is not used,\n\t\t * so it contains garbage.  The caller has to work out which\n\t\t * buffer needs to be saved.\n\t\t *\n\t\t * What was Rusty smoking when he wrote that code?\n\t\t */\n\t\tif (symtab->sym_name != knt1) {\n\t\t\tstrncpy(knt1, symtab->sym_name, knt1_size);\n\t\t\tknt1[knt1_size-1] = '\\0';\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(kdb_name_table)) {\n\t\t\tdebug_kfree(kdb_name_table[0]);\n\t\t\tmemmove(kdb_name_table, kdb_name_table+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1));\n\t\t} else {\n\t\t\tdebug_kfree(knt1);\n\t\t\tknt1 = kdb_name_table[i];\n\t\t\tmemmove(kdb_name_table+i, kdb_name_table+i+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1));\n\t\t}\n\t\ti = ARRAY_SIZE(kdb_name_table) - 1;\n\t\tkdb_name_table[i] = knt1;\n\t\tsymtab->sym_name = kdb_name_table[i];\n\t\tknt1 = NULL;\n\t}\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\", ret,\n\t\t   symtab->sym_start, symtab->mod_name, symtab->sym_name,\n\t\t   symtab->sym_name);\n\nout:\n\tdebug_kfree(knt1);\n\treturn ret;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define knt1_size 128\t\t/* must be >= kallsyms table size */"
          ],
          "globals_used": [
            "static char *kdb_name_table[100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\nstatic char *kdb_name_table[100];\n\nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\tchar *knt1 = NULL;\n\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx, symtab=%p\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), knt1);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (ret) {\n\t\tint i;\n\t\t/* Another 2.6 kallsyms \"feature\".  Sometimes the sym_name is\n\t\t * set but the buffer passed into kallsyms_lookup is not used,\n\t\t * so it contains garbage.  The caller has to work out which\n\t\t * buffer needs to be saved.\n\t\t *\n\t\t * What was Rusty smoking when he wrote that code?\n\t\t */\n\t\tif (symtab->sym_name != knt1) {\n\t\t\tstrncpy(knt1, symtab->sym_name, knt1_size);\n\t\t\tknt1[knt1_size-1] = '\\0';\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(kdb_name_table)) {\n\t\t\tdebug_kfree(kdb_name_table[0]);\n\t\t\tmemmove(kdb_name_table, kdb_name_table+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1));\n\t\t} else {\n\t\t\tdebug_kfree(knt1);\n\t\t\tknt1 = kdb_name_table[i];\n\t\t\tmemmove(kdb_name_table+i, kdb_name_table+i+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1));\n\t\t}\n\t\ti = ARRAY_SIZE(kdb_name_table) - 1;\n\t\tkdb_name_table[i] = knt1;\n\t\tsymtab->sym_name = kdb_name_table[i];\n\t\tknt1 = NULL;\n\t}\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\", ret,\n\t\t   symtab->sym_start, symtab->mod_name, symtab->sym_name,\n\t\t   symtab->sym_name);\n\nout:\n\tdebug_kfree(knt1);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nvoid kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}"
  },
  {
    "function_name": "kallsyms_symbol_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "228-244",
    "snippet": "int kallsyms_symbol_next(char *prefix_name, int flag)\n{\n\tint prefix_len = strlen(prefix_name);\n\tstatic loff_t pos;\n\tconst char *name;\n\n\tif (!flag)\n\t\tpos = 0;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrncpy(prefix_name, name, strlen(name)+1);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "prefix_name",
            "name",
            "strlen(name)+1"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "prefix_name",
            "prefix_len"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_walk_kallsyms",
          "args": [
            "&pos"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_walk_kallsyms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "679-695",
          "snippet": "const char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kallsyms_symbol_next(char *prefix_name, int flag)\n{\n\tint prefix_len = strlen(prefix_name);\n\tstatic loff_t pos;\n\tconst char *name;\n\n\tif (!flag)\n\t\tpos = 0;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrncpy(prefix_name, name, strlen(name)+1);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kallsyms_symbol_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "186-216",
    "snippet": "int kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrcpy(ks_namebuf, name);\n\t\t\t/* Work out the longest name that matches the prefix */\n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len > prefix_len)\n\t\tmemcpy(prefix_name, ks_namebuf_prev, prev_len+1);\n\treturn number;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char ks_namebuf[KSYM_NAME_LEN+1], ks_namebuf_prev[KSYM_NAME_LEN+1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "prefix_name",
            "ks_namebuf_prev",
            "prev_len+1"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "max_len-1",
            "strlen(ks_namebuf)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ks_namebuf"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "ks_namebuf",
            "name"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "prefix_name",
            "prefix_len"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_walk_kallsyms",
          "args": [
            "&pos"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_walk_kallsyms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "679-695",
          "snippet": "const char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic char ks_namebuf[KSYM_NAME_LEN+1], ks_namebuf_prev[KSYM_NAME_LEN+1];\n\nint kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrcpy(ks_namebuf, name);\n\t\t\t/* Work out the longest name that matches the prefix */\n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len > prefix_len)\n\t\tmemcpy(prefix_name, ks_namebuf_prev, prev_len+1);\n\treturn number;\n}"
  },
  {
    "function_name": "kdbnearsym_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "161-170",
    "snippet": "void kdbnearsym_cleanup(void)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\tif (kdb_name_table[i]) {\n\t\t\tdebug_kfree(kdb_name_table[i]);\n\t\t\tkdb_name_table[i] = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *kdb_name_table[100];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_kfree",
          "args": [
            "kdb_name_table[i]"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "803-860",
          "snippet": "void debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "kdb_name_table"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic char *kdb_name_table[100];\n\nvoid kdbnearsym_cleanup(void)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\tif (kdb_name_table[i]) {\n\t\t\tdebug_kfree(kdb_name_table[i]);\n\t\t\tkdb_name_table[i] = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kdbnearsym",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "82-159",
    "snippet": "int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\tchar *knt1 = NULL;\n\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx, symtab=%p\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), knt1);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (ret) {\n\t\tint i;\n\t\t/* Another 2.6 kallsyms \"feature\".  Sometimes the sym_name is\n\t\t * set but the buffer passed into kallsyms_lookup is not used,\n\t\t * so it contains garbage.  The caller has to work out which\n\t\t * buffer needs to be saved.\n\t\t *\n\t\t * What was Rusty smoking when he wrote that code?\n\t\t */\n\t\tif (symtab->sym_name != knt1) {\n\t\t\tstrncpy(knt1, symtab->sym_name, knt1_size);\n\t\t\tknt1[knt1_size-1] = '\\0';\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(kdb_name_table)) {\n\t\t\tdebug_kfree(kdb_name_table[0]);\n\t\t\tmemmove(kdb_name_table, kdb_name_table+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1));\n\t\t} else {\n\t\t\tdebug_kfree(knt1);\n\t\t\tknt1 = kdb_name_table[i];\n\t\t\tmemmove(kdb_name_table+i, kdb_name_table+i+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1));\n\t\t}\n\t\ti = ARRAY_SIZE(kdb_name_table) - 1;\n\t\tkdb_name_table[i] = knt1;\n\t\tsymtab->sym_name = kdb_name_table[i];\n\t\tknt1 = NULL;\n\t}\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\", ret,\n\t\t   symtab->sym_start, symtab->mod_name, symtab->sym_name,\n\t\t   symtab->sym_name);\n\nout:\n\tdebug_kfree(knt1);\n\treturn ret;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [
      "#define knt1_size 128\t\t/* must be >= kallsyms table size */"
    ],
    "globals_used": [
      "static char *kdb_name_table[100];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_kfree",
          "args": [
            "knt1"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "803-860",
          "snippet": "void debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\"",
            "ret",
            "symtab->sym_start",
            "symtab->mod_name",
            "symtab->sym_name",
            "symtab->sym_name"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "AR"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "kdb_name_table"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "kdb_name_table+i",
            "kdb_name_table+i+1",
            "sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "kdb_name_table"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "kdb_name_table",
            "kdb_name_table+1",
            "sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "kdb_name_table"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "kdb_name_table"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kdb_name_table[i]",
            "knt1"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "kdb_name_table"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "knt1",
            "symtab->sym_name",
            "knt1_size"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "addr",
            "&symbolsize",
            "&offset",
            "(char **)(&symtab->mod_name)",
            "knt1"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "278-311",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_kmalloc",
          "args": [
            "knt1_size",
            "GFP_ATOMIC"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "symtab",
            "0",
            "sizeof(*symtab)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "AR"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\nstatic char *kdb_name_table[100];\n\nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\tchar *knt1 = NULL;\n\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx, symtab=%p\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), knt1);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (ret) {\n\t\tint i;\n\t\t/* Another 2.6 kallsyms \"feature\".  Sometimes the sym_name is\n\t\t * set but the buffer passed into kallsyms_lookup is not used,\n\t\t * so it contains garbage.  The caller has to work out which\n\t\t * buffer needs to be saved.\n\t\t *\n\t\t * What was Rusty smoking when he wrote that code?\n\t\t */\n\t\tif (symtab->sym_name != knt1) {\n\t\t\tstrncpy(knt1, symtab->sym_name, knt1_size);\n\t\t\tknt1[knt1_size-1] = '\\0';\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(kdb_name_table)) {\n\t\t\tdebug_kfree(kdb_name_table[0]);\n\t\t\tmemmove(kdb_name_table, kdb_name_table+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1));\n\t\t} else {\n\t\t\tdebug_kfree(knt1);\n\t\t\tknt1 = kdb_name_table[i];\n\t\t\tmemmove(kdb_name_table+i, kdb_name_table+i+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1));\n\t\t}\n\t\ti = ARRAY_SIZE(kdb_name_table) - 1;\n\t\tkdb_name_table[i] = knt1;\n\t\tsymtab->sym_name = kdb_name_table[i];\n\t\tknt1 = NULL;\n\t}\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\", ret,\n\t\t   symtab->sym_start, symtab->mod_name, symtab->sym_name,\n\t\t   symtab->sym_name);\n\nout:\n\tdebug_kfree(knt1);\n\treturn ret;\n}"
  },
  {
    "function_name": "kdbgetsymval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "40-57",
    "snippet": "int kdbgetsymval(const char *symname, kdb_symtab_t *symtab)\n{\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbgetsymval: symname=%s, symtab=%p\\n\", symname,\n\t\t\t   symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\tsymtab->sym_start = kallsyms_lookup_name(symname);\n\tif (symtab->sym_start) {\n\t\tif (KDB_DEBUG(AR))\n\t\t\tkdb_printf(\"kdbgetsymval: returns 1, \"\n\t\t\t\t   \"symtab->sym_start=0x%lx\\n\",\n\t\t\t\t   symtab->sym_start);\n\t\treturn 1;\n\t}\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbgetsymval: returns 0\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"kdbgetsymval: returns 0\\n\""
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "AR"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "AR"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "symname"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4090-4111",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "symtab",
            "0",
            "sizeof(*symtab)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "AR"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdbgetsymval(const char *symname, kdb_symtab_t *symtab)\n{\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbgetsymval: symname=%s, symtab=%p\\n\", symname,\n\t\t\t   symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\tsymtab->sym_start = kallsyms_lookup_name(symname);\n\tif (symtab->sym_start) {\n\t\tif (KDB_DEBUG(AR))\n\t\t\tkdb_printf(\"kdbgetsymval: returns 1, \"\n\t\t\t\t   \"symtab->sym_start=0x%lx\\n\",\n\t\t\t\t   symtab->sym_start);\n\t\treturn 1;\n\t}\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbgetsymval: returns 0\\n\");\n\treturn 0;\n}"
  }
]