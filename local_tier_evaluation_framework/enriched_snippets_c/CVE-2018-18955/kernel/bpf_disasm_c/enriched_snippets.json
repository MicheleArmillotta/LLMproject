[
  {
    "function_name": "print_bpf_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/disasm.c",
    "lines": "125-261",
    "snippet": "void print_bpf_insn(const struct bpf_insn_cbs *cbs,\n\t\t    const struct bpf_insn *insn,\n\t\t    bool allow_ptr_leaks)\n{\n\tconst bpf_insn_print_t verbose = cbs->cb_print;\n\tu8 class = BPF_CLASS(insn->code);\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_OP(insn->code) == BPF_END) {\n\t\t\tif (class == BPF_ALU64)\n\t\t\t\tverbose(cbs->private_data, \"BUG_alu64_%02x\\n\", insn->code);\n\t\t\telse\n\t\t\t\tprint_bpf_end_insn(verbose, cbs->private_data, insn);\n\t\t} else if (BPF_OP(insn->code) == BPF_NEG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = %s-r%d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(cbs->private_data, \"(%02x) %sr%d %s %sr%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->src_reg);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"(%02x) %sr%d %s %s%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->imm);\n\t\t}\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_XADD)\n\t\t\tverbose(cbs->private_data, \"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(cbs->private_data, \"BUG_%02x\\n\", insn->code);\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(cbs->private_data, \"BUG_st_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\tinsn->code,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->dst_reg,\n\t\t\tinsn->off, insn->imm);\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(cbs->private_data, \"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(cbs->private_data, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&\n\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {\n\t\t\t/* At this point, we already made sure that the second\n\t\t\t * part of the ldimm64 insn is accessible.\n\t\t\t */\n\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\t\t\tbool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;\n\t\t\tchar tmp[64];\n\n\t\t\tif (map_ptr && !allow_ptr_leaks)\n\t\t\t\timm = 0;\n\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = %s\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\t__func_imm_name(cbs, insn, imm,\n\t\t\t\t\t\ttmp, sizeof(tmp)));\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_ld_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tchar tmp[64];\n\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL) {\n\t\t\t\tverbose(cbs->private_data, \"(%02x) call pc%s\\n\",\n\t\t\t\t\tinsn->code,\n\t\t\t\t\t__func_get_name(cbs, insn,\n\t\t\t\t\t\t\ttmp, sizeof(tmp)));\n\t\t\t} else {\n\t\t\t\tstrcpy(tmp, \"unknown\");\n\t\t\t\tverbose(cbs->private_data, \"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\t\t__func_get_name(cbs, insn,\n\t\t\t\t\t\t\ttmp, sizeof(tmp)),\n\t\t\t\t\tinsn->imm);\n\t\t\t}\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(cbs->private_data, \"(%02x) if r%d %s r%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"(%02x) if r%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(cbs->private_data, \"(%02x) %s\\n\",\n\t\t\tinsn->code, bpf_class_string[class]);\n\t}\n}",
    "includes": [
      "#include \"disasm.h\"",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char *const bpf_class_string[8] = {\n\t[BPF_LD]    = \"ld\",\n\t[BPF_LDX]   = \"ldx\",\n\t[BPF_ST]    = \"st\",\n\t[BPF_STX]   = \"stx\",\n\t[BPF_ALU]   = \"alu\",\n\t[BPF_JMP]   = \"jmp\",\n\t[BPF_RET]   = \"BUG\",\n\t[BPF_ALU64] = \"alu64\",\n};",
      "const char *const bpf_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"+=\",\n\t[BPF_SUB >> 4]  = \"-=\",\n\t[BPF_MUL >> 4]  = \"*=\",\n\t[BPF_DIV >> 4]  = \"/=\",\n\t[BPF_OR  >> 4]  = \"|=\",\n\t[BPF_AND >> 4]  = \"&=\",\n\t[BPF_LSH >> 4]  = \"<<=\",\n\t[BPF_RSH >> 4]  = \">>=\",\n\t[BPF_NEG >> 4]  = \"neg\",\n\t[BPF_MOD >> 4]  = \"%=\",\n\t[BPF_XOR >> 4]  = \"^=\",\n\t[BPF_MOV >> 4]  = \"=\",\n\t[BPF_ARSH >> 4] = \"s>>=\",\n\t[BPF_END >> 4]  = \"endian\",\n};",
      "static const char *const bpf_ldst_string[] = {\n\t[BPF_W >> 3]  = \"u32\",\n\t[BPF_H >> 3]  = \"u16\",\n\t[BPF_B >> 3]  = \"u8\",\n\t[BPF_DW >> 3] = \"u64\",\n};",
      "static const char *const bpf_jmp_string[16] = {\n\t[BPF_JA >> 4]   = \"jmp\",\n\t[BPF_JEQ >> 4]  = \"==\",\n\t[BPF_JGT >> 4]  = \">\",\n\t[BPF_JLT >> 4]  = \"<\",\n\t[BPF_JGE >> 4]  = \">=\",\n\t[BPF_JLE >> 4]  = \"<=\",\n\t[BPF_JSET >> 4] = \"&\",\n\t[BPF_JNE >> 4]  = \"!=\",\n\t[BPF_JSGT >> 4] = \"s>\",\n\t[BPF_JSLT >> 4] = \"s<\",\n\t[BPF_JSGE >> 4] = \"s>=\",\n\t[BPF_JSLE >> 4] = \"s<=\",\n\t[BPF_CALL >> 4] = \"call\",\n\t[BPF_EXIT >> 4] = \"exit\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "cbs->private_data",
            "\"(%02x) %s\\n\"",
            "insn->code",
            "bpf_class_string[class]"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/verifier.c",
          "lines": "253-264",
          "snippet": "static void verbose(void *private_data, const char *fmt, ...)\n{\n\tstruct bpf_verifier_env *env = private_data;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void verbose(void *private_data, const char *fmt, ...)\n{\n\tstruct bpf_verifier_env *env = private_data;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SRC",
          "args": [
            "insn->code"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__func_get_name",
          "args": [
            "cbs",
            "insn",
            "tmp",
            "sizeof(tmp)"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "__func_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/disasm.c",
          "lines": "24-42",
          "snippet": "static const char *__func_get_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   char *buff, size_t len)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (insn->src_reg != BPF_PSEUDO_CALL &&\n\t    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&\n\t    func_id_str[insn->imm])\n\t\treturn func_id_str[insn->imm];\n\n\tif (cbs && cbs->cb_call)\n\t\treturn cbs->cb_call(cbs->private_data, insn);\n\n\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\tsnprintf(buff, len, \"%+d\", insn->imm);\n\n\treturn buff;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};\n\nstatic const char *__func_get_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   char *buff, size_t len)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (insn->src_reg != BPF_PSEUDO_CALL &&\n\t    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&\n\t    func_id_str[insn->imm])\n\t\treturn func_id_str[insn->imm];\n\n\tif (cbs && cbs->cb_call)\n\t\treturn cbs->cb_call(cbs->private_data, insn);\n\n\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\tsnprintf(buff, len, \"%+d\", insn->imm);\n\n\treturn buff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tmp",
            "\"unknown\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__func_imm_name",
          "args": [
            "cbs",
            "insn",
            "imm",
            "tmp",
            "sizeof(tmp)"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__func_imm_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/disasm.c",
          "lines": "44-53",
          "snippet": "static const char *__func_imm_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   u64 full_imm, char *buff, size_t len)\n{\n\tif (cbs && cbs->cb_imm)\n\t\treturn cbs->cb_imm(cbs->private_data, insn, full_imm);\n\n\tsnprintf(buff, len, \"0x%llx\", (unsigned long long)full_imm);\n\treturn buff;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic const char *__func_imm_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   u64 full_imm, char *buff, size_t len)\n{\n\tif (cbs && cbs->cb_imm)\n\t\treturn cbs->cb_imm(cbs->private_data, insn, full_imm);\n\n\tsnprintf(buff, len, \"0x%llx\", (unsigned long long)full_imm);\n\treturn buff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "insn + 1"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SRC",
          "args": [
            "insn->code"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_bpf_end_insn",
          "args": [
            "verbose",
            "cbs->private_data",
            "insn"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "print_bpf_end_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/disasm.c",
          "lines": "115-123",
          "snippet": "static void print_bpf_end_insn(bpf_insn_print_t verbose,\n\t\t\t       void *private_data,\n\t\t\t       const struct bpf_insn *insn)\n{\n\tverbose(private_data, \"(%02x) r%d = %s%d r%d\\n\",\n\t\tinsn->code, insn->dst_reg,\n\t\tBPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",\n\t\tinsn->imm, insn->dst_reg);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic void print_bpf_end_insn(bpf_insn_print_t verbose,\n\t\t\t       void *private_data,\n\t\t\t       const struct bpf_insn *insn)\n{\n\tverbose(private_data, \"(%02x) r%d = %s%d r%d\\n\",\n\t\tinsn->code, insn->dst_reg,\n\t\tBPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",\n\t\tinsn->imm, insn->dst_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_CLASS",
          "args": [
            "insn->code"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nconst char *const bpf_class_string[8] = {\n\t[BPF_LD]    = \"ld\",\n\t[BPF_LDX]   = \"ldx\",\n\t[BPF_ST]    = \"st\",\n\t[BPF_STX]   = \"stx\",\n\t[BPF_ALU]   = \"alu\",\n\t[BPF_JMP]   = \"jmp\",\n\t[BPF_RET]   = \"BUG\",\n\t[BPF_ALU64] = \"alu64\",\n};\nconst char *const bpf_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"+=\",\n\t[BPF_SUB >> 4]  = \"-=\",\n\t[BPF_MUL >> 4]  = \"*=\",\n\t[BPF_DIV >> 4]  = \"/=\",\n\t[BPF_OR  >> 4]  = \"|=\",\n\t[BPF_AND >> 4]  = \"&=\",\n\t[BPF_LSH >> 4]  = \"<<=\",\n\t[BPF_RSH >> 4]  = \">>=\",\n\t[BPF_NEG >> 4]  = \"neg\",\n\t[BPF_MOD >> 4]  = \"%=\",\n\t[BPF_XOR >> 4]  = \"^=\",\n\t[BPF_MOV >> 4]  = \"=\",\n\t[BPF_ARSH >> 4] = \"s>>=\",\n\t[BPF_END >> 4]  = \"endian\",\n};\nstatic const char *const bpf_ldst_string[] = {\n\t[BPF_W >> 3]  = \"u32\",\n\t[BPF_H >> 3]  = \"u16\",\n\t[BPF_B >> 3]  = \"u8\",\n\t[BPF_DW >> 3] = \"u64\",\n};\nstatic const char *const bpf_jmp_string[16] = {\n\t[BPF_JA >> 4]   = \"jmp\",\n\t[BPF_JEQ >> 4]  = \"==\",\n\t[BPF_JGT >> 4]  = \">\",\n\t[BPF_JLT >> 4]  = \"<\",\n\t[BPF_JGE >> 4]  = \">=\",\n\t[BPF_JLE >> 4]  = \"<=\",\n\t[BPF_JSET >> 4] = \"&\",\n\t[BPF_JNE >> 4]  = \"!=\",\n\t[BPF_JSGT >> 4] = \"s>\",\n\t[BPF_JSLT >> 4] = \"s<\",\n\t[BPF_JSGE >> 4] = \"s>=\",\n\t[BPF_JSLE >> 4] = \"s<=\",\n\t[BPF_CALL >> 4] = \"call\",\n\t[BPF_EXIT >> 4] = \"exit\",\n};\n\nvoid print_bpf_insn(const struct bpf_insn_cbs *cbs,\n\t\t    const struct bpf_insn *insn,\n\t\t    bool allow_ptr_leaks)\n{\n\tconst bpf_insn_print_t verbose = cbs->cb_print;\n\tu8 class = BPF_CLASS(insn->code);\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_OP(insn->code) == BPF_END) {\n\t\t\tif (class == BPF_ALU64)\n\t\t\t\tverbose(cbs->private_data, \"BUG_alu64_%02x\\n\", insn->code);\n\t\t\telse\n\t\t\t\tprint_bpf_end_insn(verbose, cbs->private_data, insn);\n\t\t} else if (BPF_OP(insn->code) == BPF_NEG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = %s-r%d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(cbs->private_data, \"(%02x) %sr%d %s %sr%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->src_reg);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"(%02x) %sr%d %s %s%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->imm);\n\t\t}\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_XADD)\n\t\t\tverbose(cbs->private_data, \"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(cbs->private_data, \"BUG_%02x\\n\", insn->code);\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(cbs->private_data, \"BUG_st_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\tinsn->code,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->dst_reg,\n\t\t\tinsn->off, insn->imm);\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(cbs->private_data, \"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(cbs->private_data, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&\n\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {\n\t\t\t/* At this point, we already made sure that the second\n\t\t\t * part of the ldimm64 insn is accessible.\n\t\t\t */\n\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\t\t\tbool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;\n\t\t\tchar tmp[64];\n\n\t\t\tif (map_ptr && !allow_ptr_leaks)\n\t\t\t\timm = 0;\n\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = %s\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\t__func_imm_name(cbs, insn, imm,\n\t\t\t\t\t\ttmp, sizeof(tmp)));\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_ld_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tchar tmp[64];\n\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL) {\n\t\t\t\tverbose(cbs->private_data, \"(%02x) call pc%s\\n\",\n\t\t\t\t\tinsn->code,\n\t\t\t\t\t__func_get_name(cbs, insn,\n\t\t\t\t\t\t\ttmp, sizeof(tmp)));\n\t\t\t} else {\n\t\t\t\tstrcpy(tmp, \"unknown\");\n\t\t\t\tverbose(cbs->private_data, \"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\t\t__func_get_name(cbs, insn,\n\t\t\t\t\t\t\ttmp, sizeof(tmp)),\n\t\t\t\t\tinsn->imm);\n\t\t\t}\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(cbs->private_data, \"(%02x) if r%d %s r%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"(%02x) if r%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(cbs->private_data, \"(%02x) %s\\n\",\n\t\t\tinsn->code, bpf_class_string[class]);\n\t}\n}"
  },
  {
    "function_name": "print_bpf_end_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/disasm.c",
    "lines": "115-123",
    "snippet": "static void print_bpf_end_insn(bpf_insn_print_t verbose,\n\t\t\t       void *private_data,\n\t\t\t       const struct bpf_insn *insn)\n{\n\tverbose(private_data, \"(%02x) r%d = %s%d r%d\\n\",\n\t\tinsn->code, insn->dst_reg,\n\t\tBPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",\n\t\tinsn->imm, insn->dst_reg);\n}",
    "includes": [
      "#include \"disasm.h\"",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "private_data",
            "\"(%02x) r%d = %s%d r%d\\n\"",
            "insn->code",
            "insn->dst_reg",
            "BPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\"",
            "insn->imm",
            "insn->dst_reg"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/verifier.c",
          "lines": "253-264",
          "snippet": "static void verbose(void *private_data, const char *fmt, ...)\n{\n\tstruct bpf_verifier_env *env = private_data;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void verbose(void *private_data, const char *fmt, ...)\n{\n\tstruct bpf_verifier_env *env = private_data;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_SRC",
          "args": [
            "insn->code"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic void print_bpf_end_insn(bpf_insn_print_t verbose,\n\t\t\t       void *private_data,\n\t\t\t       const struct bpf_insn *insn)\n{\n\tverbose(private_data, \"(%02x) r%d = %s%d r%d\\n\",\n\t\tinsn->code, insn->dst_reg,\n\t\tBPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",\n\t\tinsn->imm, insn->dst_reg);\n}"
  },
  {
    "function_name": "func_id_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/disasm.c",
    "lines": "55-61",
    "snippet": "const char *func_id_name(int id)\n{\n\tif (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])\n\t\treturn func_id_str[id];\n\telse\n\t\treturn \"unknown\";\n}",
    "includes": [
      "#include \"disasm.h\"",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};\n\nconst char *func_id_name(int id)\n{\n\tif (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])\n\t\treturn func_id_str[id];\n\telse\n\t\treturn \"unknown\";\n}"
  },
  {
    "function_name": "__func_imm_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/disasm.c",
    "lines": "44-53",
    "snippet": "static const char *__func_imm_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   u64 full_imm, char *buff, size_t len)\n{\n\tif (cbs && cbs->cb_imm)\n\t\treturn cbs->cb_imm(cbs->private_data, insn, full_imm);\n\n\tsnprintf(buff, len, \"0x%llx\", (unsigned long long)full_imm);\n\treturn buff;\n}",
    "includes": [
      "#include \"disasm.h\"",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buff",
            "len",
            "\"0x%llx\"",
            "(unsigned long long)full_imm"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbs->cb_imm",
          "args": [
            "cbs->private_data",
            "insn",
            "full_imm"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic const char *__func_imm_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   u64 full_imm, char *buff, size_t len)\n{\n\tif (cbs && cbs->cb_imm)\n\t\treturn cbs->cb_imm(cbs->private_data, insn, full_imm);\n\n\tsnprintf(buff, len, \"0x%llx\", (unsigned long long)full_imm);\n\treturn buff;\n}"
  },
  {
    "function_name": "__func_get_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/disasm.c",
    "lines": "24-42",
    "snippet": "static const char *__func_get_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   char *buff, size_t len)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (insn->src_reg != BPF_PSEUDO_CALL &&\n\t    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&\n\t    func_id_str[insn->imm])\n\t\treturn func_id_str[insn->imm];\n\n\tif (cbs && cbs->cb_call)\n\t\treturn cbs->cb_call(cbs->private_data, insn);\n\n\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\tsnprintf(buff, len, \"%+d\", insn->imm);\n\n\treturn buff;\n}",
    "includes": [
      "#include \"disasm.h\"",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buff",
            "len",
            "\"%+d\"",
            "insn->imm"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbs->cb_call",
          "args": [
            "cbs->private_data",
            "insn"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "func_id_str"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};\n\nstatic const char *__func_get_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   char *buff, size_t len)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (insn->src_reg != BPF_PSEUDO_CALL &&\n\t    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&\n\t    func_id_str[insn->imm])\n\t\treturn func_id_str[insn->imm];\n\n\tif (cbs && cbs->cb_call)\n\t\treturn cbs->cb_call(cbs->private_data, insn);\n\n\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\tsnprintf(buff, len, \"%+d\", insn->imm);\n\n\treturn buff;\n}"
  }
]