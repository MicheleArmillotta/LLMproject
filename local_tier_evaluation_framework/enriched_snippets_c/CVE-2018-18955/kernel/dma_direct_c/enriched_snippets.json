[
  {
    "function_name": "dma_direct_mapping_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "315-318",
    "snippet": "int dma_direct_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\treturn dma_addr == DIRECT_MAPPING_ERROR;\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_direct_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\treturn dma_addr == DIRECT_MAPPING_ERROR;\n}"
  },
  {
    "function_name": "dma_direct_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "301-313",
    "snippet": "int dma_direct_supported(struct device *dev, u64 mask)\n{\n\tu64 min_mask;\n\n\tif (IS_ENABLED(CONFIG_ZONE_DMA))\n\t\tmin_mask = DMA_BIT_MASK(ARCH_ZONE_DMA_BITS);\n\telse\n\t\tmin_mask = DMA_BIT_MASK(32);\n\n\tmin_mask = min_t(u64, min_mask, (max_pfn - 1) << PAGE_SHIFT);\n\n\treturn mask >= phys_to_dma(dev, min_mask);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [
      "#define ARCH_ZONE_DMA_BITS 24"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phys_to_dma",
          "args": [
            "dev",
            "min_mask"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "56-62",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "min_mask",
            "(max_pfn - 1) << PAGE_SHIFT"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "32"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "ARCH_ZONE_DMA_BITS"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\n#define ARCH_ZONE_DMA_BITS 24\n\nint dma_direct_supported(struct device *dev, u64 mask)\n{\n\tu64 min_mask;\n\n\tif (IS_ENABLED(CONFIG_ZONE_DMA))\n\t\tmin_mask = DMA_BIT_MASK(ARCH_ZONE_DMA_BITS);\n\telse\n\t\tmin_mask = DMA_BIT_MASK(32);\n\n\tmin_mask = min_t(u64, min_mask, (max_pfn - 1) << PAGE_SHIFT);\n\n\treturn mask >= phys_to_dma(dev, min_mask);\n}"
  },
  {
    "function_name": "dma_direct_map_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "275-293",
    "snippet": "int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tBUG_ON(!sg_page(sg));\n\n\t\tsg_dma_address(sg) = phys_to_dma(dev, sg_phys(sg));\n\t\tif (!check_addr(dev, sg_dma_address(sg), sg->length, __func__))\n\t\t\treturn 0;\n\t\tsg_dma_len(sg) = sg->length;\n\t}\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_sg_for_device(dev, sgl, nents, dir);\n\treturn nents;\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_sync_sg_for_device",
          "args": [
            "dev",
            "sgl",
            "nents",
            "dir"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_sync_sg_for_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "207-218",
          "snippet": "static void dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tarch_sync_dma_for_device(dev, sg_phys(sg), sg->length, dir);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tarch_sync_dma_for_device(dev, sg_phys(sg), sg->length, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "sg"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_addr",
          "args": [
            "dev",
            "sg_dma_address(sg)",
            "sg->length",
            "__func__"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "check_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "33-54",
          "snippet": "static bool\ncheck_addr(struct device *dev, dma_addr_t dma_addr, size_t size,\n\t\tconst char *caller)\n{\n\tif (unlikely(dev && !dma_capable(dev, dma_addr, size))) {\n\t\tif (!dev->dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: call on device without dma_mask\\n\",\n\t\t\t\tcaller);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (*dev->dma_mask >= DMA_BIT_MASK(32) || dev->bus_dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: overflow %pad+%zu of device mask %llx bus mask %llx\\n\",\n\t\t\t\tcaller, &dma_addr, size,\n\t\t\t\t*dev->dma_mask, dev->bus_dma_mask);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool\ncheck_addr(struct device *dev, dma_addr_t dma_addr, size_t size,\n\t\tconst char *caller)\n{\n\tif (unlikely(dev && !dma_capable(dev, dma_addr, size))) {\n\t\tif (!dev->dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: call on device without dma_mask\\n\",\n\t\t\t\tcaller);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (*dev->dma_mask >= DMA_BIT_MASK(32) || dev->bus_dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: overflow %pad+%zu of device mask %llx bus mask %llx\\n\",\n\t\t\t\tcaller, &dma_addr, size,\n\t\t\t\t*dev->dma_mask, dev->bus_dma_mask);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "sg"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma",
          "args": [
            "dev",
            "sg_phys(sg)"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "56-62",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_phys",
          "args": [
            "sg"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "sg"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!sg_page(sg)"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "sg"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nents",
            "i"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tBUG_ON(!sg_page(sg));\n\n\t\tsg_dma_address(sg) = phys_to_dma(dev, sg_phys(sg));\n\t\tif (!check_addr(dev, sg_dma_address(sg), sg->length, __func__))\n\t\t\treturn 0;\n\t\tsg_dma_len(sg) = sg->length;\n\t}\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_sg_for_device(dev, sgl, nents, dir);\n\treturn nents;\n}"
  },
  {
    "function_name": "dma_direct_map_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "260-273",
    "snippet": "dma_addr_t dma_direct_map_page(struct device *dev, struct page *page,\n\t\tunsigned long offset, size_t size, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dma_addr = phys_to_dma(dev, phys);\n\n\tif (!check_addr(dev, dma_addr, size, __func__))\n\t\treturn DIRECT_MAPPING_ERROR;\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_device(dev, dma_addr, size, dir);\n\treturn dma_addr;\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_sync_single_for_device",
          "args": [
            "dev",
            "dma_addr",
            "size",
            "dir"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_sync_single_for_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "199-205",
          "snippet": "static void dma_direct_sync_single_for_device(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\tarch_sync_dma_for_device(dev, dma_to_phys(dev, addr), size, dir);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dma_direct_sync_single_for_device(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\tarch_sync_dma_for_device(dev, dma_to_phys(dev, addr), size, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_addr",
          "args": [
            "dev",
            "dma_addr",
            "size",
            "__func__"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "check_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "33-54",
          "snippet": "static bool\ncheck_addr(struct device *dev, dma_addr_t dma_addr, size_t size,\n\t\tconst char *caller)\n{\n\tif (unlikely(dev && !dma_capable(dev, dma_addr, size))) {\n\t\tif (!dev->dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: call on device without dma_mask\\n\",\n\t\t\t\tcaller);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (*dev->dma_mask >= DMA_BIT_MASK(32) || dev->bus_dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: overflow %pad+%zu of device mask %llx bus mask %llx\\n\",\n\t\t\t\tcaller, &dma_addr, size,\n\t\t\t\t*dev->dma_mask, dev->bus_dma_mask);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool\ncheck_addr(struct device *dev, dma_addr_t dma_addr, size_t size,\n\t\tconst char *caller)\n{\n\tif (unlikely(dev && !dma_capable(dev, dma_addr, size))) {\n\t\tif (!dev->dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: call on device without dma_mask\\n\",\n\t\t\t\tcaller);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (*dev->dma_mask >= DMA_BIT_MASK(32) || dev->bus_dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: overflow %pad+%zu of device mask %llx bus mask %llx\\n\",\n\t\t\t\tcaller, &dma_addr, size,\n\t\t\t\t*dev->dma_mask, dev->bus_dma_mask);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "phys_to_dma",
          "args": [
            "dev",
            "phys"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "56-62",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\ndma_addr_t dma_direct_map_page(struct device *dev, struct page *page,\n\t\tunsigned long offset, size_t size, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dma_addr = phys_to_dma(dev, phys);\n\n\tif (!check_addr(dev, dma_addr, size, __func__))\n\t\treturn DIRECT_MAPPING_ERROR;\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_device(dev, dma_addr, size, dir);\n\treturn dma_addr;\n}"
  },
  {
    "function_name": "dma_direct_unmap_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "252-257",
    "snippet": "static void dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_sg_for_cpu(dev, sgl, nents, dir);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_sync_sg_for_cpu",
          "args": [
            "dev",
            "sgl",
            "nents",
            "dir"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_sync_sg_for_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "231-243",
          "snippet": "static void dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tarch_sync_dma_for_cpu(dev, sg_phys(sg), sg->length, dir);\n\tarch_sync_dma_for_cpu_all(dev);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tarch_sync_dma_for_cpu(dev, sg_phys(sg), sg->length, dir);\n\tarch_sync_dma_for_cpu_all(dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_sg_for_cpu(dev, sgl, nents, dir);\n}"
  },
  {
    "function_name": "dma_direct_unmap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "245-250",
    "snippet": "static void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_sync_single_for_cpu",
          "args": [
            "dev",
            "addr",
            "size",
            "dir"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_sync_single_for_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "222-229",
          "snippet": "static void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\tarch_sync_dma_for_cpu(dev, dma_to_phys(dev, addr), size, dir);\n\tarch_sync_dma_for_cpu_all(dev);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\tarch_sync_dma_for_cpu(dev, dma_to_phys(dev, addr), size, dir);\n\tarch_sync_dma_for_cpu_all(dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n}"
  },
  {
    "function_name": "dma_direct_sync_sg_for_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "231-243",
    "snippet": "static void dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tarch_sync_dma_for_cpu(dev, sg_phys(sg), sg->length, dir);\n\tarch_sync_dma_for_cpu_all(dev);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_sync_dma_for_cpu_all",
          "args": [
            "dev"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_sync_dma_for_cpu",
          "args": [
            "dev",
            "sg_phys(sg)",
            "sg->length",
            "dir"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_phys",
          "args": [
            "sg"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nents",
            "i"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tarch_sync_dma_for_cpu(dev, sg_phys(sg), sg->length, dir);\n\tarch_sync_dma_for_cpu_all(dev);\n}"
  },
  {
    "function_name": "dma_direct_sync_single_for_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "222-229",
    "snippet": "static void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\tarch_sync_dma_for_cpu(dev, dma_to_phys(dev, addr), size, dir);\n\tarch_sync_dma_for_cpu_all(dev);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_sync_dma_for_cpu_all",
          "args": [
            "dev"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_sync_dma_for_cpu",
          "args": [
            "dev",
            "dma_to_phys(dev, addr)",
            "size",
            "dir"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "addr"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\tarch_sync_dma_for_cpu(dev, dma_to_phys(dev, addr), size, dir);\n\tarch_sync_dma_for_cpu_all(dev);\n}"
  },
  {
    "function_name": "dma_direct_sync_sg_for_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "207-218",
    "snippet": "static void dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tarch_sync_dma_for_device(dev, sg_phys(sg), sg->length, dir);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_sync_dma_for_device",
          "args": [
            "dev",
            "sg_phys(sg)",
            "sg->length",
            "dir"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_phys",
          "args": [
            "sg"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nents",
            "i"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tarch_sync_dma_for_device(dev, sg_phys(sg), sg->length, dir);\n}"
  },
  {
    "function_name": "dma_direct_sync_single_for_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "199-205",
    "snippet": "static void dma_direct_sync_single_for_device(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\tarch_sync_dma_for_device(dev, dma_to_phys(dev, addr), size, dir);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_sync_dma_for_device",
          "args": [
            "dev",
            "dma_to_phys(dev, addr)",
            "size",
            "dir"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "addr"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dma_direct_sync_single_for_device(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tif (dev_is_dma_coherent(dev))\n\t\treturn;\n\tarch_sync_dma_for_device(dev, dma_to_phys(dev, addr), size, dir);\n}"
  },
  {
    "function_name": "dma_direct_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "190-197",
    "snippet": "void dma_direct_free(struct device *dev, size_t size,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, unsigned long attrs)\n{\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_dma_free(dev, size, cpu_addr, dma_addr, attrs);\n\telse\n\t\tdma_direct_free_pages(dev, size, cpu_addr, dma_addr, attrs);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_free_pages",
          "args": [
            "dev",
            "size",
            "cpu_addr",
            "dma_addr",
            "attrs"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "170-180",
          "snippet": "void dma_direct_free_pages(struct device *dev, size_t size, void *cpu_addr,\n\t\tdma_addr_t dma_addr, unsigned long attrs)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned int page_order = get_order(size);\n\n\tif (force_dma_unencrypted())\n\t\tset_memory_encrypted((unsigned long)cpu_addr, 1 << page_order);\n\tif (!dma_release_from_contiguous(dev, virt_to_page(cpu_addr), count))\n\t\tfree_pages((unsigned long)cpu_addr, page_order);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_free_pages(struct device *dev, size_t size, void *cpu_addr,\n\t\tdma_addr_t dma_addr, unsigned long attrs)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned int page_order = get_order(size);\n\n\tif (force_dma_unencrypted())\n\t\tset_memory_encrypted((unsigned long)cpu_addr, 1 << page_order);\n\tif (!dma_release_from_contiguous(dev, virt_to_page(cpu_addr), count))\n\t\tfree_pages((unsigned long)cpu_addr, page_order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_dma_free",
          "args": [
            "dev",
            "size",
            "cpu_addr",
            "dma_addr",
            "attrs"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_free(struct device *dev, size_t size,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, unsigned long attrs)\n{\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_dma_free(dev, size, cpu_addr, dma_addr, attrs);\n\telse\n\t\tdma_direct_free_pages(dev, size, cpu_addr, dma_addr, attrs);\n}"
  },
  {
    "function_name": "dma_direct_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "182-188",
    "snippet": "void *dma_direct_alloc(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)\n{\n\tif (!dev_is_dma_coherent(dev))\n\t\treturn arch_dma_alloc(dev, size, dma_handle, gfp, attrs);\n\treturn dma_direct_alloc_pages(dev, size, dma_handle, gfp, attrs);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_alloc_pages",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "gfp",
            "attrs"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "106-164",
          "snippet": "void *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tint page_order = get_order(size);\n\tstruct page *page = NULL;\n\tu64 phys_mask;\n\tvoid *ret;\n\n\tif (attrs & DMA_ATTR_NO_WARN)\n\t\tgfp |= __GFP_NOWARN;\n\n\t/* we always manually zero the memory once we are done: */\n\tgfp &= ~__GFP_ZERO;\n\tgfp |= __dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t&phys_mask);\nagain:\n\t/* CMA can be used only in the context which permits sleeping */\n\tif (gfpflags_allow_blocking(gfp)) {\n\t\tpage = dma_alloc_from_contiguous(dev, count, page_order,\n\t\t\t\t\t\t gfp & __GFP_NOWARN);\n\t\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_pages_node(dev_to_node(dev), gfp, page_order);\n\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\t__free_pages(page, page_order);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_mask < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) &&\n\t\t    phys_mask < DMA_BIT_MASK(32) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tif (force_dma_unencrypted()) {\n\t\tset_memory_decrypted((unsigned long)ret, 1 << page_order);\n\t\t*dma_handle = __phys_to_dma(dev, page_to_phys(page));\n\t} else {\n\t\t*dma_handle = phys_to_dma(dev, page_to_phys(page));\n\t}\n\tmemset(ret, 0, size);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tint page_order = get_order(size);\n\tstruct page *page = NULL;\n\tu64 phys_mask;\n\tvoid *ret;\n\n\tif (attrs & DMA_ATTR_NO_WARN)\n\t\tgfp |= __GFP_NOWARN;\n\n\t/* we always manually zero the memory once we are done: */\n\tgfp &= ~__GFP_ZERO;\n\tgfp |= __dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t&phys_mask);\nagain:\n\t/* CMA can be used only in the context which permits sleeping */\n\tif (gfpflags_allow_blocking(gfp)) {\n\t\tpage = dma_alloc_from_contiguous(dev, count, page_order,\n\t\t\t\t\t\t gfp & __GFP_NOWARN);\n\t\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_pages_node(dev_to_node(dev), gfp, page_order);\n\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\t__free_pages(page, page_order);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_mask < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) &&\n\t\t    phys_mask < DMA_BIT_MASK(32) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tif (force_dma_unencrypted()) {\n\t\tset_memory_decrypted((unsigned long)ret, 1 << page_order);\n\t\t*dma_handle = __phys_to_dma(dev, page_to_phys(page));\n\t} else {\n\t\t*dma_handle = phys_to_dma(dev, page_to_phys(page));\n\t}\n\tmemset(ret, 0, size);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_dma_alloc",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "gfp",
            "attrs"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid *dma_direct_alloc(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)\n{\n\tif (!dev_is_dma_coherent(dev))\n\t\treturn arch_dma_alloc(dev, size, dma_handle, gfp, attrs);\n\treturn dma_direct_alloc_pages(dev, size, dma_handle, gfp, attrs);\n}"
  },
  {
    "function_name": "dma_direct_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "170-180",
    "snippet": "void dma_direct_free_pages(struct device *dev, size_t size, void *cpu_addr,\n\t\tdma_addr_t dma_addr, unsigned long attrs)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned int page_order = get_order(size);\n\n\tif (force_dma_unencrypted())\n\t\tset_memory_encrypted((unsigned long)cpu_addr, 1 << page_order);\n\tif (!dma_release_from_contiguous(dev, virt_to_page(cpu_addr), count))\n\t\tfree_pages((unsigned long)cpu_addr, page_order);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)cpu_addr",
            "page_order"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_release_from_contiguous",
          "args": [
            "dev",
            "virt_to_page(cpu_addr)",
            "count"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "dma_release_from_contiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
          "lines": "211-215",
          "snippet": "bool dma_release_from_contiguous(struct device *dev, struct page *pages,\n\t\t\t\t int count)\n{\n\treturn cma_release(dev_get_cma_area(dev), pages, count);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/dma-contiguous.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nbool dma_release_from_contiguous(struct device *dev, struct page *pages,\n\t\t\t\t int count)\n{\n\treturn cma_release(dev_get_cma_area(dev), pages, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "cpu_addr"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_encrypted",
          "args": [
            "(unsigned long)cpu_addr",
            "1 << page_order"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "force_dma_unencrypted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "28-31",
          "snippet": "static inline bool force_dma_unencrypted(void)\n{\n\treturn sev_active();\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool force_dma_unencrypted(void)\n{\n\treturn sev_active();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_free_pages(struct device *dev, size_t size, void *cpu_addr,\n\t\tdma_addr_t dma_addr, unsigned long attrs)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned int page_order = get_order(size);\n\n\tif (force_dma_unencrypted())\n\t\tset_memory_encrypted((unsigned long)cpu_addr, 1 << page_order);\n\tif (!dma_release_from_contiguous(dev, virt_to_page(cpu_addr), count))\n\t\tfree_pages((unsigned long)cpu_addr, page_order);\n}"
  },
  {
    "function_name": "dma_direct_alloc_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "106-164",
    "snippet": "void *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tint page_order = get_order(size);\n\tstruct page *page = NULL;\n\tu64 phys_mask;\n\tvoid *ret;\n\n\tif (attrs & DMA_ATTR_NO_WARN)\n\t\tgfp |= __GFP_NOWARN;\n\n\t/* we always manually zero the memory once we are done: */\n\tgfp &= ~__GFP_ZERO;\n\tgfp |= __dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t&phys_mask);\nagain:\n\t/* CMA can be used only in the context which permits sleeping */\n\tif (gfpflags_allow_blocking(gfp)) {\n\t\tpage = dma_alloc_from_contiguous(dev, count, page_order,\n\t\t\t\t\t\t gfp & __GFP_NOWARN);\n\t\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_pages_node(dev_to_node(dev), gfp, page_order);\n\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\t__free_pages(page, page_order);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_mask < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) &&\n\t\t    phys_mask < DMA_BIT_MASK(32) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tif (force_dma_unencrypted()) {\n\t\tset_memory_decrypted((unsigned long)ret, 1 << page_order);\n\t\t*dma_handle = __phys_to_dma(dev, page_to_phys(page));\n\t} else {\n\t\t*dma_handle = phys_to_dma(dev, page_to_phys(page));\n\t}\n\tmemset(ret, 0, size);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ret",
            "0",
            "size"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma",
          "args": [
            "dev",
            "page_to_phys(page)"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "56-62",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__phys_to_dma",
          "args": [
            "dev",
            "page_to_phys(page)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_decrypted",
          "args": [
            "(unsigned long)ret",
            "1 << page_order"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "force_dma_unencrypted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "28-31",
          "snippet": "static inline bool force_dma_unencrypted(void)\n{\n\treturn sev_active();\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool force_dma_unencrypted(void)\n{\n\treturn sev_active();\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "32"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "64"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA32"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "page_order"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_coherent_ok",
          "args": [
            "dev",
            "page_to_phys(page)",
            "size"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "dma_coherent_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "100-104",
          "snippet": "static bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\treturn phys_to_dma_direct(dev, phys) + size - 1 <=\n\t\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_mask);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\treturn phys_to_dma_direct(dev, phys) + size - 1 <=\n\t\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "dev_to_node(dev)",
            "gfp",
            "page_order"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "dev"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_release_from_contiguous",
          "args": [
            "dev",
            "page",
            "count"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "dma_release_from_contiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
          "lines": "211-215",
          "snippet": "bool dma_release_from_contiguous(struct device *dev, struct page *pages,\n\t\t\t\t int count)\n{\n\treturn cma_release(dev_get_cma_area(dev), pages, count);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/dma-contiguous.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nbool dma_release_from_contiguous(struct device *dev, struct page *pages,\n\t\t\t\t int count)\n{\n\treturn cma_release(dev_get_cma_area(dev), pages, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_alloc_from_contiguous",
          "args": [
            "dev",
            "count",
            "page_order",
            "gfp & __GFP_NOWARN"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_from_contiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
          "lines": "192-199",
          "snippet": "struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,\n\t\t\t\t       unsigned int align, bool no_warn)\n{\n\tif (align > CONFIG_CMA_ALIGNMENT)\n\t\talign = CONFIG_CMA_ALIGNMENT;\n\n\treturn cma_alloc(dev_get_cma_area(dev), count, align, no_warn);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/dma-contiguous.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nstruct page *dma_alloc_from_contiguous(struct device *dev, size_t count,\n\t\t\t\t       unsigned int align, bool no_warn)\n{\n\tif (align > CONFIG_CMA_ALIGNMENT)\n\t\talign = CONFIG_CMA_ALIGNMENT;\n\n\treturn cma_alloc(dev_get_cma_area(dev), count, align, no_warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "gfp"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_direct_optimal_gfp_mask",
          "args": [
            "dev",
            "dev->coherent_dma_mask",
            "&phys_mask"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_direct_optimal_gfp_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "74-98",
          "snippet": "static gfp_t __dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,\n\t\tu64 *phys_mask)\n{\n\tif (dev->bus_dma_mask && dev->bus_dma_mask < dma_mask)\n\t\tdma_mask = dev->bus_dma_mask;\n\n\tif (force_dma_unencrypted())\n\t\t*phys_mask = __dma_to_phys(dev, dma_mask);\n\telse\n\t\t*phys_mask = dma_to_phys(dev, dma_mask);\n\n\t/*\n\t * Optimistically try the zone that the physical address mask falls\n\t * into first.  If that returns memory that isn't actually addressable\n\t * we will fallback to the next lower zone and try again.\n\t *\n\t * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding\n\t * zones.\n\t */\n\tif (*phys_mask <= DMA_BIT_MASK(ARCH_ZONE_DMA_BITS))\n\t\treturn GFP_DMA;\n\tif (*phys_mask <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [
            "#define ARCH_ZONE_DMA_BITS 24"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\n#define ARCH_ZONE_DMA_BITS 24\n\nstatic gfp_t __dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,\n\t\tu64 *phys_mask)\n{\n\tif (dev->bus_dma_mask && dev->bus_dma_mask < dma_mask)\n\t\tdma_mask = dev->bus_dma_mask;\n\n\tif (force_dma_unencrypted())\n\t\t*phys_mask = __dma_to_phys(dev, dma_mask);\n\telse\n\t\t*phys_mask = dma_to_phys(dev, dma_mask);\n\n\t/*\n\t * Optimistically try the zone that the physical address mask falls\n\t * into first.  If that returns memory that isn't actually addressable\n\t * we will fallback to the next lower zone and try again.\n\t *\n\t * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding\n\t * zones.\n\t */\n\tif (*phys_mask <= DMA_BIT_MASK(ARCH_ZONE_DMA_BITS))\n\t\treturn GFP_DMA;\n\tif (*phys_mask <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tint page_order = get_order(size);\n\tstruct page *page = NULL;\n\tu64 phys_mask;\n\tvoid *ret;\n\n\tif (attrs & DMA_ATTR_NO_WARN)\n\t\tgfp |= __GFP_NOWARN;\n\n\t/* we always manually zero the memory once we are done: */\n\tgfp &= ~__GFP_ZERO;\n\tgfp |= __dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t&phys_mask);\nagain:\n\t/* CMA can be used only in the context which permits sleeping */\n\tif (gfpflags_allow_blocking(gfp)) {\n\t\tpage = dma_alloc_from_contiguous(dev, count, page_order,\n\t\t\t\t\t\t gfp & __GFP_NOWARN);\n\t\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_pages_node(dev_to_node(dev), gfp, page_order);\n\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\t__free_pages(page, page_order);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_mask < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) &&\n\t\t    phys_mask < DMA_BIT_MASK(32) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tif (force_dma_unencrypted()) {\n\t\tset_memory_decrypted((unsigned long)ret, 1 << page_order);\n\t\t*dma_handle = __phys_to_dma(dev, page_to_phys(page));\n\t} else {\n\t\t*dma_handle = phys_to_dma(dev, page_to_phys(page));\n\t}\n\tmemset(ret, 0, size);\n\treturn ret;\n}"
  },
  {
    "function_name": "dma_coherent_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "100-104",
    "snippet": "static bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\treturn phys_to_dma_direct(dev, phys) + size - 1 <=\n\t\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_mask);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_not_zero",
          "args": [
            "dev->coherent_dma_mask",
            "dev->bus_dma_mask"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma_direct",
          "args": [
            "dev",
            "phys"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "56-62",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\treturn phys_to_dma_direct(dev, phys) + size - 1 <=\n\t\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_mask);\n}"
  },
  {
    "function_name": "__dma_direct_optimal_gfp_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "74-98",
    "snippet": "static gfp_t __dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,\n\t\tu64 *phys_mask)\n{\n\tif (dev->bus_dma_mask && dev->bus_dma_mask < dma_mask)\n\t\tdma_mask = dev->bus_dma_mask;\n\n\tif (force_dma_unencrypted())\n\t\t*phys_mask = __dma_to_phys(dev, dma_mask);\n\telse\n\t\t*phys_mask = dma_to_phys(dev, dma_mask);\n\n\t/*\n\t * Optimistically try the zone that the physical address mask falls\n\t * into first.  If that returns memory that isn't actually addressable\n\t * we will fallback to the next lower zone and try again.\n\t *\n\t * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding\n\t * zones.\n\t */\n\tif (*phys_mask <= DMA_BIT_MASK(ARCH_ZONE_DMA_BITS))\n\t\treturn GFP_DMA;\n\tif (*phys_mask <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [
      "#define ARCH_ZONE_DMA_BITS 24"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "32"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "ARCH_ZONE_DMA_BITS"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "dma_mask"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_to_phys",
          "args": [
            "dev",
            "dma_mask"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "force_dma_unencrypted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "28-31",
          "snippet": "static inline bool force_dma_unencrypted(void)\n{\n\treturn sev_active();\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool force_dma_unencrypted(void)\n{\n\treturn sev_active();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\n#define ARCH_ZONE_DMA_BITS 24\n\nstatic gfp_t __dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,\n\t\tu64 *phys_mask)\n{\n\tif (dev->bus_dma_mask && dev->bus_dma_mask < dma_mask)\n\t\tdma_mask = dev->bus_dma_mask;\n\n\tif (force_dma_unencrypted())\n\t\t*phys_mask = __dma_to_phys(dev, dma_mask);\n\telse\n\t\t*phys_mask = dma_to_phys(dev, dma_mask);\n\n\t/*\n\t * Optimistically try the zone that the physical address mask falls\n\t * into first.  If that returns memory that isn't actually addressable\n\t * we will fallback to the next lower zone and try again.\n\t *\n\t * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding\n\t * zones.\n\t */\n\tif (*phys_mask <= DMA_BIT_MASK(ARCH_ZONE_DMA_BITS))\n\t\treturn GFP_DMA;\n\tif (*phys_mask <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_direct_get_required_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "64-72",
    "snippet": "u64 dma_direct_get_required_mask(struct device *dev)\n{\n\tu64 max_dma = phys_to_dma_direct(dev, (max_pfn - 1) << PAGE_SHIFT);\n\n\tif (dev->bus_dma_mask && dev->bus_dma_mask < max_dma)\n\t\tmax_dma = dev->bus_dma_mask;\n\n\treturn (1ULL << (fls64(max_dma) - 1)) * 2 - 1;\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "max_dma"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma_direct",
          "args": [
            "dev",
            "(max_pfn - 1) << PAGE_SHIFT"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "56-62",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nu64 dma_direct_get_required_mask(struct device *dev)\n{\n\tu64 max_dma = phys_to_dma_direct(dev, (max_pfn - 1) << PAGE_SHIFT);\n\n\tif (dev->bus_dma_mask && dev->bus_dma_mask < max_dma)\n\t\tmax_dma = dev->bus_dma_mask;\n\n\treturn (1ULL << (fls64(max_dma) - 1)) * 2 - 1;\n}"
  },
  {
    "function_name": "phys_to_dma_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "56-62",
    "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phys_to_dma",
          "args": [
            "dev",
            "phys"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "56-62",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__phys_to_dma",
          "args": [
            "dev",
            "phys"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "force_dma_unencrypted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
          "lines": "28-31",
          "snippet": "static inline bool force_dma_unencrypted(void)\n{\n\treturn sev_active();\n}",
          "includes": [
            "#include <linux/set_memory.h>",
            "#include <linux/pfn.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool force_dma_unencrypted(void)\n{\n\treturn sev_active();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted())\n\t\treturn __phys_to_dma(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
  },
  {
    "function_name": "check_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "33-54",
    "snippet": "static bool\ncheck_addr(struct device *dev, dma_addr_t dma_addr, size_t size,\n\t\tconst char *caller)\n{\n\tif (unlikely(dev && !dma_capable(dev, dma_addr, size))) {\n\t\tif (!dev->dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: call on device without dma_mask\\n\",\n\t\t\t\tcaller);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (*dev->dma_mask >= DMA_BIT_MASK(32) || dev->bus_dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: overflow %pad+%zu of device mask %llx bus mask %llx\\n\",\n\t\t\t\tcaller, &dma_addr, size,\n\t\t\t\t*dev->dma_mask, dev->bus_dma_mask);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"%s: overflow %pad+%zu of device mask %llx bus mask %llx\\n\"",
            "caller",
            "&dma_addr",
            "size",
            "*dev->dma_mask",
            "dev->bus_dma_mask"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "32"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"%s: call on device without dma_mask\\n\"",
            "caller"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dev && !dma_capable(dev, dma_addr, size)"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_capable",
          "args": [
            "dev",
            "dma_addr",
            "size"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool\ncheck_addr(struct device *dev, dma_addr_t dma_addr, size_t size,\n\t\tconst char *caller)\n{\n\tif (unlikely(dev && !dma_capable(dev, dma_addr, size))) {\n\t\tif (!dev->dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: call on device without dma_mask\\n\",\n\t\t\t\tcaller);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (*dev->dma_mask >= DMA_BIT_MASK(32) || dev->bus_dma_mask) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: overflow %pad+%zu of device mask %llx bus mask %llx\\n\",\n\t\t\t\tcaller, &dma_addr, size,\n\t\t\t\t*dev->dma_mask, dev->bus_dma_mask);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "force_dma_unencrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/direct.c",
    "lines": "28-31",
    "snippet": "static inline bool force_dma_unencrypted(void)\n{\n\treturn sev_active();\n}",
    "includes": [
      "#include <linux/set_memory.h>",
      "#include <linux/pfn.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sev_active",
          "args": [],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/set_memory.h>\n#include <linux/pfn.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/dma-contiguous.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direct.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool force_dma_unencrypted(void)\n{\n\treturn sev_active();\n}"
  }
]