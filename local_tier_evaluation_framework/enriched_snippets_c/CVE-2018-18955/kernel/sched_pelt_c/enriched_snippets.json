[
  {
    "function_name": "update_irq_load_avg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "365-392",
    "snippet": "int update_irq_load_avg(struct rq *rq, u64 running)\n{\n\tint ret = 0;\n\t/*\n\t * We know the time that has been used by interrupt since last update\n\t * but we don't when. Let be pessimistic and assume that interrupt has\n\t * happened just before the update. This is not so far from reality\n\t * because interrupt will most probably wake up task and trig an update\n\t * of rq clock during which the metric si updated.\n\t * We start to decay with normal context time and then we add the\n\t * interrupt context time.\n\t * We can safely remove running from rq->clock because\n\t * rq->clock += delta with delta >= running\n\t */\n\tret = ___update_load_sum(rq->clock - running, rq->cpu, &rq->avg_irq,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0);\n\tret += ___update_load_sum(rq->clock, rq->cpu, &rq->avg_irq,\n\t\t\t\t1,\n\t\t\t\t1,\n\t\t\t\t1);\n\n\tif (ret)\n\t\t___update_load_avg(&rq->avg_irq, 1, 1);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "___update_load_avg",
          "args": [
            "&rq->avg_irq",
            "1",
            "1"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "230-241",
          "snippet": "static __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}"
        }
      },
      {
        "call_info": {
          "callee": "___update_load_sum",
          "args": [
            "rq->clock",
            "rq->cpu",
            "&rq->avg_irq",
            "1",
            "1",
            "1"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "179-228",
          "snippet": "static __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nint update_irq_load_avg(struct rq *rq, u64 running)\n{\n\tint ret = 0;\n\t/*\n\t * We know the time that has been used by interrupt since last update\n\t * but we don't when. Let be pessimistic and assume that interrupt has\n\t * happened just before the update. This is not so far from reality\n\t * because interrupt will most probably wake up task and trig an update\n\t * of rq clock during which the metric si updated.\n\t * We start to decay with normal context time and then we add the\n\t * interrupt context time.\n\t * We can safely remove running from rq->clock because\n\t * rq->clock += delta with delta >= running\n\t */\n\tret = ___update_load_sum(rq->clock - running, rq->cpu, &rq->avg_irq,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0);\n\tret += ___update_load_sum(rq->clock, rq->cpu, &rq->avg_irq,\n\t\t\t\t1,\n\t\t\t\t1,\n\t\t\t\t1);\n\n\tif (ret)\n\t\t___update_load_avg(&rq->avg_irq, 1, 1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "update_dl_rq_load_avg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "341-353",
    "snippet": "int update_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\tif (___update_load_sum(now, rq->cpu, &rq->avg_dl,\n\t\t\t\trunning,\n\t\t\t\trunning,\n\t\t\t\trunning)) {\n\n\t\t___update_load_avg(&rq->avg_dl, 1, 1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "___update_load_avg",
          "args": [
            "&rq->avg_dl",
            "1",
            "1"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "230-241",
          "snippet": "static __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}"
        }
      },
      {
        "call_info": {
          "callee": "___update_load_sum",
          "args": [
            "now",
            "rq->cpu",
            "&rq->avg_dl",
            "running",
            "running",
            "running"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "179-228",
          "snippet": "static __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nint update_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\tif (___update_load_sum(now, rq->cpu, &rq->avg_dl,\n\t\t\t\trunning,\n\t\t\t\trunning,\n\t\t\t\trunning)) {\n\n\t\t___update_load_avg(&rq->avg_dl, 1, 1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "update_rt_rq_load_avg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "318-330",
    "snippet": "int update_rt_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\tif (___update_load_sum(now, rq->cpu, &rq->avg_rt,\n\t\t\t\trunning,\n\t\t\t\trunning,\n\t\t\t\trunning)) {\n\n\t\t___update_load_avg(&rq->avg_rt, 1, 1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "___update_load_avg",
          "args": [
            "&rq->avg_rt",
            "1",
            "1"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "230-241",
          "snippet": "static __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}"
        }
      },
      {
        "call_info": {
          "callee": "___update_load_sum",
          "args": [
            "now",
            "rq->cpu",
            "&rq->avg_rt",
            "running",
            "running",
            "running"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "179-228",
          "snippet": "static __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nint update_rt_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\tif (___update_load_sum(now, rq->cpu, &rq->avg_rt,\n\t\t\t\trunning,\n\t\t\t\trunning,\n\t\t\t\trunning)) {\n\n\t\t___update_load_avg(&rq->avg_rt, 1, 1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__update_load_avg_cfs_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "293-305",
    "snippet": "int __update_load_avg_cfs_rq(u64 now, int cpu, struct cfs_rq *cfs_rq)\n{\n\tif (___update_load_sum(now, cpu, &cfs_rq->avg,\n\t\t\t\tscale_load_down(cfs_rq->load.weight),\n\t\t\t\tscale_load_down(cfs_rq->runnable_weight),\n\t\t\t\tcfs_rq->curr != NULL)) {\n\n\t\t___update_load_avg(&cfs_rq->avg, 1, 1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "___update_load_avg",
          "args": [
            "&cfs_rq->avg",
            "1",
            "1"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "230-241",
          "snippet": "static __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}"
        }
      },
      {
        "call_info": {
          "callee": "___update_load_sum",
          "args": [
            "now",
            "cpu",
            "&cfs_rq->avg",
            "scale_load_down(cfs_rq->load.weight)",
            "scale_load_down(cfs_rq->runnable_weight)",
            "cfs_rq->curr != NULL"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "179-228",
          "snippet": "static __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scale_load_down",
          "args": [
            "cfs_rq->runnable_weight"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_load_down",
          "args": [
            "cfs_rq->load.weight"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nint __update_load_avg_cfs_rq(u64 now, int cpu, struct cfs_rq *cfs_rq)\n{\n\tif (___update_load_sum(now, cpu, &cfs_rq->avg,\n\t\t\t\tscale_load_down(cfs_rq->load.weight),\n\t\t\t\tscale_load_down(cfs_rq->runnable_weight),\n\t\t\t\tcfs_rq->curr != NULL)) {\n\n\t\t___update_load_avg(&cfs_rq->avg, 1, 1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__update_load_avg_se",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "280-291",
    "snippet": "int __update_load_avg_se(u64 now, int cpu, struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tif (___update_load_sum(now, cpu, &se->avg, !!se->on_rq, !!se->on_rq,\n\t\t\t\tcfs_rq->curr == se)) {\n\n\t\t___update_load_avg(&se->avg, se_weight(se), se_runnable(se));\n\t\tcfs_se_util_change(&se->avg);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cfs_se_util_change",
          "args": [
            "&se->avg"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "cfs_se_util_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.h",
          "lines": "28-43",
          "snippet": "static inline void cfs_se_util_change(struct sched_avg *avg)\n{\n\tunsigned int enqueued;\n\n\tif (!sched_feat(UTIL_EST))\n\t\treturn;\n\n\t/* Avoid store if the flag has been already set */\n\tenqueued = avg->util_est.enqueued;\n\tif (!(enqueued & UTIL_AVG_UNCHANGED))\n\t\treturn;\n\n\t/* Reset flag to report util_avg has been updated */\n\tenqueued &= ~UTIL_AVG_UNCHANGED;\n\tWRITE_ONCE(avg->util_est.enqueued, enqueued);\n}",
          "includes": [],
          "macros_used": [
            "#define UTIL_AVG_UNCHANGED 0x1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define UTIL_AVG_UNCHANGED 0x1\n\nstatic inline void cfs_se_util_change(struct sched_avg *avg)\n{\n\tunsigned int enqueued;\n\n\tif (!sched_feat(UTIL_EST))\n\t\treturn;\n\n\t/* Avoid store if the flag has been already set */\n\tenqueued = avg->util_est.enqueued;\n\tif (!(enqueued & UTIL_AVG_UNCHANGED))\n\t\treturn;\n\n\t/* Reset flag to report util_avg has been updated */\n\tenqueued &= ~UTIL_AVG_UNCHANGED;\n\tWRITE_ONCE(avg->util_est.enqueued, enqueued);\n}"
        }
      },
      {
        "call_info": {
          "callee": "___update_load_avg",
          "args": [
            "&se->avg",
            "se_weight(se)",
            "se_runnable(se)"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "230-241",
          "snippet": "static __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}"
        }
      },
      {
        "call_info": {
          "callee": "se_runnable",
          "args": [
            "se"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "se_runnable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "696-699",
          "snippet": "static inline long se_runnable(struct sched_entity *se)\n{\n\treturn scale_load_down(se->runnable_weight);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_entity_runnable_average(struct sched_entity *se);",
            "extern void post_init_entity_util_avg(struct sched_entity *se);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_entity_runnable_average(struct sched_entity *se);\nextern void post_init_entity_util_avg(struct sched_entity *se);\n\nstatic inline long se_runnable(struct sched_entity *se)\n{\n\treturn scale_load_down(se->runnable_weight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "se_weight",
          "args": [
            "se"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "se_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "691-694",
          "snippet": "static inline long se_weight(struct sched_entity *se)\n{\n\treturn scale_load_down(se->load.weight);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_entity_runnable_average(struct sched_entity *se);",
            "extern void post_init_entity_util_avg(struct sched_entity *se);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_entity_runnable_average(struct sched_entity *se);\nextern void post_init_entity_util_avg(struct sched_entity *se);\n\nstatic inline long se_weight(struct sched_entity *se)\n{\n\treturn scale_load_down(se->load.weight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "___update_load_sum",
          "args": [
            "now",
            "cpu",
            "&se->avg",
            "!!se->on_rq",
            "!!se->on_rq",
            "cfs_rq->curr == se"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "179-228",
          "snippet": "static __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nint __update_load_avg_se(u64 now, int cpu, struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tif (___update_load_sum(now, cpu, &se->avg, !!se->on_rq, !!se->on_rq,\n\t\t\t\tcfs_rq->curr == se)) {\n\n\t\t___update_load_avg(&se->avg, se_weight(se), se_runnable(se));\n\t\tcfs_se_util_change(&se->avg);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__update_load_avg_blocked_se",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "270-278",
    "snippet": "int __update_load_avg_blocked_se(u64 now, int cpu, struct sched_entity *se)\n{\n\tif (___update_load_sum(now, cpu, &se->avg, 0, 0, 0)) {\n\t\t___update_load_avg(&se->avg, se_weight(se), se_runnable(se));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "___update_load_avg",
          "args": [
            "&se->avg",
            "se_weight(se)",
            "se_runnable(se)"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "230-241",
          "snippet": "static __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}"
        }
      },
      {
        "call_info": {
          "callee": "se_runnable",
          "args": [
            "se"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "se_runnable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "696-699",
          "snippet": "static inline long se_runnable(struct sched_entity *se)\n{\n\treturn scale_load_down(se->runnable_weight);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_entity_runnable_average(struct sched_entity *se);",
            "extern void post_init_entity_util_avg(struct sched_entity *se);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_entity_runnable_average(struct sched_entity *se);\nextern void post_init_entity_util_avg(struct sched_entity *se);\n\nstatic inline long se_runnable(struct sched_entity *se)\n{\n\treturn scale_load_down(se->runnable_weight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "se_weight",
          "args": [
            "se"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "se_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "691-694",
          "snippet": "static inline long se_weight(struct sched_entity *se)\n{\n\treturn scale_load_down(se->load.weight);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_entity_runnable_average(struct sched_entity *se);",
            "extern void post_init_entity_util_avg(struct sched_entity *se);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_entity_runnable_average(struct sched_entity *se);\nextern void post_init_entity_util_avg(struct sched_entity *se);\n\nstatic inline long se_weight(struct sched_entity *se)\n{\n\treturn scale_load_down(se->load.weight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "___update_load_sum",
          "args": [
            "now",
            "cpu",
            "&se->avg",
            "0",
            "0",
            "0"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "___update_load_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "179-228",
          "snippet": "static __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nint __update_load_avg_blocked_se(u64 now, int cpu, struct sched_entity *se)\n{\n\tif (___update_load_sum(now, cpu, &se->avg, 0, 0, 0)) {\n\t\t___update_load_avg(&se->avg, se_weight(se), se_runnable(se));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "___update_load_avg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "230-241",
    "snippet": "static __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sa->util_avg",
            "sa->util_sum / divider"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "runnable * sa->runnable_load_sum",
            "divider"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "load * sa->load_sum",
            "divider"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline void\n___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)\n{\n\tu32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;\n\n\t/*\n\t * Step 2: update *_avg.\n\t */\n\tsa->load_avg = div_u64(load * sa->load_sum, divider);\n\tsa->runnable_load_avg =\tdiv_u64(runnable * sa->runnable_load_sum, divider);\n\tWRITE_ONCE(sa->util_avg, sa->util_sum / divider);\n}"
  },
  {
    "function_name": "___update_load_sum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "179-228",
    "snippet": "static __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "accumulate_sum",
          "args": [
            "delta",
            "cpu",
            "sa",
            "load",
            "runnable",
            "running"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "108-149",
          "snippet": "static __always_inline u32\naccumulate_sum(u64 delta, int cpu, struct sched_avg *sa,\n\t       unsigned long load, unsigned long runnable, int running)\n{\n\tunsigned long scale_freq, scale_cpu;\n\tu32 contrib = (u32)delta; /* p == 0 -> delta < 1024 */\n\tu64 periods;\n\n\tscale_freq = arch_scale_freq_capacity(cpu);\n\tscale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\tdelta += sa->period_contrib;\n\tperiods = delta / 1024; /* A period is 1024us (~1ms) */\n\n\t/*\n\t * Step 1: decay old *_sum if we crossed period boundaries.\n\t */\n\tif (periods) {\n\t\tsa->load_sum = decay_load(sa->load_sum, periods);\n\t\tsa->runnable_load_sum =\n\t\t\tdecay_load(sa->runnable_load_sum, periods);\n\t\tsa->util_sum = decay_load((u64)(sa->util_sum), periods);\n\n\t\t/*\n\t\t * Step 2\n\t\t */\n\t\tdelta %= 1024;\n\t\tcontrib = __accumulate_pelt_segments(periods,\n\t\t\t\t1024 - sa->period_contrib, delta);\n\t}\n\tsa->period_contrib = delta;\n\n\tcontrib = cap_scale(contrib, scale_freq);\n\tif (load)\n\t\tsa->load_sum += load * contrib;\n\tif (runnable)\n\t\tsa->runnable_load_sum += runnable * contrib;\n\tif (running)\n\t\tsa->util_sum += contrib * scale_cpu;\n\n\treturn periods;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline u32\naccumulate_sum(u64 delta, int cpu, struct sched_avg *sa,\n\t       unsigned long load, unsigned long runnable, int running)\n{\n\tunsigned long scale_freq, scale_cpu;\n\tu32 contrib = (u32)delta; /* p == 0 -> delta < 1024 */\n\tu64 periods;\n\n\tscale_freq = arch_scale_freq_capacity(cpu);\n\tscale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\tdelta += sa->period_contrib;\n\tperiods = delta / 1024; /* A period is 1024us (~1ms) */\n\n\t/*\n\t * Step 1: decay old *_sum if we crossed period boundaries.\n\t */\n\tif (periods) {\n\t\tsa->load_sum = decay_load(sa->load_sum, periods);\n\t\tsa->runnable_load_sum =\n\t\t\tdecay_load(sa->runnable_load_sum, periods);\n\t\tsa->util_sum = decay_load((u64)(sa->util_sum), periods);\n\n\t\t/*\n\t\t * Step 2\n\t\t */\n\t\tdelta %= 1024;\n\t\tcontrib = __accumulate_pelt_segments(periods,\n\t\t\t\t1024 - sa->period_contrib, delta);\n\t}\n\tsa->period_contrib = delta;\n\n\tcontrib = cap_scale(contrib, scale_freq);\n\tif (load)\n\t\tsa->load_sum += load * contrib;\n\tif (runnable)\n\t\tsa->runnable_load_sum += runnable * contrib;\n\tif (running)\n\t\tsa->util_sum += contrib * scale_cpu;\n\n\treturn periods;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline int\n___update_load_sum(u64 now, int cpu, struct sched_avg *sa,\n\t\t  unsigned long load, unsigned long runnable, int running)\n{\n\tu64 delta;\n\n\tdelta = now - sa->last_update_time;\n\t/*\n\t * This should only happen when time goes backwards, which it\n\t * unfortunately does during sched clock init when we swap over to TSC.\n\t */\n\tif ((s64)delta < 0) {\n\t\tsa->last_update_time = now;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Use 1024ns as the unit of measurement since it's a reasonable\n\t * approximation of 1us and fast to compute.\n\t */\n\tdelta >>= 10;\n\tif (!delta)\n\t\treturn 0;\n\n\tsa->last_update_time += delta << 10;\n\n\t/*\n\t * running is a subset of runnable (weight) so running can't be set if\n\t * runnable is clear. But there are some corner cases where the current\n\t * se has been already dequeued but cfs_rq->curr still points to it.\n\t * This means that weight will be 0 but not running for a sched_entity\n\t * but also for a cfs_rq if the latter becomes idle. As an example,\n\t * this happens during idle_balance() which calls\n\t * update_blocked_averages()\n\t */\n\tif (!load)\n\t\trunnable = running = 0;\n\n\t/*\n\t * Now we know we crossed measurement unit boundaries. The *_avg\n\t * accrues by two steps:\n\t *\n\t * Step 1: accumulate *_sum since last_update_time. If we haven't\n\t * crossed period boundaries, finish.\n\t */\n\tif (!accumulate_sum(delta, cpu, sa, load, runnable, running))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "accumulate_sum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "108-149",
    "snippet": "static __always_inline u32\naccumulate_sum(u64 delta, int cpu, struct sched_avg *sa,\n\t       unsigned long load, unsigned long runnable, int running)\n{\n\tunsigned long scale_freq, scale_cpu;\n\tu32 contrib = (u32)delta; /* p == 0 -> delta < 1024 */\n\tu64 periods;\n\n\tscale_freq = arch_scale_freq_capacity(cpu);\n\tscale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\tdelta += sa->period_contrib;\n\tperiods = delta / 1024; /* A period is 1024us (~1ms) */\n\n\t/*\n\t * Step 1: decay old *_sum if we crossed period boundaries.\n\t */\n\tif (periods) {\n\t\tsa->load_sum = decay_load(sa->load_sum, periods);\n\t\tsa->runnable_load_sum =\n\t\t\tdecay_load(sa->runnable_load_sum, periods);\n\t\tsa->util_sum = decay_load((u64)(sa->util_sum), periods);\n\n\t\t/*\n\t\t * Step 2\n\t\t */\n\t\tdelta %= 1024;\n\t\tcontrib = __accumulate_pelt_segments(periods,\n\t\t\t\t1024 - sa->period_contrib, delta);\n\t}\n\tsa->period_contrib = delta;\n\n\tcontrib = cap_scale(contrib, scale_freq);\n\tif (load)\n\t\tsa->load_sum += load * contrib;\n\tif (runnable)\n\t\tsa->runnable_load_sum += runnable * contrib;\n\tif (running)\n\t\tsa->util_sum += contrib * scale_cpu;\n\n\treturn periods;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_scale",
          "args": [
            "contrib",
            "scale_freq"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__accumulate_pelt_segments",
          "args": [
            "periods",
            "1024 - sa->period_contrib",
            "delta"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "__accumulate_pelt_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "62-83",
          "snippet": "static u32 __accumulate_pelt_segments(u64 periods, u32 d1, u32 d3)\n{\n\tu32 c1, c2, c3 = d3; /* y^0 == 1 */\n\n\t/*\n\t * c1 = d1 y^p\n\t */\n\tc1 = decay_load((u64)d1, periods);\n\n\t/*\n\t *            p-1\n\t * c2 = 1024 \\Sum y^n\n\t *            n=1\n\t *\n\t *              inf        inf\n\t *    = 1024 ( \\Sum y^n - \\Sum y^n - y^0 )\n\t *              n=0        n=p\n\t */\n\tc2 = LOAD_AVG_MAX - decay_load(LOAD_AVG_MAX, periods) - 1024;\n\n\treturn c1 + c2 + c3;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic u32 __accumulate_pelt_segments(u64 periods, u32 d1, u32 d3)\n{\n\tu32 c1, c2, c3 = d3; /* y^0 == 1 */\n\n\t/*\n\t * c1 = d1 y^p\n\t */\n\tc1 = decay_load((u64)d1, periods);\n\n\t/*\n\t *            p-1\n\t * c2 = 1024 \\Sum y^n\n\t *            n=1\n\t *\n\t *              inf        inf\n\t *    = 1024 ( \\Sum y^n - \\Sum y^n - y^0 )\n\t *              n=0        n=p\n\t */\n\tc2 = LOAD_AVG_MAX - decay_load(LOAD_AVG_MAX, periods) - 1024;\n\n\treturn c1 + c2 + c3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decay_load",
          "args": [
            "(u64)(sa->util_sum)",
            "periods"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "decay_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "36-60",
          "snippet": "static u64 decay_load(u64 val, u64 n)\n{\n\tunsigned int local_n;\n\n\tif (unlikely(n > LOAD_AVG_PERIOD * 63))\n\t\treturn 0;\n\n\t/* after bounds checking we can collapse to 32-bit */\n\tlocal_n = n;\n\n\t/*\n\t * As y^PERIOD = 1/2, we can combine\n\t *    y^n = 1/2^(n/PERIOD) * y^(n%PERIOD)\n\t * With a look-up table which covers y^n (n<PERIOD)\n\t *\n\t * To achieve constant time decay_load.\n\t */\n\tif (unlikely(local_n >= LOAD_AVG_PERIOD)) {\n\t\tval >>= local_n / LOAD_AVG_PERIOD;\n\t\tlocal_n %= LOAD_AVG_PERIOD;\n\t}\n\n\tval = mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32);\n\treturn val;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic u64 decay_load(u64 val, u64 n)\n{\n\tunsigned int local_n;\n\n\tif (unlikely(n > LOAD_AVG_PERIOD * 63))\n\t\treturn 0;\n\n\t/* after bounds checking we can collapse to 32-bit */\n\tlocal_n = n;\n\n\t/*\n\t * As y^PERIOD = 1/2, we can combine\n\t *    y^n = 1/2^(n/PERIOD) * y^(n%PERIOD)\n\t * With a look-up table which covers y^n (n<PERIOD)\n\t *\n\t * To achieve constant time decay_load.\n\t */\n\tif (unlikely(local_n >= LOAD_AVG_PERIOD)) {\n\t\tval >>= local_n / LOAD_AVG_PERIOD;\n\t\tlocal_n %= LOAD_AVG_PERIOD;\n\t}\n\n\tval = mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sa->util_sum"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_scale_cpu_capacity",
          "args": [
            "NULL",
            "cpu"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "arch_scale_cpu_capacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1872-1876",
          "snippet": "static __always_inline\nunsigned long arch_scale_cpu_capacity(void __always_unused *sd, int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic __always_inline\nunsigned long arch_scale_cpu_capacity(void __always_unused *sd, int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_scale_freq_capacity",
          "args": [
            "cpu"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "arch_scale_freq_capacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1852-1856",
          "snippet": "static __always_inline\nunsigned long arch_scale_freq_capacity(int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic __always_inline\nunsigned long arch_scale_freq_capacity(int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic __always_inline u32\naccumulate_sum(u64 delta, int cpu, struct sched_avg *sa,\n\t       unsigned long load, unsigned long runnable, int running)\n{\n\tunsigned long scale_freq, scale_cpu;\n\tu32 contrib = (u32)delta; /* p == 0 -> delta < 1024 */\n\tu64 periods;\n\n\tscale_freq = arch_scale_freq_capacity(cpu);\n\tscale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\tdelta += sa->period_contrib;\n\tperiods = delta / 1024; /* A period is 1024us (~1ms) */\n\n\t/*\n\t * Step 1: decay old *_sum if we crossed period boundaries.\n\t */\n\tif (periods) {\n\t\tsa->load_sum = decay_load(sa->load_sum, periods);\n\t\tsa->runnable_load_sum =\n\t\t\tdecay_load(sa->runnable_load_sum, periods);\n\t\tsa->util_sum = decay_load((u64)(sa->util_sum), periods);\n\n\t\t/*\n\t\t * Step 2\n\t\t */\n\t\tdelta %= 1024;\n\t\tcontrib = __accumulate_pelt_segments(periods,\n\t\t\t\t1024 - sa->period_contrib, delta);\n\t}\n\tsa->period_contrib = delta;\n\n\tcontrib = cap_scale(contrib, scale_freq);\n\tif (load)\n\t\tsa->load_sum += load * contrib;\n\tif (runnable)\n\t\tsa->runnable_load_sum += runnable * contrib;\n\tif (running)\n\t\tsa->util_sum += contrib * scale_cpu;\n\n\treturn periods;\n}"
  },
  {
    "function_name": "__accumulate_pelt_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "62-83",
    "snippet": "static u32 __accumulate_pelt_segments(u64 periods, u32 d1, u32 d3)\n{\n\tu32 c1, c2, c3 = d3; /* y^0 == 1 */\n\n\t/*\n\t * c1 = d1 y^p\n\t */\n\tc1 = decay_load((u64)d1, periods);\n\n\t/*\n\t *            p-1\n\t * c2 = 1024 \\Sum y^n\n\t *            n=1\n\t *\n\t *              inf        inf\n\t *    = 1024 ( \\Sum y^n - \\Sum y^n - y^0 )\n\t *              n=0        n=p\n\t */\n\tc2 = LOAD_AVG_MAX - decay_load(LOAD_AVG_MAX, periods) - 1024;\n\n\treturn c1 + c2 + c3;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decay_load",
          "args": [
            "LOAD_AVG_MAX",
            "periods"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "decay_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
          "lines": "36-60",
          "snippet": "static u64 decay_load(u64 val, u64 n)\n{\n\tunsigned int local_n;\n\n\tif (unlikely(n > LOAD_AVG_PERIOD * 63))\n\t\treturn 0;\n\n\t/* after bounds checking we can collapse to 32-bit */\n\tlocal_n = n;\n\n\t/*\n\t * As y^PERIOD = 1/2, we can combine\n\t *    y^n = 1/2^(n/PERIOD) * y^(n%PERIOD)\n\t * With a look-up table which covers y^n (n<PERIOD)\n\t *\n\t * To achieve constant time decay_load.\n\t */\n\tif (unlikely(local_n >= LOAD_AVG_PERIOD)) {\n\t\tval >>= local_n / LOAD_AVG_PERIOD;\n\t\tlocal_n %= LOAD_AVG_PERIOD;\n\t}\n\n\tval = mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32);\n\treturn val;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched-pelt.h\"",
            "#include \"sched.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic u64 decay_load(u64 val, u64 n)\n{\n\tunsigned int local_n;\n\n\tif (unlikely(n > LOAD_AVG_PERIOD * 63))\n\t\treturn 0;\n\n\t/* after bounds checking we can collapse to 32-bit */\n\tlocal_n = n;\n\n\t/*\n\t * As y^PERIOD = 1/2, we can combine\n\t *    y^n = 1/2^(n/PERIOD) * y^(n%PERIOD)\n\t * With a look-up table which covers y^n (n<PERIOD)\n\t *\n\t * To achieve constant time decay_load.\n\t */\n\tif (unlikely(local_n >= LOAD_AVG_PERIOD)) {\n\t\tval >>= local_n / LOAD_AVG_PERIOD;\n\t\tlocal_n %= LOAD_AVG_PERIOD;\n\t}\n\n\tval = mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32);\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic u32 __accumulate_pelt_segments(u64 periods, u32 d1, u32 d3)\n{\n\tu32 c1, c2, c3 = d3; /* y^0 == 1 */\n\n\t/*\n\t * c1 = d1 y^p\n\t */\n\tc1 = decay_load((u64)d1, periods);\n\n\t/*\n\t *            p-1\n\t * c2 = 1024 \\Sum y^n\n\t *            n=1\n\t *\n\t *              inf        inf\n\t *    = 1024 ( \\Sum y^n - \\Sum y^n - y^0 )\n\t *              n=0        n=p\n\t */\n\tc2 = LOAD_AVG_MAX - decay_load(LOAD_AVG_MAX, periods) - 1024;\n\n\treturn c1 + c2 + c3;\n}"
  },
  {
    "function_name": "decay_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.c",
    "lines": "36-60",
    "snippet": "static u64 decay_load(u64 val, u64 n)\n{\n\tunsigned int local_n;\n\n\tif (unlikely(n > LOAD_AVG_PERIOD * 63))\n\t\treturn 0;\n\n\t/* after bounds checking we can collapse to 32-bit */\n\tlocal_n = n;\n\n\t/*\n\t * As y^PERIOD = 1/2, we can combine\n\t *    y^n = 1/2^(n/PERIOD) * y^(n%PERIOD)\n\t * With a look-up table which covers y^n (n<PERIOD)\n\t *\n\t * To achieve constant time decay_load.\n\t */\n\tif (unlikely(local_n >= LOAD_AVG_PERIOD)) {\n\t\tval >>= local_n / LOAD_AVG_PERIOD;\n\t\tlocal_n %= LOAD_AVG_PERIOD;\n\t}\n\n\tval = mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32);\n\treturn val;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched-pelt.h\"",
      "#include \"sched.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mul_u64_u32_shr",
          "args": [
            "val",
            "runnable_avg_yN_inv[local_n]",
            "32"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "local_n >= LOAD_AVG_PERIOD"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "n > LOAD_AVG_PERIOD * 63"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched-pelt.h\"\n#include \"sched.h\"\n#include <linux/sched.h>\n\nstatic u64 decay_load(u64 val, u64 n)\n{\n\tunsigned int local_n;\n\n\tif (unlikely(n > LOAD_AVG_PERIOD * 63))\n\t\treturn 0;\n\n\t/* after bounds checking we can collapse to 32-bit */\n\tlocal_n = n;\n\n\t/*\n\t * As y^PERIOD = 1/2, we can combine\n\t *    y^n = 1/2^(n/PERIOD) * y^(n%PERIOD)\n\t * With a look-up table which covers y^n (n<PERIOD)\n\t *\n\t * To achieve constant time decay_load.\n\t */\n\tif (unlikely(local_n >= LOAD_AVG_PERIOD)) {\n\t\tval >>= local_n / LOAD_AVG_PERIOD;\n\t\tlocal_n %= LOAD_AVG_PERIOD;\n\t}\n\n\tval = mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32);\n\treturn val;\n}"
  }
]