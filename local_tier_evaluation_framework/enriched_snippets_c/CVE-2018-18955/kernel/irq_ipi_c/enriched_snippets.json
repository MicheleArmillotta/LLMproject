[
  {
    "function_name": "ipi_send_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
    "lines": "328-338",
    "snippet": "int ipi_send_mask(unsigned int virq, const struct cpumask *dest)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_mask(desc, dest);\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ipi_send_mask",
          "args": [
            "desc",
            "dest"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "__ipi_send_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
          "lines": "263-297",
          "snippet": "int __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tunsigned int cpu;\n\n#ifdef DEBUG\n\t/*\n\t * Minimise the overhead by omitting the checks for Linux SMP IPIs.\n\t * Since the callers should be arch or core code which is generally\n\t * trusted, only check for errors when debugging.\n\t */\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n#endif\n\tif (chip->ipi_send_mask) {\n\t\tchip->ipi_send_mask(data, dest);\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_ipi_per_cpu(data->domain)) {\n\t\tunsigned int base = data->irq;\n\n\t\tfor_each_cpu(cpu, dest) {\n\t\t\tunsigned irq = base + cpu - data->common->ipi_offset;\n\n\t\t\tdata = irq_get_irq_data(irq);\n\t\t\tchip->ipi_send_single(data, cpu);\n\t\t}\n\t} else {\n\t\tfor_each_cpu(cpu, dest)\n\t\t\tchip->ipi_send_single(data, cpu);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tunsigned int cpu;\n\n#ifdef DEBUG\n\t/*\n\t * Minimise the overhead by omitting the checks for Linux SMP IPIs.\n\t * Since the callers should be arch or core code which is generally\n\t * trusted, only check for errors when debugging.\n\t */\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n#endif\n\tif (chip->ipi_send_mask) {\n\t\tchip->ipi_send_mask(data, dest);\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_ipi_per_cpu(data->domain)) {\n\t\tunsigned int base = data->irq;\n\n\t\tfor_each_cpu(cpu, dest) {\n\t\t\tunsigned irq = base + cpu - data->common->ipi_offset;\n\n\t\t\tdata = irq_get_irq_data(irq);\n\t\t\tchip->ipi_send_single(data, cpu);\n\t\t}\n\t} else {\n\t\tfor_each_cpu(cpu, dest)\n\t\t\tchip->ipi_send_single(data, cpu);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ipi_send_verify(chip, data, dest, 0)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipi_send_verify",
          "args": [
            "chip",
            "data",
            "dest",
            "0"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "ipi_send_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
          "lines": "186-208",
          "snippet": "static int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\n\n\tif (!chip || !ipimask)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\n\n\tif (!chip || !ipimask)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "virq"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint ipi_send_mask(unsigned int virq, const struct cpumask *dest)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_mask(desc, dest);\n}"
  },
  {
    "function_name": "ipi_send_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
    "lines": "307-317",
    "snippet": "int ipi_send_single(unsigned int virq, unsigned int cpu)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_single(desc, cpu);\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ipi_send_single",
          "args": [
            "desc",
            "cpu"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "__ipi_send_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
          "lines": "221-250",
          "snippet": "int __ipi_send_single(struct irq_desc *desc, unsigned int cpu)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\n#ifdef DEBUG\n\t/*\n\t * Minimise the overhead by omitting the checks for Linux SMP IPIs.\n\t * Since the callers should be arch or core code which is generally\n\t * trusted, only check for errors when debugging.\n\t */\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n#endif\n\tif (!chip->ipi_send_single) {\n\t\tchip->ipi_send_mask(data, cpumask_of(cpu));\n\t\treturn 0;\n\t}\n\n\t/* FIXME: Store this information in irqdata flags */\n\tif (irq_domain_is_ipi_per_cpu(data->domain) &&\n\t    cpu != data->common->ipi_offset) {\n\t\t/* use the correct data for that cpu */\n\t\tunsigned irq = data->irq + cpu - data->common->ipi_offset;\n\n\t\tdata = irq_get_irq_data(irq);\n\t}\n\tchip->ipi_send_single(data, cpu);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint __ipi_send_single(struct irq_desc *desc, unsigned int cpu)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\n#ifdef DEBUG\n\t/*\n\t * Minimise the overhead by omitting the checks for Linux SMP IPIs.\n\t * Since the callers should be arch or core code which is generally\n\t * trusted, only check for errors when debugging.\n\t */\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n#endif\n\tif (!chip->ipi_send_single) {\n\t\tchip->ipi_send_mask(data, cpumask_of(cpu));\n\t\treturn 0;\n\t}\n\n\t/* FIXME: Store this information in irqdata flags */\n\tif (irq_domain_is_ipi_per_cpu(data->domain) &&\n\t    cpu != data->common->ipi_offset) {\n\t\t/* use the correct data for that cpu */\n\t\tunsigned irq = data->irq + cpu - data->common->ipi_offset;\n\n\t\tdata = irq_get_irq_data(irq);\n\t}\n\tchip->ipi_send_single(data, cpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ipi_send_verify(chip, data, NULL, cpu)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipi_send_verify",
          "args": [
            "chip",
            "data",
            "NULL",
            "cpu"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "ipi_send_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
          "lines": "186-208",
          "snippet": "static int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\n\n\tif (!chip || !ipimask)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\n\n\tif (!chip || !ipimask)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "virq"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint ipi_send_single(unsigned int virq, unsigned int cpu)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_single(desc, cpu);\n}"
  },
  {
    "function_name": "__ipi_send_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
    "lines": "263-297",
    "snippet": "int __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tunsigned int cpu;\n\n#ifdef DEBUG\n\t/*\n\t * Minimise the overhead by omitting the checks for Linux SMP IPIs.\n\t * Since the callers should be arch or core code which is generally\n\t * trusted, only check for errors when debugging.\n\t */\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n#endif\n\tif (chip->ipi_send_mask) {\n\t\tchip->ipi_send_mask(data, dest);\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_ipi_per_cpu(data->domain)) {\n\t\tunsigned int base = data->irq;\n\n\t\tfor_each_cpu(cpu, dest) {\n\t\t\tunsigned irq = base + cpu - data->common->ipi_offset;\n\n\t\t\tdata = irq_get_irq_data(irq);\n\t\t\tchip->ipi_send_single(data, cpu);\n\t\t}\n\t} else {\n\t\tfor_each_cpu(cpu, dest)\n\t\t\tchip->ipi_send_single(data, cpu);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "data",
            "cpu"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "dest"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chip->ipi_send_single",
          "args": [
            "data",
            "cpu"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ipi_send_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
          "lines": "307-317",
          "snippet": "int ipi_send_single(unsigned int virq, unsigned int cpu)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_single(desc, cpu);\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint ipi_send_single(unsigned int virq, unsigned int cpu)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_single(desc, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "irq"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "dest"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_is_ipi_per_cpu",
          "args": [
            "data->domain"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chip->ipi_send_mask",
          "args": [
            "data",
            "dest"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ipi_send_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
          "lines": "328-338",
          "snippet": "int ipi_send_mask(unsigned int virq, const struct cpumask *dest)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_mask(desc, dest);\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint ipi_send_mask(unsigned int virq, const struct cpumask *dest)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_mask(desc, dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ipi_send_verify(chip, data, dest, 0)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipi_send_verify",
          "args": [
            "chip",
            "data",
            "dest",
            "0"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "ipi_send_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
          "lines": "186-208",
          "snippet": "static int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\n\n\tif (!chip || !ipimask)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\n\n\tif (!chip || !ipimask)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tunsigned int cpu;\n\n#ifdef DEBUG\n\t/*\n\t * Minimise the overhead by omitting the checks for Linux SMP IPIs.\n\t * Since the callers should be arch or core code which is generally\n\t * trusted, only check for errors when debugging.\n\t */\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n#endif\n\tif (chip->ipi_send_mask) {\n\t\tchip->ipi_send_mask(data, dest);\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_ipi_per_cpu(data->domain)) {\n\t\tunsigned int base = data->irq;\n\n\t\tfor_each_cpu(cpu, dest) {\n\t\t\tunsigned irq = base + cpu - data->common->ipi_offset;\n\n\t\t\tdata = irq_get_irq_data(irq);\n\t\t\tchip->ipi_send_single(data, cpu);\n\t\t}\n\t} else {\n\t\tfor_each_cpu(cpu, dest)\n\t\t\tchip->ipi_send_single(data, cpu);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__ipi_send_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
    "lines": "221-250",
    "snippet": "int __ipi_send_single(struct irq_desc *desc, unsigned int cpu)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\n#ifdef DEBUG\n\t/*\n\t * Minimise the overhead by omitting the checks for Linux SMP IPIs.\n\t * Since the callers should be arch or core code which is generally\n\t * trusted, only check for errors when debugging.\n\t */\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n#endif\n\tif (!chip->ipi_send_single) {\n\t\tchip->ipi_send_mask(data, cpumask_of(cpu));\n\t\treturn 0;\n\t}\n\n\t/* FIXME: Store this information in irqdata flags */\n\tif (irq_domain_is_ipi_per_cpu(data->domain) &&\n\t    cpu != data->common->ipi_offset) {\n\t\t/* use the correct data for that cpu */\n\t\tunsigned irq = data->irq + cpu - data->common->ipi_offset;\n\n\t\tdata = irq_get_irq_data(irq);\n\t}\n\tchip->ipi_send_single(data, cpu);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip->ipi_send_single",
          "args": [
            "data",
            "cpu"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "ipi_send_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
          "lines": "307-317",
          "snippet": "int ipi_send_single(unsigned int virq, unsigned int cpu)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_single(desc, cpu);\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint ipi_send_single(unsigned int virq, unsigned int cpu)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_single(desc, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "irq"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_ipi_per_cpu",
          "args": [
            "data->domain"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chip->ipi_send_mask",
          "args": [
            "data",
            "cpumask_of(cpu)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ipi_send_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
          "lines": "328-338",
          "snippet": "int ipi_send_mask(unsigned int virq, const struct cpumask *dest)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_mask(desc, dest);\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint ipi_send_mask(unsigned int virq, const struct cpumask *dest)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_mask(desc, dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ipi_send_verify(chip, data, NULL, cpu)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipi_send_verify",
          "args": [
            "chip",
            "data",
            "NULL",
            "cpu"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ipi_send_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
          "lines": "186-208",
          "snippet": "static int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\n\n\tif (!chip || !ipimask)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\n\n\tif (!chip || !ipimask)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint __ipi_send_single(struct irq_desc *desc, unsigned int cpu)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\n#ifdef DEBUG\n\t/*\n\t * Minimise the overhead by omitting the checks for Linux SMP IPIs.\n\t * Since the callers should be arch or core code which is generally\n\t * trusted, only check for errors when debugging.\n\t */\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n#endif\n\tif (!chip->ipi_send_single) {\n\t\tchip->ipi_send_mask(data, cpumask_of(cpu));\n\t\treturn 0;\n\t}\n\n\t/* FIXME: Store this information in irqdata flags */\n\tif (irq_domain_is_ipi_per_cpu(data->domain) &&\n\t    cpu != data->common->ipi_offset) {\n\t\t/* use the correct data for that cpu */\n\t\tunsigned irq = data->irq + cpu - data->common->ipi_offset;\n\n\t\tdata = irq_get_irq_data(irq);\n\t}\n\tchip->ipi_send_single(data, cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "ipi_send_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
    "lines": "186-208",
    "snippet": "static int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\n\n\tif (!chip || !ipimask)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "ipimask"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "dest",
            "ipimask"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_affinity_mask",
          "args": [
            "data"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\n\n\tif (!chip || !ipimask)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ipi_get_hwirq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
    "lines": "162-183",
    "snippet": "irq_hw_number_t ipi_get_hwirq(unsigned int irq, unsigned int cpu)\n{\n\tstruct irq_data *data = irq_get_irq_data(irq);\n\tstruct cpumask *ipimask = data ? irq_data_get_affinity_mask(data) : NULL;\n\n\tif (!data || !ipimask || cpu >= nr_cpu_ids)\n\t\treturn INVALID_HWIRQ;\n\n\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\treturn INVALID_HWIRQ;\n\n\t/*\n\t * Get the real hardware irq number if the underlying implementation\n\t * uses a seperate irq per cpu. If the underlying implementation uses\n\t * a single hardware irq for all cpus then the IPI send mechanism\n\t * needs to take care of the cpu destinations.\n\t */\n\tif (irq_domain_is_ipi_per_cpu(data->domain))\n\t\tdata = irq_get_irq_data(irq + cpu - data->common->ipi_offset);\n\n\treturn data ? irqd_to_hwirq(data) : INVALID_HWIRQ;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_to_hwirq",
          "args": [
            "data"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "irq + cpu - data->common->ipi_offset"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_ipi_per_cpu",
          "args": [
            "data->domain"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "ipimask"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_affinity_mask",
          "args": [
            "data"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nirq_hw_number_t ipi_get_hwirq(unsigned int irq, unsigned int cpu)\n{\n\tstruct irq_data *data = irq_get_irq_data(irq);\n\tstruct cpumask *ipimask = data ? irq_data_get_affinity_mask(data) : NULL;\n\n\tif (!data || !ipimask || cpu >= nr_cpu_ids)\n\t\treturn INVALID_HWIRQ;\n\n\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\treturn INVALID_HWIRQ;\n\n\t/*\n\t * Get the real hardware irq number if the underlying implementation\n\t * uses a seperate irq per cpu. If the underlying implementation uses\n\t * a single hardware irq for all cpus then the IPI send mechanism\n\t * needs to take care of the cpu destinations.\n\t */\n\tif (irq_domain_is_ipi_per_cpu(data->domain))\n\t\tdata = irq_get_irq_data(irq + cpu - data->common->ipi_offset);\n\n\treturn data ? irqd_to_hwirq(data) : INVALID_HWIRQ;\n}"
  },
  {
    "function_name": "irq_destroy_ipi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
    "lines": "115-150",
    "snippet": "int irq_destroy_ipi(unsigned int irq, const struct cpumask *dest)\n{\n\tstruct irq_data *data = irq_get_irq_data(irq);\n\tstruct cpumask *ipimask = data ? irq_data_get_affinity_mask(data) : NULL;\n\tstruct irq_domain *domain;\n\tunsigned int nr_irqs;\n\n\tif (!irq || !data || !ipimask)\n\t\treturn -EINVAL;\n\n\tdomain = data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn -EINVAL;\n\n\tif (!irq_domain_is_ipi(domain)) {\n\t\tpr_warn(\"Trying to destroy a non IPI domain!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(!cpumask_subset(dest, ipimask)))\n\t\t/*\n\t\t * Must be destroying a subset of CPUs to which this IPI\n\t\t * was set up to target\n\t\t */\n\t\treturn -EINVAL;\n\n\tif (irq_domain_is_ipi_per_cpu(domain)) {\n\t\tirq = irq + cpumask_first(dest) - data->common->ipi_offset;\n\t\tnr_irqs = cpumask_weight(dest);\n\t} else {\n\t\tnr_irqs = 1;\n\t}\n\n\tirq_domain_free_irqs(irq, nr_irqs);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs",
          "args": [
            "irq",
            "nr_irqs"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1510-1527",
          "snippet": "void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "dest"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "dest"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_is_ipi_per_cpu",
          "args": [
            "domain"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!cpumask_subset(dest, ipimask)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "dest",
            "ipimask"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Trying to destroy a non IPI domain!\\n\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_is_ipi",
          "args": [
            "domain"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "domain == NULL"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_affinity_mask",
          "args": [
            "data"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "irq"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint irq_destroy_ipi(unsigned int irq, const struct cpumask *dest)\n{\n\tstruct irq_data *data = irq_get_irq_data(irq);\n\tstruct cpumask *ipimask = data ? irq_data_get_affinity_mask(data) : NULL;\n\tstruct irq_domain *domain;\n\tunsigned int nr_irqs;\n\n\tif (!irq || !data || !ipimask)\n\t\treturn -EINVAL;\n\n\tdomain = data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn -EINVAL;\n\n\tif (!irq_domain_is_ipi(domain)) {\n\t\tpr_warn(\"Trying to destroy a non IPI domain!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(!cpumask_subset(dest, ipimask)))\n\t\t/*\n\t\t * Must be destroying a subset of CPUs to which this IPI\n\t\t * was set up to target\n\t\t */\n\t\treturn -EINVAL;\n\n\tif (irq_domain_is_ipi_per_cpu(domain)) {\n\t\tirq = irq + cpumask_first(dest) - data->common->ipi_offset;\n\t\tnr_irqs = cpumask_weight(dest);\n\t} else {\n\t\tnr_irqs = 1;\n\t}\n\n\tirq_domain_free_irqs(irq, nr_irqs);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_reserve_ipi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/ipi.c",
    "lines": "23-103",
    "snippet": "int irq_reserve_ipi(struct irq_domain *domain,\n\t\t\t     const struct cpumask *dest)\n{\n\tunsigned int nr_irqs, offset;\n\tstruct irq_data *data;\n\tint virq, i;\n\n\tif (!domain ||!irq_domain_is_ipi(domain)) {\n\t\tpr_warn(\"Reservation on a non IPI domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cpumask_subset(dest, cpu_possible_mask)) {\n\t\tpr_warn(\"Reservation is not in possible_cpu_mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnr_irqs = cpumask_weight(dest);\n\tif (!nr_irqs) {\n\t\tpr_warn(\"Reservation for empty destination mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (irq_domain_is_ipi_single(domain)) {\n\t\t/*\n\t\t * If the underlying implementation uses a single HW irq on\n\t\t * all cpus then we only need a single Linux irq number for\n\t\t * it. We have no restrictions vs. the destination mask. The\n\t\t * underlying implementation can deal with holes nicely.\n\t\t */\n\t\tnr_irqs = 1;\n\t\toffset = 0;\n\t} else {\n\t\tunsigned int next;\n\n\t\t/*\n\t\t * The IPI requires a seperate HW irq on each CPU. We require\n\t\t * that the destination mask is consecutive. If an\n\t\t * implementation needs to support holes, it can reserve\n\t\t * several IPI ranges.\n\t\t */\n\t\toffset = cpumask_first(dest);\n\t\t/*\n\t\t * Find a hole and if found look for another set bit after the\n\t\t * hole. For now we don't support this scenario.\n\t\t */\n\t\tnext = cpumask_next_zero(offset, dest);\n\t\tif (next < nr_cpu_ids)\n\t\t\tnext = cpumask_next(next, dest);\n\t\tif (next < nr_cpu_ids) {\n\t\t\tpr_warn(\"Destination mask has holes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tvirq = irq_domain_alloc_descs(-1, nr_irqs, 0, NUMA_NO_NODE, NULL);\n\tif (virq <= 0) {\n\t\tpr_warn(\"Can't reserve IPI, failed to alloc descs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvirq = __irq_domain_alloc_irqs(domain, virq, nr_irqs, NUMA_NO_NODE,\n\t\t\t\t       (void *) dest, true, NULL);\n\n\tif (virq <= 0) {\n\t\tpr_warn(\"Can't reserve IPI, failed to alloc hw irqs\\n\");\n\t\tgoto free_descs;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tdata = irq_get_irq_data(virq + i);\n\t\tcpumask_copy(data->common->affinity, dest);\n\t\tdata->common->ipi_offset = offset;\n\t\tirq_set_status_flags(virq + i, IRQ_NO_BALANCING);\n\t}\n\treturn virq;\n\nfree_descs:\n\tirq_free_descs(virq, nr_irqs);\n\treturn -EBUSY;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_free_descs",
          "args": [
            "virq",
            "nr_irqs"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "irq_free_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "677-690",
          "snippet": "void irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nr_irqs = NR_IRQS;",
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nint nr_irqs = NR_IRQS;\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_status_flags",
          "args": [
            "virq + i",
            "IRQ_NO_BALANCING"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "data->common->affinity",
            "dest"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq + i"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Can't reserve IPI, failed to alloc hw irqs\\n\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_domain_alloc_irqs",
          "args": [
            "domain",
            "virq",
            "nr_irqs",
            "NUMA_NO_NODE",
            "(void *) dest",
            "true",
            "NULL"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_alloc_irqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1282-1334",
          "snippet": "int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc, const struct cpumask *affinity)\n{\n\tint i, ret, virq;\n\n\tif (domain == NULL) {\n\t\tdomain = irq_default_domain;\n\t\tif (WARN(!domain, \"domain is NULL; cannot allocate IRQ\\n\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,\n\t\t\t\t\t      affinity);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"cannot allocate IRQ(base %d, count %d)\\n\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"cannot allocate memory for IRQ%d\\n\", virq);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_desc;\n\t}\n\n\tmutex_lock(&irq_domain_mutex);\n\tret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\tgoto out_free_irq_data;\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static struct irq_domain *irq_default_domain;",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc, const struct cpumask *affinity)\n{\n\tint i, ret, virq;\n\n\tif (domain == NULL) {\n\t\tdomain = irq_default_domain;\n\t\tif (WARN(!domain, \"domain is NULL; cannot allocate IRQ\\n\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,\n\t\t\t\t\t      affinity);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"cannot allocate IRQ(base %d, count %d)\\n\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"cannot allocate memory for IRQ%d\\n\", virq);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_desc;\n\t}\n\n\tmutex_lock(&irq_domain_mutex);\n\tret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\tgoto out_free_irq_data;\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Can't reserve IPI, failed to alloc descs\\n\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_descs",
          "args": [
            "-1",
            "nr_irqs",
            "0",
            "NUMA_NO_NODE",
            "NULL"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "971-992",
          "snippet": "int irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct cpumask *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct cpumask *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Destination mask has holes\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "next",
            "dest"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next_zero",
          "args": [
            "offset",
            "dest"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "dest"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_is_ipi_single",
          "args": [
            "domain"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Reservation for empty destination mask\\n\""
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "dest"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Reservation is not in possible_cpu_mask\\n\""
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "dest",
            "cpu_possible_mask"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Reservation on a non IPI domain\\n\""
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_is_ipi",
          "args": [
            "domain"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nint irq_reserve_ipi(struct irq_domain *domain,\n\t\t\t     const struct cpumask *dest)\n{\n\tunsigned int nr_irqs, offset;\n\tstruct irq_data *data;\n\tint virq, i;\n\n\tif (!domain ||!irq_domain_is_ipi(domain)) {\n\t\tpr_warn(\"Reservation on a non IPI domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cpumask_subset(dest, cpu_possible_mask)) {\n\t\tpr_warn(\"Reservation is not in possible_cpu_mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnr_irqs = cpumask_weight(dest);\n\tif (!nr_irqs) {\n\t\tpr_warn(\"Reservation for empty destination mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (irq_domain_is_ipi_single(domain)) {\n\t\t/*\n\t\t * If the underlying implementation uses a single HW irq on\n\t\t * all cpus then we only need a single Linux irq number for\n\t\t * it. We have no restrictions vs. the destination mask. The\n\t\t * underlying implementation can deal with holes nicely.\n\t\t */\n\t\tnr_irqs = 1;\n\t\toffset = 0;\n\t} else {\n\t\tunsigned int next;\n\n\t\t/*\n\t\t * The IPI requires a seperate HW irq on each CPU. We require\n\t\t * that the destination mask is consecutive. If an\n\t\t * implementation needs to support holes, it can reserve\n\t\t * several IPI ranges.\n\t\t */\n\t\toffset = cpumask_first(dest);\n\t\t/*\n\t\t * Find a hole and if found look for another set bit after the\n\t\t * hole. For now we don't support this scenario.\n\t\t */\n\t\tnext = cpumask_next_zero(offset, dest);\n\t\tif (next < nr_cpu_ids)\n\t\t\tnext = cpumask_next(next, dest);\n\t\tif (next < nr_cpu_ids) {\n\t\t\tpr_warn(\"Destination mask has holes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tvirq = irq_domain_alloc_descs(-1, nr_irqs, 0, NUMA_NO_NODE, NULL);\n\tif (virq <= 0) {\n\t\tpr_warn(\"Can't reserve IPI, failed to alloc descs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvirq = __irq_domain_alloc_irqs(domain, virq, nr_irqs, NUMA_NO_NODE,\n\t\t\t\t       (void *) dest, true, NULL);\n\n\tif (virq <= 0) {\n\t\tpr_warn(\"Can't reserve IPI, failed to alloc hw irqs\\n\");\n\t\tgoto free_descs;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tdata = irq_get_irq_data(virq + i);\n\t\tcpumask_copy(data->common->affinity, dest);\n\t\tdata->common->ipi_offset = offset;\n\t\tirq_set_status_flags(virq + i, IRQ_NO_BALANCING);\n\t}\n\treturn virq;\n\nfree_descs:\n\tirq_free_descs(virq, nr_irqs);\n\treturn -EBUSY;\n}"
  }
]