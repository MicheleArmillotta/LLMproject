[
  {
    "function_name": "kallsyms_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "705-709",
    "snippet": "static int __init kallsyms_init(void)\n{\n\tproc_create(\"kallsyms\", 0444, NULL, &kallsyms_operations);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations kallsyms_operations = {\n\t.open = kallsyms_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release_private,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"kallsyms\"",
            "0444",
            "NULL",
            "&kallsyms_operations"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic const struct file_operations kallsyms_operations = {\n\t.open = kallsyms_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release_private,\n};\n\nstatic int __init kallsyms_init(void)\n{\n\tproc_create(\"kallsyms\", 0444, NULL, &kallsyms_operations);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_walk_kallsyms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "679-695",
    "snippet": "const char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_iter",
          "args": [
            "&kdb_walk_kallsyms_iter",
            "*pos"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "update_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "556-570",
          "snippet": "static int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_iter",
          "args": [
            "&kdb_walk_kallsyms_iter",
            "0"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "reset_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "519-529",
          "snippet": "static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t}\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&kdb_walk_kallsyms_iter",
            "0",
            "sizeof(kdb_walk_kallsyms_iter)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}"
  },
  {
    "function_name": "kallsyms_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "661-676",
    "snippet": "static int kallsyms_open(struct inode *inode, struct file *file)\n{\n\t/*\n\t * We keep iterator in m->private, since normal case is to\n\t * s_start from where we left off, so we avoid doing\n\t * using get_symbol_offset for every symbol.\n\t */\n\tstruct kallsym_iter *iter;\n\titer = __seq_open_private(file, &kallsyms_op, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\treset_iter(iter, 0);\n\n\titer->show_value = kallsyms_show_value();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations kallsyms_op = {\n\t.start = s_start,\n\t.next = s_next,\n\t.stop = s_stop,\n\t.show = s_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_show_value",
          "args": [],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_show_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "645-659",
          "snippet": "int kallsyms_show_value(void)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn 1;\n\t/* fallthrough */\n\tcase 1:\n\t\tif (has_capability_noaudit(current, CAP_SYSLOG))\n\t\t\treturn 1;\n\t/* fallthrough */\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_show_value(void)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn 1;\n\t/* fallthrough */\n\tcase 1:\n\t\tif (has_capability_noaudit(current, CAP_SYSLOG))\n\t\t\treturn 1;\n\t/* fallthrough */\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_iter",
          "args": [
            "iter",
            "0"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "reset_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "519-529",
          "snippet": "static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t}\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "&kallsyms_op",
            "sizeof(*iter)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic const struct seq_operations kallsyms_op = {\n\t.start = s_start,\n\t.next = s_next,\n\t.stop = s_stop,\n\t.show = s_show\n};\n\nstatic int kallsyms_open(struct inode *inode, struct file *file)\n{\n\t/*\n\t * We keep iterator in m->private, since normal case is to\n\t * s_start from where we left off, so we avoid doing\n\t * using get_symbol_offset for every symbol.\n\t */\n\tstruct kallsym_iter *iter;\n\titer = __seq_open_private(file, &kallsyms_op, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\treset_iter(iter, 0);\n\n\titer->show_value = kallsyms_show_value();\n\treturn 0;\n}"
  },
  {
    "function_name": "kallsyms_show_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "645-659",
    "snippet": "int kallsyms_show_value(void)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn 1;\n\t/* fallthrough */\n\tcase 1:\n\t\tif (has_capability_noaudit(current, CAP_SYSLOG))\n\t\t\treturn 1;\n\t/* fallthrough */\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_capability_noaudit",
          "args": [
            "current",
            "CAP_SYSLOG"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "has_capability_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "361-364",
          "snippet": "bool has_capability_noaudit(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool has_capability_noaudit(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_for_perf",
          "args": [],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_for_perf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "627-635",
          "snippet": "static inline int kallsyms_for_perf(void)\n{\n#ifdef CONFIG_PERF_EVENTS\n\textern int sysctl_perf_event_paranoid;\n\tif (sysctl_perf_event_paranoid <= 1)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic inline int kallsyms_for_perf(void)\n{\n#ifdef CONFIG_PERF_EVENTS\n\textern int sysctl_perf_event_paranoid;\n\tif (sysctl_perf_event_paranoid <= 1)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_show_value(void)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn 1;\n\t/* fallthrough */\n\tcase 1:\n\t\tif (has_capability_noaudit(current, CAP_SYSLOG))\n\t\t\treturn 1;\n\t/* fallthrough */\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "kallsyms_for_perf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "627-635",
    "snippet": "static inline int kallsyms_for_perf(void)\n{\n#ifdef CONFIG_PERF_EVENTS\n\textern int sysctl_perf_event_paranoid;\n\tif (sysctl_perf_event_paranoid <= 1)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic inline int kallsyms_for_perf(void)\n{\n#ifdef CONFIG_PERF_EVENTS\n\textern int sysctl_perf_event_paranoid;\n\tif (sysctl_perf_event_paranoid <= 1)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "s_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "592-618",
    "snippet": "static int s_show(struct seq_file *m, void *p)\n{\n\tvoid *value;\n\tstruct kallsym_iter *iter = m->private;\n\n\t/* Some debugging symbols have no name.  Ignore them. */\n\tif (!iter->name[0])\n\t\treturn 0;\n\n\tvalue = iter->show_value ? (void *)iter->value : NULL;\n\n\tif (iter->module_name[0]) {\n\t\tchar type;\n\n\t\t/*\n\t\t * Label it \"global\" if it is exported,\n\t\t * \"local\" if not exported.\n\t\t */\n\t\ttype = iter->exported ? toupper(iter->type) :\n\t\t\t\t\ttolower(iter->type);\n\t\tseq_printf(m, \"%px %c %s\\t[%s]\\n\", value,\n\t\t\t   type, iter->name, iter->module_name);\n\t} else\n\t\tseq_printf(m, \"%px %c %s\\n\", value,\n\t\t\t   iter->type, iter->name);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%px %c %s\\n\"",
            "value",
            "iter->type",
            "iter->name"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "iter->type"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "iter->type"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int s_show(struct seq_file *m, void *p)\n{\n\tvoid *value;\n\tstruct kallsym_iter *iter = m->private;\n\n\t/* Some debugging symbols have no name.  Ignore them. */\n\tif (!iter->name[0])\n\t\treturn 0;\n\n\tvalue = iter->show_value ? (void *)iter->value : NULL;\n\n\tif (iter->module_name[0]) {\n\t\tchar type;\n\n\t\t/*\n\t\t * Label it \"global\" if it is exported,\n\t\t * \"local\" if not exported.\n\t\t */\n\t\ttype = iter->exported ? toupper(iter->type) :\n\t\t\t\t\ttolower(iter->type);\n\t\tseq_printf(m, \"%px %c %s\\t[%s]\\n\", value,\n\t\t\t   type, iter->name, iter->module_name);\n\t} else\n\t\tseq_printf(m, \"%px %c %s\\n\", value,\n\t\t\t   iter->type, iter->name);\n\treturn 0;\n}"
  },
  {
    "function_name": "s_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "588-590",
    "snippet": "static void s_stop(struct seq_file *m, void *p)\n{\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void s_stop(struct seq_file *m, void *p)\n{\n}"
  },
  {
    "function_name": "s_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "581-586",
    "snippet": "static void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tif (!update_iter(m->private, *pos))\n\t\treturn NULL;\n\treturn m->private;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_iter",
          "args": [
            "m->private",
            "*pos"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "update_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "556-570",
          "snippet": "static int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tif (!update_iter(m->private, *pos))\n\t\treturn NULL;\n\treturn m->private;\n}"
  },
  {
    "function_name": "s_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "572-579",
    "snippet": "static void *s_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\t(*pos)++;\n\n\tif (!update_iter(m->private, *pos))\n\t\treturn NULL;\n\treturn p;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_iter",
          "args": [
            "m->private",
            "*pos"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "update_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "556-570",
          "snippet": "static int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void *s_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\t(*pos)++;\n\n\tif (!update_iter(m->private, *pos))\n\t\treturn NULL;\n\treturn p;\n}"
  },
  {
    "function_name": "update_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "556-570",
    "snippet": "static int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned int kallsyms_num_syms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_ksymbol_core",
          "args": [
            "iter"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "505-517",
          "snippet": "static unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->nameoff;\n\n\titer->module_name[0] = '\\0';\n\titer->value = kallsyms_sym_address(iter->pos);\n\n\titer->type = kallsyms_get_symbol_type(off);\n\n\toff = kallsyms_expand_symbol(off, iter->name, ARRAY_SIZE(iter->name));\n\n\treturn off - iter->nameoff;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->nameoff;\n\n\titer->module_name[0] = '\\0';\n\titer->value = kallsyms_sym_address(iter->pos);\n\n\titer->type = kallsyms_get_symbol_type(off);\n\n\toff = kallsyms_expand_symbol(off, iter->name, ARRAY_SIZE(iter->name));\n\n\treturn off - iter->nameoff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_iter",
          "args": [
            "iter",
            "pos"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "reset_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "519-529",
          "snippet": "static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t}\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_iter_mod",
          "args": [
            "iter",
            "pos"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "update_iter_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "536-553",
          "snippet": "static int update_iter_mod(struct kallsym_iter *iter, loff_t pos)\n{\n\titer->pos = pos;\n\n\tif ((!iter->pos_arch_end || iter->pos_arch_end > pos) &&\n\t    get_ksymbol_arch(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_mod_end || iter->pos_mod_end > pos) &&\n\t    get_ksymbol_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_ftrace_mod_end || iter->pos_ftrace_mod_end > pos) &&\n\t    get_ksymbol_ftrace_mod(iter))\n\t\treturn 1;\n\n\treturn get_ksymbol_bpf(iter);\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int update_iter_mod(struct kallsym_iter *iter, loff_t pos)\n{\n\titer->pos = pos;\n\n\tif ((!iter->pos_arch_end || iter->pos_arch_end > pos) &&\n\t    get_ksymbol_arch(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_mod_end || iter->pos_mod_end > pos) &&\n\t    get_ksymbol_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_ftrace_mod_end || iter->pos_ftrace_mod_end > pos) &&\n\t    get_ksymbol_ftrace_mod(iter))\n\t\treturn 1;\n\n\treturn get_ksymbol_bpf(iter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "update_iter_mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "536-553",
    "snippet": "static int update_iter_mod(struct kallsym_iter *iter, loff_t pos)\n{\n\titer->pos = pos;\n\n\tif ((!iter->pos_arch_end || iter->pos_arch_end > pos) &&\n\t    get_ksymbol_arch(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_mod_end || iter->pos_mod_end > pos) &&\n\t    get_ksymbol_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_ftrace_mod_end || iter->pos_ftrace_mod_end > pos) &&\n\t    get_ksymbol_ftrace_mod(iter))\n\t\treturn 1;\n\n\treturn get_ksymbol_bpf(iter);\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_ksymbol_bpf",
          "args": [
            "iter"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_bpf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "495-502",
          "snippet": "static int get_ksymbol_bpf(struct kallsym_iter *iter)\n{\n\titer->module_name[0] = '\\0';\n\titer->exported = 0;\n\treturn bpf_get_kallsym(iter->pos - iter->pos_ftrace_mod_end,\n\t\t\t       &iter->value, &iter->type,\n\t\t\t       iter->name) < 0 ? 0 : 1;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_bpf(struct kallsym_iter *iter)\n{\n\titer->module_name[0] = '\\0';\n\titer->exported = 0;\n\treturn bpf_get_kallsym(iter->pos - iter->pos_ftrace_mod_end,\n\t\t\t       &iter->value, &iter->type,\n\t\t\t       iter->name) < 0 ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ksymbol_ftrace_mod",
          "args": [
            "iter"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_ftrace_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "481-493",
          "snippet": "static int get_ksymbol_ftrace_mod(struct kallsym_iter *iter)\n{\n\tint ret = ftrace_mod_get_kallsym(iter->pos - iter->pos_mod_end,\n\t\t\t\t\t &iter->value, &iter->type,\n\t\t\t\t\t iter->name, iter->module_name,\n\t\t\t\t\t &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_ftrace_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_ftrace_mod(struct kallsym_iter *iter)\n{\n\tint ret = ftrace_mod_get_kallsym(iter->pos - iter->pos_mod_end,\n\t\t\t\t\t &iter->value, &iter->type,\n\t\t\t\t\t iter->name, iter->module_name,\n\t\t\t\t\t &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_ftrace_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ksymbol_mod",
          "args": [
            "iter"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "467-479",
          "snippet": "static int get_ksymbol_mod(struct kallsym_iter *iter)\n{\n\tint ret = module_get_kallsym(iter->pos - iter->pos_arch_end,\n\t\t\t\t     &iter->value, &iter->type,\n\t\t\t\t     iter->name, iter->module_name,\n\t\t\t\t     &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_mod(struct kallsym_iter *iter)\n{\n\tint ret = module_get_kallsym(iter->pos - iter->pos_arch_end,\n\t\t\t\t     &iter->value, &iter->type,\n\t\t\t\t     iter->name, iter->module_name,\n\t\t\t\t     &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ksymbol_arch",
          "args": [
            "iter"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_arch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "453-465",
          "snippet": "static int get_ksymbol_arch(struct kallsym_iter *iter)\n{\n\tint ret = arch_get_kallsym(iter->pos - kallsyms_num_syms,\n\t\t\t\t   &iter->value, &iter->type,\n\t\t\t\t   iter->name);\n\n\tif (ret < 0) {\n\t\titer->pos_arch_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int get_ksymbol_arch(struct kallsym_iter *iter)\n{\n\tint ret = arch_get_kallsym(iter->pos - kallsyms_num_syms,\n\t\t\t\t   &iter->value, &iter->type,\n\t\t\t\t   iter->name);\n\n\tif (ret < 0) {\n\t\titer->pos_arch_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int update_iter_mod(struct kallsym_iter *iter, loff_t pos)\n{\n\titer->pos = pos;\n\n\tif ((!iter->pos_arch_end || iter->pos_arch_end > pos) &&\n\t    get_ksymbol_arch(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_mod_end || iter->pos_mod_end > pos) &&\n\t    get_ksymbol_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_ftrace_mod_end || iter->pos_ftrace_mod_end > pos) &&\n\t    get_ksymbol_ftrace_mod(iter))\n\t\treturn 1;\n\n\treturn get_ksymbol_bpf(iter);\n}"
  },
  {
    "function_name": "reset_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "519-529",
    "snippet": "static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t}\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_symbol_offset",
          "args": [
            "new_pos"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "121-142",
          "snippet": "static unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const unsigned int kallsyms_markers[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const unsigned int kallsyms_markers[] __weak;\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t}\n}"
  },
  {
    "function_name": "get_ksymbol_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "505-517",
    "snippet": "static unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->nameoff;\n\n\titer->module_name[0] = '\\0';\n\titer->value = kallsyms_sym_address(iter->pos);\n\n\titer->type = kallsyms_get_symbol_type(off);\n\n\toff = kallsyms_expand_symbol(off, iter->name, ARRAY_SIZE(iter->name));\n\n\treturn off - iter->nameoff;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "off",
            "iter->name",
            "ARRAY_SIZE(iter->name)"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "56-101",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const u8 kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const u8 kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "iter->name"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_get_symbol_type",
          "args": [
            "off"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_get_symbol_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "107-114",
          "snippet": "static char kallsyms_get_symbol_type(unsigned int off)\n{\n\t/*\n\t * Get just the first code, look it up in the token table,\n\t * and return the first char from this token.\n\t */\n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const u8 kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const u8 kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic char kallsyms_get_symbol_type(unsigned int off)\n{\n\t/*\n\t * Get just the first code, look it up in the token table,\n\t * and return the first char from this token.\n\t */\n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_sym_address",
          "args": [
            "iter->pos"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_sym_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "144-159",
          "snippet": "static unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\n\nstatic unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->nameoff;\n\n\titer->module_name[0] = '\\0';\n\titer->value = kallsyms_sym_address(iter->pos);\n\n\titer->type = kallsyms_get_symbol_type(off);\n\n\toff = kallsyms_expand_symbol(off, iter->name, ARRAY_SIZE(iter->name));\n\n\treturn off - iter->nameoff;\n}"
  },
  {
    "function_name": "get_ksymbol_bpf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "495-502",
    "snippet": "static int get_ksymbol_bpf(struct kallsym_iter *iter)\n{\n\titer->module_name[0] = '\\0';\n\titer->exported = 0;\n\treturn bpf_get_kallsym(iter->pos - iter->pos_ftrace_mod_end,\n\t\t\t       &iter->value, &iter->type,\n\t\t\t       iter->name) < 0 ? 0 : 1;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_get_kallsym",
          "args": [
            "iter->pos - iter->pos_ftrace_mod_end",
            "&iter->value",
            "&iter->type",
            "iter->name"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_kallsym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "553-581",
          "snippet": "int bpf_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t    char *sym)\n{\n\tunsigned long symbol_start, symbol_end;\n\tstruct bpf_prog_aux *aux;\n\tunsigned int it = 0;\n\tint ret = -ERANGE;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn ret;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(aux, &bpf_kallsyms, ksym_lnode) {\n\t\tif (it++ != symnum)\n\t\t\tcontinue;\n\n\t\tbpf_get_prog_addr_region(aux->prog, &symbol_start, &symbol_end);\n\t\tbpf_get_prog_name(aux->prog, sym);\n\n\t\t*value = symbol_start;\n\t\t*type  = BPF_SYM_ELF_TYPE;\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t    char *sym)\n{\n\tunsigned long symbol_start, symbol_end;\n\tstruct bpf_prog_aux *aux;\n\tunsigned int it = 0;\n\tint ret = -ERANGE;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn ret;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(aux, &bpf_kallsyms, ksym_lnode) {\n\t\tif (it++ != symnum)\n\t\t\tcontinue;\n\n\t\tbpf_get_prog_addr_region(aux->prog, &symbol_start, &symbol_end);\n\t\tbpf_get_prog_name(aux->prog, sym);\n\n\t\t*value = symbol_start;\n\t\t*type  = BPF_SYM_ELF_TYPE;\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_bpf(struct kallsym_iter *iter)\n{\n\titer->module_name[0] = '\\0';\n\titer->exported = 0;\n\treturn bpf_get_kallsym(iter->pos - iter->pos_ftrace_mod_end,\n\t\t\t       &iter->value, &iter->type,\n\t\t\t       iter->name) < 0 ? 0 : 1;\n}"
  },
  {
    "function_name": "get_ksymbol_ftrace_mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "481-493",
    "snippet": "static int get_ksymbol_ftrace_mod(struct kallsym_iter *iter)\n{\n\tint ret = ftrace_mod_get_kallsym(iter->pos - iter->pos_mod_end,\n\t\t\t\t\t &iter->value, &iter->type,\n\t\t\t\t\t iter->name, iter->module_name,\n\t\t\t\t\t &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_ftrace_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_mod_get_kallsym",
          "args": [
            "iter->pos - iter->pos_mod_end",
            "&iter->value",
            "&iter->type",
            "iter->name",
            "iter->module_name",
            "&iter->exported"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_mod_get_kallsym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5945-5979",
          "snippet": "int ftrace_mod_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t   char *type, char *name,\n\t\t\t   char *module_name, int *exported)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_func *mod_func;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\n\t\tif (symnum >= mod_map->num_funcs) {\n\t\t\tsymnum -= mod_map->num_funcs;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\t\tif (symnum > 1) {\n\t\t\t\tsymnum--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t*value = mod_func->ip;\n\t\t\t*type = 'T';\n\t\t\tstrlcpy(name, mod_func->name, KSYM_NAME_LEN);\n\t\t\tstrlcpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = 1;\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\tpreempt_enable();\n\treturn -ERANGE;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_mod_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t   char *type, char *name,\n\t\t\t   char *module_name, int *exported)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_func *mod_func;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\n\t\tif (symnum >= mod_map->num_funcs) {\n\t\t\tsymnum -= mod_map->num_funcs;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\t\tif (symnum > 1) {\n\t\t\t\tsymnum--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t*value = mod_func->ip;\n\t\t\t*type = 'T';\n\t\t\tstrlcpy(name, mod_func->name, KSYM_NAME_LEN);\n\t\t\tstrlcpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = 1;\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\tpreempt_enable();\n\treturn -ERANGE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_ftrace_mod(struct kallsym_iter *iter)\n{\n\tint ret = ftrace_mod_get_kallsym(iter->pos - iter->pos_mod_end,\n\t\t\t\t\t &iter->value, &iter->type,\n\t\t\t\t\t iter->name, iter->module_name,\n\t\t\t\t\t &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_ftrace_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "get_ksymbol_mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "467-479",
    "snippet": "static int get_ksymbol_mod(struct kallsym_iter *iter)\n{\n\tint ret = module_get_kallsym(iter->pos - iter->pos_arch_end,\n\t\t\t\t     &iter->value, &iter->type,\n\t\t\t\t     iter->name, iter->module_name,\n\t\t\t\t     &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_get_kallsym",
          "args": [
            "iter->pos - iter->pos_arch_end",
            "&iter->value",
            "&iter->type",
            "iter->name",
            "iter->module_name",
            "&iter->exported"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "module_get_kallsym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4050-4075",
          "snippet": "int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t\tchar *name, char *module_name, int *exported)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tstruct mod_kallsyms *kallsyms;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tkallsyms = rcu_dereference_sched(mod->kallsyms);\n\t\tif (symnum < kallsyms->num_symtab) {\n\t\t\t*value = kallsyms->symtab[symnum].st_value;\n\t\t\t*type = kallsyms->symtab[symnum].st_info;\n\t\t\tstrlcpy(name, symname(kallsyms, symnum), KSYM_NAME_LEN);\n\t\t\tstrlcpy(module_name, mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = is_exported(name, *value, mod);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tsymnum -= kallsyms->num_symtab;\n\t}\n\tpreempt_enable();\n\treturn -ERANGE;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nint module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t\tchar *name, char *module_name, int *exported)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tstruct mod_kallsyms *kallsyms;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tkallsyms = rcu_dereference_sched(mod->kallsyms);\n\t\tif (symnum < kallsyms->num_symtab) {\n\t\t\t*value = kallsyms->symtab[symnum].st_value;\n\t\t\t*type = kallsyms->symtab[symnum].st_info;\n\t\t\tstrlcpy(name, symname(kallsyms, symnum), KSYM_NAME_LEN);\n\t\t\tstrlcpy(module_name, mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = is_exported(name, *value, mod);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tsymnum -= kallsyms->num_symtab;\n\t}\n\tpreempt_enable();\n\treturn -ERANGE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_mod(struct kallsym_iter *iter)\n{\n\tint ret = module_get_kallsym(iter->pos - iter->pos_arch_end,\n\t\t\t\t     &iter->value, &iter->type,\n\t\t\t\t     iter->name, iter->module_name,\n\t\t\t\t     &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "get_ksymbol_arch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "453-465",
    "snippet": "static int get_ksymbol_arch(struct kallsym_iter *iter)\n{\n\tint ret = arch_get_kallsym(iter->pos - kallsyms_num_syms,\n\t\t\t\t   &iter->value, &iter->type,\n\t\t\t\t   iter->name);\n\n\tif (ret < 0) {\n\t\titer->pos_arch_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned int kallsyms_num_syms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_get_kallsym",
          "args": [
            "iter->pos - kallsyms_num_syms",
            "&iter->value",
            "&iter->type",
            "iter->name"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "arch_get_kallsym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "447-451",
          "snippet": "int __weak arch_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t    char *type, char *name)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint __weak arch_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t    char *type, char *name)\n{\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int get_ksymbol_arch(struct kallsym_iter *iter)\n{\n\tint ret = arch_get_kallsym(iter->pos - kallsyms_num_syms,\n\t\t\t\t   &iter->value, &iter->type,\n\t\t\t\t   iter->name);\n\n\tif (ret < 0) {\n\t\titer->pos_arch_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "arch_get_kallsym",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "447-451",
    "snippet": "int __weak arch_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t    char *type, char *name)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint __weak arch_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t    char *type, char *name)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "sprint_backtrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "427-430",
    "snippet": "int sprint_backtrace(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, -1, 1);\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sprint_symbol",
          "args": [
            "buffer",
            "address",
            "-1",
            "1"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "__sprint_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "352-377",
          "snippet": "static int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset)\n{\n\tchar *modname;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup(address, &size, &offset, &modname, buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname)\n\t\tlen += sprintf(buffer + len, \" [%s]\", modname);\n\n\treturn len;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset)\n{\n\tchar *modname;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup(address, &size, &offset, &modname, buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname)\n\t\tlen += sprintf(buffer + len, \" [%s]\", modname);\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_backtrace(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, -1, 1);\n}"
  },
  {
    "function_name": "sprint_symbol_no_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "407-410",
    "snippet": "int sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0);\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sprint_symbol",
          "args": [
            "buffer",
            "address",
            "0",
            "0"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "__sprint_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "352-377",
          "snippet": "static int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset)\n{\n\tchar *modname;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup(address, &size, &offset, &modname, buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname)\n\t\tlen += sprintf(buffer + len, \" [%s]\", modname);\n\n\treturn len;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset)\n{\n\tchar *modname;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup(address, &size, &offset, &modname, buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname)\n\t\tlen += sprintf(buffer + len, \" [%s]\", modname);\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0);\n}"
  },
  {
    "function_name": "sprint_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "390-393",
    "snippet": "int sprint_symbol(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 1);\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sprint_symbol",
          "args": [
            "buffer",
            "address",
            "0",
            "1"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "__sprint_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "352-377",
          "snippet": "static int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset)\n{\n\tchar *modname;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup(address, &size, &offset, &modname, buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname)\n\t\tlen += sprintf(buffer + len, \" [%s]\", modname);\n\n\treturn len;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset)\n{\n\tchar *modname;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup(address, &size, &offset, &modname, buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname)\n\t\tlen += sprintf(buffer + len, \" [%s]\", modname);\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_symbol(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 1);\n}"
  },
  {
    "function_name": "__sprint_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "352-377",
    "snippet": "static int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset)\n{\n\tchar *modname;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup(address, &size, &offset, &modname, buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname)\n\t\tlen += sprintf(buffer + len, \" [%s]\", modname);\n\n\treturn len;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer + len",
            "\" [%s]\"",
            "modname"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer + len",
            "\"+%#lx/%#lx\"",
            "offset",
            "size"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "name"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"0x%lx\"",
            "address - symbol_offset"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "address",
            "&size",
            "&offset",
            "&modname",
            "buffer"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "278-311",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset)\n{\n\tchar *modname;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup(address, &size, &offset, &modname, buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname)\n\t\tlen += sprintf(buffer + len, \" [%s]\", modname);\n\n\treturn len;\n}"
  },
  {
    "function_name": "lookup_symbol_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "331-349",
    "snippet": "int lookup_symbol_attrs(unsigned long addr, unsigned long *size,\n\t\t\tunsigned long *offset, char *modname, char *name)\n{\n\tname[0] = '\\0';\n\tname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, size, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       name, KSYM_NAME_LEN);\n\t\tmodname[0] = '\\0';\n\t\treturn 0;\n\t}\n\t/* See if it's in a module. */\n\treturn lookup_module_symbol_attrs(addr, size, offset, modname, name);\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_module_symbol_attrs",
          "args": [
            "addr",
            "size",
            "offset",
            "modname",
            "name"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_module_symbol_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4022-4048",
          "snippet": "int lookup_module_symbol_attrs(unsigned long addr, unsigned long *size,\n\t\t\tunsigned long *offset, char *modname, char *name)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (within_module(addr, mod)) {\n\t\t\tconst char *sym;\n\n\t\t\tsym = get_ksymbol(mod, addr, size, offset);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\t\t\tif (modname)\n\t\t\t\tstrlcpy(modname, mod->name, MODULE_NAME_LEN);\n\t\t\tif (name)\n\t\t\t\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\treturn -ERANGE;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nint lookup_module_symbol_attrs(unsigned long addr, unsigned long *size,\n\t\t\tunsigned long *offset, char *modname, char *name)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (within_module(addr, mod)) {\n\t\t\tconst char *sym;\n\n\t\t\tsym = get_ksymbol(mod, addr, size, offset);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\t\t\tif (modname)\n\t\t\t\tstrlcpy(modname, mod->name, MODULE_NAME_LEN);\n\t\t\tif (name)\n\t\t\t\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\treturn -ERANGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "get_symbol_offset(pos)",
            "name",
            "KSYM_NAME_LEN"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "56-101",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const u8 kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const u8 kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_offset",
          "args": [
            "pos"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "121-142",
          "snippet": "static unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const unsigned int kallsyms_markers[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const unsigned int kallsyms_markers[] __weak;\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_pos",
          "args": [
            "addr",
            "size",
            "offset"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "197-255",
          "snippet": "static unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;",
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\nextern const unsigned int kallsyms_num_syms;\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ksym_addr",
          "args": [
            "addr"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint lookup_symbol_attrs(unsigned long addr, unsigned long *size,\n\t\t\tunsigned long *offset, char *modname, char *name)\n{\n\tname[0] = '\\0';\n\tname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, size, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       name, KSYM_NAME_LEN);\n\t\tmodname[0] = '\\0';\n\t\treturn 0;\n\t}\n\t/* See if it's in a module. */\n\treturn lookup_module_symbol_attrs(addr, size, offset, modname, name);\n}"
  },
  {
    "function_name": "lookup_symbol_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "313-329",
    "snippet": "int lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\treturn 0;\n\t}\n\t/* See if it's in a module. */\n\treturn lookup_module_symbol_name(addr, symname);\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_module_symbol_name",
          "args": [
            "addr",
            "symname"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_module_symbol_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "3998-4020",
          "snippet": "int lookup_module_symbol_name(unsigned long addr, char *symname)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (within_module(addr, mod)) {\n\t\t\tconst char *sym;\n\n\t\t\tsym = get_ksymbol(mod, addr, NULL, NULL);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\t\t\tstrlcpy(symname, sym, KSYM_NAME_LEN);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\treturn -ERANGE;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nint lookup_module_symbol_name(unsigned long addr, char *symname)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (within_module(addr, mod)) {\n\t\t\tconst char *sym;\n\n\t\t\tsym = get_ksymbol(mod, addr, NULL, NULL);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\t\t\tstrlcpy(symname, sym, KSYM_NAME_LEN);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\treturn -ERANGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "get_symbol_offset(pos)",
            "symname",
            "KSYM_NAME_LEN"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "56-101",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const u8 kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const u8 kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_offset",
          "args": [
            "pos"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "121-142",
          "snippet": "static unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const unsigned int kallsyms_markers[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const unsigned int kallsyms_markers[] __weak;\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_pos",
          "args": [
            "addr",
            "NULL",
            "NULL"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "197-255",
          "snippet": "static unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;",
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\nextern const unsigned int kallsyms_num_syms;\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ksym_addr",
          "args": [
            "addr"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\treturn 0;\n\t}\n\t/* See if it's in a module. */\n\treturn lookup_module_symbol_name(addr, symname);\n}"
  },
  {
    "function_name": "kallsyms_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "278-311",
    "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_mod_address_lookup",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "modname",
            "namebuf"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_mod_address_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5923-5943",
          "snippet": "const char *\nftrace_mod_address_lookup(unsigned long addr, unsigned long *size,\n\t\t   unsigned long *off, char **modname, char *sym)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tconst char *ret = NULL;\n\n\t/* mod_map is freed via call_rcu_sched() */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\t\tret = ftrace_func_address_lookup(mod_map, addr, size, off, sym);\n\t\tif (ret) {\n\t\t\tif (modname)\n\t\t\t\t*modname = mod_map->mod->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nconst char *\nftrace_mod_address_lookup(unsigned long addr, unsigned long *size,\n\t\t   unsigned long *off, char **modname, char *sym)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tconst char *ret = NULL;\n\n\t/* mod_map is freed via call_rcu_sched() */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\t\tret = ftrace_func_address_lookup(mod_map, addr, size, off, sym);\n\t\tif (ret) {\n\t\t\tif (modname)\n\t\t\t\t*modname = mod_map->mod->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_address_lookup",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "modname",
            "namebuf"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_address_lookup",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "modname",
            "namebuf"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "module_address_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "3972-3996",
          "snippet": "const char *module_address_lookup(unsigned long addr,\n\t\t\t    unsigned long *size,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname,\n\t\t\t    char *namebuf)\n{\n\tconst char *ret = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (mod) {\n\t\tif (modname)\n\t\t\t*modname = mod->name;\n\t\tret = get_ksymbol(mod, addr, size, offset);\n\t}\n\t/* Make a copy in here where it's safe */\n\tif (ret) {\n\t\tstrncpy(namebuf, ret, KSYM_NAME_LEN - 1);\n\t\tret = namebuf;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nconst char *module_address_lookup(unsigned long addr,\n\t\t\t    unsigned long *size,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname,\n\t\t\t    char *namebuf)\n{\n\tconst char *ret = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (mod) {\n\t\tif (modname)\n\t\t\t*modname = mod->name;\n\t\tret = get_ksymbol(mod, addr, size, offset);\n\t}\n\t/* Make a copy in here where it's safe */\n\tif (ret) {\n\t\tstrncpy(namebuf, ret, KSYM_NAME_LEN - 1);\n\t\tret = namebuf;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "get_symbol_offset(pos)",
            "namebuf",
            "KSYM_NAME_LEN"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "56-101",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const u8 kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const u8 kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_offset",
          "args": [
            "pos"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "121-142",
          "snippet": "static unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const unsigned int kallsyms_markers[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const unsigned int kallsyms_markers[] __weak;\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_pos",
          "args": [
            "addr",
            "symbolsize",
            "offset"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "197-255",
          "snippet": "static unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;",
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\nextern const unsigned int kallsyms_num_syms;\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ksym_addr",
          "args": [
            "addr"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}"
  },
  {
    "function_name": "kallsyms_lookup_size_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "260-269",
    "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr))\n\t\treturn !!get_symbol_pos(addr, symbolsize, offset);\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_address_lookup",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "namebuf"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_address_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "518-540",
          "snippet": "const char *__bpf_address_lookup(unsigned long addr, unsigned long *size,\n\t\t\t\t unsigned long *off, char *sym)\n{\n\tunsigned long symbol_start, symbol_end;\n\tstruct bpf_prog *prog;\n\tchar *ret = NULL;\n\n\trcu_read_lock();\n\tprog = bpf_prog_kallsyms_find(addr);\n\tif (prog) {\n\t\tbpf_get_prog_addr_region(prog, &symbol_start, &symbol_end);\n\t\tbpf_get_prog_name(prog, sym);\n\n\t\tret = sym;\n\t\tif (size)\n\t\t\t*size = symbol_end - symbol_start;\n\t\tif (off)\n\t\t\t*off  = addr - symbol_start;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst char *__bpf_address_lookup(unsigned long addr, unsigned long *size,\n\t\t\t\t unsigned long *off, char *sym)\n{\n\tunsigned long symbol_start, symbol_end;\n\tstruct bpf_prog *prog;\n\tchar *ret = NULL;\n\n\trcu_read_lock();\n\tprog = bpf_prog_kallsyms_find(addr);\n\tif (prog) {\n\t\tbpf_get_prog_addr_region(prog, &symbol_start, &symbol_end);\n\t\tbpf_get_prog_name(prog, sym);\n\n\t\tret = sym;\n\t\tif (size)\n\t\t\t*size = symbol_end - symbol_start;\n\t\tif (off)\n\t\t\t*off  = addr - symbol_start;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_address_lookup",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "NULL",
            "namebuf"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "module_address_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "3972-3996",
          "snippet": "const char *module_address_lookup(unsigned long addr,\n\t\t\t    unsigned long *size,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname,\n\t\t\t    char *namebuf)\n{\n\tconst char *ret = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (mod) {\n\t\tif (modname)\n\t\t\t*modname = mod->name;\n\t\tret = get_ksymbol(mod, addr, size, offset);\n\t}\n\t/* Make a copy in here where it's safe */\n\tif (ret) {\n\t\tstrncpy(namebuf, ret, KSYM_NAME_LEN - 1);\n\t\tret = namebuf;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nconst char *module_address_lookup(unsigned long addr,\n\t\t\t    unsigned long *size,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname,\n\t\t\t    char *namebuf)\n{\n\tconst char *ret = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (mod) {\n\t\tif (modname)\n\t\t\t*modname = mod->name;\n\t\tret = get_ksymbol(mod, addr, size, offset);\n\t}\n\t/* Make a copy in here where it's safe */\n\tif (ret) {\n\t\tstrncpy(namebuf, ret, KSYM_NAME_LEN - 1);\n\t\tret = namebuf;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_pos",
          "args": [
            "addr",
            "symbolsize",
            "offset"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "197-255",
          "snippet": "static unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;",
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\nextern const unsigned int kallsyms_num_syms;\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ksym_addr",
          "args": [
            "addr"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr))\n\t\treturn !!get_symbol_pos(addr, symbolsize, offset);\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
  },
  {
    "function_name": "get_symbol_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "197-255",
    "snippet": "static unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned long kallsyms_addresses[] __weak;",
      "extern const int kallsyms_offsets[] __weak;",
      "extern const unsigned int kallsyms_num_syms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KALLSYMS_ALL"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_kernel_inittext",
          "args": [
            "addr"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_sym_address",
          "args": [
            "i"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_sym_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "144-159",
          "snippet": "static unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\n\nstatic unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!kallsyms_offsets"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!kallsyms_addresses"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KALLSYMS_BASE_RELATIVE"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\nextern const unsigned int kallsyms_num_syms;\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}"
  },
  {
    "function_name": "kallsyms_on_each_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "178-194",
    "snippet": "int kallsyms_on_each_symbol(int (*fn)(void *, const char *, struct module *,\n\t\t\t\t      unsigned long),\n\t\t\t    void *data)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\tunsigned long i;\n\tunsigned int off;\n\tint ret;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\t\tret = fn(data, namebuf, NULL, kallsyms_sym_address(i));\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn module_kallsyms_on_each_symbol(fn, data);\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned int kallsyms_num_syms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_kallsyms_on_each_symbol",
          "args": [
            "fn",
            "data"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_on_each_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4113-4141",
          "snippet": "int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,\n\t\t\t\t\t     struct module *, unsigned long),\n\t\t\t\t   void *data)\n{\n\tstruct module *mod;\n\tunsigned int i;\n\tint ret;\n\n\tmodule_assert_mutex();\n\n\tlist_for_each_entry(mod, &modules, list) {\n\t\t/* We hold module_mutex: no need for rcu_dereference_sched */\n\t\tstruct mod_kallsyms *kallsyms = mod->kallsyms;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < kallsyms->num_symtab; i++) {\n\n\t\t\tif (kallsyms->symtab[i].st_shndx == SHN_UNDEF)\n\t\t\t\tcontinue;\n\n\t\t\tret = fn(data, symname(kallsyms, i),\n\t\t\t\t mod, kallsyms->symtab[i].st_value);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nint module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,\n\t\t\t\t\t     struct module *, unsigned long),\n\t\t\t\t   void *data)\n{\n\tstruct module *mod;\n\tunsigned int i;\n\tint ret;\n\n\tmodule_assert_mutex();\n\n\tlist_for_each_entry(mod, &modules, list) {\n\t\t/* We hold module_mutex: no need for rcu_dereference_sched */\n\t\tstruct mod_kallsyms *kallsyms = mod->kallsyms;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < kallsyms->num_symtab; i++) {\n\n\t\t\tif (kallsyms->symtab[i].st_shndx == SHN_UNDEF)\n\t\t\t\tcontinue;\n\n\t\t\tret = fn(data, symname(kallsyms, i),\n\t\t\t\t mod, kallsyms->symtab[i].st_value);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "data",
            "namebuf",
            "NULL",
            "kallsyms_sym_address(i)"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "cwt_wakefn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2947-2954",
          "snippet": "static int cwt_wakefn(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);\n\n\tif (cwait->work != key)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int cwt_wakefn(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);\n\n\tif (cwait->work != key)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_sym_address",
          "args": [
            "i"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_sym_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "144-159",
          "snippet": "static unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\n\nstatic unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "off",
            "namebuf",
            "ARRAY_SIZE(namebuf)"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "56-101",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const u8 kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const u8 kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "namebuf"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nint kallsyms_on_each_symbol(int (*fn)(void *, const char *, struct module *,\n\t\t\t\t      unsigned long),\n\t\t\t    void *data)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\tunsigned long i;\n\tunsigned int off;\n\tint ret;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\t\tret = fn(data, namebuf, NULL, kallsyms_sym_address(i));\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn module_kallsyms_on_each_symbol(fn, data);\n}"
  },
  {
    "function_name": "kallsyms_lookup_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "162-175",
    "snippet": "unsigned long kallsyms_lookup_name(const char *name)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\tunsigned long i;\n\tunsigned int off;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\n\t\tif (strcmp(namebuf, name) == 0)\n\t\t\treturn kallsyms_sym_address(i);\n\t}\n\treturn module_kallsyms_lookup_name(name);\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned int kallsyms_num_syms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_kallsyms_lookup_name",
          "args": [
            "name"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4090-4111",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_sym_address",
          "args": [
            "i"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_sym_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "144-159",
          "snippet": "static unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\n\nstatic unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "namebuf",
            "name"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "off",
            "namebuf",
            "ARRAY_SIZE(namebuf)"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "56-101",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const u8 kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const u8 kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "namebuf"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nunsigned long kallsyms_lookup_name(const char *name)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\tunsigned long i;\n\tunsigned int off;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\n\t\tif (strcmp(namebuf, name) == 0)\n\t\t\treturn kallsyms_sym_address(i);\n\t}\n\treturn module_kallsyms_lookup_name(name);\n}"
  },
  {
    "function_name": "kallsyms_sym_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "144-159",
    "snippet": "static unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned long kallsyms_addresses[] __weak;",
      "extern const int kallsyms_offsets[] __weak;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KALLSYMS_ABSOLUTE_PERCPU"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KALLSYMS_BASE_RELATIVE"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\n\nstatic unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}"
  },
  {
    "function_name": "get_symbol_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "121-142",
    "snippet": "static unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const u8 kallsyms_names[] __weak;",
      "extern const unsigned int kallsyms_markers[] __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const unsigned int kallsyms_markers[] __weak;\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}"
  },
  {
    "function_name": "kallsyms_get_symbol_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "107-114",
    "snippet": "static char kallsyms_get_symbol_type(unsigned int off)\n{\n\t/*\n\t * Get just the first code, look it up in the token table,\n\t * and return the first char from this token.\n\t */\n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const u8 kallsyms_names[] __weak;",
      "extern const u8 kallsyms_token_table[] __weak;",
      "extern const u16 kallsyms_token_index[] __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const u8 kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic char kallsyms_get_symbol_type(unsigned int off)\n{\n\t/*\n\t * Get just the first code, look it up in the token table,\n\t * and return the first char from this token.\n\t */\n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}"
  },
  {
    "function_name": "kallsyms_expand_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
    "lines": "56-101",
    "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
    "includes": [
      "#include <linux/compiler.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const u8 kallsyms_names[] __weak;",
      "extern const u8 kallsyms_token_table[] __weak;",
      "extern const u16 kallsyms_token_index[] __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const u8 kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
  }
]