[
  {
    "function_name": "__downgrade_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "327-338",
    "snippet": "void __downgrade_write(struct rw_semaphore *sem)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tsem->count = 1;\n\tif (!list_empty(&sem->wait_list))\n\t\tsem = __rwsem_do_wake(sem, 0);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rwsem_do_wake",
          "args": [
            "sem",
            "0"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__rwsem_do_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
          "lines": "66-111",
          "snippet": "static inline struct rw_semaphore *\n__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)\n{\n\tstruct rwsem_waiter *waiter;\n\tstruct task_struct *tsk;\n\tint woken;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\n\tif (waiter->type == RWSEM_WAITING_FOR_WRITE) {\n\t\tif (wakewrite)\n\t\t\t/* Wake up a writer. Note that we do not grant it the\n\t\t\t * lock - it will have to acquire it when it runs. */\n\t\t\twake_up_process(waiter->task);\n\t\tgoto out;\n\t}\n\n\t/* grant an infinite number of read locks to the front of the queue */\n\twoken = 0;\n\tdo {\n\t\tstruct list_head *next = waiter->list.next;\n\n\t\tlist_del(&waiter->list);\n\t\ttsk = waiter->task;\n\t\t/*\n\t\t * Make sure we do not wakeup the next reader before\n\t\t * setting the nil condition to grant the next reader;\n\t\t * otherwise we could miss the wakeup on the other\n\t\t * side and end up sleeping again. See the pairing\n\t\t * in rwsem_down_read_failed().\n\t\t */\n\t\tsmp_mb();\n\t\twaiter->task = NULL;\n\t\twake_up_process(tsk);\n\t\tput_task_struct(tsk);\n\t\twoken++;\n\t\tif (next == &sem->wait_list)\n\t\t\tbreak;\n\t\twaiter = list_entry(next, struct rwsem_waiter, list);\n\t} while (waiter->type != RWSEM_WAITING_FOR_WRITE);\n\n\tsem->count += woken;\n\n out:\n\treturn sem;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nstatic inline struct rw_semaphore *\n__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)\n{\n\tstruct rwsem_waiter *waiter;\n\tstruct task_struct *tsk;\n\tint woken;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\n\tif (waiter->type == RWSEM_WAITING_FOR_WRITE) {\n\t\tif (wakewrite)\n\t\t\t/* Wake up a writer. Note that we do not grant it the\n\t\t\t * lock - it will have to acquire it when it runs. */\n\t\t\twake_up_process(waiter->task);\n\t\tgoto out;\n\t}\n\n\t/* grant an infinite number of read locks to the front of the queue */\n\twoken = 0;\n\tdo {\n\t\tstruct list_head *next = waiter->list.next;\n\n\t\tlist_del(&waiter->list);\n\t\ttsk = waiter->task;\n\t\t/*\n\t\t * Make sure we do not wakeup the next reader before\n\t\t * setting the nil condition to grant the next reader;\n\t\t * otherwise we could miss the wakeup on the other\n\t\t * side and end up sleeping again. See the pairing\n\t\t * in rwsem_down_read_failed().\n\t\t */\n\t\tsmp_mb();\n\t\twaiter->task = NULL;\n\t\twake_up_process(tsk);\n\t\tput_task_struct(tsk);\n\t\twoken++;\n\t\tif (next == &sem->wait_list)\n\t\t\tbreak;\n\t\twaiter = list_entry(next, struct rwsem_waiter, list);\n\t} while (waiter->type != RWSEM_WAITING_FOR_WRITE);\n\n\tsem->count += woken;\n\n out:\n\treturn sem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sem->wait_list"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nvoid __downgrade_write(struct rw_semaphore *sem)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tsem->count = 1;\n\tif (!list_empty(&sem->wait_list))\n\t\tsem = __rwsem_do_wake(sem, 0);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n}"
  },
  {
    "function_name": "__up_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "310-321",
    "snippet": "void __up_write(struct rw_semaphore *sem)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tsem->count = 0;\n\tif (!list_empty(&sem->wait_list))\n\t\tsem = __rwsem_do_wake(sem, 1);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rwsem_do_wake",
          "args": [
            "sem",
            "1"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__rwsem_do_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
          "lines": "66-111",
          "snippet": "static inline struct rw_semaphore *\n__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)\n{\n\tstruct rwsem_waiter *waiter;\n\tstruct task_struct *tsk;\n\tint woken;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\n\tif (waiter->type == RWSEM_WAITING_FOR_WRITE) {\n\t\tif (wakewrite)\n\t\t\t/* Wake up a writer. Note that we do not grant it the\n\t\t\t * lock - it will have to acquire it when it runs. */\n\t\t\twake_up_process(waiter->task);\n\t\tgoto out;\n\t}\n\n\t/* grant an infinite number of read locks to the front of the queue */\n\twoken = 0;\n\tdo {\n\t\tstruct list_head *next = waiter->list.next;\n\n\t\tlist_del(&waiter->list);\n\t\ttsk = waiter->task;\n\t\t/*\n\t\t * Make sure we do not wakeup the next reader before\n\t\t * setting the nil condition to grant the next reader;\n\t\t * otherwise we could miss the wakeup on the other\n\t\t * side and end up sleeping again. See the pairing\n\t\t * in rwsem_down_read_failed().\n\t\t */\n\t\tsmp_mb();\n\t\twaiter->task = NULL;\n\t\twake_up_process(tsk);\n\t\tput_task_struct(tsk);\n\t\twoken++;\n\t\tif (next == &sem->wait_list)\n\t\t\tbreak;\n\t\twaiter = list_entry(next, struct rwsem_waiter, list);\n\t} while (waiter->type != RWSEM_WAITING_FOR_WRITE);\n\n\tsem->count += woken;\n\n out:\n\treturn sem;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nstatic inline struct rw_semaphore *\n__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)\n{\n\tstruct rwsem_waiter *waiter;\n\tstruct task_struct *tsk;\n\tint woken;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\n\tif (waiter->type == RWSEM_WAITING_FOR_WRITE) {\n\t\tif (wakewrite)\n\t\t\t/* Wake up a writer. Note that we do not grant it the\n\t\t\t * lock - it will have to acquire it when it runs. */\n\t\t\twake_up_process(waiter->task);\n\t\tgoto out;\n\t}\n\n\t/* grant an infinite number of read locks to the front of the queue */\n\twoken = 0;\n\tdo {\n\t\tstruct list_head *next = waiter->list.next;\n\n\t\tlist_del(&waiter->list);\n\t\ttsk = waiter->task;\n\t\t/*\n\t\t * Make sure we do not wakeup the next reader before\n\t\t * setting the nil condition to grant the next reader;\n\t\t * otherwise we could miss the wakeup on the other\n\t\t * side and end up sleeping again. See the pairing\n\t\t * in rwsem_down_read_failed().\n\t\t */\n\t\tsmp_mb();\n\t\twaiter->task = NULL;\n\t\twake_up_process(tsk);\n\t\tput_task_struct(tsk);\n\t\twoken++;\n\t\tif (next == &sem->wait_list)\n\t\t\tbreak;\n\t\twaiter = list_entry(next, struct rwsem_waiter, list);\n\t} while (waiter->type != RWSEM_WAITING_FOR_WRITE);\n\n\tsem->count += woken;\n\n out:\n\treturn sem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sem->wait_list"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nvoid __up_write(struct rw_semaphore *sem)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tsem->count = 0;\n\tif (!list_empty(&sem->wait_list))\n\t\tsem = __rwsem_do_wake(sem, 1);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n}"
  },
  {
    "function_name": "__up_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "295-305",
    "snippet": "void __up_read(struct rw_semaphore *sem)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (--sem->count == 0 && !list_empty(&sem->wait_list))\n\t\tsem = __rwsem_wake_one_writer(sem);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rwsem_wake_one_writer",
          "args": [
            "sem"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "__rwsem_wake_one_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
          "lines": "116-125",
          "snippet": "static inline struct rw_semaphore *\n__rwsem_wake_one_writer(struct rw_semaphore *sem)\n{\n\tstruct rwsem_waiter *waiter;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\twake_up_process(waiter->task);\n\n\treturn sem;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nstatic inline struct rw_semaphore *\n__rwsem_wake_one_writer(struct rw_semaphore *sem)\n{\n\tstruct rwsem_waiter *waiter;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\twake_up_process(waiter->task);\n\n\treturn sem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sem->wait_list"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nvoid __up_read(struct rw_semaphore *sem)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (--sem->count == 0 && !list_empty(&sem->wait_list))\n\t\tsem = __rwsem_wake_one_writer(sem);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n}"
  },
  {
    "function_name": "__down_write_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "274-290",
    "snippet": "int __down_write_trylock(struct rw_semaphore *sem)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (sem->count == 0) {\n\t\t/* got the lock */\n\t\tsem->count = -1;\n\t\tret = 1;\n\t}\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint __down_write_trylock(struct rw_semaphore *sem)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (sem->count == 0) {\n\t\t/* got the lock */\n\t\tsem->count = -1;\n\t\tret = 1;\n\t}\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__down_write_killable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "266-269",
    "snippet": "int __sched __down_write_killable(struct rw_semaphore *sem)\n{\n\treturn __down_write_common(sem, TASK_KILLABLE);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__down_write_common",
          "args": [
            "sem",
            "TASK_KILLABLE"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "__down_write_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
          "lines": "213-259",
          "snippet": "int __sched __down_write_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_WRITE;\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait for someone to release the lock */\n\tfor (;;) {\n\t\t/*\n\t\t * That is the key to support write lock stealing: allows the\n\t\t * task already on CPU to get the lock soon rather than put\n\t\t * itself into sleep and waiting for system woke it or someone\n\t\t * else in the head of the wait list up.\n\t\t */\n\t\tif (sem->count == 0)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\t/* got the lock */\n\tsem->count = -1;\n\tlist_del(&waiter.list);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn ret;\n\nout_nolock:\n\tlist_del(&waiter.list);\n\tif (!list_empty(&sem->wait_list) && sem->count >= 0)\n\t\t__rwsem_do_wake(sem, 0);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn -EINTR;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint __sched __down_write_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_WRITE;\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait for someone to release the lock */\n\tfor (;;) {\n\t\t/*\n\t\t * That is the key to support write lock stealing: allows the\n\t\t * task already on CPU to get the lock soon rather than put\n\t\t * itself into sleep and waiting for system woke it or someone\n\t\t * else in the head of the wait list up.\n\t\t */\n\t\tif (sem->count == 0)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\t/* got the lock */\n\tsem->count = -1;\n\tlist_del(&waiter.list);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn ret;\n\nout_nolock:\n\tlist_del(&waiter.list);\n\tif (!list_empty(&sem->wait_list) && sem->count >= 0)\n\t\t__rwsem_do_wake(sem, 0);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn -EINTR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint __sched __down_write_killable(struct rw_semaphore *sem)\n{\n\treturn __down_write_common(sem, TASK_KILLABLE);\n}"
  },
  {
    "function_name": "__down_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "261-264",
    "snippet": "void __sched __down_write(struct rw_semaphore *sem)\n{\n\t__down_write_common(sem, TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__down_write_common",
          "args": [
            "sem",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "__down_write_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
          "lines": "213-259",
          "snippet": "int __sched __down_write_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_WRITE;\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait for someone to release the lock */\n\tfor (;;) {\n\t\t/*\n\t\t * That is the key to support write lock stealing: allows the\n\t\t * task already on CPU to get the lock soon rather than put\n\t\t * itself into sleep and waiting for system woke it or someone\n\t\t * else in the head of the wait list up.\n\t\t */\n\t\tif (sem->count == 0)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\t/* got the lock */\n\tsem->count = -1;\n\tlist_del(&waiter.list);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn ret;\n\nout_nolock:\n\tlist_del(&waiter.list);\n\tif (!list_empty(&sem->wait_list) && sem->count >= 0)\n\t\t__rwsem_do_wake(sem, 0);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn -EINTR;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint __sched __down_write_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_WRITE;\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait for someone to release the lock */\n\tfor (;;) {\n\t\t/*\n\t\t * That is the key to support write lock stealing: allows the\n\t\t * task already on CPU to get the lock soon rather than put\n\t\t * itself into sleep and waiting for system woke it or someone\n\t\t * else in the head of the wait list up.\n\t\t */\n\t\tif (sem->count == 0)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\t/* got the lock */\n\tsem->count = -1;\n\tlist_del(&waiter.list);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn ret;\n\nout_nolock:\n\tlist_del(&waiter.list);\n\tif (!list_empty(&sem->wait_list) && sem->count >= 0)\n\t\t__rwsem_do_wake(sem, 0);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn -EINTR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nvoid __sched __down_write(struct rw_semaphore *sem)\n{\n\t__down_write_common(sem, TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "__down_write_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "213-259",
    "snippet": "int __sched __down_write_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_WRITE;\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait for someone to release the lock */\n\tfor (;;) {\n\t\t/*\n\t\t * That is the key to support write lock stealing: allows the\n\t\t * task already on CPU to get the lock soon rather than put\n\t\t * itself into sleep and waiting for system woke it or someone\n\t\t * else in the head of the wait list up.\n\t\t */\n\t\tif (sem->count == 0)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\t/* got the lock */\n\tsem->count = -1;\n\tlist_del(&waiter.list);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn ret;\n\nout_nolock:\n\tlist_del(&waiter.list);\n\tif (!list_empty(&sem->wait_list) && sem->count >= 0)\n\t\t__rwsem_do_wake(sem, 0);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn -EINTR;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rwsem_do_wake",
          "args": [
            "sem",
            "0"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "__rwsem_do_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
          "lines": "66-111",
          "snippet": "static inline struct rw_semaphore *\n__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)\n{\n\tstruct rwsem_waiter *waiter;\n\tstruct task_struct *tsk;\n\tint woken;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\n\tif (waiter->type == RWSEM_WAITING_FOR_WRITE) {\n\t\tif (wakewrite)\n\t\t\t/* Wake up a writer. Note that we do not grant it the\n\t\t\t * lock - it will have to acquire it when it runs. */\n\t\t\twake_up_process(waiter->task);\n\t\tgoto out;\n\t}\n\n\t/* grant an infinite number of read locks to the front of the queue */\n\twoken = 0;\n\tdo {\n\t\tstruct list_head *next = waiter->list.next;\n\n\t\tlist_del(&waiter->list);\n\t\ttsk = waiter->task;\n\t\t/*\n\t\t * Make sure we do not wakeup the next reader before\n\t\t * setting the nil condition to grant the next reader;\n\t\t * otherwise we could miss the wakeup on the other\n\t\t * side and end up sleeping again. See the pairing\n\t\t * in rwsem_down_read_failed().\n\t\t */\n\t\tsmp_mb();\n\t\twaiter->task = NULL;\n\t\twake_up_process(tsk);\n\t\tput_task_struct(tsk);\n\t\twoken++;\n\t\tif (next == &sem->wait_list)\n\t\t\tbreak;\n\t\twaiter = list_entry(next, struct rwsem_waiter, list);\n\t} while (waiter->type != RWSEM_WAITING_FOR_WRITE);\n\n\tsem->count += woken;\n\n out:\n\treturn sem;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nstatic inline struct rw_semaphore *\n__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)\n{\n\tstruct rwsem_waiter *waiter;\n\tstruct task_struct *tsk;\n\tint woken;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\n\tif (waiter->type == RWSEM_WAITING_FOR_WRITE) {\n\t\tif (wakewrite)\n\t\t\t/* Wake up a writer. Note that we do not grant it the\n\t\t\t * lock - it will have to acquire it when it runs. */\n\t\t\twake_up_process(waiter->task);\n\t\tgoto out;\n\t}\n\n\t/* grant an infinite number of read locks to the front of the queue */\n\twoken = 0;\n\tdo {\n\t\tstruct list_head *next = waiter->list.next;\n\n\t\tlist_del(&waiter->list);\n\t\ttsk = waiter->task;\n\t\t/*\n\t\t * Make sure we do not wakeup the next reader before\n\t\t * setting the nil condition to grant the next reader;\n\t\t * otherwise we could miss the wakeup on the other\n\t\t * side and end up sleeping again. See the pairing\n\t\t * in rwsem_down_read_failed().\n\t\t */\n\t\tsmp_mb();\n\t\twaiter->task = NULL;\n\t\twake_up_process(tsk);\n\t\tput_task_struct(tsk);\n\t\twoken++;\n\t\tif (next == &sem->wait_list)\n\t\t\tbreak;\n\t\twaiter = list_entry(next, struct rwsem_waiter, list);\n\t} while (waiter->type != RWSEM_WAITING_FOR_WRITE);\n\n\tsem->count += woken;\n\n out:\n\treturn sem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sem->wait_list"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&waiter.list"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "state",
            "current"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&waiter.list",
            "&sem->wait_list"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint __sched __down_write_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_WRITE;\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait for someone to release the lock */\n\tfor (;;) {\n\t\t/*\n\t\t * That is the key to support write lock stealing: allows the\n\t\t * task already on CPU to get the lock soon rather than put\n\t\t * itself into sleep and waiting for system woke it or someone\n\t\t * else in the head of the wait list up.\n\t\t */\n\t\tif (sem->count == 0)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\t/* got the lock */\n\tsem->count = -1;\n\tlist_del(&waiter.list);\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn ret;\n\nout_nolock:\n\tlist_del(&waiter.list);\n\tif (!list_empty(&sem->wait_list) && sem->count >= 0)\n\t\t__rwsem_do_wake(sem, 0);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn -EINTR;\n}"
  },
  {
    "function_name": "__down_read_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "191-208",
    "snippet": "int __down_read_trylock(struct rw_semaphore *sem)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (sem->count >= 0 && list_empty(&sem->wait_list)) {\n\t\t/* granted */\n\t\tsem->count++;\n\t\tret = 1;\n\t}\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sem->wait_list"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint __down_read_trylock(struct rw_semaphore *sem)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (sem->count >= 0 && list_empty(&sem->wait_list)) {\n\t\t/* granted */\n\t\tsem->count++;\n\t\tret = 1;\n\t}\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__down_read_killable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "183-186",
    "snippet": "int __sched __down_read_killable(struct rw_semaphore *sem)\n{\n\treturn __down_read_common(sem, TASK_KILLABLE);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__down_read_common",
          "args": [
            "sem",
            "TASK_KILLABLE"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "__down_read_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
          "lines": "130-176",
          "snippet": "int __sched __down_read_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (sem->count >= 0 && list_empty(&sem->wait_list)) {\n\t\t/* granted */\n\t\tsem->count++;\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tgoto out;\n\t}\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_READ;\n\tget_task_struct(current);\n\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait to be given the lock */\n\tfor (;;) {\n\t\tif (!waiter.task)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n out:\n\treturn 0;\n\nout_nolock:\n\t/*\n\t * We didn't take the lock, so that there is a writer, which\n\t * is owner or the first waiter of the sem. If it's a waiter,\n\t * it will be woken by current owner. Not need to wake anybody.\n\t */\n\tlist_del(&waiter.list);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\treturn -EINTR;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint __sched __down_read_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (sem->count >= 0 && list_empty(&sem->wait_list)) {\n\t\t/* granted */\n\t\tsem->count++;\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tgoto out;\n\t}\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_READ;\n\tget_task_struct(current);\n\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait to be given the lock */\n\tfor (;;) {\n\t\tif (!waiter.task)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n out:\n\treturn 0;\n\nout_nolock:\n\t/*\n\t * We didn't take the lock, so that there is a writer, which\n\t * is owner or the first waiter of the sem. If it's a waiter,\n\t * it will be woken by current owner. Not need to wake anybody.\n\t */\n\tlist_del(&waiter.list);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\treturn -EINTR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint __sched __down_read_killable(struct rw_semaphore *sem)\n{\n\treturn __down_read_common(sem, TASK_KILLABLE);\n}"
  },
  {
    "function_name": "__down_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "178-181",
    "snippet": "void __sched __down_read(struct rw_semaphore *sem)\n{\n\t__down_read_common(sem, TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__down_read_common",
          "args": [
            "sem",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__down_read_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
          "lines": "130-176",
          "snippet": "int __sched __down_read_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (sem->count >= 0 && list_empty(&sem->wait_list)) {\n\t\t/* granted */\n\t\tsem->count++;\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tgoto out;\n\t}\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_READ;\n\tget_task_struct(current);\n\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait to be given the lock */\n\tfor (;;) {\n\t\tif (!waiter.task)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n out:\n\treturn 0;\n\nout_nolock:\n\t/*\n\t * We didn't take the lock, so that there is a writer, which\n\t * is owner or the first waiter of the sem. If it's a waiter,\n\t * it will be woken by current owner. Not need to wake anybody.\n\t */\n\tlist_del(&waiter.list);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\treturn -EINTR;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint __sched __down_read_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (sem->count >= 0 && list_empty(&sem->wait_list)) {\n\t\t/* granted */\n\t\tsem->count++;\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tgoto out;\n\t}\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_READ;\n\tget_task_struct(current);\n\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait to be given the lock */\n\tfor (;;) {\n\t\tif (!waiter.task)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n out:\n\treturn 0;\n\nout_nolock:\n\t/*\n\t * We didn't take the lock, so that there is a writer, which\n\t * is owner or the first waiter of the sem. If it's a waiter,\n\t * it will be woken by current owner. Not need to wake anybody.\n\t */\n\tlist_del(&waiter.list);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\treturn -EINTR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nvoid __sched __down_read(struct rw_semaphore *sem)\n{\n\t__down_read_common(sem, TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "__down_read_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "130-176",
    "snippet": "int __sched __down_read_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (sem->count >= 0 && list_empty(&sem->wait_list)) {\n\t\t/* granted */\n\t\tsem->count++;\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tgoto out;\n\t}\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_READ;\n\tget_task_struct(current);\n\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait to be given the lock */\n\tfor (;;) {\n\t\tif (!waiter.task)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n out:\n\treturn 0;\n\nout_nolock:\n\t/*\n\t * We didn't take the lock, so that there is a writer, which\n\t * is owner or the first waiter of the sem. If it's a waiter,\n\t * it will be woken by current owner. Not need to wake anybody.\n\t */\n\tlist_del(&waiter.list);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\treturn -EINTR;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&waiter.list"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "state",
            "current"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&waiter.list",
            "&sem->wait_list"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "current"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sem->wait_list"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint __sched __down_read_common(struct rw_semaphore *sem, int state)\n{\n\tstruct rwsem_waiter waiter;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\n\tif (sem->count >= 0 && list_empty(&sem->wait_list)) {\n\t\t/* granted */\n\t\tsem->count++;\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tgoto out;\n\t}\n\n\t/* set up my own style of waitqueue */\n\twaiter.task = current;\n\twaiter.type = RWSEM_WAITING_FOR_READ;\n\tget_task_struct(current);\n\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\n\t/* wait to be given the lock */\n\tfor (;;) {\n\t\tif (!waiter.task)\n\t\t\tbreak;\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto out_nolock;\n\t\tset_current_state(state);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t\tschedule();\n\t\traw_spin_lock_irqsave(&sem->wait_lock, flags);\n\t}\n\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n out:\n\treturn 0;\n\nout_nolock:\n\t/*\n\t * We didn't take the lock, so that there is a writer, which\n\t * is owner or the first waiter of the sem. If it's a waiter,\n\t * it will be woken by current owner. Not need to wake anybody.\n\t */\n\tlist_del(&waiter.list);\n\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\treturn -EINTR;\n}"
  },
  {
    "function_name": "__rwsem_wake_one_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "116-125",
    "snippet": "static inline struct rw_semaphore *\n__rwsem_wake_one_writer(struct rw_semaphore *sem)\n{\n\tstruct rwsem_waiter *waiter;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\twake_up_process(waiter->task);\n\n\treturn sem;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "waiter->task"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "sem->wait_list.next",
            "structrwsem_waiter",
            "list"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nstatic inline struct rw_semaphore *\n__rwsem_wake_one_writer(struct rw_semaphore *sem)\n{\n\tstruct rwsem_waiter *waiter;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\twake_up_process(waiter->task);\n\n\treturn sem;\n}"
  },
  {
    "function_name": "__rwsem_do_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "66-111",
    "snippet": "static inline struct rw_semaphore *\n__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)\n{\n\tstruct rwsem_waiter *waiter;\n\tstruct task_struct *tsk;\n\tint woken;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\n\tif (waiter->type == RWSEM_WAITING_FOR_WRITE) {\n\t\tif (wakewrite)\n\t\t\t/* Wake up a writer. Note that we do not grant it the\n\t\t\t * lock - it will have to acquire it when it runs. */\n\t\t\twake_up_process(waiter->task);\n\t\tgoto out;\n\t}\n\n\t/* grant an infinite number of read locks to the front of the queue */\n\twoken = 0;\n\tdo {\n\t\tstruct list_head *next = waiter->list.next;\n\n\t\tlist_del(&waiter->list);\n\t\ttsk = waiter->task;\n\t\t/*\n\t\t * Make sure we do not wakeup the next reader before\n\t\t * setting the nil condition to grant the next reader;\n\t\t * otherwise we could miss the wakeup on the other\n\t\t * side and end up sleeping again. See the pairing\n\t\t * in rwsem_down_read_failed().\n\t\t */\n\t\tsmp_mb();\n\t\twaiter->task = NULL;\n\t\twake_up_process(tsk);\n\t\tput_task_struct(tsk);\n\t\twoken++;\n\t\tif (next == &sem->wait_list)\n\t\t\tbreak;\n\t\twaiter = list_entry(next, struct rwsem_waiter, list);\n\t} while (waiter->type != RWSEM_WAITING_FOR_WRITE);\n\n\tsem->count += woken;\n\n out:\n\treturn sem;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structrwsem_waiter",
            "list"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "tsk"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "tsk"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&waiter->list"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "sem->wait_list.next",
            "structrwsem_waiter",
            "list"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nstatic inline struct rw_semaphore *\n__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)\n{\n\tstruct rwsem_waiter *waiter;\n\tstruct task_struct *tsk;\n\tint woken;\n\n\twaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\n\n\tif (waiter->type == RWSEM_WAITING_FOR_WRITE) {\n\t\tif (wakewrite)\n\t\t\t/* Wake up a writer. Note that we do not grant it the\n\t\t\t * lock - it will have to acquire it when it runs. */\n\t\t\twake_up_process(waiter->task);\n\t\tgoto out;\n\t}\n\n\t/* grant an infinite number of read locks to the front of the queue */\n\twoken = 0;\n\tdo {\n\t\tstruct list_head *next = waiter->list.next;\n\n\t\tlist_del(&waiter->list);\n\t\ttsk = waiter->task;\n\t\t/*\n\t\t * Make sure we do not wakeup the next reader before\n\t\t * setting the nil condition to grant the next reader;\n\t\t * otherwise we could miss the wakeup on the other\n\t\t * side and end up sleeping again. See the pairing\n\t\t * in rwsem_down_read_failed().\n\t\t */\n\t\tsmp_mb();\n\t\twaiter->task = NULL;\n\t\twake_up_process(tsk);\n\t\tput_task_struct(tsk);\n\t\twoken++;\n\t\tif (next == &sem->wait_list)\n\t\t\tbreak;\n\t\twaiter = list_entry(next, struct rwsem_waiter, list);\n\t} while (waiter->type != RWSEM_WAITING_FOR_WRITE);\n\n\tsem->count += woken;\n\n out:\n\treturn sem;\n}"
  },
  {
    "function_name": "__init_rwsem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "41-54",
    "snippet": "void __init_rwsem(struct rw_semaphore *sem, const char *name,\n\t\t  struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held semaphore:\n\t */\n\tdebug_check_no_locks_freed((void *)sem, sizeof(*sem));\n\tlockdep_init_map(&sem->dep_map, name, key, 0);\n#endif\n\tsem->count = 0;\n\traw_spin_lock_init(&sem->wait_lock);\n\tINIT_LIST_HEAD(&sem->wait_list);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sem->wait_list"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&sem->wait_lock"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&sem->dep_map",
            "name",
            "key",
            "0"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_init_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3148-3152",
          "snippet": "void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)sem",
            "sizeof(*sem)"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4322-4344",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nvoid __init_rwsem(struct rw_semaphore *sem, const char *name,\n\t\t  struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held semaphore:\n\t */\n\tdebug_check_no_locks_freed((void *)sem, sizeof(*sem));\n\tlockdep_init_map(&sem->dep_map, name, key, 0);\n#endif\n\tsem->count = 0;\n\traw_spin_lock_init(&sem->wait_lock);\n\tINIT_LIST_HEAD(&sem->wait_list);\n}"
  },
  {
    "function_name": "rwsem_is_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem-spinlock.c",
    "lines": "25-35",
    "snippet": "int rwsem_is_locked(struct rw_semaphore *sem)\n{\n\tint ret = 1;\n\tunsigned long flags;\n\n\tif (raw_spin_trylock_irqsave(&sem->wait_lock, flags)) {\n\t\tret = (sem->count != 0);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock_irqsave",
          "args": [
            "&sem->wait_lock",
            "flags"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rwsem.h>\n\nint rwsem_is_locked(struct rw_semaphore *sem)\n{\n\tint ret = 1;\n\tunsigned long flags;\n\n\tif (raw_spin_trylock_irqsave(&sem->wait_lock, flags)) {\n\t\tret = (sem->count != 0);\n\t\traw_spin_unlock_irqrestore(&sem->wait_lock, flags);\n\t}\n\treturn ret;\n}"
  }
]