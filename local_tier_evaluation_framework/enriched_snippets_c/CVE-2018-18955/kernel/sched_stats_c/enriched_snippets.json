[
  {
    "function_name": "proc_schedstat_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.c",
    "lines": "123-127",
    "snippet": "static int __init proc_schedstat_init(void)\n{\n\tproc_create_seq(\"schedstat\", 0, NULL, &schedstat_sops);\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations schedstat_sops = {\n\t.start = schedstat_start,\n\t.next  = schedstat_next,\n\t.stop  = schedstat_stop,\n\t.show  = show_schedstat,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_seq",
          "args": [
            "\"schedstat\"",
            "0",
            "NULL",
            "&schedstat_sops"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic const struct seq_operations schedstat_sops = {\n\t.start = schedstat_start,\n\t.next  = schedstat_next,\n\t.stop  = schedstat_stop,\n\t.show  = show_schedstat,\n};\n\nstatic int __init proc_schedstat_init(void)\n{\n\tproc_create_seq(\"schedstat\", 0, NULL, &schedstat_sops);\n\treturn 0;\n}"
  },
  {
    "function_name": "schedstat_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.c",
    "lines": "112-114",
    "snippet": "static void schedstat_stop(struct seq_file *file, void *data)\n{\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void schedstat_stop(struct seq_file *file, void *data)\n{\n}"
  },
  {
    "function_name": "schedstat_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.c",
    "lines": "105-110",
    "snippet": "static void *schedstat_next(struct seq_file *file, void *data, loff_t *offset)\n{\n\t(*offset)++;\n\n\treturn schedstat_start(file, offset);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedstat_start",
          "args": [
            "file",
            "offset"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "schedstat_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.c",
          "lines": "83-103",
          "snippet": "static void *schedstat_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void *schedstat_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void *schedstat_next(struct seq_file *file, void *data, loff_t *offset)\n{\n\t(*offset)++;\n\n\treturn schedstat_start(file, offset);\n}"
  },
  {
    "function_name": "schedstat_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.c",
    "lines": "83-103",
    "snippet": "static void *schedstat_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "n - 1",
            "cpu_online_mask"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void *schedstat_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "show_schedstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.c",
    "lines": "15-74",
    "snippet": "static int show_schedstat(struct seq_file *seq, void *v)\n{\n\tint cpu;\n\n\tif (v == (void *)1) {\n\t\tseq_printf(seq, \"version %d\\n\", SCHEDSTAT_VERSION);\n\t\tseq_printf(seq, \"timestamp %lu\\n\", jiffies);\n\t} else {\n\t\tstruct rq *rq;\n#ifdef CONFIG_SMP\n\t\tstruct sched_domain *sd;\n\t\tint dcount = 0;\n#endif\n\t\tcpu = (unsigned long)(v - 2);\n\t\trq = cpu_rq(cpu);\n\n\t\t/* runqueue-specific stats */\n\t\tseq_printf(seq,\n\t\t    \"cpu%d %u 0 %u %u %u %u %llu %llu %lu\",\n\t\t    cpu, rq->yld_count,\n\t\t    rq->sched_count, rq->sched_goidle,\n\t\t    rq->ttwu_count, rq->ttwu_local,\n\t\t    rq->rq_cpu_time,\n\t\t    rq->rq_sched_info.run_delay, rq->rq_sched_info.pcount);\n\n\t\tseq_printf(seq, \"\\n\");\n\n#ifdef CONFIG_SMP\n\t\t/* domain-specific stats */\n\t\trcu_read_lock();\n\t\tfor_each_domain(cpu, sd) {\n\t\t\tenum cpu_idle_type itype;\n\n\t\t\tseq_printf(seq, \"domain%d %*pb\", dcount++,\n\t\t\t\t   cpumask_pr_args(sched_domain_span(sd)));\n\t\t\tfor (itype = CPU_IDLE; itype < CPU_MAX_IDLE_TYPES;\n\t\t\t\t\titype++) {\n\t\t\t\tseq_printf(seq, \" %u %u %u %u %u %u %u %u\",\n\t\t\t\t    sd->lb_count[itype],\n\t\t\t\t    sd->lb_balanced[itype],\n\t\t\t\t    sd->lb_failed[itype],\n\t\t\t\t    sd->lb_imbalance[itype],\n\t\t\t\t    sd->lb_gained[itype],\n\t\t\t\t    sd->lb_hot_gained[itype],\n\t\t\t\t    sd->lb_nobusyq[itype],\n\t\t\t\t    sd->lb_nobusyg[itype]);\n\t\t\t}\n\t\t\tseq_printf(seq,\n\t\t\t\t   \" %u %u %u %u %u %u %u %u %u %u %u %u\\n\",\n\t\t\t    sd->alb_count, sd->alb_failed, sd->alb_pushed,\n\t\t\t    sd->sbe_count, sd->sbe_balanced, sd->sbe_pushed,\n\t\t\t    sd->sbf_count, sd->sbf_balanced, sd->sbf_pushed,\n\t\t\t    sd->ttwu_wake_remote, sd->ttwu_move_affine,\n\t\t\t    sd->ttwu_move_balance);\n\t\t}\n\t\trcu_read_unlock();\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define SCHEDSTAT_VERSION 15"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\" %u %u %u %u %u %u %u %u %u %u %u %u\\n\"",
            "sd->alb_count",
            "sd->alb_failed",
            "sd->alb_pushed",
            "sd->sbe_count",
            "sd->sbe_balanced",
            "sd->sbe_pushed",
            "sd->sbf_count",
            "sd->sbf_balanced",
            "sd->sbf_pushed",
            "sd->ttwu_wake_remote",
            "sd->ttwu_move_affine",
            "sd->ttwu_move_balance"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_domain",
          "args": [
            "cpu",
            "sd"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define SCHEDSTAT_VERSION 15\n\nstatic int show_schedstat(struct seq_file *seq, void *v)\n{\n\tint cpu;\n\n\tif (v == (void *)1) {\n\t\tseq_printf(seq, \"version %d\\n\", SCHEDSTAT_VERSION);\n\t\tseq_printf(seq, \"timestamp %lu\\n\", jiffies);\n\t} else {\n\t\tstruct rq *rq;\n#ifdef CONFIG_SMP\n\t\tstruct sched_domain *sd;\n\t\tint dcount = 0;\n#endif\n\t\tcpu = (unsigned long)(v - 2);\n\t\trq = cpu_rq(cpu);\n\n\t\t/* runqueue-specific stats */\n\t\tseq_printf(seq,\n\t\t    \"cpu%d %u 0 %u %u %u %u %llu %llu %lu\",\n\t\t    cpu, rq->yld_count,\n\t\t    rq->sched_count, rq->sched_goidle,\n\t\t    rq->ttwu_count, rq->ttwu_local,\n\t\t    rq->rq_cpu_time,\n\t\t    rq->rq_sched_info.run_delay, rq->rq_sched_info.pcount);\n\n\t\tseq_printf(seq, \"\\n\");\n\n#ifdef CONFIG_SMP\n\t\t/* domain-specific stats */\n\t\trcu_read_lock();\n\t\tfor_each_domain(cpu, sd) {\n\t\t\tenum cpu_idle_type itype;\n\n\t\t\tseq_printf(seq, \"domain%d %*pb\", dcount++,\n\t\t\t\t   cpumask_pr_args(sched_domain_span(sd)));\n\t\t\tfor (itype = CPU_IDLE; itype < CPU_MAX_IDLE_TYPES;\n\t\t\t\t\titype++) {\n\t\t\t\tseq_printf(seq, \" %u %u %u %u %u %u %u %u\",\n\t\t\t\t    sd->lb_count[itype],\n\t\t\t\t    sd->lb_balanced[itype],\n\t\t\t\t    sd->lb_failed[itype],\n\t\t\t\t    sd->lb_imbalance[itype],\n\t\t\t\t    sd->lb_gained[itype],\n\t\t\t\t    sd->lb_hot_gained[itype],\n\t\t\t\t    sd->lb_nobusyq[itype],\n\t\t\t\t    sd->lb_nobusyg[itype]);\n\t\t\t}\n\t\t\tseq_printf(seq,\n\t\t\t\t   \" %u %u %u %u %u %u %u %u %u %u %u %u\\n\",\n\t\t\t    sd->alb_count, sd->alb_failed, sd->alb_pushed,\n\t\t\t    sd->sbe_count, sd->sbe_balanced, sd->sbe_pushed,\n\t\t\t    sd->sbf_count, sd->sbf_balanced, sd->sbf_pushed,\n\t\t\t    sd->ttwu_wake_remote, sd->ttwu_move_affine,\n\t\t\t    sd->ttwu_move_balance);\n\t\t}\n\t\trcu_read_unlock();\n#endif\n\t}\n\treturn 0;\n}"
  }
]