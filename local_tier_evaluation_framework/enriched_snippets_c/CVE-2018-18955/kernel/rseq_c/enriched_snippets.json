[
  {
    "function_name": "rseq_syscall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
    "lines": "290-301",
    "snippet": "void rseq_syscall(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\n\tif (!t->rseq)\n\t\treturn;\n\tif (!access_ok(VERIFY_READ, t->rseq, sizeof(*t->rseq)) ||\n\t    rseq_get_rseq_cs(t, &rseq_cs) || in_rseq_cs(ip, &rseq_cs))\n\t\tforce_sig(SIGSEGV, t);\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGSEGV",
            "t"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_ptrace_errno_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1638-1648",
          "snippet": "int force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_rseq_cs",
          "args": [
            "ip",
            "&rseq_cs"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "in_rseq_cs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
          "lines": "216-219",
          "snippet": "static bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rseq_get_rseq_cs",
          "args": [
            "t",
            "&rseq_cs"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_get_rseq_cs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
          "lines": "115-159",
          "snippet": "static int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "t->rseq",
            "sizeof(*t->rseq)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nvoid rseq_syscall(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\n\tif (!t->rseq)\n\t\treturn;\n\tif (!access_ok(VERIFY_READ, t->rseq, sizeof(*t->rseq)) ||\n\t    rseq_get_rseq_cs(t, &rseq_cs) || in_rseq_cs(ip, &rseq_cs))\n\t\tforce_sig(SIGSEGV, t);\n}"
  },
  {
    "function_name": "__rseq_handle_notify_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
    "lines": "263-282",
    "snippet": "void __rseq_handle_notify_resume(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tstruct task_struct *t = current;\n\tint ret, sig;\n\n\tif (unlikely(t->flags & PF_EXITING))\n\t\treturn;\n\tif (unlikely(!access_ok(VERIFY_WRITE, t->rseq, sizeof(*t->rseq))))\n\t\tgoto error;\n\tret = rseq_ip_fixup(regs);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\tif (unlikely(rseq_update_cpu_id(t)))\n\t\tgoto error;\n\treturn;\n\nerror:\n\tsig = ksig ? ksig->sig : 0;\n\tforce_sigsegv(sig, t);\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sigsegv",
          "args": [
            "sig",
            "t"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "force_sigsegv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1520-1529",
          "snippet": "void force_sigsegv(int sig, struct task_struct *p)\n{\n\tif (sig == SIGSEGV) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tp->sighand->action[sig - 1].sa.sa_handler = SIG_DFL;\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\n\tforce_sig(SIGSEGV, p);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sigsegv(int sig, struct task_struct *p)\n{\n\tif (sig == SIGSEGV) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tp->sighand->action[sig - 1].sa.sa_handler = SIG_DFL;\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\n\tforce_sig(SIGSEGV, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rseq_update_cpu_id(t)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rseq_update_cpu_id",
          "args": [
            "t"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_update_cpu_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
          "lines": "84-94",
          "snippet": "static int rseq_update_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id = raw_smp_processor_id();\n\n\tif (put_user(cpu_id, &t->rseq->cpu_id_start))\n\t\treturn -EFAULT;\n\tif (put_user(cpu_id, &t->rseq->cpu_id))\n\t\treturn -EFAULT;\n\ttrace_rseq_update(t);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_update_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id = raw_smp_processor_id();\n\n\tif (put_user(cpu_id, &t->rseq->cpu_id_start))\n\t\treturn -EFAULT;\n\tif (put_user(cpu_id, &t->rseq->cpu_id))\n\t\treturn -EFAULT;\n\ttrace_rseq_update(t);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rseq_ip_fixup",
          "args": [
            "regs"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_ip_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
          "lines": "221-249",
          "snippet": "static int rseq_ip_fixup(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\tint ret;\n\n\tret = rseq_get_rseq_cs(t, &rseq_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Handle potentially not being within a critical section.\n\t * If not nested over a rseq critical section, restart is useless.\n\t * Clear the rseq_cs pointer and return.\n\t */\n\tif (!in_rseq_cs(ip, &rseq_cs))\n\t\treturn clear_rseq_cs(t);\n\tret = rseq_need_restart(t, rseq_cs.flags);\n\tif (ret <= 0)\n\t\treturn ret;\n\tret = clear_rseq_cs(t);\n\tif (ret)\n\t\treturn ret;\n\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,\n\t\t\t    rseq_cs.abort_ip);\n\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_ip_fixup(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\tint ret;\n\n\tret = rseq_get_rseq_cs(t, &rseq_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Handle potentially not being within a critical section.\n\t * If not nested over a rseq critical section, restart is useless.\n\t * Clear the rseq_cs pointer and return.\n\t */\n\tif (!in_rseq_cs(ip, &rseq_cs))\n\t\treturn clear_rseq_cs(t);\n\tret = rseq_need_restart(t, rseq_cs.flags);\n\tif (ret <= 0)\n\t\treturn ret;\n\tret = clear_rseq_cs(t);\n\tif (ret)\n\t\treturn ret;\n\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,\n\t\t\t    rseq_cs.abort_ip);\n\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(VERIFY_WRITE, t->rseq, sizeof(*t->rseq))"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "t->rseq",
            "sizeof(*t->rseq)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "t->flags & PF_EXITING"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nvoid __rseq_handle_notify_resume(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tstruct task_struct *t = current;\n\tint ret, sig;\n\n\tif (unlikely(t->flags & PF_EXITING))\n\t\treturn;\n\tif (unlikely(!access_ok(VERIFY_WRITE, t->rseq, sizeof(*t->rseq))))\n\t\tgoto error;\n\tret = rseq_ip_fixup(regs);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\tif (unlikely(rseq_update_cpu_id(t)))\n\t\tgoto error;\n\treturn;\n\nerror:\n\tsig = ksig ? ksig->sig : 0;\n\tforce_sigsegv(sig, t);\n}"
  },
  {
    "function_name": "rseq_ip_fixup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
    "lines": "221-249",
    "snippet": "static int rseq_ip_fixup(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\tint ret;\n\n\tret = rseq_get_rseq_cs(t, &rseq_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Handle potentially not being within a critical section.\n\t * If not nested over a rseq critical section, restart is useless.\n\t * Clear the rseq_cs pointer and return.\n\t */\n\tif (!in_rseq_cs(ip, &rseq_cs))\n\t\treturn clear_rseq_cs(t);\n\tret = rseq_need_restart(t, rseq_cs.flags);\n\tif (ret <= 0)\n\t\treturn ret;\n\tret = clear_rseq_cs(t);\n\tif (ret)\n\t\treturn ret;\n\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,\n\t\t\t    rseq_cs.abort_ip);\n\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instruction_pointer_set",
          "args": [
            "regs",
            "(unsigned long)rseq_cs.abort_ip"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rseq_ip_fixup",
          "args": [
            "ip",
            "rseq_cs.start_ip",
            "rseq_cs.post_commit_offset",
            "rseq_cs.abort_ip"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_rseq_cs",
          "args": [
            "t"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "clear_rseq_cs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
          "lines": "197-210",
          "snippet": "static int clear_rseq_cs(struct task_struct *t)\n{\n\t/*\n\t * The rseq_cs field is set to NULL on preemption or signal\n\t * delivery on top of rseq assembly block, as well as on top\n\t * of code outside of the rseq assembly block. This performs\n\t * a lazy clear of the rseq_cs field.\n\t *\n\t * Set rseq_cs to NULL.\n\t */\n\tif (clear_user(&t->rseq->rseq_cs.ptr64, sizeof(t->rseq->rseq_cs.ptr64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int clear_rseq_cs(struct task_struct *t)\n{\n\t/*\n\t * The rseq_cs field is set to NULL on preemption or signal\n\t * delivery on top of rseq assembly block, as well as on top\n\t * of code outside of the rseq assembly block. This performs\n\t * a lazy clear of the rseq_cs field.\n\t *\n\t * Set rseq_cs to NULL.\n\t */\n\tif (clear_user(&t->rseq->rseq_cs.ptr64, sizeof(t->rseq->rseq_cs.ptr64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rseq_need_restart",
          "args": [
            "t",
            "rseq_cs.flags"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_need_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
          "lines": "161-195",
          "snippet": "static int rseq_need_restart(struct task_struct *t, u32 cs_flags)\n{\n\tu32 flags, event_mask;\n\tint ret;\n\n\t/* Get thread flags. */\n\tret = get_user(flags, &t->rseq->flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take critical section flags into account. */\n\tflags |= cs_flags;\n\n\t/*\n\t * Restart on signal can only be inhibited when restart on\n\t * preempt and restart on migrate are inhibited too. Otherwise,\n\t * a preempted signal handler could fail to restart the prior\n\t * execution context on sigreturn.\n\t */\n\tif (unlikely((flags & RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL) &&\n\t\t     (flags & RSEQ_CS_PREEMPT_MIGRATE_FLAGS) !=\n\t\t     RSEQ_CS_PREEMPT_MIGRATE_FLAGS))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Load and clear event mask atomically with respect to\n\t * scheduler preemption.\n\t */\n\tpreempt_disable();\n\tevent_mask = t->rseq_event_mask;\n\tt->rseq_event_mask = 0;\n\tpreempt_enable();\n\n\treturn !!(event_mask & ~flags);\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RSEQ_CS_PREEMPT_MIGRATE_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE | \\\n\t\t\t\t       RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\n#define RSEQ_CS_PREEMPT_MIGRATE_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE | \\\n\t\t\t\t       RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT)\n\nstatic int rseq_need_restart(struct task_struct *t, u32 cs_flags)\n{\n\tu32 flags, event_mask;\n\tint ret;\n\n\t/* Get thread flags. */\n\tret = get_user(flags, &t->rseq->flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take critical section flags into account. */\n\tflags |= cs_flags;\n\n\t/*\n\t * Restart on signal can only be inhibited when restart on\n\t * preempt and restart on migrate are inhibited too. Otherwise,\n\t * a preempted signal handler could fail to restart the prior\n\t * execution context on sigreturn.\n\t */\n\tif (unlikely((flags & RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL) &&\n\t\t     (flags & RSEQ_CS_PREEMPT_MIGRATE_FLAGS) !=\n\t\t     RSEQ_CS_PREEMPT_MIGRATE_FLAGS))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Load and clear event mask atomically with respect to\n\t * scheduler preemption.\n\t */\n\tpreempt_disable();\n\tevent_mask = t->rseq_event_mask;\n\tt->rseq_event_mask = 0;\n\tpreempt_enable();\n\n\treturn !!(event_mask & ~flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_rseq_cs",
          "args": [
            "ip",
            "&rseq_cs"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "in_rseq_cs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
          "lines": "216-219",
          "snippet": "static bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rseq_get_rseq_cs",
          "args": [
            "t",
            "&rseq_cs"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_get_rseq_cs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
          "lines": "115-159",
          "snippet": "static int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_ip_fixup(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\tint ret;\n\n\tret = rseq_get_rseq_cs(t, &rseq_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Handle potentially not being within a critical section.\n\t * If not nested over a rseq critical section, restart is useless.\n\t * Clear the rseq_cs pointer and return.\n\t */\n\tif (!in_rseq_cs(ip, &rseq_cs))\n\t\treturn clear_rseq_cs(t);\n\tret = rseq_need_restart(t, rseq_cs.flags);\n\tif (ret <= 0)\n\t\treturn ret;\n\tret = clear_rseq_cs(t);\n\tif (ret)\n\t\treturn ret;\n\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,\n\t\t\t    rseq_cs.abort_ip);\n\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);\n\treturn 0;\n}"
  },
  {
    "function_name": "in_rseq_cs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
    "lines": "216-219",
    "snippet": "static bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}"
  },
  {
    "function_name": "clear_rseq_cs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
    "lines": "197-210",
    "snippet": "static int clear_rseq_cs(struct task_struct *t)\n{\n\t/*\n\t * The rseq_cs field is set to NULL on preemption or signal\n\t * delivery on top of rseq assembly block, as well as on top\n\t * of code outside of the rseq assembly block. This performs\n\t * a lazy clear of the rseq_cs field.\n\t *\n\t * Set rseq_cs to NULL.\n\t */\n\tif (clear_user(&t->rseq->rseq_cs.ptr64, sizeof(t->rseq->rseq_cs.ptr64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "&t->rseq->rseq_cs.ptr64",
            "sizeof(t->rseq->rseq_cs.ptr64)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int clear_rseq_cs(struct task_struct *t)\n{\n\t/*\n\t * The rseq_cs field is set to NULL on preemption or signal\n\t * delivery on top of rseq assembly block, as well as on top\n\t * of code outside of the rseq assembly block. This performs\n\t * a lazy clear of the rseq_cs field.\n\t *\n\t * Set rseq_cs to NULL.\n\t */\n\tif (clear_user(&t->rseq->rseq_cs.ptr64, sizeof(t->rseq->rseq_cs.ptr64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "rseq_need_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
    "lines": "161-195",
    "snippet": "static int rseq_need_restart(struct task_struct *t, u32 cs_flags)\n{\n\tu32 flags, event_mask;\n\tint ret;\n\n\t/* Get thread flags. */\n\tret = get_user(flags, &t->rseq->flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take critical section flags into account. */\n\tflags |= cs_flags;\n\n\t/*\n\t * Restart on signal can only be inhibited when restart on\n\t * preempt and restart on migrate are inhibited too. Otherwise,\n\t * a preempted signal handler could fail to restart the prior\n\t * execution context on sigreturn.\n\t */\n\tif (unlikely((flags & RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL) &&\n\t\t     (flags & RSEQ_CS_PREEMPT_MIGRATE_FLAGS) !=\n\t\t     RSEQ_CS_PREEMPT_MIGRATE_FLAGS))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Load and clear event mask atomically with respect to\n\t * scheduler preemption.\n\t */\n\tpreempt_disable();\n\tevent_mask = t->rseq_event_mask;\n\tt->rseq_event_mask = 0;\n\tpreempt_enable();\n\n\treturn !!(event_mask & ~flags);\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RSEQ_CS_PREEMPT_MIGRATE_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE | \\\n\t\t\t\t       RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(flags & RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL) &&\n\t\t     (flags & RSEQ_CS_PREEMPT_MIGRATE_FLAGS) !=\n\t\t     RSEQ_CS_PREEMPT_MIGRATE_FLAGS"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "flags",
            "&t->rseq->flags"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\n#define RSEQ_CS_PREEMPT_MIGRATE_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE | \\\n\t\t\t\t       RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT)\n\nstatic int rseq_need_restart(struct task_struct *t, u32 cs_flags)\n{\n\tu32 flags, event_mask;\n\tint ret;\n\n\t/* Get thread flags. */\n\tret = get_user(flags, &t->rseq->flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take critical section flags into account. */\n\tflags |= cs_flags;\n\n\t/*\n\t * Restart on signal can only be inhibited when restart on\n\t * preempt and restart on migrate are inhibited too. Otherwise,\n\t * a preempted signal handler could fail to restart the prior\n\t * execution context on sigreturn.\n\t */\n\tif (unlikely((flags & RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL) &&\n\t\t     (flags & RSEQ_CS_PREEMPT_MIGRATE_FLAGS) !=\n\t\t     RSEQ_CS_PREEMPT_MIGRATE_FLAGS))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Load and clear event mask atomically with respect to\n\t * scheduler preemption.\n\t */\n\tpreempt_disable();\n\tevent_mask = t->rseq_event_mask;\n\tt->rseq_event_mask = 0;\n\tpreempt_enable();\n\n\treturn !!(event_mask & ~flags);\n}"
  },
  {
    "function_name": "rseq_get_rseq_cs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
    "lines": "115-159",
    "snippet": "static int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\"",
            "sig",
            "current->rseq_sig",
            "current->pid",
            "usig"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "sig",
            "usig"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "rseq_cs",
            "urseq_cs",
            "sizeof(*rseq_cs)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rseq_cs",
            "0",
            "sizeof(*rseq_cs)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ptr",
            "&t->rseq->rseq_cs.ptr64",
            "sizeof(ptr)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "rseq_reset_rseq_cpu_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
    "lines": "96-113",
    "snippet": "static int rseq_reset_rseq_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id_start = 0, cpu_id = RSEQ_CPU_ID_UNINITIALIZED;\n\n\t/*\n\t * Reset cpu_id_start to its initial state (0).\n\t */\n\tif (put_user(cpu_id_start, &t->rseq->cpu_id_start))\n\t\treturn -EFAULT;\n\t/*\n\t * Reset cpu_id to RSEQ_CPU_ID_UNINITIALIZED, so any user coming\n\t * in after unregistration can figure out that rseq needs to be\n\t * registered again.\n\t */\n\tif (put_user(cpu_id, &t->rseq->cpu_id))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "cpu_id",
            "&t->rseq->cpu_id"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "cpu_id_start",
            "&t->rseq->cpu_id_start"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_reset_rseq_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id_start = 0, cpu_id = RSEQ_CPU_ID_UNINITIALIZED;\n\n\t/*\n\t * Reset cpu_id_start to its initial state (0).\n\t */\n\tif (put_user(cpu_id_start, &t->rseq->cpu_id_start))\n\t\treturn -EFAULT;\n\t/*\n\t * Reset cpu_id to RSEQ_CPU_ID_UNINITIALIZED, so any user coming\n\t * in after unregistration can figure out that rseq needs to be\n\t * registered again.\n\t */\n\tif (put_user(cpu_id, &t->rseq->cpu_id))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "rseq_update_cpu_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
    "lines": "84-94",
    "snippet": "static int rseq_update_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id = raw_smp_processor_id();\n\n\tif (put_user(cpu_id, &t->rseq->cpu_id_start))\n\t\treturn -EFAULT;\n\tif (put_user(cpu_id, &t->rseq->cpu_id))\n\t\treturn -EFAULT;\n\ttrace_rseq_update(t);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rseq_update",
          "args": [
            "t"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "cpu_id",
            "&t->rseq->cpu_id"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "cpu_id",
            "&t->rseq->cpu_id_start"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_update_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id = raw_smp_processor_id();\n\n\tif (put_user(cpu_id, &t->rseq->cpu_id_start))\n\t\treturn -EFAULT;\n\tif (put_user(cpu_id, &t->rseq->cpu_id))\n\t\treturn -EFAULT;\n\ttrace_rseq_update(t);\n\treturn 0;\n}"
  },
  {
    "function_name": "rseq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rseq.c",
    "lines": "308-367",
    "snippet": "SYSCALL_DEFINE4(rseq, struct rseq __user *, rseq, u32, rseq_len,\n\t\tint, flags, u32, sig)\n{\n\tint ret;\n\n\tif (flags & RSEQ_FLAG_UNREGISTER) {\n\t\t/* Unregister rseq for current thread. */\n\t\tif (current->rseq != rseq || !current->rseq)\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_len != rseq_len)\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_sig != sig)\n\t\t\treturn -EPERM;\n\t\tret = rseq_reset_rseq_cpu_id(current);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcurrent->rseq = NULL;\n\t\tcurrent->rseq_len = 0;\n\t\tcurrent->rseq_sig = 0;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(flags))\n\t\treturn -EINVAL;\n\n\tif (current->rseq) {\n\t\t/*\n\t\t * If rseq is already registered, check whether\n\t\t * the provided address differs from the prior\n\t\t * one.\n\t\t */\n\t\tif (current->rseq != rseq || current->rseq_len != rseq_len)\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_sig != sig)\n\t\t\treturn -EPERM;\n\t\t/* Already registered. */\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * If there was no rseq previously registered,\n\t * ensure the provided rseq is properly aligned and valid.\n\t */\n\tif (!IS_ALIGNED((unsigned long)rseq, __alignof__(*rseq)) ||\n\t    rseq_len != sizeof(*rseq))\n\t\treturn -EINVAL;\n\tif (!access_ok(VERIFY_WRITE, rseq, rseq_len))\n\t\treturn -EFAULT;\n\tcurrent->rseq = rseq;\n\tcurrent->rseq_len = rseq_len;\n\tcurrent->rseq_sig = sig;\n\t/*\n\t * If rseq was previously inactive, and has just been\n\t * registered, ensure the cpu_id_start and cpu_id fields\n\t * are updated before returning to user-space.\n\t */\n\trseq_set_notify_resume(current);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nSYSCALL_DEFINE4(rseq, struct rseq __user *, rseq, u32, rseq_len,\n\t\tint, flags, u32, sig)\n{\n\tint ret;\n\n\tif (flags & RSEQ_FLAG_UNREGISTER) {\n\t\t/* Unregister rseq for current thread. */\n\t\tif (current->rseq != rseq || !current->rseq)\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_len != rseq_len)\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_sig != sig)\n\t\t\treturn -EPERM;\n\t\tret = rseq_reset_rseq_cpu_id(current);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcurrent->rseq = NULL;\n\t\tcurrent->rseq_len = 0;\n\t\tcurrent->rseq_sig = 0;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(flags))\n\t\treturn -EINVAL;\n\n\tif (current->rseq) {\n\t\t/*\n\t\t * If rseq is already registered, check whether\n\t\t * the provided address differs from the prior\n\t\t * one.\n\t\t */\n\t\tif (current->rseq != rseq || current->rseq_len != rseq_len)\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_sig != sig)\n\t\t\treturn -EPERM;\n\t\t/* Already registered. */\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * If there was no rseq previously registered,\n\t * ensure the provided rseq is properly aligned and valid.\n\t */\n\tif (!IS_ALIGNED((unsigned long)rseq, __alignof__(*rseq)) ||\n\t    rseq_len != sizeof(*rseq))\n\t\treturn -EINVAL;\n\tif (!access_ok(VERIFY_WRITE, rseq, rseq_len))\n\t\treturn -EFAULT;\n\tcurrent->rseq = rseq;\n\tcurrent->rseq_len = rseq_len;\n\tcurrent->rseq_sig = sig;\n\t/*\n\t * If rseq was previously inactive, and has just been\n\t * registered, ensure the cpu_id_start and cpu_id fields\n\t * are updated before returning to user-space.\n\t */\n\trseq_set_notify_resume(current);\n\n\treturn 0;\n}"
  }
]