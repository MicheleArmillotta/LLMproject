[
  {
    "function_name": "bpf_lru_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "691-697",
    "snippet": "void bpf_lru_destroy(struct bpf_lru *lru)\n{\n\tif (lru->percpu)\n\t\tfree_percpu(lru->percpu_lru);\n\telse\n\t\tfree_percpu(lru->common_lru.local_list);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "lru->common_lru.local_list"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_destroy(struct bpf_lru *lru)\n{\n\tif (lru->percpu)\n\t\tfree_percpu(lru->percpu_lru);\n\telse\n\t\tfree_percpu(lru->common_lru.local_list);\n}"
  },
  {
    "function_name": "bpf_lru_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "648-689",
    "snippet": "int bpf_lru_init(struct bpf_lru *lru, bool percpu, u32 hash_offset,\n\t\t del_from_htab_func del_from_htab, void *del_arg)\n{\n\tint cpu;\n\n\tif (percpu) {\n\t\tlru->percpu_lru = alloc_percpu(struct bpf_lru_list);\n\t\tif (!lru->percpu_lru)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_list *l;\n\n\t\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\t\t\tbpf_lru_list_init(l);\n\t\t}\n\t\tlru->nr_scans = PERCPU_NR_SCANS;\n\t} else {\n\t\tstruct bpf_common_lru *clru = &lru->common_lru;\n\n\t\tclru->local_list = alloc_percpu(struct bpf_lru_locallist);\n\t\tif (!clru->local_list)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\t\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\t\t\tbpf_lru_locallist_init(loc_l, cpu);\n\t\t}\n\n\t\tbpf_lru_list_init(&clru->lru_list);\n\t\tlru->nr_scans = LOCAL_NR_SCANS;\n\t}\n\n\tlru->percpu = percpu;\n\tlru->del_from_htab = del_from_htab;\n\tlru->del_arg = del_arg;\n\tlru->hash_offset = hash_offset;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [
      "#define PERCPU_NR_SCANS\t\t\tPERCPU_FREE_TARGET",
      "#define LOCAL_NR_SCANS\t\t\tLOCAL_FREE_TARGET"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_lru_list_init",
          "args": [
            "&clru->lru_list"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "633-646",
          "snippet": "static void bpf_lru_list_init(struct bpf_lru_list *l)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&l->lists[i]);\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_COUNT; i++)\n\t\tl->counts[i] = 0;\n\n\tl->next_inactive_rotation = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\n\traw_spin_lock_init(&l->lock);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_init(struct bpf_lru_list *l)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&l->lists[i]);\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_COUNT; i++)\n\t\tl->counts[i] = 0;\n\n\tl->next_inactive_rotation = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\n\traw_spin_lock_init(&l->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_locallist_init",
          "args": [
            "loc_l",
            "cpu"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_locallist_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "621-631",
          "snippet": "static void bpf_lru_locallist_init(struct bpf_lru_locallist *loc_l, int cpu)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LOCAL_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&loc_l->lists[i]);\n\n\tloc_l->next_steal = cpu;\n\n\traw_spin_lock_init(&loc_l->lock);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_locallist_init(struct bpf_lru_locallist *loc_l, int cpu)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LOCAL_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&loc_l->lists[i]);\n\n\tloc_l->next_steal = cpu;\n\n\traw_spin_lock_init(&loc_l->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "clru->local_list",
            "cpu"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structbpf_lru_locallist"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "lru->percpu_lru",
            "cpu"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define PERCPU_NR_SCANS\t\t\tPERCPU_FREE_TARGET\n#define LOCAL_NR_SCANS\t\t\tLOCAL_FREE_TARGET\n\nint bpf_lru_init(struct bpf_lru *lru, bool percpu, u32 hash_offset,\n\t\t del_from_htab_func del_from_htab, void *del_arg)\n{\n\tint cpu;\n\n\tif (percpu) {\n\t\tlru->percpu_lru = alloc_percpu(struct bpf_lru_list);\n\t\tif (!lru->percpu_lru)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_list *l;\n\n\t\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\t\t\tbpf_lru_list_init(l);\n\t\t}\n\t\tlru->nr_scans = PERCPU_NR_SCANS;\n\t} else {\n\t\tstruct bpf_common_lru *clru = &lru->common_lru;\n\n\t\tclru->local_list = alloc_percpu(struct bpf_lru_locallist);\n\t\tif (!clru->local_list)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\t\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\t\t\tbpf_lru_locallist_init(loc_l, cpu);\n\t\t}\n\n\t\tbpf_lru_list_init(&clru->lru_list);\n\t\tlru->nr_scans = LOCAL_NR_SCANS;\n\t}\n\n\tlru->percpu = percpu;\n\tlru->del_from_htab = del_from_htab;\n\tlru->del_arg = del_arg;\n\tlru->hash_offset = hash_offset;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_lru_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "633-646",
    "snippet": "static void bpf_lru_list_init(struct bpf_lru_list *l)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&l->lists[i]);\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_COUNT; i++)\n\t\tl->counts[i] = 0;\n\n\tl->next_inactive_rotation = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\n\traw_spin_lock_init(&l->lock);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&l->lock"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&l->lists[i]"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_init(struct bpf_lru_list *l)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&l->lists[i]);\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_COUNT; i++)\n\t\tl->counts[i] = 0;\n\n\tl->next_inactive_rotation = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\n\traw_spin_lock_init(&l->lock);\n}"
  },
  {
    "function_name": "bpf_lru_locallist_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "621-631",
    "snippet": "static void bpf_lru_locallist_init(struct bpf_lru_locallist *loc_l, int cpu)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LOCAL_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&loc_l->lists[i]);\n\n\tloc_l->next_steal = cpu;\n\n\traw_spin_lock_init(&loc_l->lock);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&loc_l->lock"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&loc_l->lists[i]"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_locallist_init(struct bpf_lru_locallist *loc_l, int cpu)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LOCAL_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&loc_l->lists[i]);\n\n\tloc_l->next_steal = cpu;\n\n\traw_spin_lock_init(&loc_l->lock);\n}"
  },
  {
    "function_name": "bpf_lru_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "610-619",
    "snippet": "void bpf_lru_populate(struct bpf_lru *lru, void *buf, u32 node_offset,\n\t\t      u32 elem_size, u32 nr_elems)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n\telse\n\t\tbpf_common_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_common_lru_populate",
          "args": [
            "lru",
            "buf",
            "node_offset",
            "elem_size",
            "nr_elems"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_common_lru_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "561-577",
          "snippet": "static void bpf_common_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tu32 i;\n\n\tfor (i = 0; i < nr_elems; i++) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\tbuf += elem_size;\n\t}\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_common_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tu32 i;\n\n\tfor (i = 0; i < nr_elems; i++) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\tbuf += elem_size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_lru_populate",
          "args": [
            "lru",
            "buf",
            "node_offset",
            "elem_size",
            "nr_elems"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_lru_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "579-608",
          "snippet": "static void bpf_percpu_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tu32 i, pcpu_entries;\n\tint cpu;\n\tstruct bpf_lru_list *l;\n\n\tpcpu_entries = nr_elems / num_possible_cpus();\n\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\nagain:\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->cpu = cpu;\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_percpu_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tu32 i, pcpu_entries;\n\tint cpu;\n\tstruct bpf_lru_list *l;\n\n\tpcpu_entries = nr_elems / num_possible_cpus();\n\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\nagain:\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->cpu = cpu;\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_populate(struct bpf_lru *lru, void *buf, u32 node_offset,\n\t\t      u32 elem_size, u32 nr_elems)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n\telse\n\t\tbpf_common_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n}"
  },
  {
    "function_name": "bpf_percpu_lru_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "579-608",
    "snippet": "static void bpf_percpu_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tu32 i, pcpu_entries;\n\tint cpu;\n\tstruct bpf_lru_list *l;\n\n\tpcpu_entries = nr_elems / num_possible_cpus();\n\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\nagain:\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->cpu = cpu;\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&node->list",
            "&l->lists[BPF_LRU_LIST_T_FREE]"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "lru->percpu_lru",
            "cpu"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_percpu_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tu32 i, pcpu_entries;\n\tint cpu;\n\tstruct bpf_lru_list *l;\n\n\tpcpu_entries = nr_elems / num_possible_cpus();\n\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\nagain:\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->cpu = cpu;\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}"
  },
  {
    "function_name": "bpf_common_lru_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "561-577",
    "snippet": "static void bpf_common_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tu32 i;\n\n\tfor (i = 0; i < nr_elems; i++) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\tbuf += elem_size;\n\t}\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&node->list",
            "&l->lists[BPF_LRU_LIST_T_FREE]"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_common_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tu32 i;\n\n\tfor (i = 0; i < nr_elems; i++) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\tbuf += elem_size;\n\t}\n}"
  },
  {
    "function_name": "bpf_lru_push_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "553-559",
    "snippet": "void bpf_lru_push_free(struct bpf_lru *lru, struct bpf_lru_node *node)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_push_free(lru, node);\n\telse\n\t\tbpf_common_lru_push_free(lru, node);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_common_lru_push_free",
          "args": [
            "lru",
            "node"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_common_lru_push_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "505-536",
          "snippet": "static void bpf_common_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(node->type == BPF_LRU_LIST_T_FREE) ||\n\t    WARN_ON_ONCE(node->type == BPF_LRU_LOCAL_LIST_T_FREE))\n\t\treturn;\n\n\tif (node->type == BPF_LRU_LOCAL_LIST_T_PENDING) {\n\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\tloc_l = per_cpu_ptr(lru->common_lru.local_list, node->cpu);\n\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\t\tif (unlikely(node->type != BPF_LRU_LOCAL_LIST_T_PENDING)) {\n\t\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\t\tgoto check_lru_list;\n\t\t}\n\n\t\tnode->type = BPF_LRU_LOCAL_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_move(&node->list, local_free_list(loc_l));\n\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\treturn;\n\t}\n\ncheck_lru_list:\n\tbpf_lru_list_push_free(&lru->common_lru.lru_list, node);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_common_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(node->type == BPF_LRU_LIST_T_FREE) ||\n\t    WARN_ON_ONCE(node->type == BPF_LRU_LOCAL_LIST_T_FREE))\n\t\treturn;\n\n\tif (node->type == BPF_LRU_LOCAL_LIST_T_PENDING) {\n\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\tloc_l = per_cpu_ptr(lru->common_lru.local_list, node->cpu);\n\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\t\tif (unlikely(node->type != BPF_LRU_LOCAL_LIST_T_PENDING)) {\n\t\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\t\tgoto check_lru_list;\n\t\t}\n\n\t\tnode->type = BPF_LRU_LOCAL_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_move(&node->list, local_free_list(loc_l));\n\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\treturn;\n\t}\n\ncheck_lru_list:\n\tbpf_lru_list_push_free(&lru->common_lru.lru_list, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_lru_push_free",
          "args": [
            "lru",
            "node"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_lru_push_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "538-551",
          "snippet": "static void bpf_percpu_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\n\tl = per_cpu_ptr(lru->percpu_lru, node->cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_percpu_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\n\tl = per_cpu_ptr(lru->percpu_lru, node->cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_push_free(struct bpf_lru *lru, struct bpf_lru_node *node)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_push_free(lru, node);\n\telse\n\t\tbpf_common_lru_push_free(lru, node);\n}"
  },
  {
    "function_name": "bpf_percpu_lru_push_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "538-551",
    "snippet": "static void bpf_percpu_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\n\tl = per_cpu_ptr(lru->percpu_lru, node->cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_FREE"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "103-125",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "lru->percpu_lru",
            "node->cpu"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_percpu_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\n\tl = per_cpu_ptr(lru->percpu_lru, node->cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}"
  },
  {
    "function_name": "bpf_common_lru_push_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "505-536",
    "snippet": "static void bpf_common_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(node->type == BPF_LRU_LIST_T_FREE) ||\n\t    WARN_ON_ONCE(node->type == BPF_LRU_LOCAL_LIST_T_FREE))\n\t\treturn;\n\n\tif (node->type == BPF_LRU_LOCAL_LIST_T_PENDING) {\n\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\tloc_l = per_cpu_ptr(lru->common_lru.local_list, node->cpu);\n\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\t\tif (unlikely(node->type != BPF_LRU_LOCAL_LIST_T_PENDING)) {\n\t\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\t\tgoto check_lru_list;\n\t\t}\n\n\t\tnode->type = BPF_LRU_LOCAL_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_move(&node->list, local_free_list(loc_l));\n\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\treturn;\n\t}\n\ncheck_lru_list:\n\tbpf_lru_list_push_free(&lru->common_lru.lru_list, node);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_lru_list_push_free",
          "args": [
            "&lru->common_lru.lru_list",
            "node"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_push_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "308-319",
          "snippet": "static void bpf_lru_list_push_free(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_push_free(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&loc_l->lock",
            "flags"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&node->list",
            "local_free_list(loc_l)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_free_list",
          "args": [
            "loc_l"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "local_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "34-37",
          "snippet": "static struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)\n\nstatic struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "node->type != BPF_LRU_LOCAL_LIST_T_PENDING"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&loc_l->lock",
            "flags"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "lru->common_lru.local_list",
            "node->cpu"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "node->type == BPF_LRU_LOCAL_LIST_T_FREE"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "node->type == BPF_LRU_LIST_T_FREE"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_common_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(node->type == BPF_LRU_LIST_T_FREE) ||\n\t    WARN_ON_ONCE(node->type == BPF_LRU_LOCAL_LIST_T_FREE))\n\t\treturn;\n\n\tif (node->type == BPF_LRU_LOCAL_LIST_T_PENDING) {\n\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\tloc_l = per_cpu_ptr(lru->common_lru.local_list, node->cpu);\n\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\t\tif (unlikely(node->type != BPF_LRU_LOCAL_LIST_T_PENDING)) {\n\t\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\t\tgoto check_lru_list;\n\t\t}\n\n\t\tnode->type = BPF_LRU_LOCAL_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_move(&node->list, local_free_list(loc_l));\n\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\treturn;\n\t}\n\ncheck_lru_list:\n\tbpf_lru_list_push_free(&lru->common_lru.lru_list, node);\n}"
  },
  {
    "function_name": "bpf_lru_pop_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "497-503",
    "snippet": "struct bpf_lru_node *bpf_lru_pop_free(struct bpf_lru *lru, u32 hash)\n{\n\tif (lru->percpu)\n\t\treturn bpf_percpu_lru_pop_free(lru, hash);\n\telse\n\t\treturn bpf_common_lru_pop_free(lru, hash);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_common_lru_pop_free",
          "args": [
            "lru",
            "hash"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_common_lru_pop_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "434-495",
          "snippet": "static struct bpf_lru_node *bpf_common_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct bpf_lru_locallist *loc_l, *steal_loc_l;\n\tstruct bpf_common_lru *clru = &lru->common_lru;\n\tstruct bpf_lru_node *node;\n\tint steal, first_steal;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\n\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\tnode = __local_list_pop_free(loc_l);\n\tif (!node) {\n\t\tbpf_lru_list_pop_free_to_local(lru, loc_l);\n\t\tnode = __local_list_pop_free(loc_l);\n\t}\n\n\tif (node)\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\n\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\n\tif (node)\n\t\treturn node;\n\n\t/* No free nodes found from the local free list and\n\t * the global LRU list.\n\t *\n\t * Steal from the local free/pending list of the\n\t * current CPU and remote CPU in RR.  It starts\n\t * with the loc_l->next_steal CPU.\n\t */\n\n\tfirst_steal = loc_l->next_steal;\n\tsteal = first_steal;\n\tdo {\n\t\tsteal_loc_l = per_cpu_ptr(clru->local_list, steal);\n\n\t\traw_spin_lock_irqsave(&steal_loc_l->lock, flags);\n\n\t\tnode = __local_list_pop_free(steal_loc_l);\n\t\tif (!node)\n\t\t\tnode = __local_list_pop_pending(lru, steal_loc_l);\n\n\t\traw_spin_unlock_irqrestore(&steal_loc_l->lock, flags);\n\n\t\tsteal = get_next_cpu(steal);\n\t} while (!node && steal != first_steal);\n\n\tloc_l->next_steal = steal;\n\n\tif (node) {\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t}\n\n\treturn node;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *bpf_common_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct bpf_lru_locallist *loc_l, *steal_loc_l;\n\tstruct bpf_common_lru *clru = &lru->common_lru;\n\tstruct bpf_lru_node *node;\n\tint steal, first_steal;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\n\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\tnode = __local_list_pop_free(loc_l);\n\tif (!node) {\n\t\tbpf_lru_list_pop_free_to_local(lru, loc_l);\n\t\tnode = __local_list_pop_free(loc_l);\n\t}\n\n\tif (node)\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\n\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\n\tif (node)\n\t\treturn node;\n\n\t/* No free nodes found from the local free list and\n\t * the global LRU list.\n\t *\n\t * Steal from the local free/pending list of the\n\t * current CPU and remote CPU in RR.  It starts\n\t * with the loc_l->next_steal CPU.\n\t */\n\n\tfirst_steal = loc_l->next_steal;\n\tsteal = first_steal;\n\tdo {\n\t\tsteal_loc_l = per_cpu_ptr(clru->local_list, steal);\n\n\t\traw_spin_lock_irqsave(&steal_loc_l->lock, flags);\n\n\t\tnode = __local_list_pop_free(steal_loc_l);\n\t\tif (!node)\n\t\t\tnode = __local_list_pop_pending(lru, steal_loc_l);\n\n\t\traw_spin_unlock_irqrestore(&steal_loc_l->lock, flags);\n\n\t\tsteal = get_next_cpu(steal);\n\t} while (!node && steal != first_steal);\n\n\tloc_l->next_steal = steal;\n\n\tif (node) {\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t}\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_lru_pop_free",
          "args": [
            "lru",
            "hash"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_lru_pop_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "402-432",
          "snippet": "static struct bpf_lru_node *bpf_percpu_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct list_head *free_list;\n\tstruct bpf_lru_node *node = NULL;\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tfree_list = &l->lists[BPF_LRU_LIST_T_FREE];\n\tif (list_empty(free_list))\n\t\t__bpf_lru_list_shrink(lru, l, PERCPU_FREE_TARGET, free_list,\n\t\t\t\t      BPF_LRU_LIST_T_FREE);\n\n\tif (!list_empty(free_list)) {\n\t\tnode = list_first_entry(free_list, struct bpf_lru_node, list);\n\t\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\t\tnode->ref = 0;\n\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\t}\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n\n\treturn node;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define PERCPU_FREE_TARGET\t\t(4)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define PERCPU_FREE_TARGET\t\t(4)\n\nstatic struct bpf_lru_node *bpf_percpu_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct list_head *free_list;\n\tstruct bpf_lru_node *node = NULL;\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tfree_list = &l->lists[BPF_LRU_LIST_T_FREE];\n\tif (list_empty(free_list))\n\t\t__bpf_lru_list_shrink(lru, l, PERCPU_FREE_TARGET, free_list,\n\t\t\t\t      BPF_LRU_LIST_T_FREE);\n\n\tif (!list_empty(free_list)) {\n\t\tnode = list_first_entry(free_list, struct bpf_lru_node, list);\n\t\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\t\tnode->ref = 0;\n\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\t}\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstruct bpf_lru_node *bpf_lru_pop_free(struct bpf_lru *lru, u32 hash)\n{\n\tif (lru->percpu)\n\t\treturn bpf_percpu_lru_pop_free(lru, hash);\n\telse\n\t\treturn bpf_common_lru_pop_free(lru, hash);\n}"
  },
  {
    "function_name": "bpf_common_lru_pop_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "434-495",
    "snippet": "static struct bpf_lru_node *bpf_common_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct bpf_lru_locallist *loc_l, *steal_loc_l;\n\tstruct bpf_common_lru *clru = &lru->common_lru;\n\tstruct bpf_lru_node *node;\n\tint steal, first_steal;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\n\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\tnode = __local_list_pop_free(loc_l);\n\tif (!node) {\n\t\tbpf_lru_list_pop_free_to_local(lru, loc_l);\n\t\tnode = __local_list_pop_free(loc_l);\n\t}\n\n\tif (node)\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\n\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\n\tif (node)\n\t\treturn node;\n\n\t/* No free nodes found from the local free list and\n\t * the global LRU list.\n\t *\n\t * Steal from the local free/pending list of the\n\t * current CPU and remote CPU in RR.  It starts\n\t * with the loc_l->next_steal CPU.\n\t */\n\n\tfirst_steal = loc_l->next_steal;\n\tsteal = first_steal;\n\tdo {\n\t\tsteal_loc_l = per_cpu_ptr(clru->local_list, steal);\n\n\t\traw_spin_lock_irqsave(&steal_loc_l->lock, flags);\n\n\t\tnode = __local_list_pop_free(steal_loc_l);\n\t\tif (!node)\n\t\t\tnode = __local_list_pop_pending(lru, steal_loc_l);\n\n\t\traw_spin_unlock_irqrestore(&steal_loc_l->lock, flags);\n\n\t\tsteal = get_next_cpu(steal);\n\t} while (!node && steal != first_steal);\n\n\tloc_l->next_steal = steal;\n\n\tif (node) {\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t}\n\n\treturn node;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&loc_l->lock",
            "flags"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__local_list_add_pending",
          "args": [
            "lru",
            "loc_l",
            "cpu",
            "node",
            "hash"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "__local_list_add_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "350-361",
          "snippet": "static void __local_list_add_pending(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_locallist *loc_l,\n\t\t\t\t     int cpu,\n\t\t\t\t     struct bpf_lru_node *node,\n\t\t\t\t     u32 hash)\n{\n\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\tnode->cpu = cpu;\n\tnode->type = BPF_LRU_LOCAL_LIST_T_PENDING;\n\tnode->ref = 0;\n\tlist_add(&node->list, local_pending_list(loc_l));\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __local_list_add_pending(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_locallist *loc_l,\n\t\t\t\t     int cpu,\n\t\t\t\t     struct bpf_lru_node *node,\n\t\t\t\t     u32 hash)\n{\n\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\tnode->cpu = cpu;\n\tnode->type = BPF_LRU_LOCAL_LIST_T_PENDING;\n\tnode->ref = 0;\n\tlist_add(&node->list, local_pending_list(loc_l));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&loc_l->lock",
            "flags"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_cpu",
          "args": [
            "steal"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "25-31",
          "snippet": "static int get_next_cpu(int cpu)\n{\n\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\tif (cpu >= nr_cpu_ids)\n\t\tcpu = cpumask_first(cpu_possible_mask);\n\treturn cpu;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic int get_next_cpu(int cpu)\n{\n\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\tif (cpu >= nr_cpu_ids)\n\t\tcpu = cpumask_first(cpu_possible_mask);\n\treturn cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__local_list_pop_pending",
          "args": [
            "lru",
            "steal_loc_l"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "__local_list_pop_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "377-400",
          "snippet": "static struct bpf_lru_node *\n__local_list_pop_pending(struct bpf_lru *lru, struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\tbool force = false;\n\nignore_ref:\n\t/* Get from the tail (i.e. older element) of the pending list. */\n\tlist_for_each_entry_reverse(node, local_pending_list(loc_l),\n\t\t\t\t    list) {\n\t\tif ((!bpf_lru_node_is_ref(node) || force) &&\n\t\t    lru->del_from_htab(lru->del_arg, node)) {\n\t\t\tlist_del(&node->list);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tif (!force) {\n\t\tforce = true;\n\t\tgoto ignore_ref;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *\n__local_list_pop_pending(struct bpf_lru *lru, struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\tbool force = false;\n\nignore_ref:\n\t/* Get from the tail (i.e. older element) of the pending list. */\n\tlist_for_each_entry_reverse(node, local_pending_list(loc_l),\n\t\t\t\t    list) {\n\t\tif ((!bpf_lru_node_is_ref(node) || force) &&\n\t\t    lru->del_from_htab(lru->del_arg, node)) {\n\t\t\tlist_del(&node->list);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tif (!force) {\n\t\tforce = true;\n\t\tgoto ignore_ref;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__local_list_pop_free",
          "args": [
            "steal_loc_l"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "__local_list_pop_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "363-375",
          "snippet": "static struct bpf_lru_node *\n__local_list_pop_free(struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\n\tnode = list_first_entry_or_null(local_free_list(loc_l),\n\t\t\t\t\tstruct bpf_lru_node,\n\t\t\t\t\tlist);\n\tif (node)\n\t\tlist_del(&node->list);\n\n\treturn node;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *\n__local_list_pop_free(struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\n\tnode = list_first_entry_or_null(local_free_list(loc_l),\n\t\t\t\t\tstruct bpf_lru_node,\n\t\t\t\t\tlist);\n\tif (node)\n\t\tlist_del(&node->list);\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "clru->local_list",
            "steal"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_pop_free_to_local",
          "args": [
            "lru",
            "loc_l"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_pop_free_to_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "321-348",
          "snippet": "static void bpf_lru_list_pop_free_to_local(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nfree = 0;\n\n\traw_spin_lock(&l->lock);\n\n\t__local_list_flush(l, loc_l);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tlist_for_each_entry_safe(node, tmp_node, &l->lists[BPF_LRU_LIST_T_FREE],\n\t\t\t\t list) {\n\t\t__bpf_lru_node_move_to_free(l, node, local_free_list(loc_l),\n\t\t\t\t\t    BPF_LRU_LOCAL_LIST_T_FREE);\n\t\tif (++nfree == LOCAL_FREE_TARGET)\n\t\t\tbreak;\n\t}\n\n\tif (nfree < LOCAL_FREE_TARGET)\n\t\t__bpf_lru_list_shrink(lru, l, LOCAL_FREE_TARGET - nfree,\n\t\t\t\t      local_free_list(loc_l),\n\t\t\t\t      BPF_LRU_LOCAL_LIST_T_FREE);\n\n\traw_spin_unlock(&l->lock);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_FREE_TARGET\t\t(128)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_TARGET\t\t(128)\n\nstatic void bpf_lru_list_pop_free_to_local(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nfree = 0;\n\n\traw_spin_lock(&l->lock);\n\n\t__local_list_flush(l, loc_l);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tlist_for_each_entry_safe(node, tmp_node, &l->lists[BPF_LRU_LIST_T_FREE],\n\t\t\t\t list) {\n\t\t__bpf_lru_node_move_to_free(l, node, local_free_list(loc_l),\n\t\t\t\t\t    BPF_LRU_LOCAL_LIST_T_FREE);\n\t\tif (++nfree == LOCAL_FREE_TARGET)\n\t\t\tbreak;\n\t}\n\n\tif (nfree < LOCAL_FREE_TARGET)\n\t\t__bpf_lru_list_shrink(lru, l, LOCAL_FREE_TARGET - nfree,\n\t\t\t\t      local_free_list(loc_l),\n\t\t\t\t      BPF_LRU_LOCAL_LIST_T_FREE);\n\n\traw_spin_unlock(&l->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "clru->local_list",
            "cpu"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *bpf_common_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct bpf_lru_locallist *loc_l, *steal_loc_l;\n\tstruct bpf_common_lru *clru = &lru->common_lru;\n\tstruct bpf_lru_node *node;\n\tint steal, first_steal;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\n\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\tnode = __local_list_pop_free(loc_l);\n\tif (!node) {\n\t\tbpf_lru_list_pop_free_to_local(lru, loc_l);\n\t\tnode = __local_list_pop_free(loc_l);\n\t}\n\n\tif (node)\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\n\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\n\tif (node)\n\t\treturn node;\n\n\t/* No free nodes found from the local free list and\n\t * the global LRU list.\n\t *\n\t * Steal from the local free/pending list of the\n\t * current CPU and remote CPU in RR.  It starts\n\t * with the loc_l->next_steal CPU.\n\t */\n\n\tfirst_steal = loc_l->next_steal;\n\tsteal = first_steal;\n\tdo {\n\t\tsteal_loc_l = per_cpu_ptr(clru->local_list, steal);\n\n\t\traw_spin_lock_irqsave(&steal_loc_l->lock, flags);\n\n\t\tnode = __local_list_pop_free(steal_loc_l);\n\t\tif (!node)\n\t\t\tnode = __local_list_pop_pending(lru, steal_loc_l);\n\n\t\traw_spin_unlock_irqrestore(&steal_loc_l->lock, flags);\n\n\t\tsteal = get_next_cpu(steal);\n\t} while (!node && steal != first_steal);\n\n\tloc_l->next_steal = steal;\n\n\tif (node) {\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t}\n\n\treturn node;\n}"
  },
  {
    "function_name": "bpf_percpu_lru_pop_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "402-432",
    "snippet": "static struct bpf_lru_node *bpf_percpu_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct list_head *free_list;\n\tstruct bpf_lru_node *node = NULL;\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tfree_list = &l->lists[BPF_LRU_LIST_T_FREE];\n\tif (list_empty(free_list))\n\t\t__bpf_lru_list_shrink(lru, l, PERCPU_FREE_TARGET, free_list,\n\t\t\t\t      BPF_LRU_LIST_T_FREE);\n\n\tif (!list_empty(free_list)) {\n\t\tnode = list_first_entry(free_list, struct bpf_lru_node, list);\n\t\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\t\tnode->ref = 0;\n\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\t}\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n\n\treturn node;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [
      "#define PERCPU_FREE_TARGET\t\t(4)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_INACTIVE"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "103-125",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "free_list",
            "structbpf_lru_node",
            "list"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "free_list"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_shrink",
          "args": [
            "lru",
            "l",
            "PERCPU_FREE_TARGET",
            "free_list",
            "BPF_LRU_LIST_T_FREE"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "258-290",
          "snippet": "static unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_rotate",
          "args": [
            "lru",
            "l"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_rotate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "240-246",
          "snippet": "static void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "lru->percpu_lru",
            "cpu"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define PERCPU_FREE_TARGET\t\t(4)\n\nstatic struct bpf_lru_node *bpf_percpu_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct list_head *free_list;\n\tstruct bpf_lru_node *node = NULL;\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tfree_list = &l->lists[BPF_LRU_LIST_T_FREE];\n\tif (list_empty(free_list))\n\t\t__bpf_lru_list_shrink(lru, l, PERCPU_FREE_TARGET, free_list,\n\t\t\t\t      BPF_LRU_LIST_T_FREE);\n\n\tif (!list_empty(free_list)) {\n\t\tnode = list_first_entry(free_list, struct bpf_lru_node, list);\n\t\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\t\tnode->ref = 0;\n\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\t}\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n\n\treturn node;\n}"
  },
  {
    "function_name": "__local_list_pop_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "377-400",
    "snippet": "static struct bpf_lru_node *\n__local_list_pop_pending(struct bpf_lru *lru, struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\tbool force = false;\n\nignore_ref:\n\t/* Get from the tail (i.e. older element) of the pending list. */\n\tlist_for_each_entry_reverse(node, local_pending_list(loc_l),\n\t\t\t\t    list) {\n\t\tif ((!bpf_lru_node_is_ref(node) || force) &&\n\t\t    lru->del_from_htab(lru->del_arg, node)) {\n\t\t\tlist_del(&node->list);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tif (!force) {\n\t\tforce = true;\n\t\tgoto ignore_ref;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&node->list"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru->del_from_htab",
          "args": [
            "lru->del_arg",
            "node"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_is_ref",
          "args": [
            "node"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_is_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "45-48",
          "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "node",
            "local_pending_list(loc_l)",
            "list"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_pending_list",
          "args": [
            "loc_l"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "local_pending_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "39-42",
          "snippet": "static struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)\n\nstatic struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *\n__local_list_pop_pending(struct bpf_lru *lru, struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\tbool force = false;\n\nignore_ref:\n\t/* Get from the tail (i.e. older element) of the pending list. */\n\tlist_for_each_entry_reverse(node, local_pending_list(loc_l),\n\t\t\t\t    list) {\n\t\tif ((!bpf_lru_node_is_ref(node) || force) &&\n\t\t    lru->del_from_htab(lru->del_arg, node)) {\n\t\t\tlist_del(&node->list);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tif (!force) {\n\t\tforce = true;\n\t\tgoto ignore_ref;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__local_list_pop_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "363-375",
    "snippet": "static struct bpf_lru_node *\n__local_list_pop_free(struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\n\tnode = list_first_entry_or_null(local_free_list(loc_l),\n\t\t\t\t\tstruct bpf_lru_node,\n\t\t\t\t\tlist);\n\tif (node)\n\t\tlist_del(&node->list);\n\n\treturn node;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&node->list"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "local_free_list(loc_l)",
            "structbpf_lru_node",
            "list"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_free_list",
          "args": [
            "loc_l"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "local_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "34-37",
          "snippet": "static struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)\n\nstatic struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *\n__local_list_pop_free(struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\n\tnode = list_first_entry_or_null(local_free_list(loc_l),\n\t\t\t\t\tstruct bpf_lru_node,\n\t\t\t\t\tlist);\n\tif (node)\n\t\tlist_del(&node->list);\n\n\treturn node;\n}"
  },
  {
    "function_name": "__local_list_add_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "350-361",
    "snippet": "static void __local_list_add_pending(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_locallist *loc_l,\n\t\t\t\t     int cpu,\n\t\t\t\t     struct bpf_lru_node *node,\n\t\t\t\t     u32 hash)\n{\n\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\tnode->cpu = cpu;\n\tnode->type = BPF_LRU_LOCAL_LIST_T_PENDING;\n\tnode->ref = 0;\n\tlist_add(&node->list, local_pending_list(loc_l));\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&node->list",
            "local_pending_list(loc_l)"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_pending_list",
          "args": [
            "loc_l"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "local_pending_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "39-42",
          "snippet": "static struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)\n\nstatic struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __local_list_add_pending(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_locallist *loc_l,\n\t\t\t\t     int cpu,\n\t\t\t\t     struct bpf_lru_node *node,\n\t\t\t\t     u32 hash)\n{\n\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\tnode->cpu = cpu;\n\tnode->type = BPF_LRU_LOCAL_LIST_T_PENDING;\n\tnode->ref = 0;\n\tlist_add(&node->list, local_pending_list(loc_l));\n}"
  },
  {
    "function_name": "bpf_lru_list_pop_free_to_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "321-348",
    "snippet": "static void bpf_lru_list_pop_free_to_local(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nfree = 0;\n\n\traw_spin_lock(&l->lock);\n\n\t__local_list_flush(l, loc_l);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tlist_for_each_entry_safe(node, tmp_node, &l->lists[BPF_LRU_LIST_T_FREE],\n\t\t\t\t list) {\n\t\t__bpf_lru_node_move_to_free(l, node, local_free_list(loc_l),\n\t\t\t\t\t    BPF_LRU_LOCAL_LIST_T_FREE);\n\t\tif (++nfree == LOCAL_FREE_TARGET)\n\t\t\tbreak;\n\t}\n\n\tif (nfree < LOCAL_FREE_TARGET)\n\t\t__bpf_lru_list_shrink(lru, l, LOCAL_FREE_TARGET - nfree,\n\t\t\t\t      local_free_list(loc_l),\n\t\t\t\t      BPF_LRU_LOCAL_LIST_T_FREE);\n\n\traw_spin_unlock(&l->lock);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [
      "#define LOCAL_FREE_TARGET\t\t(128)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&l->lock"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_shrink",
          "args": [
            "lru",
            "l",
            "LOCAL_FREE_TARGET - nfree",
            "local_free_list(loc_l)",
            "BPF_LRU_LOCAL_LIST_T_FREE"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "258-290",
          "snippet": "static unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_free_list",
          "args": [
            "loc_l"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "local_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "34-37",
          "snippet": "static struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)\n\nstatic struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_node_move_to_free",
          "args": [
            "l",
            "node",
            "local_free_list(loc_l)",
            "BPF_LRU_LOCAL_LIST_T_FREE"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move_to_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "64-82",
          "snippet": "static void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "node",
            "tmp_node",
            "&l->lists[BPF_LRU_LIST_T_FREE]",
            "list"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_rotate",
          "args": [
            "lru",
            "l"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_rotate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "240-246",
          "snippet": "static void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__local_list_flush",
          "args": [
            "l",
            "loc_l"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "__local_list_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "293-306",
          "snippet": "static void __local_list_flush(struct bpf_lru_list *l,\n\t\t\t       struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node,\n\t\t\t\t\t local_pending_list(loc_l), list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move_in(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move_in(l, node,\n\t\t\t\t\t       BPF_LRU_LIST_T_INACTIVE);\n\t}\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __local_list_flush(struct bpf_lru_list *l,\n\t\t\t       struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node,\n\t\t\t\t\t local_pending_list(loc_l), list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move_in(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move_in(l, node,\n\t\t\t\t\t       BPF_LRU_LIST_T_INACTIVE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&l->lock"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_TARGET\t\t(128)\n\nstatic void bpf_lru_list_pop_free_to_local(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nfree = 0;\n\n\traw_spin_lock(&l->lock);\n\n\t__local_list_flush(l, loc_l);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tlist_for_each_entry_safe(node, tmp_node, &l->lists[BPF_LRU_LIST_T_FREE],\n\t\t\t\t list) {\n\t\t__bpf_lru_node_move_to_free(l, node, local_free_list(loc_l),\n\t\t\t\t\t    BPF_LRU_LOCAL_LIST_T_FREE);\n\t\tif (++nfree == LOCAL_FREE_TARGET)\n\t\t\tbreak;\n\t}\n\n\tif (nfree < LOCAL_FREE_TARGET)\n\t\t__bpf_lru_list_shrink(lru, l, LOCAL_FREE_TARGET - nfree,\n\t\t\t\t      local_free_list(loc_l),\n\t\t\t\t      BPF_LRU_LOCAL_LIST_T_FREE);\n\n\traw_spin_unlock(&l->lock);\n}"
  },
  {
    "function_name": "bpf_lru_list_push_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "308-319",
    "snippet": "static void bpf_lru_list_push_free(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_FREE"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "103-125",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_LOCAL_LIST_TYPE(node->type)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "node->type"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_push_free(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}"
  },
  {
    "function_name": "__local_list_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "293-306",
    "snippet": "static void __local_list_flush(struct bpf_lru_list *l,\n\t\t\t       struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node,\n\t\t\t\t\t local_pending_list(loc_l), list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move_in(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move_in(l, node,\n\t\t\t\t\t       BPF_LRU_LIST_T_INACTIVE);\n\t}\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_node_move_in",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_INACTIVE"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "85-97",
          "snippet": "static void __bpf_lru_node_move_in(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node,\n\t\t\t\t   enum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(!IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tbpf_lru_list_count_inc(l, tgt_type);\n\tnode->type = tgt_type;\n\tnode->ref = 0;\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_in(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node,\n\t\t\t\t   enum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(!IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tbpf_lru_list_count_inc(l, tgt_type);\n\tnode->type = tgt_type;\n\tnode->ref = 0;\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_is_ref",
          "args": [
            "node"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_is_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "45-48",
          "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "node",
            "tmp_node",
            "local_pending_list(loc_l)",
            "list"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_pending_list",
          "args": [
            "loc_l"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "local_pending_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "39-42",
          "snippet": "static struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)\n\nstatic struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __local_list_flush(struct bpf_lru_list *l,\n\t\t\t       struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node,\n\t\t\t\t\t local_pending_list(loc_l), list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move_in(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move_in(l, node,\n\t\t\t\t\t       BPF_LRU_LIST_T_INACTIVE);\n\t}\n}"
  },
  {
    "function_name": "__bpf_lru_list_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "258-290",
    "snippet": "static unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_node_move_to_free",
          "args": [
            "l",
            "node",
            "free_list",
            "tgt_free_type"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move_to_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "64-82",
          "snippet": "static void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru->del_from_htab",
          "args": [
            "lru->del_arg",
            "node"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "node",
            "tmp_node",
            "force_shrink_list",
            "list"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&l->lists[BPF_LRU_LIST_T_INACTIVE]"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_shrink_inactive",
          "args": [
            "lru",
            "l",
            "tgt_nshrink",
            "free_list",
            "tgt_free_type"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_shrink_inactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "208-235",
          "snippet": "static unsigned int\n__bpf_lru_list_shrink_inactive(struct bpf_lru *lru,\n\t\t\t       struct bpf_lru_list *l,\n\t\t\t       unsigned int tgt_nshrink,\n\t\t\t       struct list_head *free_list,\n\t\t\t       enum bpf_lru_list_type tgt_free_type)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nshrinked = 0;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, inactive, list) {\n\t\tif (bpf_lru_node_is_ref(node)) {\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\t} else if (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\tif (++nshrinked == tgt_nshrink)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++i == lru->nr_scans)\n\t\t\tbreak;\n\t}\n\n\treturn nshrinked;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic unsigned int\n__bpf_lru_list_shrink_inactive(struct bpf_lru *lru,\n\t\t\t       struct bpf_lru_list *l,\n\t\t\t       unsigned int tgt_nshrink,\n\t\t\t       struct list_head *free_list,\n\t\t\t       enum bpf_lru_list_type tgt_free_type)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nshrinked = 0;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, inactive, list) {\n\t\tif (bpf_lru_node_is_ref(node)) {\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\t} else if (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\tif (++nshrinked == tgt_nshrink)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++i == lru->nr_scans)\n\t\t\tbreak;\n\t}\n\n\treturn nshrinked;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__bpf_lru_list_rotate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "240-246",
    "snippet": "static void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_list_rotate_inactive",
          "args": [
            "lru",
            "l"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_rotate_inactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "169-202",
          "snippet": "static void __bpf_lru_list_rotate_inactive(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_list *l)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct list_head *cur, *last, *next = inactive;\n\tstruct bpf_lru_node *node;\n\tunsigned int i = 0;\n\n\tif (list_empty(inactive))\n\t\treturn;\n\n\tlast = l->next_inactive_rotation->next;\n\tif (last == inactive)\n\t\tlast = last->next;\n\n\tcur = l->next_inactive_rotation;\n\twhile (i < lru->nr_scans) {\n\t\tif (cur == inactive) {\n\t\t\tcur = cur->prev;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnode = list_entry(cur, struct bpf_lru_node, list);\n\t\tnext = cur->prev;\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\tif (cur == last)\n\t\t\tbreak;\n\t\tcur = next;\n\t\ti++;\n\t}\n\n\tl->next_inactive_rotation = next;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate_inactive(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_list *l)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct list_head *cur, *last, *next = inactive;\n\tstruct bpf_lru_node *node;\n\tunsigned int i = 0;\n\n\tif (list_empty(inactive))\n\t\treturn;\n\n\tlast = l->next_inactive_rotation->next;\n\tif (last == inactive)\n\t\tlast = last->next;\n\n\tcur = l->next_inactive_rotation;\n\twhile (i < lru->nr_scans) {\n\t\tif (cur == inactive) {\n\t\t\tcur = cur->prev;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnode = list_entry(cur, struct bpf_lru_node, list);\n\t\tnext = cur->prev;\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\tif (cur == last)\n\t\t\tbreak;\n\t\tcur = next;\n\t\ti++;\n\t}\n\n\tl->next_inactive_rotation = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_rotate_active",
          "args": [
            "lru",
            "l"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_rotate_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "142-159",
          "snippet": "static void __bpf_lru_list_rotate_active(struct bpf_lru *lru,\n\t\t\t\t\t struct bpf_lru_list *l)\n{\n\tstruct list_head *active = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node, *first_node;\n\tunsigned int i = 0;\n\n\tfirst_node = list_first_entry(active, struct bpf_lru_node, list);\n\tlist_for_each_entry_safe_reverse(node, tmp_node, active, list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\n\t\tif (++i == lru->nr_scans || node == first_node)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate_active(struct bpf_lru *lru,\n\t\t\t\t\t struct bpf_lru_list *l)\n{\n\tstruct list_head *active = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node, *first_node;\n\tunsigned int i = 0;\n\n\tfirst_node = list_first_entry(active, struct bpf_lru_node, list);\n\tlist_for_each_entry_safe_reverse(node, tmp_node, active, list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\n\t\tif (++i == lru->nr_scans || node == first_node)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_inactive_low",
          "args": [
            "l"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_inactive_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "127-131",
          "snippet": "static bool bpf_lru_list_inactive_low(const struct bpf_lru_list *l)\n{\n\treturn l->counts[BPF_LRU_LIST_T_INACTIVE] <\n\t\tl->counts[BPF_LRU_LIST_T_ACTIVE];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_list_inactive_low(const struct bpf_lru_list *l)\n{\n\treturn l->counts[BPF_LRU_LIST_T_INACTIVE] <\n\t\tl->counts[BPF_LRU_LIST_T_ACTIVE];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}"
  },
  {
    "function_name": "__bpf_lru_list_shrink_inactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "208-235",
    "snippet": "static unsigned int\n__bpf_lru_list_shrink_inactive(struct bpf_lru *lru,\n\t\t\t       struct bpf_lru_list *l,\n\t\t\t       unsigned int tgt_nshrink,\n\t\t\t       struct list_head *free_list,\n\t\t\t       enum bpf_lru_list_type tgt_free_type)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nshrinked = 0;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, inactive, list) {\n\t\tif (bpf_lru_node_is_ref(node)) {\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\t} else if (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\tif (++nshrinked == tgt_nshrink)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++i == lru->nr_scans)\n\t\t\tbreak;\n\t}\n\n\treturn nshrinked;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_node_move_to_free",
          "args": [
            "l",
            "node",
            "free_list",
            "tgt_free_type"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move_to_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "64-82",
          "snippet": "static void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru->del_from_htab",
          "args": [
            "lru->del_arg",
            "node"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_ACTIVE"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "103-125",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_is_ref",
          "args": [
            "node"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_is_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "45-48",
          "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "node",
            "tmp_node",
            "inactive",
            "list"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic unsigned int\n__bpf_lru_list_shrink_inactive(struct bpf_lru *lru,\n\t\t\t       struct bpf_lru_list *l,\n\t\t\t       unsigned int tgt_nshrink,\n\t\t\t       struct list_head *free_list,\n\t\t\t       enum bpf_lru_list_type tgt_free_type)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nshrinked = 0;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, inactive, list) {\n\t\tif (bpf_lru_node_is_ref(node)) {\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\t} else if (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\tif (++nshrinked == tgt_nshrink)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++i == lru->nr_scans)\n\t\t\tbreak;\n\t}\n\n\treturn nshrinked;\n}"
  },
  {
    "function_name": "__bpf_lru_list_rotate_inactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "169-202",
    "snippet": "static void __bpf_lru_list_rotate_inactive(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_list *l)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct list_head *cur, *last, *next = inactive;\n\tstruct bpf_lru_node *node;\n\tunsigned int i = 0;\n\n\tif (list_empty(inactive))\n\t\treturn;\n\n\tlast = l->next_inactive_rotation->next;\n\tif (last == inactive)\n\t\tlast = last->next;\n\n\tcur = l->next_inactive_rotation;\n\twhile (i < lru->nr_scans) {\n\t\tif (cur == inactive) {\n\t\t\tcur = cur->prev;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnode = list_entry(cur, struct bpf_lru_node, list);\n\t\tnext = cur->prev;\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\tif (cur == last)\n\t\t\tbreak;\n\t\tcur = next;\n\t\ti++;\n\t}\n\n\tl->next_inactive_rotation = next;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_ACTIVE"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "103-125",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_is_ref",
          "args": [
            "node"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_is_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "45-48",
          "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cur",
            "structbpf_lru_node",
            "list"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "inactive"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate_inactive(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_list *l)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct list_head *cur, *last, *next = inactive;\n\tstruct bpf_lru_node *node;\n\tunsigned int i = 0;\n\n\tif (list_empty(inactive))\n\t\treturn;\n\n\tlast = l->next_inactive_rotation->next;\n\tif (last == inactive)\n\t\tlast = last->next;\n\n\tcur = l->next_inactive_rotation;\n\twhile (i < lru->nr_scans) {\n\t\tif (cur == inactive) {\n\t\t\tcur = cur->prev;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnode = list_entry(cur, struct bpf_lru_node, list);\n\t\tnext = cur->prev;\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\tif (cur == last)\n\t\t\tbreak;\n\t\tcur = next;\n\t\ti++;\n\t}\n\n\tl->next_inactive_rotation = next;\n}"
  },
  {
    "function_name": "__bpf_lru_list_rotate_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "142-159",
    "snippet": "static void __bpf_lru_list_rotate_active(struct bpf_lru *lru,\n\t\t\t\t\t struct bpf_lru_list *l)\n{\n\tstruct list_head *active = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node, *first_node;\n\tunsigned int i = 0;\n\n\tfirst_node = list_first_entry(active, struct bpf_lru_node, list);\n\tlist_for_each_entry_safe_reverse(node, tmp_node, active, list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\n\t\tif (++i == lru->nr_scans || node == first_node)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_INACTIVE"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "103-125",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_is_ref",
          "args": [
            "node"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_is_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "45-48",
          "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "node",
            "tmp_node",
            "active",
            "list"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "active",
            "structbpf_lru_node",
            "list"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate_active(struct bpf_lru *lru,\n\t\t\t\t\t struct bpf_lru_list *l)\n{\n\tstruct list_head *active = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node, *first_node;\n\tunsigned int i = 0;\n\n\tfirst_node = list_first_entry(active, struct bpf_lru_node, list);\n\tlist_for_each_entry_safe_reverse(node, tmp_node, active, list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\n\t\tif (++i == lru->nr_scans || node == first_node)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "bpf_lru_list_inactive_low",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "127-131",
    "snippet": "static bool bpf_lru_list_inactive_low(const struct bpf_lru_list *l)\n{\n\treturn l->counts[BPF_LRU_LIST_T_INACTIVE] <\n\t\tl->counts[BPF_LRU_LIST_T_ACTIVE];\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_list_inactive_low(const struct bpf_lru_list *l)\n{\n\treturn l->counts[BPF_LRU_LIST_T_INACTIVE] <\n\t\tl->counts[BPF_LRU_LIST_T_ACTIVE];\n}"
  },
  {
    "function_name": "__bpf_lru_node_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "103-125",
    "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&node->list",
            "&l->lists[tgt_type]"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_count_inc",
          "args": [
            "l",
            "tgt_type"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_count_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "50-55",
          "snippet": "static void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_count_dec",
          "args": [
            "l",
            "node->type"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_count_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "57-62",
          "snippet": "static void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_LOCAL_LIST_TYPE(tgt_type)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "tgt_type"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_LOCAL_LIST_TYPE(node->type)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "node->type"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
  },
  {
    "function_name": "__bpf_lru_node_move_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "85-97",
    "snippet": "static void __bpf_lru_node_move_in(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node,\n\t\t\t\t   enum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(!IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tbpf_lru_list_count_inc(l, tgt_type);\n\tnode->type = tgt_type;\n\tnode->ref = 0;\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&node->list",
            "&l->lists[tgt_type]"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_count_inc",
          "args": [
            "l",
            "tgt_type"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_count_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "50-55",
          "snippet": "static void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_LOCAL_LIST_TYPE(tgt_type)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "tgt_type"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!IS_LOCAL_LIST_TYPE(node->type)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "node->type"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_in(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node,\n\t\t\t\t   enum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(!IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tbpf_lru_list_count_inc(l, tgt_type);\n\tnode->type = tgt_type;\n\tnode->ref = 0;\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
  },
  {
    "function_name": "__bpf_lru_node_move_to_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "64-82",
    "snippet": "static void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&node->list",
            "free_list"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_count_dec",
          "args": [
            "l",
            "node->type"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_count_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "57-62",
          "snippet": "static void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_LOCAL_LIST_TYPE(node->type)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "node->type"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}"
  },
  {
    "function_name": "bpf_lru_list_count_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "57-62",
    "snippet": "static void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}"
  },
  {
    "function_name": "bpf_lru_list_count_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "50-55",
    "snippet": "static void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}"
  },
  {
    "function_name": "bpf_lru_node_is_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "45-48",
    "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
  },
  {
    "function_name": "local_pending_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "39-42",
    "snippet": "static struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [
      "#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)\n\nstatic struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}"
  },
  {
    "function_name": "local_free_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "34-37",
    "snippet": "static struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [
      "#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)\n\nstatic struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}"
  },
  {
    "function_name": "get_next_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "25-31",
    "snippet": "static int get_next_cpu(int cpu)\n{\n\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\tif (cpu >= nr_cpu_ids)\n\t\tcpu = cpumask_first(cpu_possible_mask);\n\treturn cpu;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_possible_mask"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "cpu",
            "cpu_possible_mask"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic int get_next_cpu(int cpu)\n{\n\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\tif (cpu >= nr_cpu_ids)\n\t\tcpu = cpumask_first(cpu_possible_mask);\n\treturn cpu;\n}"
  }
]