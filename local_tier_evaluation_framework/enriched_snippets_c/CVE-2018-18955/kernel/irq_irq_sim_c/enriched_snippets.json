[
  {
    "function_name": "irq_sim_irqnum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
    "lines": "159-162",
    "snippet": "int irq_sim_irqnum(struct irq_sim *sim, unsigned int offset)\n{\n\treturn sim->irqs[offset].irqnum;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nint irq_sim_irqnum(struct irq_sim *sim, unsigned int offset)\n{\n\treturn sim->irqs[offset].irqnum;\n}"
  },
  {
    "function_name": "irq_sim_fire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
    "lines": "143-149",
    "snippet": "void irq_sim_fire(struct irq_sim *sim, unsigned int offset)\n{\n\tif (sim->irqs[offset].enabled) {\n\t\tsim->work_ctx.irq = irq_sim_irqnum(sim, offset);\n\t\tirq_work_queue(&sim->work_ctx.work);\n\t}\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&sim->work_ctx.work"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "90-112",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_sim_irqnum",
          "args": [
            "sim",
            "offset"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "irq_sim_irqnum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
          "lines": "159-162",
          "snippet": "int irq_sim_irqnum(struct irq_sim *sim, unsigned int offset)\n{\n\treturn sim->irqs[offset].irqnum;\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irq_sim.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nint irq_sim_irqnum(struct irq_sim *sim, unsigned int offset)\n{\n\treturn sim->irqs[offset].irqnum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nvoid irq_sim_fire(struct irq_sim *sim, unsigned int offset)\n{\n\tif (sim->irqs[offset].enabled) {\n\t\tsim->work_ctx.irq = irq_sim_irqnum(sim, offset);\n\t\tirq_work_queue(&sim->work_ctx.work);\n\t}\n}"
  },
  {
    "function_name": "devm_irq_sim_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
    "lines": "114-134",
    "snippet": "int devm_irq_sim_init(struct device *dev, struct irq_sim *sim,\n\t\t      unsigned int num_irqs)\n{\n\tstruct irq_sim_devres *dr;\n\tint rv;\n\n\tdr = devres_alloc(devm_irq_sim_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\trv = irq_sim_init(sim, num_irqs);\n\tif (rv < 0) {\n\t\tdevres_free(dr);\n\t\treturn rv;\n\t}\n\n\tdr->sim = sim;\n\tdevres_add(dev, dr);\n\n\treturn rv;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "dr"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_sim_init",
          "args": [
            "sim",
            "num_irqs"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "irq_sim_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
          "lines": "52-80",
          "snippet": "int irq_sim_init(struct irq_sim *sim, unsigned int num_irqs)\n{\n\tint i;\n\n\tsim->irqs = kmalloc_array(num_irqs, sizeof(*sim->irqs), GFP_KERNEL);\n\tif (!sim->irqs)\n\t\treturn -ENOMEM;\n\n\tsim->irq_base = irq_alloc_descs(-1, 0, num_irqs, 0);\n\tif (sim->irq_base < 0) {\n\t\tkfree(sim->irqs);\n\t\treturn sim->irq_base;\n\t}\n\n\tfor (i = 0; i < num_irqs; i++) {\n\t\tsim->irqs[i].irqnum = sim->irq_base + i;\n\t\tsim->irqs[i].enabled = false;\n\t\tirq_set_chip(sim->irq_base + i, &irq_sim_irqchip);\n\t\tirq_set_chip_data(sim->irq_base + i, &sim->irqs[i]);\n\t\tirq_set_handler(sim->irq_base + i, &handle_simple_irq);\n\t\tirq_modify_status(sim->irq_base + i,\n\t\t\t\t  IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);\n\t}\n\n\tinit_irq_work(&sim->work_ctx.work, irq_sim_handle_irq);\n\tsim->irq_count = num_irqs;\n\n\treturn sim->irq_base;\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irq_sim.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct irq_chip irq_sim_irqchip = {\n\t.name\t\t= \"irq_sim\",\n\t.irq_mask\t= irq_sim_irqmask,\n\t.irq_unmask\t= irq_sim_irqunmask,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nstatic struct irq_chip irq_sim_irqchip = {\n\t.name\t\t= \"irq_sim\",\n\t.irq_mask\t= irq_sim_irqmask,\n\t.irq_unmask\t= irq_sim_irqunmask,\n};\n\nint irq_sim_init(struct irq_sim *sim, unsigned int num_irqs)\n{\n\tint i;\n\n\tsim->irqs = kmalloc_array(num_irqs, sizeof(*sim->irqs), GFP_KERNEL);\n\tif (!sim->irqs)\n\t\treturn -ENOMEM;\n\n\tsim->irq_base = irq_alloc_descs(-1, 0, num_irqs, 0);\n\tif (sim->irq_base < 0) {\n\t\tkfree(sim->irqs);\n\t\treturn sim->irq_base;\n\t}\n\n\tfor (i = 0; i < num_irqs; i++) {\n\t\tsim->irqs[i].irqnum = sim->irq_base + i;\n\t\tsim->irqs[i].enabled = false;\n\t\tirq_set_chip(sim->irq_base + i, &irq_sim_irqchip);\n\t\tirq_set_chip_data(sim->irq_base + i, &sim->irqs[i]);\n\t\tirq_set_handler(sim->irq_base + i, &handle_simple_irq);\n\t\tirq_modify_status(sim->irq_base + i,\n\t\t\t\t  IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);\n\t}\n\n\tinit_irq_work(&sim->work_ctx.work, irq_sim_handle_irq);\n\tsim->irq_count = num_irqs;\n\n\treturn sim->irq_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_irq_sim_release",
            "sizeof(*dr)",
            "GFP_KERNEL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nint devm_irq_sim_init(struct device *dev, struct irq_sim *sim,\n\t\t      unsigned int num_irqs)\n{\n\tstruct irq_sim_devres *dr;\n\tint rv;\n\n\tdr = devres_alloc(devm_irq_sim_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\trv = irq_sim_init(sim, num_irqs);\n\tif (rv < 0) {\n\t\tdevres_free(dr);\n\t\treturn rv;\n\t}\n\n\tdr->sim = sim;\n\tdevres_add(dev, dr);\n\n\treturn rv;\n}"
  },
  {
    "function_name": "devm_irq_sim_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
    "lines": "97-102",
    "snippet": "static void devm_irq_sim_release(struct device *dev, void *res)\n{\n\tstruct irq_sim_devres *this = res;\n\n\tirq_sim_fini(this->sim);\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_sim_fini",
          "args": [
            "this->sim"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "irq_sim_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
          "lines": "89-94",
          "snippet": "void irq_sim_fini(struct irq_sim *sim)\n{\n\tirq_work_sync(&sim->work_ctx.work);\n\tirq_free_descs(sim->irq_base, sim->irq_count);\n\tkfree(sim->irqs);\n}",
          "includes": [
            "#include <linux/irq.h>",
            "#include <linux/irq_sim.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nvoid irq_sim_fini(struct irq_sim *sim)\n{\n\tirq_work_sync(&sim->work_ctx.work);\n\tirq_free_descs(sim->irq_base, sim->irq_count);\n\tkfree(sim->irqs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nstatic void devm_irq_sim_release(struct device *dev, void *res)\n{\n\tstruct irq_sim_devres *this = res;\n\n\tirq_sim_fini(this->sim);\n}"
  },
  {
    "function_name": "irq_sim_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
    "lines": "89-94",
    "snippet": "void irq_sim_fini(struct irq_sim *sim)\n{\n\tirq_work_sync(&sim->work_ctx.work);\n\tirq_free_descs(sim->irq_base, sim->irq_count);\n\tkfree(sim->irqs);\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sim->irqs"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_free_descs",
          "args": [
            "sim->irq_base",
            "sim->irq_count"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "irq_free_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "677-690",
          "snippet": "void irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nr_irqs = NR_IRQS;",
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nint nr_irqs = NR_IRQS;\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_work_sync",
          "args": [
            "&sim->work_ctx.work"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "188-194",
          "snippet": "void irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\n\twhile (work->flags & IRQ_WORK_BUSY)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\n\twhile (work->flags & IRQ_WORK_BUSY)\n\t\tcpu_relax();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nvoid irq_sim_fini(struct irq_sim *sim)\n{\n\tirq_work_sync(&sim->work_ctx.work);\n\tirq_free_descs(sim->irq_base, sim->irq_count);\n\tkfree(sim->irqs);\n}"
  },
  {
    "function_name": "irq_sim_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
    "lines": "52-80",
    "snippet": "int irq_sim_init(struct irq_sim *sim, unsigned int num_irqs)\n{\n\tint i;\n\n\tsim->irqs = kmalloc_array(num_irqs, sizeof(*sim->irqs), GFP_KERNEL);\n\tif (!sim->irqs)\n\t\treturn -ENOMEM;\n\n\tsim->irq_base = irq_alloc_descs(-1, 0, num_irqs, 0);\n\tif (sim->irq_base < 0) {\n\t\tkfree(sim->irqs);\n\t\treturn sim->irq_base;\n\t}\n\n\tfor (i = 0; i < num_irqs; i++) {\n\t\tsim->irqs[i].irqnum = sim->irq_base + i;\n\t\tsim->irqs[i].enabled = false;\n\t\tirq_set_chip(sim->irq_base + i, &irq_sim_irqchip);\n\t\tirq_set_chip_data(sim->irq_base + i, &sim->irqs[i]);\n\t\tirq_set_handler(sim->irq_base + i, &handle_simple_irq);\n\t\tirq_modify_status(sim->irq_base + i,\n\t\t\t\t  IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);\n\t}\n\n\tinit_irq_work(&sim->work_ctx.work, irq_sim_handle_irq);\n\tsim->irq_count = num_irqs;\n\n\treturn sim->irq_base;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_chip irq_sim_irqchip = {\n\t.name\t\t= \"irq_sim\",\n\t.irq_mask\t= irq_sim_irqmask,\n\t.irq_unmask\t= irq_sim_irqunmask,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&sim->work_ctx.work",
            "irq_sim_handle_irq"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_modify_status",
          "args": [
            "sim->irq_base + i",
            "IRQ_NOREQUEST | IRQ_NOAUTOEN",
            "IRQ_NOPROBE"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "irq_modify_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "1022-1058",
          "snippet": "void irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set)\n{\n\tunsigned long flags, trigger, tmp;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t/*\n\t * Warn when a driver sets the no autoenable flag on an already\n\t * active interrupt.\n\t */\n\tWARN_ON_ONCE(!desc->depth && (set & _IRQ_NOAUTOEN));\n\n\tirq_settings_clr_and_set(desc, clr, set);\n\n\ttrigger = irqd_get_trigger_type(&desc->irq_data);\n\n\tirqd_clear(&desc->irq_data, IRQD_NO_BALANCING | IRQD_PER_CPU |\n\t\t   IRQD_TRIGGER_MASK | IRQD_LEVEL | IRQD_MOVE_PCNTXT);\n\tif (irq_settings_has_no_balance_set(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\tif (irq_settings_is_per_cpu(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\tif (irq_settings_can_move_pcntxt(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_MOVE_PCNTXT);\n\tif (irq_settings_is_level(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\n\ttmp = irq_settings_get_trigger_mask(desc);\n\tif (tmp != IRQ_TYPE_NONE)\n\t\ttrigger = tmp;\n\n\tirqd_set(&desc->irq_data, trigger);\n\n\tirq_put_desc_unlock(desc, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set)\n{\n\tunsigned long flags, trigger, tmp;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t/*\n\t * Warn when a driver sets the no autoenable flag on an already\n\t * active interrupt.\n\t */\n\tWARN_ON_ONCE(!desc->depth && (set & _IRQ_NOAUTOEN));\n\n\tirq_settings_clr_and_set(desc, clr, set);\n\n\ttrigger = irqd_get_trigger_type(&desc->irq_data);\n\n\tirqd_clear(&desc->irq_data, IRQD_NO_BALANCING | IRQD_PER_CPU |\n\t\t   IRQD_TRIGGER_MASK | IRQD_LEVEL | IRQD_MOVE_PCNTXT);\n\tif (irq_settings_has_no_balance_set(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\tif (irq_settings_is_per_cpu(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\tif (irq_settings_can_move_pcntxt(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_MOVE_PCNTXT);\n\tif (irq_settings_is_level(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\n\ttmp = irq_settings_get_trigger_mask(desc);\n\tif (tmp != IRQ_TYPE_NONE)\n\t\ttrigger = tmp;\n\n\tirqd_set(&desc->irq_data, trigger);\n\n\tirq_put_desc_unlock(desc, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_handler",
          "args": [
            "sim->irq_base + i",
            "&handle_simple_irq"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "90-100",
          "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip_data",
          "args": [
            "sim->irq_base + i",
            "&sim->irqs[i]"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_chip_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "145-155",
          "snippet": "int irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sim->irqs"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_alloc_descs",
          "args": [
            "-1",
            "0",
            "num_irqs",
            "0"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "num_irqs",
            "sizeof(*sim->irqs)",
            "GFP_KERNEL"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nstatic struct irq_chip irq_sim_irqchip = {\n\t.name\t\t= \"irq_sim\",\n\t.irq_mask\t= irq_sim_irqmask,\n\t.irq_unmask\t= irq_sim_irqunmask,\n};\n\nint irq_sim_init(struct irq_sim *sim, unsigned int num_irqs)\n{\n\tint i;\n\n\tsim->irqs = kmalloc_array(num_irqs, sizeof(*sim->irqs), GFP_KERNEL);\n\tif (!sim->irqs)\n\t\treturn -ENOMEM;\n\n\tsim->irq_base = irq_alloc_descs(-1, 0, num_irqs, 0);\n\tif (sim->irq_base < 0) {\n\t\tkfree(sim->irqs);\n\t\treturn sim->irq_base;\n\t}\n\n\tfor (i = 0; i < num_irqs; i++) {\n\t\tsim->irqs[i].irqnum = sim->irq_base + i;\n\t\tsim->irqs[i].enabled = false;\n\t\tirq_set_chip(sim->irq_base + i, &irq_sim_irqchip);\n\t\tirq_set_chip_data(sim->irq_base + i, &sim->irqs[i]);\n\t\tirq_set_handler(sim->irq_base + i, &handle_simple_irq);\n\t\tirq_modify_status(sim->irq_base + i,\n\t\t\t\t  IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);\n\t}\n\n\tinit_irq_work(&sim->work_ctx.work, irq_sim_handle_irq);\n\tsim->irq_count = num_irqs;\n\n\treturn sim->irq_base;\n}"
  },
  {
    "function_name": "irq_sim_handle_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
    "lines": "34-40",
    "snippet": "static void irq_sim_handle_irq(struct irq_work *work)\n{\n\tstruct irq_sim_work_ctx *work_ctx;\n\n\twork_ctx = container_of(work, struct irq_sim_work_ctx, work);\n\thandle_simple_irq(irq_to_desc(work_ctx->irq));\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_simple_irq",
          "args": [
            "irq_to_desc(work_ctx->irq)"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "handle_simple_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "532-551",
          "snippet": "void handle_simple_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\thandle_irq_event(desc);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid handle_simple_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\thandle_irq_event(desc);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "work_ctx->irq"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structirq_sim_work_ctx",
            "work"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nstatic void irq_sim_handle_irq(struct irq_work *work)\n{\n\tstruct irq_sim_work_ctx *work_ctx;\n\n\twork_ctx = container_of(work, struct irq_sim_work_ctx, work);\n\thandle_simple_irq(irq_to_desc(work_ctx->irq));\n}"
  },
  {
    "function_name": "irq_sim_irqunmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
    "lines": "21-26",
    "snippet": "static void irq_sim_irqunmask(struct irq_data *data)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\n\tirq_ctx->enabled = true;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip_data",
          "args": [
            "data"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nstatic void irq_sim_irqunmask(struct irq_data *data)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\n\tirq_ctx->enabled = true;\n}"
  },
  {
    "function_name": "irq_sim_irqmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irq_sim.c",
    "lines": "14-19",
    "snippet": "static void irq_sim_irqmask(struct irq_data *data)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\n\tirq_ctx->enabled = false;\n}",
    "includes": [
      "#include <linux/irq.h>",
      "#include <linux/irq_sim.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip_data",
          "args": [
            "data"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/slab.h>\n\nstatic void irq_sim_irqmask(struct irq_data *data)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\n\tirq_ctx->enabled = false;\n}"
  }
]