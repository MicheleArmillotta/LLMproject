[
  {
    "function_name": "register_trigger_cmds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1625-1635",
    "snippet": "__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\tregister_trigger_hist_enable_disable_cmds();\n\tregister_trigger_hist_cmd();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_trigger_hist_cmd",
          "args": [],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_hist_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5666-5674",
          "snippet": "__init int register_trigger_hist_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_hist_cmd;",
            "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\n__init int register_trigger_hist_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trigger_hist_enable_disable_cmds",
          "args": [],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_hist_enable_disable_cmds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5795-5807",
          "snippet": "__init int register_trigger_hist_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_hist_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_hist_enable_disable_cmds();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\n__init int register_trigger_hist_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_hist_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_hist_enable_disable_cmds();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trigger_enable_disable_cmds",
          "args": [],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_enable_disable_cmds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1597-1609",
          "snippet": "static __init int register_trigger_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init int register_trigger_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trigger_stacktrace_cmd",
          "args": [],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_stacktrace_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1223-1223",
          "snippet": "static __init int register_trigger_stacktrace_cmd(void) { return 0; }",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic __init int register_trigger_stacktrace_cmd(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "register_trigger_snapshot_cmd",
          "args": [],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_snapshot_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1133-1133",
          "snippet": "static __init int register_trigger_snapshot_cmd(void) { return 0; }",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic __init int register_trigger_snapshot_cmd(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "register_trigger_traceon_traceoff_cmds",
          "args": [],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_traceon_traceoff_cmds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1611-1623",
          "snippet": "static __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\tregister_trigger_hist_enable_disable_cmds();\n\tregister_trigger_hist_cmd();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "register_trigger_traceon_traceoff_cmds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1611-1623",
    "snippet": "static __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trigger_traceon_traceoff_cmds",
          "args": [],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trigger_traceon_traceoff_cmds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1226-1230",
          "snippet": "static __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_traceoff_cmd"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "339-356",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_trigger_enable_disable_cmds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1597-1609",
    "snippet": "static __init int register_trigger_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trigger_enable_disable_cmds",
          "args": [],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trigger_enable_disable_cmds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1591-1595",
          "snippet": "static __init void unregister_trigger_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_enable_cmd);\n\tunregister_event_command(&trigger_disable_cmd);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_enable_cmd);\n\tunregister_event_command(&trigger_disable_cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_disable_cmd"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "339-356",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init int register_trigger_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_trigger_enable_disable_cmds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1591-1595",
    "snippet": "static __init void unregister_trigger_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_enable_cmd);\n\tunregister_event_command(&trigger_disable_cmd);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_event_command",
          "args": [
            "&trigger_disable_cmd"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "339-356",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_enable_cmd);\n\tunregister_event_command(&trigger_disable_cmd);\n}"
  },
  {
    "function_name": "event_enable_get_trigger_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1549-1569",
    "snippet": "static struct event_trigger_ops *\nevent_enable_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\tbool enable;\n\n#ifdef CONFIG_HIST_TRIGGERS\n\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||\n\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));\n#else\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n#endif\n\tif (enable)\n\t\tops = param ? &event_enable_count_trigger_ops :\n\t\t\t&event_enable_trigger_ops;\n\telse\n\t\tops = param ? &event_disable_count_trigger_ops :\n\t\t\t&event_disable_trigger_ops;\n\n\treturn ops;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_trigger_ops event_enable_trigger_ops = {\n\t.func\t\t\t= event_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops event_enable_count_trigger_ops = {\n\t.func\t\t\t= event_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops event_disable_trigger_ops = {\n\t.func\t\t\t= event_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops event_disable_count_trigger_ops = {\n\t.func\t\t\t= event_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_EVENT_STR"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_HIST_STR"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_EVENT_STR"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_trigger_ops event_enable_trigger_ops = {\n\t.func\t\t\t= event_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops event_enable_count_trigger_ops = {\n\t.func\t\t\t= event_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops event_disable_trigger_ops = {\n\t.func\t\t\t= event_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops event_disable_count_trigger_ops = {\n\t.func\t\t\t= event_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops *\nevent_enable_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\tbool enable;\n\n#ifdef CONFIG_HIST_TRIGGERS\n\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||\n\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));\n#else\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n#endif\n\tif (enable)\n\t\tops = param ? &event_enable_count_trigger_ops :\n\t\t\t&event_enable_trigger_ops;\n\telse\n\t\tops = param ? &event_disable_count_trigger_ops :\n\t\t\t&event_disable_trigger_ops;\n\n\treturn ops;\n}"
  },
  {
    "function_name": "event_enable_unregister_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1521-1547",
    "snippet": "void event_enable_unregister_trigger(char *glob,\n\t\t\t\t     struct event_trigger_ops *ops,\n\t\t\t\t     struct event_trigger_data *test,\n\t\t\t\t     struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *test_enable_data = test->private_data;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tenable_data = data->private_data;\n\t\tif (enable_data &&\n\t\t    (data->cmd_ops->trigger_type ==\n\t\t     test->cmd_ops->trigger_type) &&\n\t\t    (enable_data->file == test_enable_data->file)) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->free",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "493-510",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "434-452",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid event_enable_unregister_trigger(char *glob,\n\t\t\t\t     struct event_trigger_ops *ops,\n\t\t\t\t     struct event_trigger_data *test,\n\t\t\t\t     struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *test_enable_data = test->private_data;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tenable_data = data->private_data;\n\t\tif (enable_data &&\n\t\t    (data->cmd_ops->trigger_type ==\n\t\t     test->cmd_ops->trigger_type) &&\n\t\t    (enable_data->file == test_enable_data->file)) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}"
  },
  {
    "function_name": "event_enable_register_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1481-1519",
    "snippet": "int event_enable_register_trigger(char *glob,\n\t\t\t\t  struct event_trigger_ops *ops,\n\t\t\t\t  struct event_trigger_data *data,\n\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct enable_trigger_data *test_enable_data;\n\tstruct event_trigger_data *test;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\ttest_enable_data = test->private_data;\n\t\tif (test_enable_data &&\n\t\t    (test->cmd_ops->trigger_type ==\n\t\t     data->cmd_ops->trigger_type) &&\n\t\t    (test_enable_data->file == enable_data->file)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->list, &file->triggers);\n\tret++;\n\n\tupdate_cond_flag(file);\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "493-510",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "1"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "434-452",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&data->list",
            "&file->triggers"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->ops->init",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint event_enable_register_trigger(char *glob,\n\t\t\t\t  struct event_trigger_ops *ops,\n\t\t\t\t  struct event_trigger_data *data,\n\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct enable_trigger_data *test_enable_data;\n\tstruct event_trigger_data *test;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\ttest_enable_data = test->private_data;\n\t\tif (test_enable_data &&\n\t\t    (test->cmd_ops->trigger_type ==\n\t\t     data->cmd_ops->trigger_type) &&\n\t\t    (test_enable_data->file == enable_data->file)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->list, &file->triggers);\n\tret++;\n\n\tupdate_cond_flag(file);\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "event_enable_trigger_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1335-1479",
    "snippet": "int event_enable_trigger_func(struct event_command *cmd_ops,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *glob, char *cmd, char *param)\n{\n\tstruct trace_event_file *event_enable_file;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct trace_array *tr = file->tr;\n\tconst char *system;\n\tconst char *event;\n\tbool hist = false;\n\tchar *trigger;\n\tchar *number;\n\tbool enable;\n\tint ret;\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\t/* separate the trigger from the filter (s:e:n [if filter]) */\n\ttrigger = strsep(&param, \" \\t\");\n\tif (!trigger)\n\t\treturn -EINVAL;\n\n\tsystem = strsep(&trigger, \":\");\n\tif (!trigger)\n\t\treturn -EINVAL;\n\n\tevent = strsep(&trigger, \":\");\n\n\tret = -EINVAL;\n\tevent_enable_file = find_event_file(tr, system, event);\n\tif (!event_enable_file)\n\t\tgoto out;\n\n#ifdef CONFIG_HIST_TRIGGERS\n\thist = ((strcmp(cmd, ENABLE_HIST_STR) == 0) ||\n\t\t(strcmp(cmd, DISABLE_HIST_STR) == 0));\n\n\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||\n\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));\n#else\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n#endif\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\tret = -ENOMEM;\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\tgoto out;\n\n\tenable_data = kzalloc(sizeof(*enable_data), GFP_KERNEL);\n\tif (!enable_data) {\n\t\tkfree(trigger_data);\n\t\tgoto out;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\tenable_data->hist = hist;\n\tenable_data->enable = enable;\n\tenable_data->file = event_enable_file;\n\ttrigger_data->private_data = enable_data;\n\n\tif (glob[0] == '!') {\n\t\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n\t\tkfree(trigger_data);\n\t\tkfree(enable_data);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Up the trigger_data count to make sure nothing frees it on failure */\n\tevent_trigger_init(trigger_ops, trigger_data);\n\n\tif (trigger) {\n\t\tnumber = strsep(&trigger, \":\");\n\n\t\tret = -EINVAL;\n\t\tif (!strlen(number))\n\t\t\tgoto out_free;\n\n\t\t/*\n\t\t * We use the callback data field (which is a pointer)\n\t\t * as our counter.\n\t\t */\n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tif (!param) /* if param is non-empty, it's supposed to be a filter */\n\t\tgoto out_reg;\n\n\tif (!cmd_ops->set_filter)\n\t\tgoto out_reg;\n\n\tret = cmd_ops->set_filter(param, trigger_data, file);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Don't let event modules unload while probe registered */\n\tret = try_module_get(event_enable_file->event_call->mod);\n\tif (!ret) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = trace_event_enable_disable(event_enable_file, 1, 1);\n\tif (ret < 0)\n\t\tgoto out_put;\n\tret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tret = -ENOENT;\n\t\tgoto out_disable;\n\t} else if (ret < 0)\n\t\tgoto out_disable;\n\t/* Just return zero, not the number of enabled functions */\n\tret = 0;\n\tevent_trigger_free(trigger_ops, trigger_data);\n out:\n\treturn ret;\n\n out_disable:\n\ttrace_event_enable_disable(event_enable_file, 0, 1);\n out_put:\n\tmodule_put(event_enable_file->event_call->mod);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\tevent_trigger_free(trigger_ops, trigger_data);\n\tkfree(enable_data);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "enable_data"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_trigger_free",
          "args": [
            "trigger_ops",
            "trigger_data"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "422-432",
          "snippet": "static void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "NULL",
            "trigger_data",
            "NULL"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "event_enable_file->event_call->mod"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_enable_disable",
          "args": [
            "event_enable_file",
            "0",
            "1"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "487-491",
          "snippet": "int trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nint trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->reg",
          "args": [
            "glob",
            "trigger_ops",
            "trigger_data",
            "file"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "event_enable_file->event_call->mod"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1113-1129",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "param",
            "trigger_data",
            "file"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "number",
            "0",
            "&trigger_data->count"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "number"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&trigger",
            "\":\""
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_trigger_init",
          "args": [
            "trigger_ops",
            "trigger_data"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "405-410",
          "snippet": "int event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob+1",
            "trigger_ops",
            "trigger_data",
            "file"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "trigger_data->filter",
            "NULL"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger_data->list"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*enable_data)",
            "GFP_KERNEL"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*trigger_data)",
            "GFP_KERNEL"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->get_trigger_ops",
          "args": [
            "cmd",
            "trigger"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_EVENT_STR"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_HIST_STR"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_EVENT_STR"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "DISABLE_HIST_STR"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_HIST_STR"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_event_file",
          "args": [
            "tr",
            "system",
            "event"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2503-2514",
          "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&trigger",
            "\":\""
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&trigger",
            "\":\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\" \\t\""
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint event_enable_trigger_func(struct event_command *cmd_ops,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *glob, char *cmd, char *param)\n{\n\tstruct trace_event_file *event_enable_file;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct trace_array *tr = file->tr;\n\tconst char *system;\n\tconst char *event;\n\tbool hist = false;\n\tchar *trigger;\n\tchar *number;\n\tbool enable;\n\tint ret;\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\t/* separate the trigger from the filter (s:e:n [if filter]) */\n\ttrigger = strsep(&param, \" \\t\");\n\tif (!trigger)\n\t\treturn -EINVAL;\n\n\tsystem = strsep(&trigger, \":\");\n\tif (!trigger)\n\t\treturn -EINVAL;\n\n\tevent = strsep(&trigger, \":\");\n\n\tret = -EINVAL;\n\tevent_enable_file = find_event_file(tr, system, event);\n\tif (!event_enable_file)\n\t\tgoto out;\n\n#ifdef CONFIG_HIST_TRIGGERS\n\thist = ((strcmp(cmd, ENABLE_HIST_STR) == 0) ||\n\t\t(strcmp(cmd, DISABLE_HIST_STR) == 0));\n\n\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||\n\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));\n#else\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n#endif\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\tret = -ENOMEM;\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\tgoto out;\n\n\tenable_data = kzalloc(sizeof(*enable_data), GFP_KERNEL);\n\tif (!enable_data) {\n\t\tkfree(trigger_data);\n\t\tgoto out;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\tenable_data->hist = hist;\n\tenable_data->enable = enable;\n\tenable_data->file = event_enable_file;\n\ttrigger_data->private_data = enable_data;\n\n\tif (glob[0] == '!') {\n\t\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n\t\tkfree(trigger_data);\n\t\tkfree(enable_data);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Up the trigger_data count to make sure nothing frees it on failure */\n\tevent_trigger_init(trigger_ops, trigger_data);\n\n\tif (trigger) {\n\t\tnumber = strsep(&trigger, \":\");\n\n\t\tret = -EINVAL;\n\t\tif (!strlen(number))\n\t\t\tgoto out_free;\n\n\t\t/*\n\t\t * We use the callback data field (which is a pointer)\n\t\t * as our counter.\n\t\t */\n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tif (!param) /* if param is non-empty, it's supposed to be a filter */\n\t\tgoto out_reg;\n\n\tif (!cmd_ops->set_filter)\n\t\tgoto out_reg;\n\n\tret = cmd_ops->set_filter(param, trigger_data, file);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Don't let event modules unload while probe registered */\n\tret = try_module_get(event_enable_file->event_call->mod);\n\tif (!ret) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = trace_event_enable_disable(event_enable_file, 1, 1);\n\tif (ret < 0)\n\t\tgoto out_put;\n\tret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tret = -ENOENT;\n\t\tgoto out_disable;\n\t} else if (ret < 0)\n\t\tgoto out_disable;\n\t/* Just return zero, not the number of enabled functions */\n\tret = 0;\n\tevent_trigger_free(trigger_ops, trigger_data);\n out:\n\treturn ret;\n\n out_disable:\n\ttrace_event_enable_disable(event_enable_file, 0, 1);\n out_put:\n\tmodule_put(event_enable_file->event_call->mod);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\tevent_trigger_free(trigger_ops, trigger_data);\n\tkfree(enable_data);\n\tgoto out;\n}"
  },
  {
    "function_name": "event_enable_trigger_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1289-1305",
    "snippet": "void event_enable_trigger_free(struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\ttrace_event_enable_disable(enable_data->file, 0, 1);\n\t\tmodule_put(enable_data->file->event_call->mod);\n\t\ttrigger_data_free(data);\n\t\tkfree(enable_data);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "enable_data"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_data_free",
          "args": [
            "data"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_data_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "19-28",
          "snippet": "void trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "enable_data->file->event_call->mod"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_enable_disable",
          "args": [
            "enable_data->file",
            "0",
            "1"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "487-491",
          "snippet": "int trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nint trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "data->ref <= 0"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid event_enable_trigger_free(struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\ttrace_event_enable_disable(enable_data->file, 0, 1);\n\t\tmodule_put(enable_data->file->event_call->mod);\n\t\ttrigger_data_free(data);\n\t\tkfree(enable_data);\n\t}\n}"
  },
  {
    "function_name": "event_enable_trigger_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1263-1287",
    "snippet": "int event_enable_trigger_print(struct seq_file *m,\n\t\t\t       struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   enable_data->hist ?\n\t\t   (enable_data->enable ? ENABLE_HIST_STR : DISABLE_HIST_STR) :\n\t\t   (enable_data->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR),\n\t\t   enable_data->file->event_call->class->system,\n\t\t   trace_event_name(enable_data->file->event_call));\n\n\tif (data->count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", data->count);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\\n\", data->filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" if %s\\n\"",
            "data->filter_str"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\":unlimited\""
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "enable_data->file->event_call"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint event_enable_trigger_print(struct seq_file *m,\n\t\t\t       struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   enable_data->hist ?\n\t\t   (enable_data->enable ? ENABLE_HIST_STR : DISABLE_HIST_STR) :\n\t\t   (enable_data->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR),\n\t\t   enable_data->file->event_call->class->system,\n\t\t   trace_event_name(enable_data->file->event_call));\n\n\tif (data->count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", data->count);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\\n\", data->filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_enable_count_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1244-1261",
    "snippet": "static void\nevent_enable_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t\t   struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (!data->count)\n\t\treturn;\n\n\t/* Skip if the event is in a state we want to switch to */\n\tif (enable_data->enable == !(enable_data->file->flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tevent_enable_trigger(data, rec, event);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_enable_trigger",
          "args": [
            "data",
            "rec",
            "event"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "event_enable_trigger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1263-1287",
          "snippet": "int event_enable_trigger_print(struct seq_file *m,\n\t\t\t       struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   enable_data->hist ?\n\t\t   (enable_data->enable ? ENABLE_HIST_STR : DISABLE_HIST_STR) :\n\t\t   (enable_data->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR),\n\t\t   enable_data->file->event_call->class->system,\n\t\t   trace_event_name(enable_data->file->event_call));\n\n\tif (data->count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", data->count);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\\n\", data->filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint event_enable_trigger_print(struct seq_file *m,\n\t\t\t       struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   enable_data->hist ?\n\t\t   (enable_data->enable ? ENABLE_HIST_STR : DISABLE_HIST_STR) :\n\t\t   (enable_data->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR),\n\t\t   enable_data->file->event_call->class->system,\n\t\t   trace_event_name(enable_data->file->event_call));\n\n\tif (data->count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", data->count);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\\n\", data->filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\nevent_enable_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t\t   struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (!data->count)\n\t\treturn;\n\n\t/* Skip if the event is in a state we want to switch to */\n\tif (enable_data->enable == !(enable_data->file->flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tevent_enable_trigger(data, rec, event);\n}"
  },
  {
    "function_name": "event_enable_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1232-1242",
    "snippet": "static void\nevent_enable_trigger(struct event_trigger_data *data, void *rec,\n\t\t     struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (enable_data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_SOFT_DISABLED_BIT",
            "&enable_data->file->flags"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_SOFT_DISABLED_BIT",
            "&enable_data->file->flags"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\nevent_enable_trigger(struct event_trigger_data *data, void *rec,\n\t\t     struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (enable_data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n}"
  },
  {
    "function_name": "unregister_trigger_traceon_traceoff_cmds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1226-1230",
    "snippet": "static __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_event_command",
          "args": [
            "&trigger_traceoff_cmd"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "339-356",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.func\t\t\t= event_trigger_callback,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}"
  },
  {
    "function_name": "register_trigger_stacktrace_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1223-1223",
    "snippet": "static __init int register_trigger_stacktrace_cmd(void) { return 0; }",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic __init int register_trigger_stacktrace_cmd(void) { return 0; }"
  },
  {
    "function_name": "register_trigger_stacktrace_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1213-1221",
    "snippet": "static __init int register_trigger_stacktrace_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_stacktrace_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_stacktrace_cmd"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "339-356",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic __init int register_trigger_stacktrace_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_stacktrace_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "stacktrace_get_trigger_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1196-1200",
    "snippet": "static struct event_trigger_ops *\nstacktrace_get_trigger_ops(char *cmd, char *param)\n{\n\treturn param ? &stacktrace_count_trigger_ops : &stacktrace_trigger_ops;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_trigger_ops *\nstacktrace_get_trigger_ops(char *cmd, char *param)\n{\n\treturn param ? &stacktrace_count_trigger_ops : &stacktrace_trigger_ops;\n}"
  },
  {
    "function_name": "stacktrace_trigger_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1174-1180",
    "snippet": "static int\nstacktrace_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t\t struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"stacktrace\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_print",
          "args": [
            "\"stacktrace\"",
            "m",
            "(void *)data->count",
            "data->filter_str"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "372-391",
          "snippet": "static int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nstacktrace_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t\t struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"stacktrace\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}"
  },
  {
    "function_name": "stacktrace_count_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1161-1172",
    "snippet": "static void\nstacktrace_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t\t struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tstacktrace_trigger(data, rec, event);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stacktrace_trigger",
          "args": [
            "data",
            "rec",
            "event"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "stacktrace_trigger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1174-1180",
          "snippet": "static int\nstacktrace_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t\t struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"stacktrace\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nstacktrace_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t\t struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"stacktrace\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\nstacktrace_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t\t struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tstacktrace_trigger(data, rec, event);\n}"
  },
  {
    "function_name": "stacktrace_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1154-1159",
    "snippet": "static void\nstacktrace_trigger(struct event_trigger_data *data, void *rec,\n\t\t   struct ring_buffer_event *event)\n{\n\ttrace_dump_stack(STACK_SKIP);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STACK_SKIP 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_dump_stack",
          "args": [
            "STACK_SKIP"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "trace_dump_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2714-2729",
          "snippet": "void trace_dump_stack(int skip)\n{\n\tunsigned long flags;\n\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn;\n\n\tlocal_save_flags(flags);\n\n#ifndef CONFIG_UNWINDER_ORC\n\t/* Skip 1 to skip this function. */\n\tskip++;\n#endif\n\t__ftrace_trace_stack(global_trace.trace_buffer.buffer,\n\t\t\t     flags, skip, preempt_count(), NULL);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid trace_dump_stack(int skip)\n{\n\tunsigned long flags;\n\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn;\n\n\tlocal_save_flags(flags);\n\n#ifndef CONFIG_UNWINDER_ORC\n\t/* Skip 1 to skip this function. */\n\tskip++;\n#endif\n\t__ftrace_trace_stack(global_trace.trace_buffer.buffer,\n\t\t\t     flags, skip, preempt_count(), NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define STACK_SKIP 4\n\nstatic void\nstacktrace_trigger(struct event_trigger_data *data, void *rec,\n\t\t   struct ring_buffer_event *event)\n{\n\ttrace_dump_stack(STACK_SKIP);\n}"
  },
  {
    "function_name": "register_trigger_snapshot_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1133-1133",
    "snippet": "static __init int register_trigger_snapshot_cmd(void) { return 0; }",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic __init int register_trigger_snapshot_cmd(void) { return 0; }"
  },
  {
    "function_name": "register_trigger_snapshot_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1123-1131",
    "snippet": "static __init int register_trigger_snapshot_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_snapshot_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_snapshot_cmd"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "339-356",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic __init int register_trigger_snapshot_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_snapshot_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "snapshot_get_trigger_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1107-1111",
    "snippet": "static struct event_trigger_ops *\nsnapshot_get_trigger_ops(char *cmd, char *param)\n{\n\treturn param ? &snapshot_count_trigger_ops : &snapshot_trigger_ops;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_trigger_ops *\nsnapshot_get_trigger_ops(char *cmd, char *param)\n{\n\treturn param ? &snapshot_count_trigger_ops : &snapshot_trigger_ops;\n}"
  },
  {
    "function_name": "snapshot_trigger_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1085-1091",
    "snippet": "static int\nsnapshot_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"snapshot\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_print",
          "args": [
            "\"snapshot\"",
            "m",
            "(void *)data->count",
            "data->filter_str"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "372-391",
          "snippet": "static int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nsnapshot_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"snapshot\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}"
  },
  {
    "function_name": "register_snapshot_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1070-1083",
    "snippet": "static int\nregister_snapshot_trigger(char *glob, struct event_trigger_ops *ops,\n\t\t\t  struct event_trigger_data *data,\n\t\t\t  struct trace_event_file *file)\n{\n\tint ret = register_trigger(glob, ops, data, file);\n\n\tif (ret > 0 && tracing_alloc_snapshot_instance(file->tr) != 0) {\n\t\tunregister_trigger(glob, ops, data, file);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trigger",
          "args": [
            "glob",
            "ops",
            "data",
            "file"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "event_enable_unregister_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1521-1547",
          "snippet": "void event_enable_unregister_trigger(char *glob,\n\t\t\t\t     struct event_trigger_ops *ops,\n\t\t\t\t     struct event_trigger_data *test,\n\t\t\t\t     struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *test_enable_data = test->private_data;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tenable_data = data->private_data;\n\t\tif (enable_data &&\n\t\t    (data->cmd_ops->trigger_type ==\n\t\t     test->cmd_ops->trigger_type) &&\n\t\t    (enable_data->file == test_enable_data->file)) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid event_enable_unregister_trigger(char *glob,\n\t\t\t\t     struct event_trigger_ops *ops,\n\t\t\t\t     struct event_trigger_data *test,\n\t\t\t\t     struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *test_enable_data = test->private_data;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tenable_data = data->private_data;\n\t\tif (enable_data &&\n\t\t    (data->cmd_ops->trigger_type ==\n\t\t     test->cmd_ops->trigger_type) &&\n\t\t    (enable_data->file == test_enable_data->file)) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_alloc_snapshot_instance",
          "args": [
            "file->tr"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_alloc_snapshot_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "953-969",
          "snippet": "int tracing_alloc_snapshot_instance(struct trace_array *tr)\n{\n\tint ret;\n\n\tif (!tr->allocated_snapshot) {\n\n\t\t/* allocate spare buffer */\n\t\tret = resize_buffer_duplicate_size(&tr->max_buffer,\n\t\t\t\t   &tr->trace_buffer, RING_BUFFER_ALL_CPUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttr->allocated_snapshot = true;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_alloc_snapshot_instance(struct trace_array *tr)\n{\n\tint ret;\n\n\tif (!tr->allocated_snapshot) {\n\n\t\t/* allocate spare buffer */\n\t\tret = resize_buffer_duplicate_size(&tr->max_buffer,\n\t\t\t\t   &tr->trace_buffer, RING_BUFFER_ALL_CPUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttr->allocated_snapshot = true;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nregister_snapshot_trigger(char *glob, struct event_trigger_ops *ops,\n\t\t\t  struct event_trigger_data *data,\n\t\t\t  struct trace_event_file *file)\n{\n\tint ret = register_trigger(glob, ops, data, file);\n\n\tif (ret > 0 && tracing_alloc_snapshot_instance(file->tr) != 0) {\n\t\tunregister_trigger(glob, ops, data, file);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "snapshot_count_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1057-1068",
    "snippet": "static void\nsnapshot_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t       struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tsnapshot_trigger(data, rec, event);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snapshot_trigger",
          "args": [
            "data",
            "rec",
            "event"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_trigger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1085-1091",
          "snippet": "static int\nsnapshot_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"snapshot\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nsnapshot_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"snapshot\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\nsnapshot_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t       struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tsnapshot_trigger(data, rec, event);\n}"
  },
  {
    "function_name": "snapshot_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1045-1055",
    "snippet": "static void\nsnapshot_trigger(struct event_trigger_data *data, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file)\n\t\ttracing_snapshot_instance(file->tr);\n\telse\n\t\ttracing_snapshot();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_snapshot",
          "args": [],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_snapshot_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1040-1044",
          "snippet": "void tracing_snapshot_alloc(void)\n{\n\t/* Give warning */\n\ttracing_snapshot();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nvoid tracing_snapshot_alloc(void)\n{\n\t/* Give warning */\n\ttracing_snapshot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_snapshot_instance",
          "args": [
            "file->tr"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_snapshot_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "897-925",
          "snippet": "void tracing_snapshot_instance(struct trace_array *tr)\n{\n\tstruct tracer *tracer = tr->current_trace;\n\tunsigned long flags;\n\n\tif (in_nmi()) {\n\t\tinternal_trace_puts(\"*** SNAPSHOT CALLED FROM NMI CONTEXT ***\\n\");\n\t\tinternal_trace_puts(\"*** snapshot is being ignored        ***\\n\");\n\t\treturn;\n\t}\n\n\tif (!tr->allocated_snapshot) {\n\t\tinternal_trace_puts(\"*** SNAPSHOT NOT ALLOCATED ***\\n\");\n\t\tinternal_trace_puts(\"*** stopping trace here!   ***\\n\");\n\t\ttracing_off();\n\t\treturn;\n\t}\n\n\t/* Note, snapshot can not be used when the tracer uses it */\n\tif (tracer->use_max_tr) {\n\t\tinternal_trace_puts(\"*** LATENCY TRACER ACTIVE ***\\n\");\n\t\tinternal_trace_puts(\"*** Can not use snapshot (sorry) ***\\n\");\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\tupdate_max_tr(tr, current, smp_processor_id());\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_snapshot_instance(struct trace_array *tr)\n{\n\tstruct tracer *tracer = tr->current_trace;\n\tunsigned long flags;\n\n\tif (in_nmi()) {\n\t\tinternal_trace_puts(\"*** SNAPSHOT CALLED FROM NMI CONTEXT ***\\n\");\n\t\tinternal_trace_puts(\"*** snapshot is being ignored        ***\\n\");\n\t\treturn;\n\t}\n\n\tif (!tr->allocated_snapshot) {\n\t\tinternal_trace_puts(\"*** SNAPSHOT NOT ALLOCATED ***\\n\");\n\t\tinternal_trace_puts(\"*** stopping trace here!   ***\\n\");\n\t\ttracing_off();\n\t\treturn;\n\t}\n\n\t/* Note, snapshot can not be used when the tracer uses it */\n\tif (tracer->use_max_tr) {\n\t\tinternal_trace_puts(\"*** LATENCY TRACER ACTIVE ***\\n\");\n\t\tinternal_trace_puts(\"*** Can not use snapshot (sorry) ***\\n\");\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\tupdate_max_tr(tr, current, smp_processor_id());\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\nsnapshot_trigger(struct event_trigger_data *data, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file)\n\t\ttracing_snapshot_instance(file->tr);\n\telse\n\t\ttracing_snapshot();\n}"
  },
  {
    "function_name": "onoff_get_trigger_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1007-1021",
    "snippet": "static struct event_trigger_ops *\nonoff_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\n\t/* we register both traceon and traceoff to this callback */\n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_trigger_ops :\n\t\t\t&traceon_trigger_ops;\n\telse\n\t\tops = param ? &traceoff_count_trigger_ops :\n\t\t\t&traceoff_trigger_ops;\n\n\treturn ops;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_trigger_ops traceon_trigger_ops = {\n\t.func\t\t\t= traceon_trigger,\n\t.print\t\t\t= traceon_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};",
      "static struct event_trigger_ops traceon_count_trigger_ops = {\n\t.func\t\t\t= traceon_count_trigger,\n\t.print\t\t\t= traceon_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};",
      "static struct event_trigger_ops traceoff_trigger_ops = {\n\t.func\t\t\t= traceoff_trigger,\n\t.print\t\t\t= traceoff_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};",
      "static struct event_trigger_ops traceoff_count_trigger_ops = {\n\t.func\t\t\t= traceoff_count_trigger,\n\t.print\t\t\t= traceoff_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"traceon\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct event_trigger_ops traceon_trigger_ops = {\n\t.func\t\t\t= traceon_trigger,\n\t.print\t\t\t= traceon_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\nstatic struct event_trigger_ops traceon_count_trigger_ops = {\n\t.func\t\t\t= traceon_count_trigger,\n\t.print\t\t\t= traceon_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\nstatic struct event_trigger_ops traceoff_trigger_ops = {\n\t.func\t\t\t= traceoff_trigger,\n\t.print\t\t\t= traceoff_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\nstatic struct event_trigger_ops traceoff_count_trigger_ops = {\n\t.func\t\t\t= traceoff_count_trigger,\n\t.print\t\t\t= traceoff_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\n\nstatic struct event_trigger_ops *\nonoff_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\n\t/* we register both traceon and traceoff to this callback */\n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_trigger_ops :\n\t\t\t&traceon_trigger_ops;\n\telse\n\t\tops = param ? &traceoff_count_trigger_ops :\n\t\t\t&traceoff_trigger_ops;\n\n\treturn ops;\n}"
  },
  {
    "function_name": "traceoff_trigger_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "971-977",
    "snippet": "static int\ntraceoff_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"traceoff\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_print",
          "args": [
            "\"traceoff\"",
            "m",
            "(void *)data->count",
            "data->filter_str"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "372-391",
          "snippet": "static int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\ntraceoff_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"traceoff\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}"
  },
  {
    "function_name": "traceon_trigger_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "963-969",
    "snippet": "static int\ntraceon_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t      struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"traceon\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_print",
          "args": [
            "\"traceon\"",
            "m",
            "(void *)data->count",
            "data->filter_str"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "372-391",
          "snippet": "static int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\ntraceon_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t      struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"traceon\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}"
  },
  {
    "function_name": "traceoff_count_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "947-961",
    "snippet": "static void\ntraceoff_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t       struct ring_buffer_event *event)\n{\n\tif (!tracing_is_on())\n\t\treturn;\n\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\ttracing_off();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_off",
          "args": [],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1073-1076",
          "snippet": "void tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1101-1104",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\ntraceoff_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t       struct ring_buffer_event *event)\n{\n\tif (!tracing_is_on())\n\t\treturn;\n\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\ttracing_off();\n}"
  },
  {
    "function_name": "traceoff_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "937-945",
    "snippet": "static void\ntraceoff_trigger(struct event_trigger_data *data, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tif (!tracing_is_on())\n\t\treturn;\n\n\ttracing_off();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_off",
          "args": [],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1073-1076",
          "snippet": "void tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1101-1104",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\ntraceoff_trigger(struct event_trigger_data *data, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tif (!tracing_is_on())\n\t\treturn;\n\n\ttracing_off();\n}"
  },
  {
    "function_name": "traceon_count_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "921-935",
    "snippet": "static void\ntraceon_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t      struct ring_buffer_event *event)\n{\n\tif (tracing_is_on())\n\t\treturn;\n\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\ttracing_on();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_on",
          "args": [],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "783-786",
          "snippet": "void tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1101-1104",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\ntraceon_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t      struct ring_buffer_event *event)\n{\n\tif (tracing_is_on())\n\t\treturn;\n\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\ttracing_on();\n}"
  },
  {
    "function_name": "traceon_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "911-919",
    "snippet": "static void\ntraceon_trigger(struct event_trigger_data *data, void *rec,\n\t\tstruct ring_buffer_event *event)\n{\n\tif (tracing_is_on())\n\t\treturn;\n\n\ttracing_on();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_on",
          "args": [],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "783-786",
          "snippet": "void tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1101-1104",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\ntraceon_trigger(struct event_trigger_data *data, void *rec,\n\t\tstruct ring_buffer_event *event)\n{\n\tif (tracing_is_on())\n\t\treturn;\n\n\ttracing_on();\n}"
  },
  {
    "function_name": "get_named_trigger_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "905-909",
    "snippet": "struct event_trigger_data *\nget_named_trigger_data(struct event_trigger_data *data)\n{\n\treturn data->named_data;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstruct event_trigger_data *\nget_named_trigger_data(struct event_trigger_data *data)\n{\n\treturn data->named_data;\n}"
  },
  {
    "function_name": "set_named_trigger_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "899-903",
    "snippet": "void set_named_trigger_data(struct event_trigger_data *data,\n\t\t\t    struct event_trigger_data *named_data)\n{\n\tdata->named_data = named_data;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid set_named_trigger_data(struct event_trigger_data *data,\n\t\t\t    struct event_trigger_data *named_data)\n{\n\tdata->named_data = named_data;\n}"
  },
  {
    "function_name": "unpause_named_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "883-886",
    "snippet": "void unpause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, false);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pause_named_trigger",
          "args": [
            "data",
            "false"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "__pause_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "844-858",
          "snippet": "static void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstatic void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid unpause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, false);\n}"
  },
  {
    "function_name": "pause_named_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "869-872",
    "snippet": "void pause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, true);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pause_named_trigger",
          "args": [
            "data",
            "true"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "__pause_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "844-858",
          "snippet": "static void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstatic void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid pause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, true);\n}"
  },
  {
    "function_name": "__pause_named_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "844-858",
    "snippet": "static void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(named_triggers);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "test->name",
            "data->name"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&named_triggers",
            "named_list"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstatic void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "del_named_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "836-842",
    "snippet": "void del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&data->named_list"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data->name"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}"
  },
  {
    "function_name": "save_named_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "821-830",
    "snippet": "int save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(named_triggers);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&data->named_list",
            "&named_triggers"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nint save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_named_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "802-812",
    "snippet": "bool is_named_trigger(struct event_trigger_data *test)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (test == data)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(named_triggers);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "data",
            "&named_triggers",
            "named_list"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nbool is_named_trigger(struct event_trigger_data *test)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (test == data)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "find_named_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "779-794",
    "snippet": "struct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(named_triggers);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->name",
            "name"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "data",
            "&named_triggers",
            "named_list"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "set_trigger_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "713-761",
    "snippet": "int set_trigger_filter(char *filter_str,\n\t\t       struct event_trigger_data *trigger_data,\n\t\t       struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data = trigger_data;\n\tstruct event_filter *filter = NULL, *tmp;\n\tint ret = -EINVAL;\n\tchar *s;\n\n\tif (!filter_str) /* clear the current filter */\n\t\tgoto assign;\n\n\ts = strsep(&filter_str, \" \\t\");\n\n\tif (!strlen(s) || strcmp(s, \"if\") != 0)\n\t\tgoto out;\n\n\tif (!filter_str)\n\t\tgoto out;\n\n\t/* The filter is for the 'trigger' event, not the triggered event */\n\tret = create_event_filter(file->event_call, filter_str, false, &filter);\n\tif (ret)\n\t\tgoto out;\n assign:\n\ttmp = rcu_access_pointer(data->filter);\n\n\trcu_assign_pointer(data->filter, filter);\n\n\tif (tmp) {\n\t\t/* Make sure the call is done with the filter */\n\t\ttracepoint_synchronize_unregister();\n\t\tfree_event_filter(tmp);\n\t}\n\n\tkfree(data->filter_str);\n\tdata->filter_str = NULL;\n\n\tif (filter_str) {\n\t\tdata->filter_str = kstrdup(filter_str, GFP_KERNEL);\n\t\tif (!data->filter_str) {\n\t\t\tfree_event_filter(rcu_access_pointer(data->filter));\n\t\t\tdata->filter = NULL;\n\t\t\tret = -ENOMEM;\n\t\t}\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_event_filter",
          "args": [
            "rcu_access_pointer(data->filter)"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1017-1020",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "data->filter"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "filter_str",
            "GFP_KERNEL"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data->filter_str"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "data->filter",
            "filter"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "data->filter"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_event_filter",
          "args": [
            "file->event_call",
            "filter_str",
            "false",
            "&filter"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "create_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1725-1730",
          "snippet": "int create_event_filter(struct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(call, filter_str, set_str, filterp);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint create_event_filter(struct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(call, filter_str, set_str, filterp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"if\""
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&filter_str",
            "\" \\t\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint set_trigger_filter(char *filter_str,\n\t\t       struct event_trigger_data *trigger_data,\n\t\t       struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data = trigger_data;\n\tstruct event_filter *filter = NULL, *tmp;\n\tint ret = -EINVAL;\n\tchar *s;\n\n\tif (!filter_str) /* clear the current filter */\n\t\tgoto assign;\n\n\ts = strsep(&filter_str, \" \\t\");\n\n\tif (!strlen(s) || strcmp(s, \"if\") != 0)\n\t\tgoto out;\n\n\tif (!filter_str)\n\t\tgoto out;\n\n\t/* The filter is for the 'trigger' event, not the triggered event */\n\tret = create_event_filter(file->event_call, filter_str, false, &filter);\n\tif (ret)\n\t\tgoto out;\n assign:\n\ttmp = rcu_access_pointer(data->filter);\n\n\trcu_assign_pointer(data->filter, filter);\n\n\tif (tmp) {\n\t\t/* Make sure the call is done with the filter */\n\t\ttracepoint_synchronize_unregister();\n\t\tfree_event_filter(tmp);\n\t}\n\n\tkfree(data->filter_str);\n\tdata->filter_str = NULL;\n\n\tif (filter_str) {\n\t\tdata->filter_str = kstrdup(filter_str, GFP_KERNEL);\n\t\tif (!data->filter_str) {\n\t\t\tfree_event_filter(rcu_access_pointer(data->filter));\n\t\t\tdata->filter = NULL;\n\t\t\tret = -ENOMEM;\n\t\t}\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "608-695",
    "snippet": "static int\nevent_trigger_callback(struct event_command *cmd_ops,\n\t\t       struct trace_event_file *file,\n\t\t       char *glob, char *cmd, char *param)\n{\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\tchar *trigger = NULL;\n\tchar *number;\n\tint ret;\n\n\t/* separate the trigger from the filter (t:n [if filter]) */\n\tif (param && isdigit(param[0]))\n\t\ttrigger = strsep(&param, \" \\t\");\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\tret = -ENOMEM;\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\tgoto out;\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\ttrigger_data->private_data = file;\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tINIT_LIST_HEAD(&trigger_data->named_list);\n\n\tif (glob[0] == '!') {\n\t\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n\t\tkfree(trigger_data);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (trigger) {\n\t\tnumber = strsep(&trigger, \":\");\n\n\t\tret = -EINVAL;\n\t\tif (!strlen(number))\n\t\t\tgoto out_free;\n\n\t\t/*\n\t\t * We use the callback data field (which is a pointer)\n\t\t * as our counter.\n\t\t */\n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tif (!param) /* if param is non-empty, it's supposed to be a filter */\n\t\tgoto out_reg;\n\n\tif (!cmd_ops->set_filter)\n\t\tgoto out_reg;\n\n\tret = cmd_ops->set_filter(param, trigger_data, file);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Up the trigger_data count to make sure reg doesn't free it on failure */\n\tevent_trigger_init(trigger_ops, trigger_data);\n\tret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tcmd_ops->unreg(glob, trigger_ops, trigger_data, file);\n\t\tret = -ENOENT;\n\t} else if (ret > 0)\n\t\tret = 0;\n\n\t/* Down the counter of trigger_data or free it if not used anymore */\n\tevent_trigger_free(trigger_ops, trigger_data);\n out:\n\treturn ret;\n\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\tkfree(trigger_data);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "trigger_data"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "NULL",
            "trigger_data",
            "NULL"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_trigger_free",
          "args": [
            "trigger_ops",
            "trigger_data"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "422-432",
          "snippet": "static void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob",
            "trigger_ops",
            "trigger_data",
            "file"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->reg",
          "args": [
            "glob",
            "trigger_ops",
            "trigger_data",
            "file"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_trigger_init",
          "args": [
            "trigger_ops",
            "trigger_data"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "405-410",
          "snippet": "int event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "param",
            "trigger_data",
            "file"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "number",
            "0",
            "&trigger_data->count"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "number"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&trigger",
            "\":\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob+1",
            "trigger_ops",
            "trigger_data",
            "file"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger_data->named_list"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger_data->list"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*trigger_data)",
            "GFP_KERNEL"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->get_trigger_ops",
          "args": [
            "cmd",
            "trigger"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\" \\t\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "param[0]"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nevent_trigger_callback(struct event_command *cmd_ops,\n\t\t       struct trace_event_file *file,\n\t\t       char *glob, char *cmd, char *param)\n{\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\tchar *trigger = NULL;\n\tchar *number;\n\tint ret;\n\n\t/* separate the trigger from the filter (t:n [if filter]) */\n\tif (param && isdigit(param[0]))\n\t\ttrigger = strsep(&param, \" \\t\");\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\tret = -ENOMEM;\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\tgoto out;\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\ttrigger_data->private_data = file;\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tINIT_LIST_HEAD(&trigger_data->named_list);\n\n\tif (glob[0] == '!') {\n\t\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n\t\tkfree(trigger_data);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (trigger) {\n\t\tnumber = strsep(&trigger, \":\");\n\n\t\tret = -EINVAL;\n\t\tif (!strlen(number))\n\t\t\tgoto out_free;\n\n\t\t/*\n\t\t * We use the callback data field (which is a pointer)\n\t\t * as our counter.\n\t\t */\n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tif (!param) /* if param is non-empty, it's supposed to be a filter */\n\t\tgoto out_reg;\n\n\tif (!cmd_ops->set_filter)\n\t\tgoto out_reg;\n\n\tret = cmd_ops->set_filter(param, trigger_data, file);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Up the trigger_data count to make sure reg doesn't free it on failure */\n\tevent_trigger_init(trigger_ops, trigger_data);\n\tret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tcmd_ops->unreg(glob, trigger_ops, trigger_data, file);\n\t\tret = -ENOENT;\n\t} else if (ret > 0)\n\t\tret = 0;\n\n\t/* Down the counter of trigger_data or free it if not used anymore */\n\tevent_trigger_free(trigger_ops, trigger_data);\n out:\n\treturn ret;\n\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\tkfree(trigger_data);\n\tgoto out;\n}"
  },
  {
    "function_name": "unregister_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "571-590",
    "snippet": "static void unregister_trigger(char *glob, struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *test,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == test->cmd_ops->trigger_type) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->free",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "493-510",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "434-452",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void unregister_trigger(char *glob, struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *test,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == test->cmd_ops->trigger_type) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}"
  },
  {
    "function_name": "register_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "526-557",
    "snippet": "static int register_trigger(char *glob, struct event_trigger_ops *ops,\n\t\t\t    struct event_trigger_data *data,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == data->cmd_ops->trigger_type) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->list, &file->triggers);\n\tret++;\n\n\tupdate_cond_flag(file);\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "493-510",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "1"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "434-452",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&data->list",
            "&file->triggers"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->ops->init",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int register_trigger(char *glob, struct event_trigger_ops *ops,\n\t\t\t    struct event_trigger_data *data,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\tint ret = 0;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == data->cmd_ops->trigger_type) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->list, &file->triggers);\n\tret++;\n\n\tupdate_cond_flag(file);\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "update_cond_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "493-510",
    "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_TRIGGER_COND_BIT",
            "&file->flags"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_TRIGGER_COND_BIT",
            "&file->flags"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_command_needs_rec",
          "args": [
            "data->cmd_ops"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "event_command_needs_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1739-1742",
          "snippet": "static inline bool event_command_needs_rec(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_NEEDS_REC;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool event_command_needs_rec(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_NEEDS_REC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_command_post_trigger",
          "args": [
            "data->cmd_ops"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "event_command_post_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1734-1737",
          "snippet": "static inline bool event_command_post_trigger(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_POST_TRIGGER;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool event_command_post_trigger(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_POST_TRIGGER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
  },
  {
    "function_name": "clear_event_triggers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "467-481",
    "snippet": "void\nclear_event_triggers(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tstruct event_trigger_data *data, *n;\n\t\tlist_for_each_entry_safe(data, n, &file->triggers, list) {\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tlist_del_rcu(&data->list);\n\t\t\tif (data->ops->free)\n\t\t\t\tdata->ops->free(data->ops, data);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->free",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "434-452",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "data",
            "n",
            "&file->triggers",
            "list"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid\nclear_event_triggers(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tstruct event_trigger_data *data, *n;\n\t\tlist_for_each_entry_safe(data, n, &file->triggers, list) {\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tlist_del_rcu(&data->list);\n\t\t\tif (data->ops->free)\n\t\t\t\tdata->ops->free(data->ops, data);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "trace_event_trigger_enable_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "434-452",
    "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_event_enable_disable",
          "args": [
            "file",
            "0",
            "1"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "487-491",
          "snippet": "int trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nint trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_TRIGGER_MODE_BIT",
            "&file->flags"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&file->tm_ref"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_TRIGGER_MODE_BIT",
            "&file->flags"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&file->tm_ref"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "422-432",
    "snippet": "static void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trigger_data_free",
          "args": [
            "data"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_data_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "19-28",
          "snippet": "void trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "data->ref <= 0"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}"
  },
  {
    "function_name": "event_trigger_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "405-410",
    "snippet": "int event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trigger_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "372-391",
    "snippet": "static int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" if %s\\n\"",
            "filter_str"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\":unlimited\""
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "unregister_event_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "339-356",
    "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(trigger_commands);",
      "static DEFINE_MUTEX(trigger_cmd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->list"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd->name",
            "p->name"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "&trigger_commands",
            "list"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_event_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "316-333",
    "snippet": "__init int register_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &trigger_commands);\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(trigger_commands);",
      "static DEFINE_MUTEX(trigger_cmd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cmd->list",
            "&trigger_commands"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd->name",
            "p->name"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&trigger_commands",
            "list"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int register_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &trigger_commands);\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "298-302",
    "snippet": "static int\nevent_trigger_release(struct inode *inode, struct file *file)\n{\n\treturn event_trigger_regex_release(inode, file);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_regex_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_regex_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "273-283",
          "snippet": "static int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nevent_trigger_release(struct inode *inode, struct file *file)\n{\n\treturn event_trigger_regex_release(inode, file);\n}"
  },
  {
    "function_name": "event_trigger_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "292-296",
    "snippet": "static int\nevent_trigger_open(struct inode *inode, struct file *filp)\n{\n\treturn event_trigger_regex_open(inode, filp);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_regex_open",
          "args": [
            "inode",
            "filp"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_regex_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "174-209",
          "snippet": "static int event_trigger_regex_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tif (unlikely(!event_file_data(file))) {\n\t\tmutex_unlock(&event_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC)) {\n\t\tstruct trace_event_file *event_file;\n\t\tstruct event_command *p;\n\n\t\tevent_file = event_file_data(file);\n\n\t\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\t\tif (p->unreg_all)\n\t\t\t\tp->unreg_all(event_file);\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &event_triggers_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = file;\n\t\t}\n\t}\n\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static const struct seq_operations event_triggers_seq_ops = {\n\t.start = trigger_start,\n\t.next = trigger_next,\n\t.stop = trigger_stop,\n\t.show = trigger_show,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic const struct seq_operations event_triggers_seq_ops = {\n\t.start = trigger_start,\n\t.next = trigger_next,\n\t.stop = trigger_stop,\n\t.show = trigger_show,\n};\n\nstatic int event_trigger_regex_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tif (unlikely(!event_file_data(file))) {\n\t\tmutex_unlock(&event_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC)) {\n\t\tstruct trace_event_file *event_file;\n\t\tstruct event_command *p;\n\n\t\tevent_file = event_file_data(file);\n\n\t\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\t\tif (p->unreg_all)\n\t\t\t\tp->unreg_all(event_file);\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &event_triggers_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = file;\n\t\t}\n\t}\n\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int\nevent_trigger_open(struct inode *inode, struct file *filp)\n{\n\treturn event_trigger_regex_open(inode, filp);\n}"
  },
  {
    "function_name": "event_trigger_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "285-290",
    "snippet": "static ssize_t\nevent_trigger_write(struct file *filp, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn event_trigger_regex_write(filp, ubuf, cnt, ppos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_regex_write",
          "args": [
            "filp",
            "ubuf",
            "cnt",
            "ppos"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_regex_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "233-271",
          "snippet": "static ssize_t event_trigger_regex_write(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_event_file *event_file;\n\tssize_t ret;\n\tchar *buf;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(file);\n\tif (unlikely(!event_file)) {\n\t\tmutex_unlock(&event_mutex);\n\t\tkfree(buf);\n\t\treturn -ENODEV;\n\t}\n\tret = trigger_process_regex(event_file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic ssize_t event_trigger_regex_write(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_event_file *event_file;\n\tssize_t ret;\n\tchar *buf;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(file);\n\tif (unlikely(!event_file)) {\n\t\tmutex_unlock(&event_mutex);\n\t\tkfree(buf);\n\t\treturn -ENODEV;\n\t}\n\tret = trigger_process_regex(event_file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic ssize_t\nevent_trigger_write(struct file *filp, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn event_trigger_regex_write(filp, ubuf, cnt, ppos);\n}"
  },
  {
    "function_name": "event_trigger_regex_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "273-283",
    "snippet": "static int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "219-233",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trigger_regex_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "233-271",
    "snippet": "static ssize_t event_trigger_regex_write(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_event_file *event_file;\n\tssize_t ret;\n\tchar *buf;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(file);\n\tif (unlikely(!event_file)) {\n\t\tmutex_unlock(&event_mutex);\n\t\tkfree(buf);\n\t\treturn -ENODEV;\n\t}\n\tret = trigger_process_regex(event_file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_process_regex",
          "args": [
            "event_file",
            "buf"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_process_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "211-231",
          "snippet": "static int trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next = buff;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tcommand = strsep(&next, \": \\t\");\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\nstatic int trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next = buff;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tcommand = strsep(&next, \": \\t\");\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event_file"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "file"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strim",
          "args": [
            "buf"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "buf"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "buf"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "ubuf",
            "cnt"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic ssize_t event_trigger_regex_write(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_event_file *event_file;\n\tssize_t ret;\n\tchar *buf;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(file);\n\tif (unlikely(!event_file)) {\n\t\tmutex_unlock(&event_mutex);\n\t\tkfree(buf);\n\t\treturn -ENODEV;\n\t}\n\tret = trigger_process_regex(event_file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "trigger_process_regex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "211-231",
    "snippet": "static int trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next = buff;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tcommand = strsep(&next, \": \\t\");\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(trigger_commands);",
      "static DEFINE_MUTEX(trigger_cmd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->func",
          "args": [
            "p",
            "file",
            "buff",
            "command",
            "next"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p->name",
            "command"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&trigger_commands",
            "list"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&next",
            "\": \\t\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\nstatic int trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next = buff;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tcommand = strsep(&next, \": \\t\");\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_regex_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "174-209",
    "snippet": "static int event_trigger_regex_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tif (unlikely(!event_file_data(file))) {\n\t\tmutex_unlock(&event_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC)) {\n\t\tstruct trace_event_file *event_file;\n\t\tstruct event_command *p;\n\n\t\tevent_file = event_file_data(file);\n\n\t\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\t\tif (p->unreg_all)\n\t\t\t\tp->unreg_all(event_file);\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &event_triggers_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = file;\n\t\t}\n\t}\n\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(trigger_commands);",
      "static const struct seq_operations event_triggers_seq_ops = {\n\t.start = trigger_start,\n\t.next = trigger_next,\n\t.stop = trigger_stop,\n\t.show = trigger_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&event_triggers_seq_ops"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->unreg_all",
          "args": [
            "event_file"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&trigger_commands",
            "list"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "file"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event_file_data(file)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic const struct seq_operations event_triggers_seq_ops = {\n\t.start = trigger_start,\n\t.next = trigger_next,\n\t.stop = trigger_stop,\n\t.show = trigger_show,\n};\n\nstatic int event_trigger_regex_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tif (unlikely(!event_file_data(file))) {\n\t\tmutex_unlock(&event_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC)) {\n\t\tstruct trace_event_file *event_file;\n\t\tstruct event_command *p;\n\n\t\tevent_file = event_file_data(file);\n\n\t\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\t\tif (p->unreg_all)\n\t\t\t\tp->unreg_all(event_file);\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &event_triggers_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = file;\n\t\t}\n\t}\n\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trigger_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "145-165",
    "snippet": "static int trigger_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct event_command *p;\n\n\tif (v == SHOW_AVAILABLE_TRIGGERS) {\n\t\tseq_puts(m, \"# Available triggers:\\n\");\n\t\tseq_putc(m, '#');\n\t\tmutex_lock(&trigger_cmd_mutex);\n\t\tlist_for_each_entry_reverse(p, &trigger_commands, list)\n\t\t\tseq_printf(m, \" %s\", p->name);\n\t\tseq_putc(m, '\\n');\n\t\tmutex_unlock(&trigger_cmd_mutex);\n\t\treturn 0;\n\t}\n\n\tdata = list_entry(v, struct event_trigger_data, list);\n\tdata->ops->print(m, data->ops, data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)"
    ],
    "globals_used": [
      "static LIST_HEAD(trigger_commands);",
      "static DEFINE_MUTEX(trigger_cmd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->print",
          "args": [
            "m",
            "data->ops",
            "data"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structevent_trigger_data",
            "list"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %s\"",
            "p->name"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "p",
            "&trigger_commands",
            "list"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"# Available triggers:\\n\""
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\nstatic int trigger_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct event_command *p;\n\n\tif (v == SHOW_AVAILABLE_TRIGGERS) {\n\t\tseq_puts(m, \"# Available triggers:\\n\");\n\t\tseq_putc(m, '#');\n\t\tmutex_lock(&trigger_cmd_mutex);\n\t\tlist_for_each_entry_reverse(p, &trigger_commands, list)\n\t\t\tseq_printf(m, \" %s\", p->name);\n\t\tseq_putc(m, '\\n');\n\t\tmutex_unlock(&trigger_cmd_mutex);\n\t\treturn 0;\n\t}\n\n\tdata = list_entry(v, struct event_trigger_data, list);\n\tdata->ops->print(m, data->ops, data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trigger_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "140-143",
    "snippet": "static void trigger_stop(struct seq_file *m, void *t)\n{\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void trigger_stop(struct seq_file *m, void *t)\n{\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "trigger_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "124-138",
    "snippet": "static void *trigger_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *event_file;\n\n\t/* ->stop() is called even if ->start() fails */\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (list_empty(&event_file->triggers))\n\t\treturn *pos == 0 ? SHOW_AVAILABLE_TRIGGERS : NULL;\n\n\treturn seq_list_start(&event_file->triggers, *pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&event_file->triggers",
            "*pos"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&event_file->triggers"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event_file"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)\n\nstatic void *trigger_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *event_file;\n\n\t/* ->stop() is called even if ->start() fails */\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (list_empty(&event_file->triggers))\n\t\treturn *pos == 0 ? SHOW_AVAILABLE_TRIGGERS : NULL;\n\n\treturn seq_list_start(&event_file->triggers, *pos);\n}"
  },
  {
    "function_name": "trigger_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "114-122",
    "snippet": "static void *trigger_next(struct seq_file *m, void *t, loff_t *pos)\n{\n\tstruct trace_event_file *event_file = event_file_data(m->private);\n\n\tif (t == SHOW_AVAILABLE_TRIGGERS)\n\t\treturn NULL;\n\n\treturn seq_list_next(t, &event_file->triggers, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "t",
            "&event_file->triggers",
            "pos"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)\n\nstatic void *trigger_next(struct seq_file *m, void *t, loff_t *pos)\n{\n\tstruct trace_event_file *event_file = event_file_data(m->private);\n\n\tif (t == SHOW_AVAILABLE_TRIGGERS)\n\t\treturn NULL;\n\n\treturn seq_list_next(t, &event_file->triggers, pos);\n}"
  },
  {
    "function_name": "event_triggers_post_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "97-109",
    "snippet": "void\nevent_triggers_post_call(struct trace_event_file *file,\n\t\t\t enum event_trigger_type tt)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->paused)\n\t\t\tcontinue;\n\t\tif (data->cmd_ops->trigger_type & tt)\n\t\t\tdata->ops->func(data, NULL, NULL);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->func",
          "args": [
            "data",
            "NULL",
            "NULL"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid\nevent_triggers_post_call(struct trace_event_file *file,\n\t\t\t enum event_trigger_type tt)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->paused)\n\t\t\tcontinue;\n\t\tif (data->cmd_ops->trigger_type & tt)\n\t\t\tdata->ops->func(data, NULL, NULL);\n\t}\n}"
  },
  {
    "function_name": "event_triggers_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "54-82",
    "snippet": "enum event_trigger_type\nevent_triggers_call(struct trace_event_file *file, void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct event_trigger_data *data;\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct event_filter *filter;\n\n\tif (list_empty(&file->triggers))\n\t\treturn tt;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->paused)\n\t\t\tcontinue;\n\t\tif (!rec) {\n\t\t\tdata->ops->func(data, rec, event);\n\t\t\tcontinue;\n\t\t}\n\t\tfilter = rcu_dereference_sched(data->filter);\n\t\tif (filter && !filter_match_preds(filter, rec))\n\t\t\tcontinue;\n\t\tif (event_command_post_trigger(data->cmd_ops)) {\n\t\t\ttt |= data->cmd_ops->trigger_type;\n\t\t\tcontinue;\n\t\t}\n\t\tdata->ops->func(data, rec, event);\n\t}\n\treturn tt;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->func",
          "args": [
            "data",
            "rec",
            "event"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_command_post_trigger",
          "args": [
            "data->cmd_ops"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "event_command_post_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1734-1737",
          "snippet": "static inline bool event_command_post_trigger(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_POST_TRIGGER;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool event_command_post_trigger(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_POST_TRIGGER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_match_preds",
          "args": [
            "filter",
            "rec"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "filter_match_preds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "880-901",
          "snippet": "int filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "data->filter"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->ops->func",
          "args": [
            "data",
            "rec",
            "event"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&file->triggers"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nenum event_trigger_type\nevent_triggers_call(struct trace_event_file *file, void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct event_trigger_data *data;\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct event_filter *filter;\n\n\tif (list_empty(&file->triggers))\n\t\treturn tt;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->paused)\n\t\t\tcontinue;\n\t\tif (!rec) {\n\t\t\tdata->ops->func(data, rec, event);\n\t\t\tcontinue;\n\t\t}\n\t\tfilter = rcu_dereference_sched(data->filter);\n\t\tif (filter && !filter_match_preds(filter, rec))\n\t\t\tcontinue;\n\t\tif (event_command_post_trigger(data->cmd_ops)) {\n\t\t\ttt |= data->cmd_ops->trigger_type;\n\t\t\tcontinue;\n\t\t}\n\t\tdata->ops->func(data, rec, event);\n\t}\n\treturn tt;\n}"
  },
  {
    "function_name": "trigger_data_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
    "lines": "19-28",
    "snippet": "void trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->cmd_ops->set_filter",
          "args": [
            "NULL",
            "data",
            "NULL"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}"
  }
]