[
  {
    "function_name": "context_tracking_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
    "lines": "211-217",
    "snippet": "void __init context_tracking_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcontext_tracking_cpu_set(cpu);\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid __init context_tracking_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcontext_tracking_cpu_set(cpu);\n}"
  },
  {
    "function_name": "context_tracking_cpu_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
    "lines": "188-208",
    "snippet": "void __init context_tracking_cpu_set(int cpu)\n{\n\tstatic __initdata bool initialized = false;\n\n\tif (!per_cpu(context_tracking.active, cpu)) {\n\t\tper_cpu(context_tracking.active, cpu) = true;\n\t\tstatic_branch_inc(&context_tracking_enabled);\n\t}\n\n\tif (initialized)\n\t\treturn;\n\n\t/*\n\t * Set TIF_NOHZ to init/0 and let it propagate to all tasks through fork\n\t * This assumes that init is the only task at this early boot stage.\n\t */\n\tset_tsk_thread_flag(&init_task, TIF_NOHZ);\n\tWARN_ON_ONCE(!tasklist_empty());\n\n\tinitialized = true;\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tasklist_empty()"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasklist_empty",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "&init_task",
            "TIF_NOHZ"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&context_tracking_enabled"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "context_tracking.active",
            "cpu"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid __init context_tracking_cpu_set(int cpu)\n{\n\tstatic __initdata bool initialized = false;\n\n\tif (!per_cpu(context_tracking.active, cpu)) {\n\t\tper_cpu(context_tracking.active, cpu) = true;\n\t\tstatic_branch_inc(&context_tracking_enabled);\n\t}\n\n\tif (initialized)\n\t\treturn;\n\n\t/*\n\t * Set TIF_NOHZ to init/0 and let it propagate to all tasks through fork\n\t * This assumes that init is the only task at this early boot stage.\n\t */\n\tset_tsk_thread_flag(&init_task, TIF_NOHZ);\n\tWARN_ON_ONCE(!tasklist_empty());\n\n\tinitialized = true;\n}"
  },
  {
    "function_name": "context_tracking_user_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
    "lines": "182-185",
    "snippet": "void context_tracking_user_exit(void)\n{\n\tuser_exit();\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_exit",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_user_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
          "lines": "182-185",
          "snippet": "void context_tracking_user_exit(void)\n{\n\tuser_exit();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid context_tracking_user_exit(void)\n{\n\tuser_exit();\n}"
  },
  {
    "function_name": "context_tracking_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
    "lines": "168-178",
    "snippet": "void context_tracking_exit(enum ctx_state state)\n{\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\t__context_tracking_exit(state);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__context_tracking_exit",
          "args": [
            "state"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__context_tracking_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
          "lines": "144-164",
          "snippet": "void __context_tracking_exit(enum ctx_state state)\n{\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif (__this_cpu_read(context_tracking.state) == state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * We are going to run code that may use RCU. Inform\n\t\t\t * RCU core about that (ie: we may need the tick again).\n\t\t\t */\n\t\t\trcu_user_exit();\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tvtime_user_exit(current);\n\t\t\t\ttrace_user_exit(0);\n\t\t\t}\n\t\t}\n\t\t__this_cpu_write(context_tracking.state, CONTEXT_KERNEL);\n\t}\n\tcontext_tracking_recursion_exit();\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid __context_tracking_exit(enum ctx_state state)\n{\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif (__this_cpu_read(context_tracking.state) == state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * We are going to run code that may use RCU. Inform\n\t\t\t * RCU core about that (ie: we may need the tick again).\n\t\t\t */\n\t\t\trcu_user_exit();\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tvtime_user_exit(current);\n\t\t\t\ttrace_user_exit(0);\n\t\t\t}\n\t\t}\n\t\t__this_cpu_write(context_tracking.state, CONTEXT_KERNEL);\n\t}\n\tcontext_tracking_recursion_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid context_tracking_exit(enum ctx_state state)\n{\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\t__context_tracking_exit(state);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__context_tracking_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
    "lines": "144-164",
    "snippet": "void __context_tracking_exit(enum ctx_state state)\n{\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif (__this_cpu_read(context_tracking.state) == state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * We are going to run code that may use RCU. Inform\n\t\t\t * RCU core about that (ie: we may need the tick again).\n\t\t\t */\n\t\t\trcu_user_exit();\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tvtime_user_exit(current);\n\t\t\t\ttrace_user_exit(0);\n\t\t\t}\n\t\t}\n\t\t__this_cpu_write(context_tracking.state, CONTEXT_KERNEL);\n\t}\n\tcontext_tracking_recursion_exit();\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_tracking_recursion_exit",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_recursion_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
          "lines": "47-50",
          "snippet": "static void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "context_tracking.state",
            "CONTEXT_KERNEL"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_user_exit",
          "args": [
            "0"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_user_exit",
          "args": [
            "current"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_user_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "759-771",
          "snippet": "void vtime_user_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->utime += get_vtime_delta(vtime);\n\tif (vtime->utime >= TICK_NSEC) {\n\t\taccount_user_time(tsk, vtime->utime);\n\t\tvtime->utime = 0;\n\t}\n\tvtime->state = VTIME_SYS;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_user_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->utime += get_vtime_delta(vtime);\n\tif (vtime->utime >= TICK_NSEC) {\n\t\taccount_user_time(tsk, vtime->utime);\n\t\tvtime->utime = 0;\n\t}\n\tvtime->state = VTIME_SYS;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_user_exit",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_user_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "787-790",
          "snippet": "void rcu_user_exit(void)\n{\n\trcu_eqs_exit(1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_user_exit(void)\n{\n\trcu_eqs_exit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "context_tracking.active"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "context_tracking.state"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_tracking_recursion_enter",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_recursion_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
          "lines": "33-45",
          "snippet": "static bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid __context_tracking_exit(enum ctx_state state)\n{\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif (__this_cpu_read(context_tracking.state) == state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * We are going to run code that may use RCU. Inform\n\t\t\t * RCU core about that (ie: we may need the tick again).\n\t\t\t */\n\t\t\trcu_user_exit();\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tvtime_user_exit(current);\n\t\t\t\ttrace_user_exit(0);\n\t\t\t}\n\t\t}\n\t\t__this_cpu_write(context_tracking.state, CONTEXT_KERNEL);\n\t}\n\tcontext_tracking_recursion_exit();\n}"
  },
  {
    "function_name": "context_tracking_user_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
    "lines": "126-129",
    "snippet": "void context_tracking_user_enter(void)\n{\n\tuser_enter();\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_enter",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_user_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
          "lines": "126-129",
          "snippet": "void context_tracking_user_enter(void)\n{\n\tuser_enter();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid context_tracking_user_enter(void)\n{\n\tuser_enter();\n}"
  },
  {
    "function_name": "context_tracking_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
    "lines": "104-122",
    "snippet": "void context_tracking_enter(enum ctx_state state)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Some contexts may involve an exception occuring in an irq,\n\t * leading to that nesting:\n\t * rcu_irq_enter() rcu_user_exit() rcu_user_exit() rcu_irq_exit()\n\t * This would mess up the dyntick_nesting count though. And rcu_irq_*()\n\t * helpers are enough to protect RCU uses inside the exception. So\n\t * just return immediately if we detect we are in an IRQ.\n\t */\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\t__context_tracking_enter(state);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__context_tracking_enter",
          "args": [
            "state"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__context_tracking_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
          "lines": "61-100",
          "snippet": "void __context_tracking_enter(enum ctx_state state)\n{\n\t/* Kernel threads aren't supposed to go to userspace */\n\tWARN_ON_ONCE(!current->mm);\n\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif ( __this_cpu_read(context_tracking.state) != state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * At this stage, only low level arch entry code remains and\n\t\t\t * then we'll run in userspace. We can assume there won't be\n\t\t\t * any RCU read-side critical section until the next call to\n\t\t\t * user_exit() or rcu_irq_enter(). Let's remove RCU's dependency\n\t\t\t * on the tick.\n\t\t\t */\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\ttrace_user_enter(0);\n\t\t\t\tvtime_user_enter(current);\n\t\t\t}\n\t\t\trcu_user_enter();\n\t\t}\n\t\t/*\n\t\t * Even if context tracking is disabled on this CPU, because it's outside\n\t\t * the full dynticks mask for example, we still have to keep track of the\n\t\t * context transitions and states to prevent inconsistency on those of\n\t\t * other CPUs.\n\t\t * If a task triggers an exception in userspace, sleep on the exception\n\t\t * handler and then migrate to another CPU, that new CPU must know where\n\t\t * the exception returns by the time we call exception_exit().\n\t\t * This information can only be provided by the previous CPU when it called\n\t\t * exception_enter().\n\t\t * OTOH we can spare the calls to vtime and RCU when context_tracking.active\n\t\t * is false because we know that CPU is not tickless.\n\t\t */\n\t\t__this_cpu_write(context_tracking.state, state);\n\t}\n\tcontext_tracking_recursion_exit();\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid __context_tracking_enter(enum ctx_state state)\n{\n\t/* Kernel threads aren't supposed to go to userspace */\n\tWARN_ON_ONCE(!current->mm);\n\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif ( __this_cpu_read(context_tracking.state) != state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * At this stage, only low level arch entry code remains and\n\t\t\t * then we'll run in userspace. We can assume there won't be\n\t\t\t * any RCU read-side critical section until the next call to\n\t\t\t * user_exit() or rcu_irq_enter(). Let's remove RCU's dependency\n\t\t\t * on the tick.\n\t\t\t */\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\ttrace_user_enter(0);\n\t\t\t\tvtime_user_enter(current);\n\t\t\t}\n\t\t\trcu_user_enter();\n\t\t}\n\t\t/*\n\t\t * Even if context tracking is disabled on this CPU, because it's outside\n\t\t * the full dynticks mask for example, we still have to keep track of the\n\t\t * context transitions and states to prevent inconsistency on those of\n\t\t * other CPUs.\n\t\t * If a task triggers an exception in userspace, sleep on the exception\n\t\t * handler and then migrate to another CPU, that new CPU must know where\n\t\t * the exception returns by the time we call exception_exit().\n\t\t * This information can only be provided by the previous CPU when it called\n\t\t * exception_enter().\n\t\t * OTOH we can spare the calls to vtime and RCU when context_tracking.active\n\t\t * is false because we know that CPU is not tickless.\n\t\t */\n\t\t__this_cpu_write(context_tracking.state, state);\n\t}\n\tcontext_tracking_recursion_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid context_tracking_enter(enum ctx_state state)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Some contexts may involve an exception occuring in an irq,\n\t * leading to that nesting:\n\t * rcu_irq_enter() rcu_user_exit() rcu_user_exit() rcu_irq_exit()\n\t * This would mess up the dyntick_nesting count though. And rcu_irq_*()\n\t * helpers are enough to protect RCU uses inside the exception. So\n\t * just return immediately if we detect we are in an IRQ.\n\t */\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\t__context_tracking_enter(state);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__context_tracking_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
    "lines": "61-100",
    "snippet": "void __context_tracking_enter(enum ctx_state state)\n{\n\t/* Kernel threads aren't supposed to go to userspace */\n\tWARN_ON_ONCE(!current->mm);\n\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif ( __this_cpu_read(context_tracking.state) != state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * At this stage, only low level arch entry code remains and\n\t\t\t * then we'll run in userspace. We can assume there won't be\n\t\t\t * any RCU read-side critical section until the next call to\n\t\t\t * user_exit() or rcu_irq_enter(). Let's remove RCU's dependency\n\t\t\t * on the tick.\n\t\t\t */\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\ttrace_user_enter(0);\n\t\t\t\tvtime_user_enter(current);\n\t\t\t}\n\t\t\trcu_user_enter();\n\t\t}\n\t\t/*\n\t\t * Even if context tracking is disabled on this CPU, because it's outside\n\t\t * the full dynticks mask for example, we still have to keep track of the\n\t\t * context transitions and states to prevent inconsistency on those of\n\t\t * other CPUs.\n\t\t * If a task triggers an exception in userspace, sleep on the exception\n\t\t * handler and then migrate to another CPU, that new CPU must know where\n\t\t * the exception returns by the time we call exception_exit().\n\t\t * This information can only be provided by the previous CPU when it called\n\t\t * exception_enter().\n\t\t * OTOH we can spare the calls to vtime and RCU when context_tracking.active\n\t\t * is false because we know that CPU is not tickless.\n\t\t */\n\t\t__this_cpu_write(context_tracking.state, state);\n\t}\n\tcontext_tracking_recursion_exit();\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_tracking_recursion_exit",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_recursion_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
          "lines": "47-50",
          "snippet": "static void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "context_tracking.state",
            "state"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_user_enter",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_user_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "624-628",
          "snippet": "void rcu_user_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(true);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_user_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_user_enter",
          "args": [
            "current"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_user_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "749-757",
          "snippet": "void vtime_user_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_system(tsk, vtime);\n\tvtime->state = VTIME_USER;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_user_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_system(tsk, vtime);\n\tvtime->state = VTIME_USER;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_user_enter",
          "args": [
            "0"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "context_tracking.active"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "context_tracking.state"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_tracking_recursion_enter",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_recursion_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
          "lines": "33-45",
          "snippet": "static bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!current->mm"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid __context_tracking_enter(enum ctx_state state)\n{\n\t/* Kernel threads aren't supposed to go to userspace */\n\tWARN_ON_ONCE(!current->mm);\n\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif ( __this_cpu_read(context_tracking.state) != state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * At this stage, only low level arch entry code remains and\n\t\t\t * then we'll run in userspace. We can assume there won't be\n\t\t\t * any RCU read-side critical section until the next call to\n\t\t\t * user_exit() or rcu_irq_enter(). Let's remove RCU's dependency\n\t\t\t * on the tick.\n\t\t\t */\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\ttrace_user_enter(0);\n\t\t\t\tvtime_user_enter(current);\n\t\t\t}\n\t\t\trcu_user_enter();\n\t\t}\n\t\t/*\n\t\t * Even if context tracking is disabled on this CPU, because it's outside\n\t\t * the full dynticks mask for example, we still have to keep track of the\n\t\t * context transitions and states to prevent inconsistency on those of\n\t\t * other CPUs.\n\t\t * If a task triggers an exception in userspace, sleep on the exception\n\t\t * handler and then migrate to another CPU, that new CPU must know where\n\t\t * the exception returns by the time we call exception_exit().\n\t\t * This information can only be provided by the previous CPU when it called\n\t\t * exception_enter().\n\t\t * OTOH we can spare the calls to vtime and RCU when context_tracking.active\n\t\t * is false because we know that CPU is not tickless.\n\t\t */\n\t\t__this_cpu_write(context_tracking.state, state);\n\t}\n\tcontext_tracking_recursion_exit();\n}"
  },
  {
    "function_name": "context_tracking_recursion_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
    "lines": "47-50",
    "snippet": "static void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "context_tracking.recursion"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}"
  },
  {
    "function_name": "context_tracking_recursion_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/context_tracking.c",
    "lines": "33-45",
    "snippet": "static bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "context_tracking.recursion"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "(recursion < 1)",
            "\"Invalid context tracking recursion value %d\\n\"",
            "recursion"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "context_tracking.recursion"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}"
  }
]