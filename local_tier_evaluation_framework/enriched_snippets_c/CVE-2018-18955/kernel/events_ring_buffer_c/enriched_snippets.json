[
  {
    "function_name": "perf_mmap_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "873-889",
    "snippet": "struct page *\nperf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\tif (rb->aux_nr_pages) {\n\t\t/* above AUX space */\n\t\tif (pgoff > rb->aux_pgoff + rb->aux_nr_pages)\n\t\t\treturn NULL;\n\n\t\t/* AUX space */\n\t\tif (pgoff >= rb->aux_pgoff) {\n\t\t\tint aux_pgoff = array_index_nospec(pgoff - rb->aux_pgoff, rb->aux_nr_pages);\n\t\t\treturn virt_to_page(rb->aux_pages[aux_pgoff]);\n\t\t}\n\t}\n\n\treturn __perf_mmap_to_page(rb, pgoff);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__perf_mmap_to_page",
          "args": [
            "rb",
            "pgoff"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "__perf_mmap_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "794-802",
          "snippet": "static struct page *\n__perf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\t/* The '>' counts in the user page. */\n\tif (pgoff > data_page_nr(rb))\n\t\treturn NULL;\n\n\treturn vmalloc_to_page((void *)rb->user_page + pgoff * PAGE_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic struct page *\n__perf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\t/* The '>' counts in the user page. */\n\tif (pgoff > data_page_nr(rb))\n\t\treturn NULL;\n\n\treturn vmalloc_to_page((void *)rb->user_page + pgoff * PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "rb->aux_pages[aux_pgoff]"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "pgoff - rb->aux_pgoff",
            "rb->aux_nr_pages"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstruct page *\nperf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\tif (rb->aux_nr_pages) {\n\t\t/* above AUX space */\n\t\tif (pgoff > rb->aux_pgoff + rb->aux_nr_pages)\n\t\t\treturn NULL;\n\n\t\t/* AUX space */\n\t\tif (pgoff >= rb->aux_pgoff) {\n\t\t\tint aux_pgoff = array_index_nospec(pgoff - rb->aux_pgoff, rb->aux_nr_pages);\n\t\t\treturn virt_to_page(rb->aux_pages[aux_pgoff]);\n\t\t}\n\t}\n\n\treturn __perf_mmap_to_page(rb, pgoff);\n}"
  },
  {
    "function_name": "rb_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "834-869",
    "snippet": "struct ring_buffer *rb_alloc(int nr_pages, long watermark, int cpu, int flags)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long size;\n\tvoid *all_buf;\n\n\tsize = sizeof(struct ring_buffer);\n\tsize += sizeof(void *);\n\n\trb = kzalloc(size, GFP_KERNEL);\n\tif (!rb)\n\t\tgoto fail;\n\n\tINIT_WORK(&rb->work, rb_free_work);\n\n\tall_buf = vmalloc_user((nr_pages + 1) * PAGE_SIZE);\n\tif (!all_buf)\n\t\tgoto fail_all_buf;\n\n\trb->user_page = all_buf;\n\trb->data_pages[0] = all_buf + PAGE_SIZE;\n\tif (nr_pages) {\n\t\trb->nr_pages = 1;\n\t\trb->page_order = ilog2(nr_pages);\n\t}\n\n\tring_buffer_init(rb, watermark, flags);\n\n\treturn rb;\n\nfail_all_buf:\n\tkfree(rb);\n\nfail:\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_init",
          "args": [
            "rb",
            "watermark",
            "flags"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "272-299",
          "snippet": "static void\nring_buffer_init(struct ring_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\tatomic_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void\nring_buffer_init(struct ring_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\tatomic_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "nr_pages"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_user",
          "args": [
            "(nr_pages + 1) * PAGE_SIZE"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&rb->work",
            "rb_free_work"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstruct ring_buffer *rb_alloc(int nr_pages, long watermark, int cpu, int flags)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long size;\n\tvoid *all_buf;\n\n\tsize = sizeof(struct ring_buffer);\n\tsize += sizeof(void *);\n\n\trb = kzalloc(size, GFP_KERNEL);\n\tif (!rb)\n\t\tgoto fail;\n\n\tINIT_WORK(&rb->work, rb_free_work);\n\n\tall_buf = vmalloc_user((nr_pages + 1) * PAGE_SIZE);\n\tif (!all_buf)\n\t\tgoto fail_all_buf;\n\n\trb->user_page = all_buf;\n\trb->data_pages[0] = all_buf + PAGE_SIZE;\n\tif (nr_pages) {\n\t\trb->nr_pages = 1;\n\t\trb->page_order = ilog2(nr_pages);\n\t}\n\n\tring_buffer_init(rb, watermark, flags);\n\n\treturn rb;\n\nfail_all_buf:\n\tkfree(rb);\n\nfail:\n\treturn NULL;\n}"
  },
  {
    "function_name": "rb_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "829-832",
    "snippet": "void rb_free(struct ring_buffer *rb)\n{\n\tschedule_work(&rb->work);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&rb->work"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid rb_free(struct ring_buffer *rb)\n{\n\tschedule_work(&rb->work);\n}"
  },
  {
    "function_name": "rb_free_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "811-827",
    "snippet": "static void rb_free_work(struct work_struct *work)\n{\n\tstruct ring_buffer *rb;\n\tvoid *base;\n\tint i, nr;\n\n\trb = container_of(work, struct ring_buffer, work);\n\tnr = data_page_nr(rb);\n\n\tbase = rb->user_page;\n\t/* The '<=' counts in the user page. */\n\tfor (i = 0; i <= nr; i++)\n\t\tperf_mmap_unmark_page(base + (i * PAGE_SIZE));\n\n\tvfree(base);\n\tkfree(rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "base"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_mmap_unmark_page",
          "args": [
            "base + (i * PAGE_SIZE)"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mmap_unmark_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "804-809",
          "snippet": "static void perf_mmap_unmark_page(void *addr)\n{\n\tstruct page *page = vmalloc_to_page(addr);\n\n\tpage->mapping = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_mmap_unmark_page(void *addr)\n{\n\tstruct page *page = vmalloc_to_page(addr);\n\n\tpage->mapping = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_page_nr",
          "args": [
            "rb"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "data_page_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "789-792",
          "snippet": "static int data_page_nr(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic int data_page_nr(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structring_buffer",
            "work"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void rb_free_work(struct work_struct *work)\n{\n\tstruct ring_buffer *rb;\n\tvoid *base;\n\tint i, nr;\n\n\trb = container_of(work, struct ring_buffer, work);\n\tnr = data_page_nr(rb);\n\n\tbase = rb->user_page;\n\t/* The '<=' counts in the user page. */\n\tfor (i = 0; i <= nr; i++)\n\t\tperf_mmap_unmark_page(base + (i * PAGE_SIZE));\n\n\tvfree(base);\n\tkfree(rb);\n}"
  },
  {
    "function_name": "perf_mmap_unmark_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "804-809",
    "snippet": "static void perf_mmap_unmark_page(void *addr)\n{\n\tstruct page *page = vmalloc_to_page(addr);\n\n\tpage->mapping = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "addr"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_mmap_unmark_page(void *addr)\n{\n\tstruct page *page = vmalloc_to_page(addr);\n\n\tpage->mapping = NULL;\n}"
  },
  {
    "function_name": "__perf_mmap_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "794-802",
    "snippet": "static struct page *\n__perf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\t/* The '>' counts in the user page. */\n\tif (pgoff > data_page_nr(rb))\n\t\treturn NULL;\n\n\treturn vmalloc_to_page((void *)rb->user_page + pgoff * PAGE_SIZE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "(void *)rb->user_page + pgoff * PAGE_SIZE"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_page_nr",
          "args": [
            "rb"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "data_page_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "789-792",
          "snippet": "static int data_page_nr(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic int data_page_nr(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic struct page *\n__perf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\t/* The '>' counts in the user page. */\n\tif (pgoff > data_page_nr(rb))\n\t\treturn NULL;\n\n\treturn vmalloc_to_page((void *)rb->user_page + pgoff * PAGE_SIZE);\n}"
  },
  {
    "function_name": "data_page_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "789-792",
    "snippet": "static int data_page_nr(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "rb"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "111-114",
          "snippet": "static inline int page_order(struct ring_buffer *rb)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline int page_order(struct ring_buffer *rb)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic int data_page_nr(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}"
  },
  {
    "function_name": "rb_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "778-786",
    "snippet": "void rb_free(struct ring_buffer *rb)\n{\n\tint i;\n\n\tperf_mmap_free_page((unsigned long)rb->user_page);\n\tfor (i = 0; i < rb->nr_pages; i++)\n\t\tperf_mmap_free_page((unsigned long)rb->data_pages[i]);\n\tkfree(rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_mmap_free_page",
          "args": [
            "(unsigned long)rb->data_pages[i]"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mmap_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "770-776",
          "snippet": "static void perf_mmap_free_page(unsigned long addr)\n{\n\tstruct page *page = virt_to_page((void *)addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_mmap_free_page(unsigned long addr)\n{\n\tstruct page *page = virt_to_page((void *)addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid rb_free(struct ring_buffer *rb)\n{\n\tint i;\n\n\tperf_mmap_free_page((unsigned long)rb->user_page);\n\tfor (i = 0; i < rb->nr_pages; i++)\n\t\tperf_mmap_free_page((unsigned long)rb->data_pages[i]);\n\tkfree(rb);\n}"
  },
  {
    "function_name": "perf_mmap_free_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "770-776",
    "snippet": "static void perf_mmap_free_page(unsigned long addr)\n{\n\tstruct page *page = virt_to_page((void *)addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "(void *)addr"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_mmap_free_page(unsigned long addr)\n{\n\tstruct page *page = virt_to_page((void *)addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}"
  },
  {
    "function_name": "rb_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "728-768",
    "snippet": "struct ring_buffer *rb_alloc(int nr_pages, long watermark, int cpu, int flags)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long size;\n\tint i;\n\n\tsize = sizeof(struct ring_buffer);\n\tsize += nr_pages * sizeof(void *);\n\n\trb = kzalloc(size, GFP_KERNEL);\n\tif (!rb)\n\t\tgoto fail;\n\n\trb->user_page = perf_mmap_alloc_page(cpu);\n\tif (!rb->user_page)\n\t\tgoto fail_user_page;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\trb->data_pages[i] = perf_mmap_alloc_page(cpu);\n\t\tif (!rb->data_pages[i])\n\t\t\tgoto fail_data_pages;\n\t}\n\n\trb->nr_pages = nr_pages;\n\n\tring_buffer_init(rb, watermark, flags);\n\n\treturn rb;\n\nfail_data_pages:\n\tfor (i--; i >= 0; i--)\n\t\tfree_page((unsigned long)rb->data_pages[i]);\n\n\tfree_page((unsigned long)rb->user_page);\n\nfail_user_page:\n\tkfree(rb);\n\nfail:\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)rb->user_page"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mmap_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "770-776",
          "snippet": "static void perf_mmap_free_page(unsigned long addr)\n{\n\tstruct page *page = virt_to_page((void *)addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_mmap_free_page(unsigned long addr)\n{\n\tstruct page *page = virt_to_page((void *)addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_init",
          "args": [
            "rb",
            "watermark",
            "flags"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "272-299",
          "snippet": "static void\nring_buffer_init(struct ring_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\tatomic_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void\nring_buffer_init(struct ring_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\tatomic_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_mmap_alloc_page",
          "args": [
            "cpu"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mmap_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "715-726",
          "snippet": "static void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstruct ring_buffer *rb_alloc(int nr_pages, long watermark, int cpu, int flags)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long size;\n\tint i;\n\n\tsize = sizeof(struct ring_buffer);\n\tsize += nr_pages * sizeof(void *);\n\n\trb = kzalloc(size, GFP_KERNEL);\n\tif (!rb)\n\t\tgoto fail;\n\n\trb->user_page = perf_mmap_alloc_page(cpu);\n\tif (!rb->user_page)\n\t\tgoto fail_user_page;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\trb->data_pages[i] = perf_mmap_alloc_page(cpu);\n\t\tif (!rb->data_pages[i])\n\t\t\tgoto fail_data_pages;\n\t}\n\n\trb->nr_pages = nr_pages;\n\n\tring_buffer_init(rb, watermark, flags);\n\n\treturn rb;\n\nfail_data_pages:\n\tfor (i--; i >= 0; i--)\n\t\tfree_page((unsigned long)rb->data_pages[i]);\n\n\tfree_page((unsigned long)rb->user_page);\n\nfail_user_page:\n\tkfree(rb);\n\nfail:\n\treturn NULL;\n}"
  },
  {
    "function_name": "perf_mmap_alloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "715-726",
    "snippet": "static void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "GFP_KERNEL | __GFP_ZERO",
            "0"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}"
  },
  {
    "function_name": "__perf_mmap_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "703-713",
    "snippet": "static struct page *\n__perf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\tif (pgoff > rb->nr_pages)\n\t\treturn NULL;\n\n\tif (pgoff == 0)\n\t\treturn virt_to_page(rb->user_page);\n\n\treturn virt_to_page(rb->data_pages[pgoff - 1]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "rb->data_pages[pgoff - 1]"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "rb->user_page"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic struct page *\n__perf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\tif (pgoff > rb->nr_pages)\n\t\treturn NULL;\n\n\tif (pgoff == 0)\n\t\treturn virt_to_page(rb->user_page);\n\n\treturn virt_to_page(rb->data_pages[pgoff - 1]);\n}"
  },
  {
    "function_name": "rb_free_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "691-695",
    "snippet": "void rb_free_aux(struct ring_buffer *rb)\n{\n\tif (atomic_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rb_free_aux",
          "args": [
            "rb"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "__rb_free_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "570-595",
          "snippet": "static void __rb_free_aux(struct ring_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void __rb_free_aux(struct ring_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rb->aux_refcount"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid rb_free_aux(struct ring_buffer *rb)\n{\n\tif (atomic_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}"
  },
  {
    "function_name": "rb_alloc_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "597-689",
    "snippet": "int rb_alloc_aux(struct ring_buffer *rb, struct perf_event *event,\n\t\t pgoff_t pgoff, int nr_pages, long watermark, int flags)\n{\n\tbool overwrite = !(flags & RING_BUFFER_WRITABLE);\n\tint node = (event->cpu == -1) ? -1 : cpu_to_node(event->cpu);\n\tint ret = -ENOMEM, max_order = 0;\n\n\tif (!has_aux(event))\n\t\treturn -EOPNOTSUPP;\n\n\tif (event->pmu->capabilities & PERF_PMU_CAP_AUX_NO_SG) {\n\t\t/*\n\t\t * We need to start with the max_order that fits in nr_pages,\n\t\t * not the other way around, hence ilog2() and not get_order.\n\t\t */\n\t\tmax_order = ilog2(nr_pages);\n\n\t\t/*\n\t\t * PMU requests more than one contiguous chunks of memory\n\t\t * for SW double buffering\n\t\t */\n\t\tif ((event->pmu->capabilities & PERF_PMU_CAP_AUX_SW_DOUBLEBUF) &&\n\t\t    !overwrite) {\n\t\t\tif (!max_order)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmax_order--;\n\t\t}\n\t}\n\n\trb->aux_pages = kcalloc_node(nr_pages, sizeof(void *), GFP_KERNEL,\n\t\t\t\t     node);\n\tif (!rb->aux_pages)\n\t\treturn -ENOMEM;\n\n\trb->free_aux = event->pmu->free_aux;\n\tfor (rb->aux_nr_pages = 0; rb->aux_nr_pages < nr_pages;) {\n\t\tstruct page *page;\n\t\tint last, order;\n\n\t\torder = min(max_order, ilog2(nr_pages - rb->aux_nr_pages));\n\t\tpage = rb_alloc_aux_page(node, order);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\tfor (last = rb->aux_nr_pages + (1 << page_private(page));\n\t\t     last > rb->aux_nr_pages; rb->aux_nr_pages++)\n\t\t\trb->aux_pages[rb->aux_nr_pages] = page_address(page++);\n\t}\n\n\t/*\n\t * In overwrite mode, PMUs that don't support SG may not handle more\n\t * than one contiguous allocation, since they rely on PMI to do double\n\t * buffering. In this case, the entire buffer has to be one contiguous\n\t * chunk.\n\t */\n\tif ((event->pmu->capabilities & PERF_PMU_CAP_AUX_NO_SG) &&\n\t    overwrite) {\n\t\tstruct page *page = virt_to_page(rb->aux_pages[0]);\n\n\t\tif (page_private(page) != max_order)\n\t\t\tgoto out;\n\t}\n\n\trb->aux_priv = event->pmu->setup_aux(event->cpu, rb->aux_pages, nr_pages,\n\t\t\t\t\t     overwrite);\n\tif (!rb->aux_priv)\n\t\tgoto out;\n\n\tret = 0;\n\n\t/*\n\t * aux_pages (and pmu driver's private data, aux_priv) will be\n\t * referenced in both producer's and consumer's contexts, thus\n\t * we keep a refcount here to make sure either of the two can\n\t * reference them safely.\n\t */\n\tatomic_set(&rb->aux_refcount, 1);\n\n\trb->aux_overwrite = overwrite;\n\trb->aux_watermark = watermark;\n\n\tif (!rb->aux_watermark && !rb->aux_overwrite)\n\t\trb->aux_watermark = nr_pages << (PAGE_SHIFT - 1);\n\nout:\n\tif (!ret)\n\t\trb->aux_pgoff = pgoff;\n\telse\n\t\t__rb_free_aux(rb);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rb_free_aux",
          "args": [
            "rb"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "__rb_free_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "570-595",
          "snippet": "static void __rb_free_aux(struct ring_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void __rb_free_aux(struct ring_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rb->aux_refcount",
            "1"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event->pmu->setup_aux",
          "args": [
            "event->cpu",
            "rb->aux_pages",
            "nr_pages",
            "overwrite"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "rb->aux_pages[0]"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page++"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_alloc_aux_page",
          "args": [
            "node",
            "order"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "rb_alloc_aux_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "535-559",
          "snippet": "static struct page *rb_alloc_aux_page(int node, int order)\n{\n\tstruct page *page;\n\n\tif (order > MAX_ORDER)\n\t\torder = MAX_ORDER;\n\n\tdo {\n\t\tpage = alloc_pages_node(node, PERF_AUX_GFP, order);\n\t} while (!page && order--);\n\n\tif (page && order) {\n\t\t/*\n\t\t * Communicate the allocation size to the driver:\n\t\t * if we managed to secure a high-order allocation,\n\t\t * set its first page's private to this order;\n\t\t * !PagePrivate(page) means it's just a normal page.\n\t\t */\n\t\tsplit_page(page, order);\n\t\tSetPagePrivate(page);\n\t\tset_page_private(page, order);\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [
            "#define PERF_AUX_GFP\t(GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\n#define PERF_AUX_GFP\t(GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY)\n\nstatic struct page *rb_alloc_aux_page(int node, int order)\n{\n\tstruct page *page;\n\n\tif (order > MAX_ORDER)\n\t\torder = MAX_ORDER;\n\n\tdo {\n\t\tpage = alloc_pages_node(node, PERF_AUX_GFP, order);\n\t} while (!page && order--);\n\n\tif (page && order) {\n\t\t/*\n\t\t * Communicate the allocation size to the driver:\n\t\t * if we managed to secure a high-order allocation,\n\t\t * set its first page's private to this order;\n\t\t * !PagePrivate(page) means it's just a normal page.\n\t\t */\n\t\tsplit_page(page, order);\n\t\tSetPagePrivate(page);\n\t\tset_page_private(page, order);\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max_order",
            "ilog2(nr_pages - rb->aux_nr_pages)"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "nr_pages - rb->aux_nr_pages"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc_node",
          "args": [
            "nr_pages",
            "sizeof(void *)",
            "GFP_KERNEL",
            "node"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "nr_pages"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_aux",
          "args": [
            "event"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "rb_has_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "86-89",
          "snippet": "static inline bool rb_has_aux(struct ring_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline bool rb_has_aux(struct ring_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "event->cpu"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nint rb_alloc_aux(struct ring_buffer *rb, struct perf_event *event,\n\t\t pgoff_t pgoff, int nr_pages, long watermark, int flags)\n{\n\tbool overwrite = !(flags & RING_BUFFER_WRITABLE);\n\tint node = (event->cpu == -1) ? -1 : cpu_to_node(event->cpu);\n\tint ret = -ENOMEM, max_order = 0;\n\n\tif (!has_aux(event))\n\t\treturn -EOPNOTSUPP;\n\n\tif (event->pmu->capabilities & PERF_PMU_CAP_AUX_NO_SG) {\n\t\t/*\n\t\t * We need to start with the max_order that fits in nr_pages,\n\t\t * not the other way around, hence ilog2() and not get_order.\n\t\t */\n\t\tmax_order = ilog2(nr_pages);\n\n\t\t/*\n\t\t * PMU requests more than one contiguous chunks of memory\n\t\t * for SW double buffering\n\t\t */\n\t\tif ((event->pmu->capabilities & PERF_PMU_CAP_AUX_SW_DOUBLEBUF) &&\n\t\t    !overwrite) {\n\t\t\tif (!max_order)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmax_order--;\n\t\t}\n\t}\n\n\trb->aux_pages = kcalloc_node(nr_pages, sizeof(void *), GFP_KERNEL,\n\t\t\t\t     node);\n\tif (!rb->aux_pages)\n\t\treturn -ENOMEM;\n\n\trb->free_aux = event->pmu->free_aux;\n\tfor (rb->aux_nr_pages = 0; rb->aux_nr_pages < nr_pages;) {\n\t\tstruct page *page;\n\t\tint last, order;\n\n\t\torder = min(max_order, ilog2(nr_pages - rb->aux_nr_pages));\n\t\tpage = rb_alloc_aux_page(node, order);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\tfor (last = rb->aux_nr_pages + (1 << page_private(page));\n\t\t     last > rb->aux_nr_pages; rb->aux_nr_pages++)\n\t\t\trb->aux_pages[rb->aux_nr_pages] = page_address(page++);\n\t}\n\n\t/*\n\t * In overwrite mode, PMUs that don't support SG may not handle more\n\t * than one contiguous allocation, since they rely on PMI to do double\n\t * buffering. In this case, the entire buffer has to be one contiguous\n\t * chunk.\n\t */\n\tif ((event->pmu->capabilities & PERF_PMU_CAP_AUX_NO_SG) &&\n\t    overwrite) {\n\t\tstruct page *page = virt_to_page(rb->aux_pages[0]);\n\n\t\tif (page_private(page) != max_order)\n\t\t\tgoto out;\n\t}\n\n\trb->aux_priv = event->pmu->setup_aux(event->cpu, rb->aux_pages, nr_pages,\n\t\t\t\t\t     overwrite);\n\tif (!rb->aux_priv)\n\t\tgoto out;\n\n\tret = 0;\n\n\t/*\n\t * aux_pages (and pmu driver's private data, aux_priv) will be\n\t * referenced in both producer's and consumer's contexts, thus\n\t * we keep a refcount here to make sure either of the two can\n\t * reference them safely.\n\t */\n\tatomic_set(&rb->aux_refcount, 1);\n\n\trb->aux_overwrite = overwrite;\n\trb->aux_watermark = watermark;\n\n\tif (!rb->aux_watermark && !rb->aux_overwrite)\n\t\trb->aux_watermark = nr_pages << (PAGE_SHIFT - 1);\n\nout:\n\tif (!ret)\n\t\trb->aux_pgoff = pgoff;\n\telse\n\t\t__rb_free_aux(rb);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__rb_free_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "570-595",
    "snippet": "static void __rb_free_aux(struct ring_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb->aux_pages"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_free_aux_page",
          "args": [
            "rb",
            "pg"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "rb_free_aux_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "561-568",
          "snippet": "static void rb_free_aux_page(struct ring_buffer *rb, int idx)\n{\n\tstruct page *page = virt_to_page(rb->aux_pages[idx]);\n\n\tClearPagePrivate(page);\n\tpage->mapping = NULL;\n\t__free_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void rb_free_aux_page(struct ring_buffer *rb, int idx)\n{\n\tstruct page *page = virt_to_page(rb->aux_pages[idx]);\n\n\tClearPagePrivate(page);\n\tpage->mapping = NULL;\n\t__free_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb->free_aux",
          "args": [
            "rb->aux_priv"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_atomic()"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void __rb_free_aux(struct ring_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}"
  },
  {
    "function_name": "rb_free_aux_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "561-568",
    "snippet": "static void rb_free_aux_page(struct ring_buffer *rb, int idx)\n{\n\tstruct page *page = virt_to_page(rb->aux_pages[idx]);\n\n\tClearPagePrivate(page);\n\tpage->mapping = NULL;\n\t__free_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "rb->aux_pages[idx]"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void rb_free_aux_page(struct ring_buffer *rb, int idx)\n{\n\tstruct page *page = virt_to_page(rb->aux_pages[idx]);\n\n\tClearPagePrivate(page);\n\tpage->mapping = NULL;\n\t__free_page(page);\n}"
  },
  {
    "function_name": "rb_alloc_aux_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "535-559",
    "snippet": "static struct page *rb_alloc_aux_page(int node, int order)\n{\n\tstruct page *page;\n\n\tif (order > MAX_ORDER)\n\t\torder = MAX_ORDER;\n\n\tdo {\n\t\tpage = alloc_pages_node(node, PERF_AUX_GFP, order);\n\t} while (!page && order--);\n\n\tif (page && order) {\n\t\t/*\n\t\t * Communicate the allocation size to the driver:\n\t\t * if we managed to secure a high-order allocation,\n\t\t * set its first page's private to this order;\n\t\t * !PagePrivate(page) means it's just a normal page.\n\t\t */\n\t\tsplit_page(page, order);\n\t\tSetPagePrivate(page);\n\t\tset_page_private(page, order);\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [
      "#define PERF_AUX_GFP\t(GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "order"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_page",
          "args": [
            "page",
            "order"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "PERF_AUX_GFP",
            "order"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\n#define PERF_AUX_GFP\t(GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY)\n\nstatic struct page *rb_alloc_aux_page(int node, int order)\n{\n\tstruct page *page;\n\n\tif (order > MAX_ORDER)\n\t\torder = MAX_ORDER;\n\n\tdo {\n\t\tpage = alloc_pages_node(node, PERF_AUX_GFP, order);\n\t} while (!page && order--);\n\n\tif (page && order) {\n\t\t/*\n\t\t * Communicate the allocation size to the driver:\n\t\t * if we managed to secure a high-order allocation,\n\t\t * set its first page's private to this order;\n\t\t * !PagePrivate(page) means it's just a normal page.\n\t\t */\n\t\tsplit_page(page, order);\n\t\tSetPagePrivate(page);\n\t\tset_page_private(page, order);\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "perf_get_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "523-530",
    "snippet": "void *perf_get_aux(struct perf_output_handle *handle)\n{\n\t/* this is only valid between perf_aux_output_begin and *_end */\n\tif (!handle->event)\n\t\treturn NULL;\n\n\treturn handle->rb->aux_priv;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid *perf_get_aux(struct perf_output_handle *handle)\n{\n\t/* this is only valid between perf_aux_output_begin and *_end */\n\tif (!handle->event)\n\t\treturn NULL;\n\n\treturn handle->rb->aux_priv;\n}"
  },
  {
    "function_name": "perf_aux_output_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "501-520",
    "snippet": "int perf_aux_output_skip(struct perf_output_handle *handle, unsigned long size)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\n\tif (size > handle->size)\n\t\treturn -ENOSPC;\n\n\trb->aux_head += size;\n\n\trb->user_page->aux_head = rb->aux_head;\n\tif (rb_need_aux_wakeup(rb)) {\n\t\tperf_output_wakeup(handle);\n\t\thandle->wakeup = rb->aux_wakeup + rb->aux_watermark;\n\t}\n\n\thandle->head = rb->aux_head;\n\thandle->size -= size;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_output_wakeup",
          "args": [
            "handle"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "21-27",
          "snippet": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_need_aux_wakeup",
          "args": [
            "rb"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "rb_need_aux_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "417-428",
          "snippet": "static __always_inline bool rb_need_aux_wakeup(struct ring_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline bool rb_need_aux_wakeup(struct ring_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nint perf_aux_output_skip(struct perf_output_handle *handle, unsigned long size)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\n\tif (size > handle->size)\n\t\treturn -ENOSPC;\n\n\trb->aux_head += size;\n\n\trb->user_page->aux_head = rb->aux_head;\n\tif (rb_need_aux_wakeup(rb)) {\n\t\tperf_output_wakeup(handle);\n\t\thandle->wakeup = rb->aux_wakeup + rb->aux_watermark;\n\t}\n\n\thandle->head = rb->aux_head;\n\thandle->size -= size;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "perf_aux_output_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "440-494",
    "snippet": "void perf_aux_output_end(struct perf_output_handle *handle, unsigned long size)\n{\n\tbool wakeup = !!(handle->aux_flags & PERF_AUX_FLAG_TRUNCATED);\n\tstruct ring_buffer *rb = handle->rb;\n\tunsigned long aux_head;\n\n\t/* in overwrite mode, driver provides aux_head via handle */\n\tif (rb->aux_overwrite) {\n\t\thandle->aux_flags |= PERF_AUX_FLAG_OVERWRITE;\n\n\t\taux_head = handle->head;\n\t\trb->aux_head = aux_head;\n\t} else {\n\t\thandle->aux_flags &= ~PERF_AUX_FLAG_OVERWRITE;\n\n\t\taux_head = rb->aux_head;\n\t\trb->aux_head += size;\n\t}\n\n\tif (size || handle->aux_flags) {\n\t\t/*\n\t\t * Only send RECORD_AUX if we have something useful to communicate\n\t\t *\n\t\t * Note: the OVERWRITE records by themselves are not considered\n\t\t * useful, as they don't communicate any *new* information,\n\t\t * aside from the short-lived offset, that becomes history at\n\t\t * the next event sched-in and therefore isn't useful.\n\t\t * The userspace that needs to copy out AUX data in overwrite\n\t\t * mode should know to use user_page::aux_head for the actual\n\t\t * offset. So, from now on we don't output AUX records that\n\t\t * have *only* OVERWRITE flag set.\n\t\t */\n\n\t\tif (handle->aux_flags & ~(u64)PERF_AUX_FLAG_OVERWRITE)\n\t\t\tperf_event_aux_event(handle->event, aux_head, size,\n\t\t\t                     handle->aux_flags);\n\t}\n\n\trb->user_page->aux_head = rb->aux_head;\n\tif (rb_need_aux_wakeup(rb))\n\t\twakeup = true;\n\n\tif (wakeup) {\n\t\tif (handle->aux_flags & PERF_AUX_FLAG_TRUNCATED)\n\t\t\thandle->event->pending_disable = 1;\n\t\tperf_output_wakeup(handle);\n\t}\n\n\thandle->event = NULL;\n\n\tlocal_set(&rb->aux_nest, 0);\n\t/* can't be last */\n\trb_free_aux(rb);\n\tring_buffer_put(rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_put",
          "args": [
            "rb"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "5399-5407",
          "snippet": "void ring_buffer_put(struct ring_buffer *rb)\n{\n\tif (!atomic_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&rb->event_list));\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb);\n\nvoid ring_buffer_put(struct ring_buffer *rb)\n{\n\tif (!atomic_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&rb->event_list));\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_free_aux",
          "args": [
            "rb"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "rb_free_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "691-695",
          "snippet": "void rb_free_aux(struct ring_buffer *rb)\n{\n\tif (atomic_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid rb_free_aux(struct ring_buffer *rb)\n{\n\tif (atomic_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_set",
          "args": [
            "&rb->aux_nest",
            "0"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_output_wakeup",
          "args": [
            "handle"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "21-27",
          "snippet": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_need_aux_wakeup",
          "args": [
            "rb"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "rb_need_aux_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "417-428",
          "snippet": "static __always_inline bool rb_need_aux_wakeup(struct ring_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline bool rb_need_aux_wakeup(struct ring_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_aux_event",
          "args": [
            "handle->event",
            "aux_head",
            "size",
            "handle->aux_flags"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_aux_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "7456-7488",
          "snippet": "void perf_event_aux_event(struct perf_event *event, unsigned long head,\n\t\t\t  unsigned long size, u64 flags)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\toffset;\n\t\tu64\t\t\t\tsize;\n\t\tu64\t\t\t\tflags;\n\t} rec = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_AUX,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(rec),\n\t\t},\n\t\t.offset\t\t= head,\n\t\t.size\t\t= size,\n\t\t.flags\t\t= flags,\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t       struct list_head *head);",
            "static void perf_pmu_output_stop(struct perf_event *event);",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t       struct list_head *head);\nstatic void perf_pmu_output_stop(struct perf_event *event);\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_aux_event(struct perf_event *event, unsigned long head,\n\t\t\t  unsigned long size, u64 flags)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\toffset;\n\t\tu64\t\t\t\tsize;\n\t\tu64\t\t\t\tflags;\n\t} rec = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_AUX,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(rec),\n\t\t},\n\t\t.offset\t\t= head,\n\t\t.size\t\t= size,\n\t\t.flags\t\t= flags,\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid perf_aux_output_end(struct perf_output_handle *handle, unsigned long size)\n{\n\tbool wakeup = !!(handle->aux_flags & PERF_AUX_FLAG_TRUNCATED);\n\tstruct ring_buffer *rb = handle->rb;\n\tunsigned long aux_head;\n\n\t/* in overwrite mode, driver provides aux_head via handle */\n\tif (rb->aux_overwrite) {\n\t\thandle->aux_flags |= PERF_AUX_FLAG_OVERWRITE;\n\n\t\taux_head = handle->head;\n\t\trb->aux_head = aux_head;\n\t} else {\n\t\thandle->aux_flags &= ~PERF_AUX_FLAG_OVERWRITE;\n\n\t\taux_head = rb->aux_head;\n\t\trb->aux_head += size;\n\t}\n\n\tif (size || handle->aux_flags) {\n\t\t/*\n\t\t * Only send RECORD_AUX if we have something useful to communicate\n\t\t *\n\t\t * Note: the OVERWRITE records by themselves are not considered\n\t\t * useful, as they don't communicate any *new* information,\n\t\t * aside from the short-lived offset, that becomes history at\n\t\t * the next event sched-in and therefore isn't useful.\n\t\t * The userspace that needs to copy out AUX data in overwrite\n\t\t * mode should know to use user_page::aux_head for the actual\n\t\t * offset. So, from now on we don't output AUX records that\n\t\t * have *only* OVERWRITE flag set.\n\t\t */\n\n\t\tif (handle->aux_flags & ~(u64)PERF_AUX_FLAG_OVERWRITE)\n\t\t\tperf_event_aux_event(handle->event, aux_head, size,\n\t\t\t                     handle->aux_flags);\n\t}\n\n\trb->user_page->aux_head = rb->aux_head;\n\tif (rb_need_aux_wakeup(rb))\n\t\twakeup = true;\n\n\tif (wakeup) {\n\t\tif (handle->aux_flags & PERF_AUX_FLAG_TRUNCATED)\n\t\t\thandle->event->pending_disable = 1;\n\t\tperf_output_wakeup(handle);\n\t}\n\n\thandle->event = NULL;\n\n\tlocal_set(&rb->aux_nest, 0);\n\t/* can't be last */\n\trb_free_aux(rb);\n\tring_buffer_put(rb);\n}"
  },
  {
    "function_name": "rb_need_aux_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "417-428",
    "snippet": "static __always_inline bool rb_need_aux_wakeup(struct ring_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "rb->aux_head",
            "rb->aux_watermark"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline bool rb_need_aux_wakeup(struct ring_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "perf_aux_output_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "328-414",
    "snippet": "void *perf_aux_output_begin(struct perf_output_handle *handle,\n\t\t\t    struct perf_event *event)\n{\n\tstruct perf_event *output_event = event;\n\tunsigned long aux_head, aux_tail;\n\tstruct ring_buffer *rb;\n\n\tif (output_event->parent)\n\t\toutput_event = output_event->parent;\n\n\t/*\n\t * Since this will typically be open across pmu::add/pmu::del, we\n\t * grab ring_buffer's refcount instead of holding rcu read lock\n\t * to make sure it doesn't disappear under us.\n\t */\n\trb = ring_buffer_get(output_event);\n\tif (!rb)\n\t\treturn NULL;\n\n\tif (!rb_has_aux(rb))\n\t\tgoto err;\n\n\t/*\n\t * If aux_mmap_count is zero, the aux buffer is in perf_mmap_close(),\n\t * about to get freed, so we leave immediately.\n\t *\n\t * Checking rb::aux_mmap_count and rb::refcount has to be done in\n\t * the same order, see perf_mmap_close. Otherwise we end up freeing\n\t * aux pages in this path, which is a bug, because in_atomic().\n\t */\n\tif (!atomic_read(&rb->aux_mmap_count))\n\t\tgoto err;\n\n\tif (!atomic_inc_not_zero(&rb->aux_refcount))\n\t\tgoto err;\n\n\t/*\n\t * Nesting is not supported for AUX area, make sure nested\n\t * writers are caught early\n\t */\n\tif (WARN_ON_ONCE(local_xchg(&rb->aux_nest, 1)))\n\t\tgoto err_put;\n\n\taux_head = rb->aux_head;\n\n\thandle->rb = rb;\n\thandle->event = event;\n\thandle->head = aux_head;\n\thandle->size = 0;\n\thandle->aux_flags = 0;\n\n\t/*\n\t * In overwrite mode, AUX data stores do not depend on aux_tail,\n\t * therefore (A) control dependency barrier does not exist. The\n\t * (B) <-> (C) ordering is still observed by the pmu driver.\n\t */\n\tif (!rb->aux_overwrite) {\n\t\taux_tail = READ_ONCE(rb->user_page->aux_tail);\n\t\thandle->wakeup = rb->aux_wakeup + rb->aux_watermark;\n\t\tif (aux_head - aux_tail < perf_aux_size(rb))\n\t\t\thandle->size = CIRC_SPACE(aux_head, aux_tail, perf_aux_size(rb));\n\n\t\t/*\n\t\t * handle->size computation depends on aux_tail load; this forms a\n\t\t * control dependency barrier separating aux_tail load from aux data\n\t\t * store that will be enabled on successful return\n\t\t */\n\t\tif (!handle->size) { /* A, matches D */\n\t\t\tevent->pending_disable = 1;\n\t\t\tperf_output_wakeup(handle);\n\t\t\tlocal_set(&rb->aux_nest, 0);\n\t\t\tgoto err_put;\n\t\t}\n\t}\n\n\treturn handle->rb->aux_priv;\n\nerr_put:\n\t/* can't be last */\n\trb_free_aux(rb);\n\nerr:\n\tring_buffer_put(rb);\n\thandle->event = NULL;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_put",
          "args": [
            "rb"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "5399-5407",
          "snippet": "void ring_buffer_put(struct ring_buffer *rb)\n{\n\tif (!atomic_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&rb->event_list));\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb);\n\nvoid ring_buffer_put(struct ring_buffer *rb)\n{\n\tif (!atomic_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&rb->event_list));\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_free_aux",
          "args": [
            "rb"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "rb_free_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "691-695",
          "snippet": "void rb_free_aux(struct ring_buffer *rb)\n{\n\tif (atomic_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid rb_free_aux(struct ring_buffer *rb)\n{\n\tif (atomic_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_set",
          "args": [
            "&rb->aux_nest",
            "0"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_output_wakeup",
          "args": [
            "handle"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "21-27",
          "snippet": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIRC_SPACE",
          "args": [
            "aux_head",
            "aux_tail",
            "perf_aux_size(rb)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_aux_size",
          "args": [
            "rb"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "perf_aux_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "122-125",
          "snippet": "static inline unsigned long perf_aux_size(struct ring_buffer *rb)\n{\n\treturn rb->aux_nr_pages << PAGE_SHIFT;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long perf_aux_size(struct ring_buffer *rb)\n{\n\treturn rb->aux_nr_pages << PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rb->user_page->aux_tail"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "local_xchg(&rb->aux_nest, 1)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_xchg",
          "args": [
            "&rb->aux_nest",
            "1"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&rb->aux_refcount"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rb->aux_mmap_count"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_has_aux",
          "args": [
            "rb"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "rb_has_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "86-89",
          "snippet": "static inline bool rb_has_aux(struct ring_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline bool rb_has_aux(struct ring_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_get",
          "args": [
            "output_event"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "5384-5397",
          "snippet": "struct ring_buffer *ring_buffer_get(struct perf_event *event)\n{\n\tstruct ring_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (rb) {\n\t\tif (!atomic_inc_not_zero(&rb->refcount))\n\t\t\trb = NULL;\n\t}\n\trcu_read_unlock();\n\n\treturn rb;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstruct ring_buffer *ring_buffer_get(struct perf_event *event)\n{\n\tstruct ring_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (rb) {\n\t\tif (!atomic_inc_not_zero(&rb->refcount))\n\t\t\trb = NULL;\n\t}\n\trcu_read_unlock();\n\n\treturn rb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid *perf_aux_output_begin(struct perf_output_handle *handle,\n\t\t\t    struct perf_event *event)\n{\n\tstruct perf_event *output_event = event;\n\tunsigned long aux_head, aux_tail;\n\tstruct ring_buffer *rb;\n\n\tif (output_event->parent)\n\t\toutput_event = output_event->parent;\n\n\t/*\n\t * Since this will typically be open across pmu::add/pmu::del, we\n\t * grab ring_buffer's refcount instead of holding rcu read lock\n\t * to make sure it doesn't disappear under us.\n\t */\n\trb = ring_buffer_get(output_event);\n\tif (!rb)\n\t\treturn NULL;\n\n\tif (!rb_has_aux(rb))\n\t\tgoto err;\n\n\t/*\n\t * If aux_mmap_count is zero, the aux buffer is in perf_mmap_close(),\n\t * about to get freed, so we leave immediately.\n\t *\n\t * Checking rb::aux_mmap_count and rb::refcount has to be done in\n\t * the same order, see perf_mmap_close. Otherwise we end up freeing\n\t * aux pages in this path, which is a bug, because in_atomic().\n\t */\n\tif (!atomic_read(&rb->aux_mmap_count))\n\t\tgoto err;\n\n\tif (!atomic_inc_not_zero(&rb->aux_refcount))\n\t\tgoto err;\n\n\t/*\n\t * Nesting is not supported for AUX area, make sure nested\n\t * writers are caught early\n\t */\n\tif (WARN_ON_ONCE(local_xchg(&rb->aux_nest, 1)))\n\t\tgoto err_put;\n\n\taux_head = rb->aux_head;\n\n\thandle->rb = rb;\n\thandle->event = event;\n\thandle->head = aux_head;\n\thandle->size = 0;\n\thandle->aux_flags = 0;\n\n\t/*\n\t * In overwrite mode, AUX data stores do not depend on aux_tail,\n\t * therefore (A) control dependency barrier does not exist. The\n\t * (B) <-> (C) ordering is still observed by the pmu driver.\n\t */\n\tif (!rb->aux_overwrite) {\n\t\taux_tail = READ_ONCE(rb->user_page->aux_tail);\n\t\thandle->wakeup = rb->aux_wakeup + rb->aux_watermark;\n\t\tif (aux_head - aux_tail < perf_aux_size(rb))\n\t\t\thandle->size = CIRC_SPACE(aux_head, aux_tail, perf_aux_size(rb));\n\n\t\t/*\n\t\t * handle->size computation depends on aux_tail load; this forms a\n\t\t * control dependency barrier separating aux_tail load from aux data\n\t\t * store that will be enabled on successful return\n\t\t */\n\t\tif (!handle->size) { /* A, matches D */\n\t\t\tevent->pending_disable = 1;\n\t\t\tperf_output_wakeup(handle);\n\t\t\tlocal_set(&rb->aux_nest, 0);\n\t\t\tgoto err_put;\n\t\t}\n\t}\n\n\treturn handle->rb->aux_priv;\n\nerr_put:\n\t/* can't be last */\n\trb_free_aux(rb);\n\nerr:\n\tring_buffer_put(rb);\n\thandle->event = NULL;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "perf_aux_output_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "301-311",
    "snippet": "void perf_aux_output_flag(struct perf_output_handle *handle, u64 flags)\n{\n\t/*\n\t * OVERWRITE is determined by perf_aux_output_end() and can't\n\t * be passed in directly.\n\t */\n\tif (WARN_ON_ONCE(flags & PERF_AUX_FLAG_OVERWRITE))\n\t\treturn;\n\n\thandle->aux_flags |= flags;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "flags & PERF_AUX_FLAG_OVERWRITE"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid perf_aux_output_flag(struct perf_output_handle *handle, u64 flags)\n{\n\t/*\n\t * OVERWRITE is determined by perf_aux_output_end() and can't\n\t * be passed in directly.\n\t */\n\tif (WARN_ON_ONCE(flags & PERF_AUX_FLAG_OVERWRITE))\n\t\treturn;\n\n\thandle->aux_flags |= flags;\n}"
  },
  {
    "function_name": "ring_buffer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "272-299",
    "snippet": "static void\nring_buffer_init(struct ring_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\tatomic_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&rb->event_lock"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rb->event_list"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rb->refcount",
            "1"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max_size",
            "watermark"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "perf_data_size",
          "args": [
            "rb"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "perf_data_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "117-120",
          "snippet": "static inline unsigned long perf_data_size(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long perf_data_size(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void\nring_buffer_init(struct ring_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\tatomic_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}"
  },
  {
    "function_name": "perf_output_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "266-270",
    "snippet": "void perf_output_end(struct perf_output_handle *handle)\n{\n\tperf_output_put_handle(handle);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_output_put_handle",
          "args": [
            "handle"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_put_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "46-104",
          "snippet": "static void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\tunsigned long head;\n\nagain:\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here, which means we can miss a head update.\n\t */\n\n\tif (!local_dec_and_test(&rb->nest))\n\t\tgoto out;\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\trb->user_page->data_head = head;\n\n\t/*\n\t * Now check if we missed an update -- rely on previous implied\n\t * compiler barriers to force a re-read.\n\t */\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tlocal_inc(&rb->nest);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\tunsigned long head;\n\nagain:\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here, which means we can miss a head update.\n\t */\n\n\tif (!local_dec_and_test(&rb->nest))\n\t\tgoto out;\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\trb->user_page->data_head = head;\n\n\t/*\n\t * Now check if we missed an update -- rely on previous implied\n\t * compiler barriers to force a re-read.\n\t */\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tlocal_inc(&rb->nest);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid perf_output_end(struct perf_output_handle *handle)\n{\n\tperf_output_put_handle(handle);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "perf_output_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "260-264",
    "snippet": "unsigned int perf_output_skip(struct perf_output_handle *handle,\n\t\t\t      unsigned int len)\n{\n\treturn __output_skip(handle, NULL, len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__output_skip",
          "args": [
            "handle",
            "NULL",
            "len"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nunsigned int perf_output_skip(struct perf_output_handle *handle,\n\t\t\t      unsigned int len)\n{\n\treturn __output_skip(handle, NULL, len);\n}"
  },
  {
    "function_name": "perf_output_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "254-258",
    "snippet": "unsigned int perf_output_copy(struct perf_output_handle *handle,\n\t\t      const void *buf, unsigned int len)\n{\n\treturn __output_copy(handle, buf, len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__output_copy",
          "args": [
            "handle",
            "buf",
            "len"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nunsigned int perf_output_copy(struct perf_output_handle *handle,\n\t\t      const void *buf, unsigned int len)\n{\n\treturn __output_copy(handle, buf, len);\n}"
  },
  {
    "function_name": "perf_output_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "246-252",
    "snippet": "int perf_output_begin(struct perf_output_handle *handle,\n\t\t      struct perf_event *event, unsigned int size)\n{\n\n\treturn __perf_output_begin(handle, event, size,\n\t\t\t\t   unlikely(is_write_backward(event)));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__perf_output_begin",
          "args": [
            "handle",
            "event",
            "size",
            "unlikely(is_write_backward(event))"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__perf_output_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "117-232",
          "snippet": "static __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tstruct perf_sample_data sample_data;\n\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\tperf_event_header__init_id(&lost_event.header,\n\t\t\t\t\t   &sample_data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, &sample_data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tstruct perf_sample_data sample_data;\n\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\tperf_event_header__init_id(&lost_event.header,\n\t\t\t\t\t   &sample_data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, &sample_data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_write_backward(event)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_backward",
          "args": [
            "event"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nint perf_output_begin(struct perf_output_handle *handle,\n\t\t      struct perf_event *event, unsigned int size)\n{\n\n\treturn __perf_output_begin(handle, event, size,\n\t\t\t\t   unlikely(is_write_backward(event)));\n}"
  },
  {
    "function_name": "perf_output_begin_backward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "240-244",
    "snippet": "int perf_output_begin_backward(struct perf_output_handle *handle,\n\t\t\t       struct perf_event *event, unsigned int size)\n{\n\treturn __perf_output_begin(handle, event, size, true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__perf_output_begin",
          "args": [
            "handle",
            "event",
            "size",
            "true"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "__perf_output_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "117-232",
          "snippet": "static __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tstruct perf_sample_data sample_data;\n\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\tperf_event_header__init_id(&lost_event.header,\n\t\t\t\t\t   &sample_data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, &sample_data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tstruct perf_sample_data sample_data;\n\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\tperf_event_header__init_id(&lost_event.header,\n\t\t\t\t\t   &sample_data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, &sample_data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nint perf_output_begin_backward(struct perf_output_handle *handle,\n\t\t\t       struct perf_event *event, unsigned int size)\n{\n\treturn __perf_output_begin(handle, event, size, true);\n}"
  },
  {
    "function_name": "perf_output_begin_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "234-238",
    "snippet": "int perf_output_begin_forward(struct perf_output_handle *handle,\n\t\t\t     struct perf_event *event, unsigned int size)\n{\n\treturn __perf_output_begin(handle, event, size, false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__perf_output_begin",
          "args": [
            "handle",
            "event",
            "size",
            "false"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "__perf_output_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "117-232",
          "snippet": "static __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tstruct perf_sample_data sample_data;\n\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\tperf_event_header__init_id(&lost_event.header,\n\t\t\t\t\t   &sample_data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, &sample_data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tstruct perf_sample_data sample_data;\n\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\tperf_event_header__init_id(&lost_event.header,\n\t\t\t\t\t   &sample_data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, &sample_data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nint perf_output_begin_forward(struct perf_output_handle *handle,\n\t\t\t     struct perf_event *event, unsigned int size)\n{\n\treturn __perf_output_begin(handle, event, size, false);\n}"
  },
  {
    "function_name": "__perf_output_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "117-232",
    "snippet": "static __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tstruct perf_sample_data sample_data;\n\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\tperf_event_header__init_id(&lost_event.header,\n\t\t\t\t\t   &sample_data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, &sample_data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_output_put_handle",
          "args": [
            "handle"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_put_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "46-104",
          "snippet": "static void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\tunsigned long head;\n\nagain:\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here, which means we can miss a head update.\n\t */\n\n\tif (!local_dec_and_test(&rb->nest))\n\t\tgoto out;\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\trb->user_page->data_head = head;\n\n\t/*\n\t * Now check if we missed an update -- rely on previous implied\n\t * compiler barriers to force a re-read.\n\t */\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tlocal_inc(&rb->nest);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\tunsigned long head;\n\nagain:\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here, which means we can miss a head update.\n\t */\n\n\tif (!local_dec_and_test(&rb->nest))\n\t\tgoto out;\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\trb->user_page->data_head = head;\n\n\t/*\n\t * Now check if we missed an update -- rely on previous implied\n\t * compiler barriers to force a re-read.\n\t */\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tlocal_inc(&rb->nest);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_inc",
          "args": [
            "&rb->lost"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event__output_id_sample",
          "args": [
            "event",
            "handle",
            "&sample_data"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event__output_id_sample",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "6045-6051",
          "snippet": "void perf_event__output_id_sample(struct perf_event *event,\n\t\t\t\t  struct perf_output_handle *handle,\n\t\t\t\t  struct perf_sample_data *sample)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event__output_id_sample(handle, sample);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event__output_id_sample(struct perf_event *event,\n\t\t\t\t  struct perf_output_handle *handle,\n\t\t\t\t  struct perf_sample_data *sample)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event__output_id_sample(handle, sample);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_output_put",
          "args": [
            "handle",
            "lost_event"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_header__init_id",
          "args": [
            "&lost_event.header",
            "&sample_data",
            "event"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_header__init_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "6013-6019",
          "snippet": "void perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct perf_event *event)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event_header__init_id(header, data, event);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct perf_event *event)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event_header__init_id(header, data, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_xchg",
          "args": [
            "&rb->lost",
            "0"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "have_lost"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "rb"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "111-114",
          "snippet": "static inline int page_order(struct ring_buffer *rb)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline int page_order(struct ring_buffer *rb)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_add",
          "args": [
            "rb->watermark",
            "&rb->wakeup"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "head - local_read(&rb->wakeup) > rb->watermark"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->wakeup"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-head"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_cmpxchg",
          "args": [
            "&rb->head",
            "offset",
            "head"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_has_space",
          "args": [
            "head",
            "tail",
            "perf_data_size(rb)",
            "size",
            "backward"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_has_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "106-115",
          "snippet": "static __always_inline bool\nring_buffer_has_space(unsigned long head, unsigned long tail,\n\t\t      unsigned long data_size, unsigned int size,\n\t\t      bool backward)\n{\n\tif (!backward)\n\t\treturn CIRC_SPACE(head, tail, data_size) >= size;\n\telse\n\t\treturn CIRC_SPACE(tail, head, data_size) >= size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline bool\nring_buffer_has_space(unsigned long head, unsigned long tail,\n\t\t      unsigned long data_size, unsigned int size,\n\t\t      bool backward)\n{\n\tif (!backward)\n\t\treturn CIRC_SPACE(head, tail, data_size) >= size;\n\telse\n\t\treturn CIRC_SPACE(tail, head, data_size) >= size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_data_size",
          "args": [
            "rb"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "perf_data_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "117-120",
          "snippet": "static inline unsigned long perf_data_size(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long perf_data_size(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->head"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rb->user_page->data_tail"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_output_get_handle",
          "args": [
            "handle"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_get_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "37-44",
          "snippet": "static void perf_output_get_handle(struct perf_output_handle *handle)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\n\tpreempt_disable();\n\tlocal_inc(&rb->nest);\n\thandle->wakeup = local_read(&rb->wakeup);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_get_handle(struct perf_output_handle *handle)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\n\tpreempt_disable();\n\tlocal_inc(&rb->nest);\n\thandle->wakeup = local_read(&rb->wakeup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "have_lost"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->lost"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_inc",
          "args": [
            "&rb->lost"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rb->paused"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rb"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "event->rb"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tstruct perf_sample_data sample_data;\n\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\tperf_event_header__init_id(&lost_event.header,\n\t\t\t\t\t   &sample_data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, &sample_data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "ring_buffer_has_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "106-115",
    "snippet": "static __always_inline bool\nring_buffer_has_space(unsigned long head, unsigned long tail,\n\t\t      unsigned long data_size, unsigned int size,\n\t\t      bool backward)\n{\n\tif (!backward)\n\t\treturn CIRC_SPACE(head, tail, data_size) >= size;\n\telse\n\t\treturn CIRC_SPACE(tail, head, data_size) >= size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIRC_SPACE",
          "args": [
            "tail",
            "head",
            "data_size"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIRC_SPACE",
          "args": [
            "head",
            "tail",
            "data_size"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline bool\nring_buffer_has_space(unsigned long head, unsigned long tail,\n\t\t      unsigned long data_size, unsigned int size,\n\t\t      bool backward)\n{\n\tif (!backward)\n\t\treturn CIRC_SPACE(head, tail, data_size) >= size;\n\telse\n\t\treturn CIRC_SPACE(tail, head, data_size) >= size;\n}"
  },
  {
    "function_name": "perf_output_put_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "46-104",
    "snippet": "static void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\tunsigned long head;\n\nagain:\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here, which means we can miss a head update.\n\t */\n\n\tif (!local_dec_and_test(&rb->nest))\n\t\tgoto out;\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\trb->user_page->data_head = head;\n\n\t/*\n\t * Now check if we missed an update -- rely on previous implied\n\t * compiler barriers to force a re-read.\n\t */\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tlocal_inc(&rb->nest);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_output_wakeup",
          "args": [
            "handle"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
          "lines": "21-27",
          "snippet": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->wakeup"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_inc",
          "args": [
            "&rb->nest"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "head != local_read(&rb->head)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->head"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_dec_and_test",
          "args": [
            "&rb->nest"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->head"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\tunsigned long head;\n\nagain:\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here, which means we can miss a head update.\n\t */\n\n\tif (!local_dec_and_test(&rb->nest))\n\t\tgoto out;\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\trb->user_page->data_head = head;\n\n\t/*\n\t * Now check if we missed an update -- rely on previous implied\n\t * compiler barriers to force a re-read.\n\t */\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tlocal_inc(&rb->nest);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "perf_output_get_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "37-44",
    "snippet": "static void perf_output_get_handle(struct perf_output_handle *handle)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\n\tpreempt_disable();\n\tlocal_inc(&rb->nest);\n\thandle->wakeup = local_read(&rb->wakeup);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->wakeup"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_inc",
          "args": [
            "&rb->nest"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_get_handle(struct perf_output_handle *handle)\n{\n\tstruct ring_buffer *rb = handle->rb;\n\n\tpreempt_disable();\n\tlocal_inc(&rb->nest);\n\thandle->wakeup = local_read(&rb->wakeup);\n}"
  },
  {
    "function_name": "perf_output_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/ring_buffer.c",
    "lines": "21-27",
    "snippet": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&handle->event->pending"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "90-112",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&handle->rb->poll",
            "EPOLLIN"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}"
  }
]