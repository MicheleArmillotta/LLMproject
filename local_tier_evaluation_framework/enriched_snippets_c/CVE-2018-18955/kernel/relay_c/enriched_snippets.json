[
  {
    "function_name": "relay_file_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "1284-1320",
    "snippet": "static ssize_t relay_file_splice_read(struct file *in,\n\t\t\t\t      loff_t *ppos,\n\t\t\t\t      struct pipe_inode_info *pipe,\n\t\t\t\t      size_t len,\n\t\t\t\t      unsigned int flags)\n{\n\tssize_t spliced;\n\tint ret;\n\tint nonpad_ret = 0;\n\n\tret = 0;\n\tspliced = 0;\n\n\twhile (len && !spliced) {\n\t\tret = subbuf_splice_actor(in, ppos, pipe, len, flags, &nonpad_ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\t*ppos += ret;\n\t\tif (ret > len)\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen -= ret;\n\t\tspliced += nonpad_ret;\n\t\tnonpad_ret = 0;\n\t}\n\n\tif (spliced)\n\t\treturn spliced;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "subbuf_splice_actor",
          "args": [
            "in",
            "ppos",
            "pipe",
            "len",
            "flags",
            "&nonpad_ret"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "subbuf_splice_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "1192-1282",
          "snippet": "static ssize_t subbuf_splice_actor(struct file *in,\n\t\t\t       loff_t *ppos,\n\t\t\t       struct pipe_inode_info *pipe,\n\t\t\t       size_t len,\n\t\t\t       unsigned int flags,\n\t\t\t       int *nonpad_ret)\n{\n\tunsigned int pidx, poff, total_len, subbuf_pages, nr_pages;\n\tstruct rchan_buf *rbuf = in->private_data;\n\tunsigned int subbuf_size = rbuf->chan->subbuf_size;\n\tuint64_t pos = (uint64_t) *ppos;\n\tuint32_t alloc_size = (uint32_t) rbuf->chan->alloc_size;\n\tsize_t read_start = (size_t) do_div(pos, alloc_size);\n\tsize_t read_subbuf = read_start / subbuf_size;\n\tsize_t padding = rbuf->padding[read_subbuf];\n\tsize_t nonpad_end = read_subbuf * subbuf_size + subbuf_size - padding;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.nr_pages = 0,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.partial = partial,\n\t\t.ops = &relay_pipe_buf_ops,\n\t\t.spd_release = relay_page_release,\n\t};\n\tssize_t ret;\n\n\tif (rbuf->subbufs_produced == rbuf->subbufs_consumed)\n\t\treturn 0;\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Adjust read len, if longer than what is available\n\t */\n\tif (len > (subbuf_size - read_start % subbuf_size))\n\t\tlen = subbuf_size - read_start % subbuf_size;\n\n\tsubbuf_pages = rbuf->chan->alloc_size >> PAGE_SHIFT;\n\tpidx = (read_start / PAGE_SIZE) % subbuf_pages;\n\tpoff = read_start & ~PAGE_MASK;\n\tnr_pages = min_t(unsigned int, subbuf_pages, spd.nr_pages_max);\n\n\tfor (total_len = 0; spd.nr_pages < nr_pages; spd.nr_pages++) {\n\t\tunsigned int this_len, this_end, private;\n\t\tunsigned int cur_pos = read_start + total_len;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tthis_len = min_t(unsigned long, len, PAGE_SIZE - poff);\n\t\tprivate = this_len;\n\n\t\tspd.pages[spd.nr_pages] = rbuf->page_array[pidx];\n\t\tspd.partial[spd.nr_pages].offset = poff;\n\n\t\tthis_end = cur_pos + this_len;\n\t\tif (this_end >= nonpad_end) {\n\t\t\tthis_len = nonpad_end - cur_pos;\n\t\t\tprivate = this_len + padding;\n\t\t}\n\t\tspd.partial[spd.nr_pages].len = this_len;\n\t\tspd.partial[spd.nr_pages].private = private;\n\n\t\tlen -= this_len;\n\t\ttotal_len += this_len;\n\t\tpoff = 0;\n\t\tpidx = (pidx + 1) % subbuf_pages;\n\n\t\tif (this_end >= nonpad_end) {\n\t\t\tspd.nr_pages++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (!spd.nr_pages)\n\t\tgoto out;\n\n\tret = *nonpad_ret = splice_to_pipe(pipe, &spd);\n\tif (ret < 0 || ret < total_len)\n\t\tgoto out;\n\n        if (read_start + ret == nonpad_end)\n                ret += padding;\n\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct pipe_buf_operations relay_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = relay_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic const struct pipe_buf_operations relay_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = relay_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\n\nstatic ssize_t subbuf_splice_actor(struct file *in,\n\t\t\t       loff_t *ppos,\n\t\t\t       struct pipe_inode_info *pipe,\n\t\t\t       size_t len,\n\t\t\t       unsigned int flags,\n\t\t\t       int *nonpad_ret)\n{\n\tunsigned int pidx, poff, total_len, subbuf_pages, nr_pages;\n\tstruct rchan_buf *rbuf = in->private_data;\n\tunsigned int subbuf_size = rbuf->chan->subbuf_size;\n\tuint64_t pos = (uint64_t) *ppos;\n\tuint32_t alloc_size = (uint32_t) rbuf->chan->alloc_size;\n\tsize_t read_start = (size_t) do_div(pos, alloc_size);\n\tsize_t read_subbuf = read_start / subbuf_size;\n\tsize_t padding = rbuf->padding[read_subbuf];\n\tsize_t nonpad_end = read_subbuf * subbuf_size + subbuf_size - padding;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.nr_pages = 0,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.partial = partial,\n\t\t.ops = &relay_pipe_buf_ops,\n\t\t.spd_release = relay_page_release,\n\t};\n\tssize_t ret;\n\n\tif (rbuf->subbufs_produced == rbuf->subbufs_consumed)\n\t\treturn 0;\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Adjust read len, if longer than what is available\n\t */\n\tif (len > (subbuf_size - read_start % subbuf_size))\n\t\tlen = subbuf_size - read_start % subbuf_size;\n\n\tsubbuf_pages = rbuf->chan->alloc_size >> PAGE_SHIFT;\n\tpidx = (read_start / PAGE_SIZE) % subbuf_pages;\n\tpoff = read_start & ~PAGE_MASK;\n\tnr_pages = min_t(unsigned int, subbuf_pages, spd.nr_pages_max);\n\n\tfor (total_len = 0; spd.nr_pages < nr_pages; spd.nr_pages++) {\n\t\tunsigned int this_len, this_end, private;\n\t\tunsigned int cur_pos = read_start + total_len;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tthis_len = min_t(unsigned long, len, PAGE_SIZE - poff);\n\t\tprivate = this_len;\n\n\t\tspd.pages[spd.nr_pages] = rbuf->page_array[pidx];\n\t\tspd.partial[spd.nr_pages].offset = poff;\n\n\t\tthis_end = cur_pos + this_len;\n\t\tif (this_end >= nonpad_end) {\n\t\t\tthis_len = nonpad_end - cur_pos;\n\t\t\tprivate = this_len + padding;\n\t\t}\n\t\tspd.partial[spd.nr_pages].len = this_len;\n\t\tspd.partial[spd.nr_pages].private = private;\n\n\t\tlen -= this_len;\n\t\ttotal_len += this_len;\n\t\tpoff = 0;\n\t\tpidx = (pidx + 1) % subbuf_pages;\n\n\t\tif (this_end >= nonpad_end) {\n\t\t\tspd.nr_pages++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (!spd.nr_pages)\n\t\tgoto out;\n\n\tret = *nonpad_ret = splice_to_pipe(pipe, &spd);\n\tif (ret < 0 || ret < total_len)\n\t\tgoto out;\n\n        if (read_start + ret == nonpad_end)\n                ret += padding;\n\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic ssize_t relay_file_splice_read(struct file *in,\n\t\t\t\t      loff_t *ppos,\n\t\t\t\t      struct pipe_inode_info *pipe,\n\t\t\t\t      size_t len,\n\t\t\t\t      unsigned int flags)\n{\n\tssize_t spliced;\n\tint ret;\n\tint nonpad_ret = 0;\n\n\tret = 0;\n\tspliced = 0;\n\n\twhile (len && !spliced) {\n\t\tret = subbuf_splice_actor(in, ppos, pipe, len, flags, &nonpad_ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\t*ppos += ret;\n\t\tif (ret > len)\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen -= ret;\n\t\tspliced += nonpad_ret;\n\t\tnonpad_ret = 0;\n\t}\n\n\tif (spliced)\n\t\treturn spliced;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "subbuf_splice_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "1192-1282",
    "snippet": "static ssize_t subbuf_splice_actor(struct file *in,\n\t\t\t       loff_t *ppos,\n\t\t\t       struct pipe_inode_info *pipe,\n\t\t\t       size_t len,\n\t\t\t       unsigned int flags,\n\t\t\t       int *nonpad_ret)\n{\n\tunsigned int pidx, poff, total_len, subbuf_pages, nr_pages;\n\tstruct rchan_buf *rbuf = in->private_data;\n\tunsigned int subbuf_size = rbuf->chan->subbuf_size;\n\tuint64_t pos = (uint64_t) *ppos;\n\tuint32_t alloc_size = (uint32_t) rbuf->chan->alloc_size;\n\tsize_t read_start = (size_t) do_div(pos, alloc_size);\n\tsize_t read_subbuf = read_start / subbuf_size;\n\tsize_t padding = rbuf->padding[read_subbuf];\n\tsize_t nonpad_end = read_subbuf * subbuf_size + subbuf_size - padding;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.nr_pages = 0,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.partial = partial,\n\t\t.ops = &relay_pipe_buf_ops,\n\t\t.spd_release = relay_page_release,\n\t};\n\tssize_t ret;\n\n\tif (rbuf->subbufs_produced == rbuf->subbufs_consumed)\n\t\treturn 0;\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Adjust read len, if longer than what is available\n\t */\n\tif (len > (subbuf_size - read_start % subbuf_size))\n\t\tlen = subbuf_size - read_start % subbuf_size;\n\n\tsubbuf_pages = rbuf->chan->alloc_size >> PAGE_SHIFT;\n\tpidx = (read_start / PAGE_SIZE) % subbuf_pages;\n\tpoff = read_start & ~PAGE_MASK;\n\tnr_pages = min_t(unsigned int, subbuf_pages, spd.nr_pages_max);\n\n\tfor (total_len = 0; spd.nr_pages < nr_pages; spd.nr_pages++) {\n\t\tunsigned int this_len, this_end, private;\n\t\tunsigned int cur_pos = read_start + total_len;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tthis_len = min_t(unsigned long, len, PAGE_SIZE - poff);\n\t\tprivate = this_len;\n\n\t\tspd.pages[spd.nr_pages] = rbuf->page_array[pidx];\n\t\tspd.partial[spd.nr_pages].offset = poff;\n\n\t\tthis_end = cur_pos + this_len;\n\t\tif (this_end >= nonpad_end) {\n\t\t\tthis_len = nonpad_end - cur_pos;\n\t\t\tprivate = this_len + padding;\n\t\t}\n\t\tspd.partial[spd.nr_pages].len = this_len;\n\t\tspd.partial[spd.nr_pages].private = private;\n\n\t\tlen -= this_len;\n\t\ttotal_len += this_len;\n\t\tpoff = 0;\n\t\tpidx = (pidx + 1) % subbuf_pages;\n\n\t\tif (this_end >= nonpad_end) {\n\t\t\tspd.nr_pages++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (!spd.nr_pages)\n\t\tgoto out;\n\n\tret = *nonpad_ret = splice_to_pipe(pipe, &spd);\n\tif (ret < 0 || ret < total_len)\n\t\tgoto out;\n\n        if (read_start + ret == nonpad_end)\n                ret += padding;\n\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pipe_buf_operations relay_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = relay_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_shrink_spd",
          "args": [
            "&spd"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_to_pipe",
          "args": [
            "pipe",
            "&spd"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "len",
            "PAGE_SIZE - poff"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "subbuf_pages",
            "spd.nr_pages_max"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_grow_spd",
          "args": [
            "pipe",
            "&spd"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "pos",
            "alloc_size"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic const struct pipe_buf_operations relay_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = relay_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\n\nstatic ssize_t subbuf_splice_actor(struct file *in,\n\t\t\t       loff_t *ppos,\n\t\t\t       struct pipe_inode_info *pipe,\n\t\t\t       size_t len,\n\t\t\t       unsigned int flags,\n\t\t\t       int *nonpad_ret)\n{\n\tunsigned int pidx, poff, total_len, subbuf_pages, nr_pages;\n\tstruct rchan_buf *rbuf = in->private_data;\n\tunsigned int subbuf_size = rbuf->chan->subbuf_size;\n\tuint64_t pos = (uint64_t) *ppos;\n\tuint32_t alloc_size = (uint32_t) rbuf->chan->alloc_size;\n\tsize_t read_start = (size_t) do_div(pos, alloc_size);\n\tsize_t read_subbuf = read_start / subbuf_size;\n\tsize_t padding = rbuf->padding[read_subbuf];\n\tsize_t nonpad_end = read_subbuf * subbuf_size + subbuf_size - padding;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.nr_pages = 0,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.partial = partial,\n\t\t.ops = &relay_pipe_buf_ops,\n\t\t.spd_release = relay_page_release,\n\t};\n\tssize_t ret;\n\n\tif (rbuf->subbufs_produced == rbuf->subbufs_consumed)\n\t\treturn 0;\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Adjust read len, if longer than what is available\n\t */\n\tif (len > (subbuf_size - read_start % subbuf_size))\n\t\tlen = subbuf_size - read_start % subbuf_size;\n\n\tsubbuf_pages = rbuf->chan->alloc_size >> PAGE_SHIFT;\n\tpidx = (read_start / PAGE_SIZE) % subbuf_pages;\n\tpoff = read_start & ~PAGE_MASK;\n\tnr_pages = min_t(unsigned int, subbuf_pages, spd.nr_pages_max);\n\n\tfor (total_len = 0; spd.nr_pages < nr_pages; spd.nr_pages++) {\n\t\tunsigned int this_len, this_end, private;\n\t\tunsigned int cur_pos = read_start + total_len;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tthis_len = min_t(unsigned long, len, PAGE_SIZE - poff);\n\t\tprivate = this_len;\n\n\t\tspd.pages[spd.nr_pages] = rbuf->page_array[pidx];\n\t\tspd.partial[spd.nr_pages].offset = poff;\n\n\t\tthis_end = cur_pos + this_len;\n\t\tif (this_end >= nonpad_end) {\n\t\t\tthis_len = nonpad_end - cur_pos;\n\t\t\tprivate = this_len + padding;\n\t\t}\n\t\tspd.partial[spd.nr_pages].len = this_len;\n\t\tspd.partial[spd.nr_pages].private = private;\n\n\t\tlen -= this_len;\n\t\ttotal_len += this_len;\n\t\tpoff = 0;\n\t\tpidx = (pidx + 1) % subbuf_pages;\n\n\t\tif (this_end >= nonpad_end) {\n\t\t\tspd.nr_pages++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (!spd.nr_pages)\n\t\tgoto out;\n\n\tret = *nonpad_ret = splice_to_pipe(pipe, &spd);\n\tif (ret < 0 || ret < total_len)\n\t\tgoto out;\n\n        if (read_start + ret == nonpad_end)\n                ret += padding;\n\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n}"
  },
  {
    "function_name": "relay_page_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "1185-1187",
    "snippet": "static void relay_page_release(struct splice_pipe_desc *spd, unsigned int i)\n{\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_page_release(struct splice_pipe_desc *spd, unsigned int i)\n{\n}"
  },
  {
    "function_name": "relay_pipe_buf_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "1168-1175",
    "snippet": "static void relay_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct rchan_buf *rbuf;\n\n\trbuf = (struct rchan_buf *)page_private(buf->page);\n\trelay_consume_bytes(rbuf, buf->private);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_consume_bytes",
          "args": [
            "rbuf",
            "buf->private"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "relay_consume_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "1158-1166",
          "snippet": "static void relay_consume_bytes(struct rchan_buf *rbuf, int bytes_consumed)\n{\n\trbuf->bytes_consumed += bytes_consumed;\n\n\tif (rbuf->bytes_consumed >= rbuf->chan->subbuf_size) {\n\t\trelay_subbufs_consumed(rbuf->chan, rbuf->cpu, 1);\n\t\trbuf->bytes_consumed %= rbuf->chan->subbuf_size;\n\t}\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_consume_bytes(struct rchan_buf *rbuf, int bytes_consumed)\n{\n\trbuf->bytes_consumed += bytes_consumed;\n\n\tif (rbuf->bytes_consumed >= rbuf->chan->subbuf_size) {\n\t\trelay_subbufs_consumed(rbuf->chan, rbuf->cpu, 1);\n\t\trbuf->bytes_consumed %= rbuf->chan->subbuf_size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "buf->page"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct rchan_buf *rbuf;\n\n\trbuf = (struct rchan_buf *)page_private(buf->page);\n\trelay_consume_bytes(rbuf, buf->private);\n}"
  },
  {
    "function_name": "relay_consume_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "1158-1166",
    "snippet": "static void relay_consume_bytes(struct rchan_buf *rbuf, int bytes_consumed)\n{\n\trbuf->bytes_consumed += bytes_consumed;\n\n\tif (rbuf->bytes_consumed >= rbuf->chan->subbuf_size) {\n\t\trelay_subbufs_consumed(rbuf->chan, rbuf->cpu, 1);\n\t\trbuf->bytes_consumed %= rbuf->chan->subbuf_size;\n\t}\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_subbufs_consumed",
          "args": [
            "rbuf->chan",
            "rbuf->cpu",
            "1"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "relay_subbufs_consumed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "806-823",
          "snippet": "void relay_subbufs_consumed(struct rchan *chan,\n\t\t\t    unsigned int cpu,\n\t\t\t    size_t subbufs_consumed)\n{\n\tstruct rchan_buf *buf;\n\n\tif (!chan || cpu >= NR_CPUS)\n\t\treturn;\n\n\tbuf = *per_cpu_ptr(chan->buf, cpu);\n\tif (!buf || subbufs_consumed > chan->n_subbufs)\n\t\treturn;\n\n\tif (subbufs_consumed > buf->subbufs_produced - buf->subbufs_consumed)\n\t\tbuf->subbufs_consumed = buf->subbufs_produced;\n\telse\n\t\tbuf->subbufs_consumed += subbufs_consumed;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nvoid relay_subbufs_consumed(struct rchan *chan,\n\t\t\t    unsigned int cpu,\n\t\t\t    size_t subbufs_consumed)\n{\n\tstruct rchan_buf *buf;\n\n\tif (!chan || cpu >= NR_CPUS)\n\t\treturn;\n\n\tbuf = *per_cpu_ptr(chan->buf, cpu);\n\tif (!buf || subbufs_consumed > chan->n_subbufs)\n\t\treturn;\n\n\tif (subbufs_consumed > buf->subbufs_produced - buf->subbufs_consumed)\n\t\tbuf->subbufs_consumed = buf->subbufs_produced;\n\telse\n\t\tbuf->subbufs_consumed += subbufs_consumed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_consume_bytes(struct rchan_buf *rbuf, int bytes_consumed)\n{\n\trbuf->bytes_consumed += bytes_consumed;\n\n\tif (rbuf->bytes_consumed >= rbuf->chan->subbuf_size) {\n\t\trelay_subbufs_consumed(rbuf->chan, rbuf->cpu, 1);\n\t\trbuf->bytes_consumed %= rbuf->chan->subbuf_size;\n\t}\n}"
  },
  {
    "function_name": "relay_file_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "1115-1156",
    "snippet": "static ssize_t relay_file_read(struct file *filp,\n\t\t\t       char __user *buffer,\n\t\t\t       size_t count,\n\t\t\t       loff_t *ppos)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\tsize_t read_start, avail;\n\tsize_t written = 0;\n\tint ret;\n\n\tif (!count)\n\t\treturn 0;\n\n\tinode_lock(file_inode(filp));\n\tdo {\n\t\tvoid *from;\n\n\t\tif (!relay_file_read_avail(buf, *ppos))\n\t\t\tbreak;\n\n\t\tread_start = relay_file_read_start_pos(*ppos, buf);\n\t\tavail = relay_file_read_subbuf_avail(read_start, buf);\n\t\tif (!avail)\n\t\t\tbreak;\n\n\t\tavail = min(count, avail);\n\t\tfrom = buf->start + read_start;\n\t\tret = avail;\n\t\tif (copy_to_user(buffer, from, avail))\n\t\t\tbreak;\n\n\t\tbuffer += ret;\n\t\twritten += ret;\n\t\tcount -= ret;\n\n\t\trelay_file_read_consume(buf, read_start, ret);\n\t\t*ppos = relay_file_read_end_pos(buf, read_start, ret);\n\t} while (count);\n\tinode_unlock(file_inode(filp));\n\n\treturn written;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "file_inode(filp)"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_file_read_end_pos",
          "args": [
            "buf",
            "read_start",
            "ret"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "relay_file_read_end_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "1095-1113",
          "snippet": "static size_t relay_file_read_end_pos(struct rchan_buf *buf,\n\t\t\t\t      size_t read_pos,\n\t\t\t\t      size_t count)\n{\n\tsize_t read_subbuf, padding, end_pos;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tif (read_pos % subbuf_size + count + padding == subbuf_size)\n\t\tend_pos = (read_subbuf + 1) * subbuf_size;\n\telse\n\t\tend_pos = read_pos + count;\n\tif (end_pos >= subbuf_size * n_subbufs)\n\t\tend_pos = 0;\n\n\treturn end_pos;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic size_t relay_file_read_end_pos(struct rchan_buf *buf,\n\t\t\t\t      size_t read_pos,\n\t\t\t\t      size_t count)\n{\n\tsize_t read_subbuf, padding, end_pos;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tif (read_pos % subbuf_size + count + padding == subbuf_size)\n\t\tend_pos = (read_subbuf + 1) * subbuf_size;\n\telse\n\t\tend_pos = read_pos + count;\n\tif (end_pos >= subbuf_size * n_subbufs)\n\t\tend_pos = 0;\n\n\treturn end_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_file_read_consume",
          "args": [
            "buf",
            "read_start",
            "ret"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "relay_file_read_consume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "958-987",
          "snippet": "static void relay_file_read_consume(struct rchan_buf *buf,\n\t\t\t\t    size_t read_pos,\n\t\t\t\t    size_t bytes_consumed)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t read_subbuf;\n\n\tif (buf->subbufs_produced == buf->subbufs_consumed &&\n\t    buf->offset == buf->bytes_consumed)\n\t\treturn;\n\n\tif (buf->bytes_consumed + bytes_consumed > subbuf_size) {\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tbuf->bytes_consumed += bytes_consumed;\n\tif (!read_pos)\n\t\tread_subbuf = buf->subbufs_consumed % n_subbufs;\n\telse\n\t\tread_subbuf = read_pos / buf->chan->subbuf_size;\n\tif (buf->bytes_consumed + buf->padding[read_subbuf] == subbuf_size) {\n\t\tif ((read_subbuf == buf->subbufs_produced % n_subbufs) &&\n\t\t    (buf->offset == subbuf_size))\n\t\t\treturn;\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_file_read_consume(struct rchan_buf *buf,\n\t\t\t\t    size_t read_pos,\n\t\t\t\t    size_t bytes_consumed)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t read_subbuf;\n\n\tif (buf->subbufs_produced == buf->subbufs_consumed &&\n\t    buf->offset == buf->bytes_consumed)\n\t\treturn;\n\n\tif (buf->bytes_consumed + bytes_consumed > subbuf_size) {\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tbuf->bytes_consumed += bytes_consumed;\n\tif (!read_pos)\n\t\tread_subbuf = buf->subbufs_consumed % n_subbufs;\n\telse\n\t\tread_subbuf = read_pos / buf->chan->subbuf_size;\n\tif (buf->bytes_consumed + buf->padding[read_subbuf] == subbuf_size) {\n\t\tif ((read_subbuf == buf->subbufs_produced % n_subbufs) &&\n\t\t    (buf->offset == subbuf_size))\n\t\t\treturn;\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "from",
            "avail"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "avail"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "relay_file_read_subbuf_avail",
          "args": [
            "read_start",
            "buf"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "relay_file_read_subbuf_avail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "1036-1056",
          "snippet": "static size_t relay_file_read_subbuf_avail(size_t read_pos,\n\t\t\t\t\t   struct rchan_buf *buf)\n{\n\tsize_t padding, avail = 0;\n\tsize_t read_subbuf, read_offset, write_subbuf, write_offset;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\n\twrite_subbuf = (buf->data - buf->start) / subbuf_size;\n\twrite_offset = buf->offset > subbuf_size ? subbuf_size : buf->offset;\n\tread_subbuf = read_pos / subbuf_size;\n\tread_offset = read_pos % subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\n\tif (read_subbuf == write_subbuf) {\n\t\tif (read_offset + padding < write_offset)\n\t\t\tavail = write_offset - (read_offset + padding);\n\t} else\n\t\tavail = (subbuf_size - padding) - read_offset;\n\n\treturn avail;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic size_t relay_file_read_subbuf_avail(size_t read_pos,\n\t\t\t\t\t   struct rchan_buf *buf)\n{\n\tsize_t padding, avail = 0;\n\tsize_t read_subbuf, read_offset, write_subbuf, write_offset;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\n\twrite_subbuf = (buf->data - buf->start) / subbuf_size;\n\twrite_offset = buf->offset > subbuf_size ? subbuf_size : buf->offset;\n\tread_subbuf = read_pos / subbuf_size;\n\tread_offset = read_pos % subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\n\tif (read_subbuf == write_subbuf) {\n\t\tif (read_offset + padding < write_offset)\n\t\t\tavail = write_offset - (read_offset + padding);\n\t} else\n\t\tavail = (subbuf_size - padding) - read_offset;\n\n\treturn avail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_file_read_start_pos",
          "args": [
            "*ppos",
            "buf"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "relay_file_read_start_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "1067-1087",
          "snippet": "static size_t relay_file_read_start_pos(size_t read_pos,\n\t\t\t\t\tstruct rchan_buf *buf)\n{\n\tsize_t read_subbuf, padding, padding_start, padding_end;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t consumed = buf->subbufs_consumed % n_subbufs;\n\n\tif (!read_pos)\n\t\tread_pos = consumed * subbuf_size + buf->bytes_consumed;\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tpadding_start = (read_subbuf + 1) * subbuf_size - padding;\n\tpadding_end = (read_subbuf + 1) * subbuf_size;\n\tif (read_pos >= padding_start && read_pos < padding_end) {\n\t\tread_subbuf = (read_subbuf + 1) % n_subbufs;\n\t\tread_pos = read_subbuf * subbuf_size;\n\t}\n\n\treturn read_pos;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic size_t relay_file_read_start_pos(size_t read_pos,\n\t\t\t\t\tstruct rchan_buf *buf)\n{\n\tsize_t read_subbuf, padding, padding_start, padding_end;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t consumed = buf->subbufs_consumed % n_subbufs;\n\n\tif (!read_pos)\n\t\tread_pos = consumed * subbuf_size + buf->bytes_consumed;\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tpadding_start = (read_subbuf + 1) * subbuf_size - padding;\n\tpadding_end = (read_subbuf + 1) * subbuf_size;\n\tif (read_pos >= padding_start && read_pos < padding_end) {\n\t\tread_subbuf = (read_subbuf + 1) % n_subbufs;\n\t\tread_pos = read_subbuf * subbuf_size;\n\t}\n\n\treturn read_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_file_read_avail",
          "args": [
            "buf",
            "*ppos"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "relay_file_read_avail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "992-1029",
          "snippet": "static int relay_file_read_avail(struct rchan_buf *buf, size_t read_pos)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t produced = buf->subbufs_produced;\n\tsize_t consumed = buf->subbufs_consumed;\n\n\trelay_file_read_consume(buf, read_pos, 0);\n\n\tconsumed = buf->subbufs_consumed;\n\n\tif (unlikely(buf->offset > subbuf_size)) {\n\t\tif (produced == consumed)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\tif (unlikely(produced - consumed >= n_subbufs)) {\n\t\tconsumed = produced - n_subbufs + 1;\n\t\tbuf->subbufs_consumed = consumed;\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tproduced = (produced % n_subbufs) * subbuf_size + buf->offset;\n\tconsumed = (consumed % n_subbufs) * subbuf_size + buf->bytes_consumed;\n\n\tif (consumed > produced)\n\t\tproduced += n_subbufs * subbuf_size;\n\n\tif (consumed == produced) {\n\t\tif (buf->offset == subbuf_size &&\n\t\t    buf->subbufs_produced > buf->subbufs_consumed)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic int relay_file_read_avail(struct rchan_buf *buf, size_t read_pos)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t produced = buf->subbufs_produced;\n\tsize_t consumed = buf->subbufs_consumed;\n\n\trelay_file_read_consume(buf, read_pos, 0);\n\n\tconsumed = buf->subbufs_consumed;\n\n\tif (unlikely(buf->offset > subbuf_size)) {\n\t\tif (produced == consumed)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\tif (unlikely(produced - consumed >= n_subbufs)) {\n\t\tconsumed = produced - n_subbufs + 1;\n\t\tbuf->subbufs_consumed = consumed;\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tproduced = (produced % n_subbufs) * subbuf_size + buf->offset;\n\tconsumed = (consumed % n_subbufs) * subbuf_size + buf->bytes_consumed;\n\n\tif (consumed > produced)\n\t\tproduced += n_subbufs * subbuf_size;\n\n\tif (consumed == produced) {\n\t\tif (buf->offset == subbuf_size &&\n\t\t    buf->subbufs_produced > buf->subbufs_consumed)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "file_inode(filp)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic ssize_t relay_file_read(struct file *filp,\n\t\t\t       char __user *buffer,\n\t\t\t       size_t count,\n\t\t\t       loff_t *ppos)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\tsize_t read_start, avail;\n\tsize_t written = 0;\n\tint ret;\n\n\tif (!count)\n\t\treturn 0;\n\n\tinode_lock(file_inode(filp));\n\tdo {\n\t\tvoid *from;\n\n\t\tif (!relay_file_read_avail(buf, *ppos))\n\t\t\tbreak;\n\n\t\tread_start = relay_file_read_start_pos(*ppos, buf);\n\t\tavail = relay_file_read_subbuf_avail(read_start, buf);\n\t\tif (!avail)\n\t\t\tbreak;\n\n\t\tavail = min(count, avail);\n\t\tfrom = buf->start + read_start;\n\t\tret = avail;\n\t\tif (copy_to_user(buffer, from, avail))\n\t\t\tbreak;\n\n\t\tbuffer += ret;\n\t\twritten += ret;\n\t\tcount -= ret;\n\n\t\trelay_file_read_consume(buf, read_start, ret);\n\t\t*ppos = relay_file_read_end_pos(buf, read_start, ret);\n\t} while (count);\n\tinode_unlock(file_inode(filp));\n\n\treturn written;\n}"
  },
  {
    "function_name": "relay_file_read_end_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "1095-1113",
    "snippet": "static size_t relay_file_read_end_pos(struct rchan_buf *buf,\n\t\t\t\t      size_t read_pos,\n\t\t\t\t      size_t count)\n{\n\tsize_t read_subbuf, padding, end_pos;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tif (read_pos % subbuf_size + count + padding == subbuf_size)\n\t\tend_pos = (read_subbuf + 1) * subbuf_size;\n\telse\n\t\tend_pos = read_pos + count;\n\tif (end_pos >= subbuf_size * n_subbufs)\n\t\tend_pos = 0;\n\n\treturn end_pos;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic size_t relay_file_read_end_pos(struct rchan_buf *buf,\n\t\t\t\t      size_t read_pos,\n\t\t\t\t      size_t count)\n{\n\tsize_t read_subbuf, padding, end_pos;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tif (read_pos % subbuf_size + count + padding == subbuf_size)\n\t\tend_pos = (read_subbuf + 1) * subbuf_size;\n\telse\n\t\tend_pos = read_pos + count;\n\tif (end_pos >= subbuf_size * n_subbufs)\n\t\tend_pos = 0;\n\n\treturn end_pos;\n}"
  },
  {
    "function_name": "relay_file_read_start_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "1067-1087",
    "snippet": "static size_t relay_file_read_start_pos(size_t read_pos,\n\t\t\t\t\tstruct rchan_buf *buf)\n{\n\tsize_t read_subbuf, padding, padding_start, padding_end;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t consumed = buf->subbufs_consumed % n_subbufs;\n\n\tif (!read_pos)\n\t\tread_pos = consumed * subbuf_size + buf->bytes_consumed;\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tpadding_start = (read_subbuf + 1) * subbuf_size - padding;\n\tpadding_end = (read_subbuf + 1) * subbuf_size;\n\tif (read_pos >= padding_start && read_pos < padding_end) {\n\t\tread_subbuf = (read_subbuf + 1) % n_subbufs;\n\t\tread_pos = read_subbuf * subbuf_size;\n\t}\n\n\treturn read_pos;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic size_t relay_file_read_start_pos(size_t read_pos,\n\t\t\t\t\tstruct rchan_buf *buf)\n{\n\tsize_t read_subbuf, padding, padding_start, padding_end;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t consumed = buf->subbufs_consumed % n_subbufs;\n\n\tif (!read_pos)\n\t\tread_pos = consumed * subbuf_size + buf->bytes_consumed;\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tpadding_start = (read_subbuf + 1) * subbuf_size - padding;\n\tpadding_end = (read_subbuf + 1) * subbuf_size;\n\tif (read_pos >= padding_start && read_pos < padding_end) {\n\t\tread_subbuf = (read_subbuf + 1) % n_subbufs;\n\t\tread_pos = read_subbuf * subbuf_size;\n\t}\n\n\treturn read_pos;\n}"
  },
  {
    "function_name": "relay_file_read_subbuf_avail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "1036-1056",
    "snippet": "static size_t relay_file_read_subbuf_avail(size_t read_pos,\n\t\t\t\t\t   struct rchan_buf *buf)\n{\n\tsize_t padding, avail = 0;\n\tsize_t read_subbuf, read_offset, write_subbuf, write_offset;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\n\twrite_subbuf = (buf->data - buf->start) / subbuf_size;\n\twrite_offset = buf->offset > subbuf_size ? subbuf_size : buf->offset;\n\tread_subbuf = read_pos / subbuf_size;\n\tread_offset = read_pos % subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\n\tif (read_subbuf == write_subbuf) {\n\t\tif (read_offset + padding < write_offset)\n\t\t\tavail = write_offset - (read_offset + padding);\n\t} else\n\t\tavail = (subbuf_size - padding) - read_offset;\n\n\treturn avail;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic size_t relay_file_read_subbuf_avail(size_t read_pos,\n\t\t\t\t\t   struct rchan_buf *buf)\n{\n\tsize_t padding, avail = 0;\n\tsize_t read_subbuf, read_offset, write_subbuf, write_offset;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\n\twrite_subbuf = (buf->data - buf->start) / subbuf_size;\n\twrite_offset = buf->offset > subbuf_size ? subbuf_size : buf->offset;\n\tread_subbuf = read_pos / subbuf_size;\n\tread_offset = read_pos % subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\n\tif (read_subbuf == write_subbuf) {\n\t\tif (read_offset + padding < write_offset)\n\t\t\tavail = write_offset - (read_offset + padding);\n\t} else\n\t\tavail = (subbuf_size - padding) - read_offset;\n\n\treturn avail;\n}"
  },
  {
    "function_name": "relay_file_read_avail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "992-1029",
    "snippet": "static int relay_file_read_avail(struct rchan_buf *buf, size_t read_pos)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t produced = buf->subbufs_produced;\n\tsize_t consumed = buf->subbufs_consumed;\n\n\trelay_file_read_consume(buf, read_pos, 0);\n\n\tconsumed = buf->subbufs_consumed;\n\n\tif (unlikely(buf->offset > subbuf_size)) {\n\t\tif (produced == consumed)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\tif (unlikely(produced - consumed >= n_subbufs)) {\n\t\tconsumed = produced - n_subbufs + 1;\n\t\tbuf->subbufs_consumed = consumed;\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tproduced = (produced % n_subbufs) * subbuf_size + buf->offset;\n\tconsumed = (consumed % n_subbufs) * subbuf_size + buf->bytes_consumed;\n\n\tif (consumed > produced)\n\t\tproduced += n_subbufs * subbuf_size;\n\n\tif (consumed == produced) {\n\t\tif (buf->offset == subbuf_size &&\n\t\t    buf->subbufs_produced > buf->subbufs_consumed)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "produced - consumed >= n_subbufs"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buf->offset > subbuf_size"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_file_read_consume",
          "args": [
            "buf",
            "read_pos",
            "0"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "relay_file_read_consume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "958-987",
          "snippet": "static void relay_file_read_consume(struct rchan_buf *buf,\n\t\t\t\t    size_t read_pos,\n\t\t\t\t    size_t bytes_consumed)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t read_subbuf;\n\n\tif (buf->subbufs_produced == buf->subbufs_consumed &&\n\t    buf->offset == buf->bytes_consumed)\n\t\treturn;\n\n\tif (buf->bytes_consumed + bytes_consumed > subbuf_size) {\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tbuf->bytes_consumed += bytes_consumed;\n\tif (!read_pos)\n\t\tread_subbuf = buf->subbufs_consumed % n_subbufs;\n\telse\n\t\tread_subbuf = read_pos / buf->chan->subbuf_size;\n\tif (buf->bytes_consumed + buf->padding[read_subbuf] == subbuf_size) {\n\t\tif ((read_subbuf == buf->subbufs_produced % n_subbufs) &&\n\t\t    (buf->offset == subbuf_size))\n\t\t\treturn;\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_file_read_consume(struct rchan_buf *buf,\n\t\t\t\t    size_t read_pos,\n\t\t\t\t    size_t bytes_consumed)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t read_subbuf;\n\n\tif (buf->subbufs_produced == buf->subbufs_consumed &&\n\t    buf->offset == buf->bytes_consumed)\n\t\treturn;\n\n\tif (buf->bytes_consumed + bytes_consumed > subbuf_size) {\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tbuf->bytes_consumed += bytes_consumed;\n\tif (!read_pos)\n\t\tread_subbuf = buf->subbufs_consumed % n_subbufs;\n\telse\n\t\tread_subbuf = read_pos / buf->chan->subbuf_size;\n\tif (buf->bytes_consumed + buf->padding[read_subbuf] == subbuf_size) {\n\t\tif ((read_subbuf == buf->subbufs_produced % n_subbufs) &&\n\t\t    (buf->offset == subbuf_size))\n\t\t\treturn;\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic int relay_file_read_avail(struct rchan_buf *buf, size_t read_pos)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t produced = buf->subbufs_produced;\n\tsize_t consumed = buf->subbufs_consumed;\n\n\trelay_file_read_consume(buf, read_pos, 0);\n\n\tconsumed = buf->subbufs_consumed;\n\n\tif (unlikely(buf->offset > subbuf_size)) {\n\t\tif (produced == consumed)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\tif (unlikely(produced - consumed >= n_subbufs)) {\n\t\tconsumed = produced - n_subbufs + 1;\n\t\tbuf->subbufs_consumed = consumed;\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tproduced = (produced % n_subbufs) * subbuf_size + buf->offset;\n\tconsumed = (consumed % n_subbufs) * subbuf_size + buf->bytes_consumed;\n\n\tif (consumed > produced)\n\t\tproduced += n_subbufs * subbuf_size;\n\n\tif (consumed == produced) {\n\t\tif (buf->offset == subbuf_size &&\n\t\t    buf->subbufs_produced > buf->subbufs_consumed)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "relay_file_read_consume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "958-987",
    "snippet": "static void relay_file_read_consume(struct rchan_buf *buf,\n\t\t\t\t    size_t read_pos,\n\t\t\t\t    size_t bytes_consumed)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t read_subbuf;\n\n\tif (buf->subbufs_produced == buf->subbufs_consumed &&\n\t    buf->offset == buf->bytes_consumed)\n\t\treturn;\n\n\tif (buf->bytes_consumed + bytes_consumed > subbuf_size) {\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tbuf->bytes_consumed += bytes_consumed;\n\tif (!read_pos)\n\t\tread_subbuf = buf->subbufs_consumed % n_subbufs;\n\telse\n\t\tread_subbuf = read_pos / buf->chan->subbuf_size;\n\tif (buf->bytes_consumed + buf->padding[read_subbuf] == subbuf_size) {\n\t\tif ((read_subbuf == buf->subbufs_produced % n_subbufs) &&\n\t\t    (buf->offset == subbuf_size))\n\t\t\treturn;\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_subbufs_consumed",
          "args": [
            "buf->chan",
            "buf->cpu",
            "1"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "relay_subbufs_consumed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "806-823",
          "snippet": "void relay_subbufs_consumed(struct rchan *chan,\n\t\t\t    unsigned int cpu,\n\t\t\t    size_t subbufs_consumed)\n{\n\tstruct rchan_buf *buf;\n\n\tif (!chan || cpu >= NR_CPUS)\n\t\treturn;\n\n\tbuf = *per_cpu_ptr(chan->buf, cpu);\n\tif (!buf || subbufs_consumed > chan->n_subbufs)\n\t\treturn;\n\n\tif (subbufs_consumed > buf->subbufs_produced - buf->subbufs_consumed)\n\t\tbuf->subbufs_consumed = buf->subbufs_produced;\n\telse\n\t\tbuf->subbufs_consumed += subbufs_consumed;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nvoid relay_subbufs_consumed(struct rchan *chan,\n\t\t\t    unsigned int cpu,\n\t\t\t    size_t subbufs_consumed)\n{\n\tstruct rchan_buf *buf;\n\n\tif (!chan || cpu >= NR_CPUS)\n\t\treturn;\n\n\tbuf = *per_cpu_ptr(chan->buf, cpu);\n\tif (!buf || subbufs_consumed > chan->n_subbufs)\n\t\treturn;\n\n\tif (subbufs_consumed > buf->subbufs_produced - buf->subbufs_consumed)\n\t\tbuf->subbufs_consumed = buf->subbufs_produced;\n\telse\n\t\tbuf->subbufs_consumed += subbufs_consumed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_file_read_consume(struct rchan_buf *buf,\n\t\t\t\t    size_t read_pos,\n\t\t\t\t    size_t bytes_consumed)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t read_subbuf;\n\n\tif (buf->subbufs_produced == buf->subbufs_consumed &&\n\t    buf->offset == buf->bytes_consumed)\n\t\treturn;\n\n\tif (buf->bytes_consumed + bytes_consumed > subbuf_size) {\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tbuf->bytes_consumed += bytes_consumed;\n\tif (!read_pos)\n\t\tread_subbuf = buf->subbufs_consumed % n_subbufs;\n\telse\n\t\tread_subbuf = read_pos / buf->chan->subbuf_size;\n\tif (buf->bytes_consumed + buf->padding[read_subbuf] == subbuf_size) {\n\t\tif ((read_subbuf == buf->subbufs_produced % n_subbufs) &&\n\t\t    (buf->offset == subbuf_size))\n\t\t\treturn;\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n}"
  },
  {
    "function_name": "relay_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "947-953",
    "snippet": "static int relay_file_release(struct inode *inode, struct file *filp)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\tkref_put(&buf->kref, relay_remove_buf);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&buf->kref",
            "relay_remove_buf"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic int relay_file_release(struct inode *inode, struct file *filp)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\tkref_put(&buf->kref, relay_remove_buf);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "relay_file_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "922-937",
    "snippet": "static __poll_t relay_file_poll(struct file *filp, poll_table *wait)\n{\n\t__poll_t mask = 0;\n\tstruct rchan_buf *buf = filp->private_data;\n\n\tif (buf->finalized)\n\t\treturn EPOLLERR;\n\n\tif (filp->f_mode & FMODE_READ) {\n\t\tpoll_wait(filp, &buf->read_wait, wait);\n\t\tif (!relay_buf_empty(buf))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn mask;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_buf_empty",
          "args": [
            "buf"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "relay_buf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "244-247",
          "snippet": "static int relay_buf_empty(struct rchan_buf *buf)\n{\n\treturn (buf->subbufs_produced - buf->subbufs_consumed) ? 0 : 1;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic int relay_buf_empty(struct rchan_buf *buf)\n{\n\treturn (buf->subbufs_produced - buf->subbufs_consumed) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "filp",
            "&buf->read_wait",
            "wait"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic __poll_t relay_file_poll(struct file *filp, poll_table *wait)\n{\n\t__poll_t mask = 0;\n\tstruct rchan_buf *buf = filp->private_data;\n\n\tif (buf->finalized)\n\t\treturn EPOLLERR;\n\n\tif (filp->f_mode & FMODE_READ) {\n\t\tpoll_wait(filp, &buf->read_wait, wait);\n\t\tif (!relay_buf_empty(buf))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn mask;\n}"
  },
  {
    "function_name": "relay_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "909-913",
    "snippet": "static int relay_file_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\treturn relay_mmap_buf(buf, vma);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_mmap_buf",
          "args": [
            "buf",
            "vma"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "relay_mmap_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "96-113",
          "snippet": "static int relay_mmap_buf(struct rchan_buf *buf, struct vm_area_struct *vma)\n{\n\tunsigned long length = vma->vm_end - vma->vm_start;\n\tstruct file *filp = vma->vm_file;\n\n\tif (!buf)\n\t\treturn -EBADF;\n\n\tif (length != (unsigned long)buf->chan->alloc_size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &relay_file_mmap_ops;\n\tvma->vm_flags |= VM_DONTEXPAND;\n\tvma->vm_private_data = buf;\n\tbuf->chan->cb->buf_mapped(buf, filp);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct vm_operations_struct relay_file_mmap_ops = {\n\t.fault = relay_buf_fault,\n\t.close = relay_file_mmap_close,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic const struct vm_operations_struct relay_file_mmap_ops = {\n\t.fault = relay_buf_fault,\n\t.close = relay_file_mmap_close,\n};\n\nstatic int relay_mmap_buf(struct rchan_buf *buf, struct vm_area_struct *vma)\n{\n\tunsigned long length = vma->vm_end - vma->vm_start;\n\tstruct file *filp = vma->vm_file;\n\n\tif (!buf)\n\t\treturn -EBADF;\n\n\tif (length != (unsigned long)buf->chan->alloc_size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &relay_file_mmap_ops;\n\tvma->vm_flags |= VM_DONTEXPAND;\n\tvma->vm_private_data = buf;\n\tbuf->chan->cb->buf_mapped(buf, filp);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic int relay_file_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\treturn relay_mmap_buf(buf, vma);\n}"
  },
  {
    "function_name": "relay_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "893-900",
    "snippet": "static int relay_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct rchan_buf *buf = inode->i_private;\n\tkref_get(&buf->kref);\n\tfilp->private_data = buf;\n\n\treturn nonseekable_open(inode, filp);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nonseekable_open",
          "args": [
            "inode",
            "filp"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&buf->kref"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/autogroup.c",
          "lines": "43-47",
          "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic int relay_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct rchan_buf *buf = inode->i_private;\n\tkref_get(&buf->kref);\n\tfilp->private_data = buf;\n\n\treturn nonseekable_open(inode, filp);\n}"
  },
  {
    "function_name": "relay_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "865-883",
    "snippet": "void relay_flush(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0))) {\n\t\trelay_switch_subbuf(buf, 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_switch_subbuf(buf, 0);\n\tmutex_unlock(&relay_channels_mutex);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(relay_channels_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_switch_subbuf",
          "args": [
            "buf",
            "0"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "relay_switch_subbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "739-790",
          "snippet": "size_t relay_switch_subbuf(struct rchan_buf *buf, size_t length)\n{\n\tvoid *old, *new;\n\tsize_t old_subbuf, new_subbuf;\n\n\tif (unlikely(length > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\tif (buf->offset != buf->chan->subbuf_size + 1) {\n\t\tbuf->prev_padding = buf->chan->subbuf_size - buf->offset;\n\t\told_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\t\tbuf->padding[old_subbuf] = buf->prev_padding;\n\t\tbuf->subbufs_produced++;\n\t\tif (buf->dentry)\n\t\t\td_inode(buf->dentry)->i_size +=\n\t\t\t\tbuf->chan->subbuf_size -\n\t\t\t\tbuf->padding[old_subbuf];\n\t\telse\n\t\t\tbuf->early_bytes += buf->chan->subbuf_size -\n\t\t\t\t\t    buf->padding[old_subbuf];\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&buf->read_wait)) {\n\t\t\t/*\n\t\t\t * Calling wake_up_interruptible() from here\n\t\t\t * will deadlock if we happen to be logging\n\t\t\t * from the scheduler (trying to re-grab\n\t\t\t * rq->lock), so defer it.\n\t\t\t */\n\t\t\tirq_work_queue(&buf->wakeup_work);\n\t\t}\n\t}\n\n\told = buf->data;\n\tnew_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\tnew = buf->start + new_subbuf * buf->chan->subbuf_size;\n\tbuf->offset = 0;\n\tif (!buf->chan->cb->subbuf_start(buf, new, old, buf->prev_padding)) {\n\t\tbuf->offset = buf->chan->subbuf_size + 1;\n\t\treturn 0;\n\t}\n\tbuf->data = new;\n\tbuf->padding[new_subbuf] = 0;\n\n\tif (unlikely(length + buf->offset > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\treturn length;\n\ntoobig:\n\tbuf->chan->last_toobig = length;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nsize_t relay_switch_subbuf(struct rchan_buf *buf, size_t length)\n{\n\tvoid *old, *new;\n\tsize_t old_subbuf, new_subbuf;\n\n\tif (unlikely(length > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\tif (buf->offset != buf->chan->subbuf_size + 1) {\n\t\tbuf->prev_padding = buf->chan->subbuf_size - buf->offset;\n\t\told_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\t\tbuf->padding[old_subbuf] = buf->prev_padding;\n\t\tbuf->subbufs_produced++;\n\t\tif (buf->dentry)\n\t\t\td_inode(buf->dentry)->i_size +=\n\t\t\t\tbuf->chan->subbuf_size -\n\t\t\t\tbuf->padding[old_subbuf];\n\t\telse\n\t\t\tbuf->early_bytes += buf->chan->subbuf_size -\n\t\t\t\t\t    buf->padding[old_subbuf];\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&buf->read_wait)) {\n\t\t\t/*\n\t\t\t * Calling wake_up_interruptible() from here\n\t\t\t * will deadlock if we happen to be logging\n\t\t\t * from the scheduler (trying to re-grab\n\t\t\t * rq->lock), so defer it.\n\t\t\t */\n\t\t\tirq_work_queue(&buf->wakeup_work);\n\t\t}\n\t}\n\n\told = buf->data;\n\tnew_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\tnew = buf->start + new_subbuf * buf->chan->subbuf_size;\n\tbuf->offset = 0;\n\tif (!buf->chan->cb->subbuf_start(buf, new, old, buf->prev_padding)) {\n\t\tbuf->offset = buf->chan->subbuf_size + 1;\n\t\treturn 0;\n\t}\n\tbuf->data = new;\n\tbuf->padding[new_subbuf] = 0;\n\n\tif (unlikely(length + buf->offset > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\treturn length;\n\ntoobig:\n\tbuf->chan->last_toobig = length;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "i"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "0"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\n\nvoid relay_flush(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0))) {\n\t\trelay_switch_subbuf(buf, 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_switch_subbuf(buf, 0);\n\tmutex_unlock(&relay_channels_mutex);\n}"
  },
  {
    "function_name": "relay_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "832-856",
    "snippet": "void relay_close(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tmutex_lock(&relay_channels_mutex);\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0)))\n\t\trelay_close_buf(buf);\n\telse\n\t\tfor_each_possible_cpu(i)\n\t\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\t\trelay_close_buf(buf);\n\n\tif (chan->last_toobig)\n\t\tprintk(KERN_WARNING \"relay: one or more items not logged \"\n\t\t       \"[item size (%zd) > sub-buffer size (%zd)]\\n\",\n\t\t       chan->last_toobig, chan->subbuf_size);\n\n\tlist_del(&chan->list);\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(relay_channels_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&chan->kref",
            "relay_destroy_channel"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&chan->list"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"relay: one or more items not logged \"\n\t\t       \"[item size (%zd) > sub-buffer size (%zd)]\\n\"",
            "chan->last_toobig",
            "chan->subbuf_size"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_close_buf",
          "args": [
            "buf"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "relay_close_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "491-497",
          "snippet": "static void relay_close_buf(struct rchan_buf *buf)\n{\n\tbuf->finalized = 1;\n\tirq_work_sync(&buf->wakeup_work);\n\tbuf->chan->cb->remove_buf_file(buf->dentry);\n\tkref_put(&buf->kref, relay_remove_buf);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_close_buf(struct rchan_buf *buf)\n{\n\tbuf->finalized = 1;\n\tirq_work_sync(&buf->wakeup_work);\n\tbuf->chan->cb->remove_buf_file(buf->dentry);\n\tkref_put(&buf->kref, relay_remove_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "i"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_possible_cpu",
          "args": [
            "i"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "0"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\n\nvoid relay_close(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tmutex_lock(&relay_channels_mutex);\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0)))\n\t\trelay_close_buf(buf);\n\telse\n\t\tfor_each_possible_cpu(i)\n\t\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\t\trelay_close_buf(buf);\n\n\tif (chan->last_toobig)\n\t\tprintk(KERN_WARNING \"relay: one or more items not logged \"\n\t\t       \"[item size (%zd) > sub-buffer size (%zd)]\\n\",\n\t\t       chan->last_toobig, chan->subbuf_size);\n\n\tlist_del(&chan->list);\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n}"
  },
  {
    "function_name": "relay_subbufs_consumed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "806-823",
    "snippet": "void relay_subbufs_consumed(struct rchan *chan,\n\t\t\t    unsigned int cpu,\n\t\t\t    size_t subbufs_consumed)\n{\n\tstruct rchan_buf *buf;\n\n\tif (!chan || cpu >= NR_CPUS)\n\t\treturn;\n\n\tbuf = *per_cpu_ptr(chan->buf, cpu);\n\tif (!buf || subbufs_consumed > chan->n_subbufs)\n\t\treturn;\n\n\tif (subbufs_consumed > buf->subbufs_produced - buf->subbufs_consumed)\n\t\tbuf->subbufs_consumed = buf->subbufs_produced;\n\telse\n\t\tbuf->subbufs_consumed += subbufs_consumed;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "cpu"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nvoid relay_subbufs_consumed(struct rchan *chan,\n\t\t\t    unsigned int cpu,\n\t\t\t    size_t subbufs_consumed)\n{\n\tstruct rchan_buf *buf;\n\n\tif (!chan || cpu >= NR_CPUS)\n\t\treturn;\n\n\tbuf = *per_cpu_ptr(chan->buf, cpu);\n\tif (!buf || subbufs_consumed > chan->n_subbufs)\n\t\treturn;\n\n\tif (subbufs_consumed > buf->subbufs_produced - buf->subbufs_consumed)\n\t\tbuf->subbufs_consumed = buf->subbufs_produced;\n\telse\n\t\tbuf->subbufs_consumed += subbufs_consumed;\n}"
  },
  {
    "function_name": "relay_switch_subbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "739-790",
    "snippet": "size_t relay_switch_subbuf(struct rchan_buf *buf, size_t length)\n{\n\tvoid *old, *new;\n\tsize_t old_subbuf, new_subbuf;\n\n\tif (unlikely(length > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\tif (buf->offset != buf->chan->subbuf_size + 1) {\n\t\tbuf->prev_padding = buf->chan->subbuf_size - buf->offset;\n\t\told_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\t\tbuf->padding[old_subbuf] = buf->prev_padding;\n\t\tbuf->subbufs_produced++;\n\t\tif (buf->dentry)\n\t\t\td_inode(buf->dentry)->i_size +=\n\t\t\t\tbuf->chan->subbuf_size -\n\t\t\t\tbuf->padding[old_subbuf];\n\t\telse\n\t\t\tbuf->early_bytes += buf->chan->subbuf_size -\n\t\t\t\t\t    buf->padding[old_subbuf];\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&buf->read_wait)) {\n\t\t\t/*\n\t\t\t * Calling wake_up_interruptible() from here\n\t\t\t * will deadlock if we happen to be logging\n\t\t\t * from the scheduler (trying to re-grab\n\t\t\t * rq->lock), so defer it.\n\t\t\t */\n\t\t\tirq_work_queue(&buf->wakeup_work);\n\t\t}\n\t}\n\n\told = buf->data;\n\tnew_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\tnew = buf->start + new_subbuf * buf->chan->subbuf_size;\n\tbuf->offset = 0;\n\tif (!buf->chan->cb->subbuf_start(buf, new, old, buf->prev_padding)) {\n\t\tbuf->offset = buf->chan->subbuf_size + 1;\n\t\treturn 0;\n\t}\n\tbuf->data = new;\n\tbuf->padding[new_subbuf] = 0;\n\n\tif (unlikely(length + buf->offset > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\treturn length;\n\ntoobig:\n\tbuf->chan->last_toobig = length;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "length + buf->offset > buf->chan->subbuf_size"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->chan->cb->subbuf_start",
          "args": [
            "buf",
            "new",
            "old",
            "buf->prev_padding"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&buf->wakeup_work"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "90-112",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&buf->read_wait"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "buf->dentry"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "length > buf->chan->subbuf_size"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nsize_t relay_switch_subbuf(struct rchan_buf *buf, size_t length)\n{\n\tvoid *old, *new;\n\tsize_t old_subbuf, new_subbuf;\n\n\tif (unlikely(length > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\tif (buf->offset != buf->chan->subbuf_size + 1) {\n\t\tbuf->prev_padding = buf->chan->subbuf_size - buf->offset;\n\t\told_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\t\tbuf->padding[old_subbuf] = buf->prev_padding;\n\t\tbuf->subbufs_produced++;\n\t\tif (buf->dentry)\n\t\t\td_inode(buf->dentry)->i_size +=\n\t\t\t\tbuf->chan->subbuf_size -\n\t\t\t\tbuf->padding[old_subbuf];\n\t\telse\n\t\t\tbuf->early_bytes += buf->chan->subbuf_size -\n\t\t\t\t\t    buf->padding[old_subbuf];\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&buf->read_wait)) {\n\t\t\t/*\n\t\t\t * Calling wake_up_interruptible() from here\n\t\t\t * will deadlock if we happen to be logging\n\t\t\t * from the scheduler (trying to re-grab\n\t\t\t * rq->lock), so defer it.\n\t\t\t */\n\t\t\tirq_work_queue(&buf->wakeup_work);\n\t\t}\n\t}\n\n\told = buf->data;\n\tnew_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\tnew = buf->start + new_subbuf * buf->chan->subbuf_size;\n\tbuf->offset = 0;\n\tif (!buf->chan->cb->subbuf_start(buf, new, old, buf->prev_padding)) {\n\t\tbuf->offset = buf->chan->subbuf_size + 1;\n\t\treturn 0;\n\t}\n\tbuf->data = new;\n\tbuf->padding[new_subbuf] = 0;\n\n\tif (unlikely(length + buf->offset > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\treturn length;\n\ntoobig:\n\tbuf->chan->last_toobig = length;\n\treturn 0;\n}"
  },
  {
    "function_name": "relay_late_setup_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "647-726",
    "snippet": "int relay_late_setup_files(struct rchan *chan,\n\t\t\t   const char *base_filename,\n\t\t\t   struct dentry *parent)\n{\n\tint err = 0;\n\tunsigned int i, curr_cpu;\n\tunsigned long flags;\n\tstruct dentry *dentry;\n\tstruct rchan_buf *buf;\n\tstruct rchan_percpu_buf_dispatcher disp;\n\n\tif (!chan || !base_filename)\n\t\treturn -EINVAL;\n\n\tstrlcpy(chan->base_filename, base_filename, NAME_MAX);\n\n\tmutex_lock(&relay_channels_mutex);\n\t/* Is chan already set up? */\n\tif (unlikely(chan->has_base_filename)) {\n\t\tmutex_unlock(&relay_channels_mutex);\n\t\treturn -EEXIST;\n\t}\n\tchan->has_base_filename = 1;\n\tchan->parent = parent;\n\n\tif (chan->is_global) {\n\t\terr = -EINVAL;\n\t\tbuf = *per_cpu_ptr(chan->buf, 0);\n\t\tif (!WARN_ON_ONCE(!buf)) {\n\t\t\tdentry = relay_create_buf_file(chan, buf, 0);\n\t\t\tif (dentry && !WARN_ON_ONCE(!chan->is_global)) {\n\t\t\t\trelay_set_buf_dentry(buf, dentry);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&relay_channels_mutex);\n\t\treturn err;\n\t}\n\n\tcurr_cpu = get_cpu();\n\t/*\n\t * The CPU hotplug notifier ran before us and created buffers with\n\t * no files associated. So it's safe to call relay_setup_buf_file()\n\t * on all currently online CPUs.\n\t */\n\tfor_each_online_cpu(i) {\n\t\tbuf = *per_cpu_ptr(chan->buf, i);\n\t\tif (unlikely(!buf)) {\n\t\t\tWARN_ONCE(1, KERN_ERR \"CPU has no buffer!\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdentry = relay_create_buf_file(chan, buf, i);\n\t\tif (unlikely(!dentry)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (curr_cpu == i) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trelay_set_buf_dentry(buf, dentry);\n\t\t\tlocal_irq_restore(flags);\n\t\t} else {\n\t\t\tdisp.buf = buf;\n\t\t\tdisp.dentry = dentry;\n\t\t\tsmp_mb();\n\t\t\t/* relay_channels_mutex must be held, so wait. */\n\t\t\terr = smp_call_function_single(i,\n\t\t\t\t\t\t       __relay_set_buf_dentry,\n\t\t\t\t\t\t       &disp, 1);\n\t\t}\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\tput_cpu();\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(relay_channels_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "i",
            "__relay_set_buf_dentry",
            "&disp",
            "1"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "11-23",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_set_buf_dentry",
          "args": [
            "buf",
            "dentry"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "relay_set_buf_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "408-413",
          "snippet": "static inline void relay_set_buf_dentry(struct rchan_buf *buf,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\tbuf->dentry = dentry;\n\td_inode(buf->dentry)->i_size = buf->early_bytes;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic inline void relay_set_buf_dentry(struct rchan_buf *buf,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\tbuf->dentry = dentry;\n\td_inode(buf->dentry)->i_size = buf->early_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dentry"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_create_buf_file",
          "args": [
            "chan",
            "buf",
            "i"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "relay_create_buf_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "415-435",
          "snippet": "static struct dentry *relay_create_buf_file(struct rchan *chan,\n\t\t\t\t\t    struct rchan_buf *buf,\n\t\t\t\t\t    unsigned int cpu)\n{\n\tstruct dentry *dentry;\n\tchar *tmpname;\n\n\ttmpname = kzalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!tmpname)\n\t\treturn NULL;\n\tsnprintf(tmpname, NAME_MAX, \"%s%d\", chan->base_filename, cpu);\n\n\t/* Create file in fs */\n\tdentry = chan->cb->create_buf_file(tmpname, chan->parent,\n\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t   &chan->is_global);\n\n\tkfree(tmpname);\n\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct dentry *relay_create_buf_file(struct rchan *chan,\n\t\t\t\t\t    struct rchan_buf *buf,\n\t\t\t\t\t    unsigned int cpu)\n{\n\tstruct dentry *dentry;\n\tchar *tmpname;\n\n\ttmpname = kzalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!tmpname)\n\t\treturn NULL;\n\tsnprintf(tmpname, NAME_MAX, \"%s%d\", chan->base_filename, cpu);\n\n\t/* Create file in fs */\n\tdentry = chan->cb->create_buf_file(tmpname, chan->parent,\n\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t   &chan->is_global);\n\n\tkfree(tmpname);\n\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "KERN_ERR \"CPU has no buffer!\\n\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buf"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "i"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!chan->is_global"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!buf"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "0"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "chan->has_base_filename"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "chan->base_filename",
            "base_filename",
            "NAME_MAX"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\n\nint relay_late_setup_files(struct rchan *chan,\n\t\t\t   const char *base_filename,\n\t\t\t   struct dentry *parent)\n{\n\tint err = 0;\n\tunsigned int i, curr_cpu;\n\tunsigned long flags;\n\tstruct dentry *dentry;\n\tstruct rchan_buf *buf;\n\tstruct rchan_percpu_buf_dispatcher disp;\n\n\tif (!chan || !base_filename)\n\t\treturn -EINVAL;\n\n\tstrlcpy(chan->base_filename, base_filename, NAME_MAX);\n\n\tmutex_lock(&relay_channels_mutex);\n\t/* Is chan already set up? */\n\tif (unlikely(chan->has_base_filename)) {\n\t\tmutex_unlock(&relay_channels_mutex);\n\t\treturn -EEXIST;\n\t}\n\tchan->has_base_filename = 1;\n\tchan->parent = parent;\n\n\tif (chan->is_global) {\n\t\terr = -EINVAL;\n\t\tbuf = *per_cpu_ptr(chan->buf, 0);\n\t\tif (!WARN_ON_ONCE(!buf)) {\n\t\t\tdentry = relay_create_buf_file(chan, buf, 0);\n\t\t\tif (dentry && !WARN_ON_ONCE(!chan->is_global)) {\n\t\t\t\trelay_set_buf_dentry(buf, dentry);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&relay_channels_mutex);\n\t\treturn err;\n\t}\n\n\tcurr_cpu = get_cpu();\n\t/*\n\t * The CPU hotplug notifier ran before us and created buffers with\n\t * no files associated. So it's safe to call relay_setup_buf_file()\n\t * on all currently online CPUs.\n\t */\n\tfor_each_online_cpu(i) {\n\t\tbuf = *per_cpu_ptr(chan->buf, i);\n\t\tif (unlikely(!buf)) {\n\t\t\tWARN_ONCE(1, KERN_ERR \"CPU has no buffer!\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdentry = relay_create_buf_file(chan, buf, i);\n\t\tif (unlikely(!dentry)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (curr_cpu == i) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trelay_set_buf_dentry(buf, dentry);\n\t\t\tlocal_irq_restore(flags);\n\t\t} else {\n\t\t\tdisp.buf = buf;\n\t\t\tdisp.dentry = dentry;\n\t\t\tsmp_mb();\n\t\t\t/* relay_channels_mutex must be held, so wait. */\n\t\t\terr = smp_call_function_single(i,\n\t\t\t\t\t\t       __relay_set_buf_dentry,\n\t\t\t\t\t\t       &disp, 1);\n\t\t}\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\tput_cpu();\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "__relay_set_buf_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "625-630",
    "snippet": "static void __relay_set_buf_dentry(void *info)\n{\n\tstruct rchan_percpu_buf_dispatcher *p = info;\n\n\trelay_set_buf_dentry(p->buf, p->dentry);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_set_buf_dentry",
          "args": [
            "p->buf",
            "p->dentry"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "relay_set_buf_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "408-413",
          "snippet": "static inline void relay_set_buf_dentry(struct rchan_buf *buf,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\tbuf->dentry = dentry;\n\td_inode(buf->dentry)->i_size = buf->early_bytes;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic inline void relay_set_buf_dentry(struct rchan_buf *buf,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\tbuf->dentry = dentry;\n\td_inode(buf->dentry)->i_size = buf->early_bytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void __relay_set_buf_dentry(void *info)\n{\n\tstruct rchan_percpu_buf_dispatcher *p = info;\n\n\trelay_set_buf_dentry(p->buf, p->dentry);\n}"
  },
  {
    "function_name": "relay_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "561-616",
    "snippet": "struct rchan *relay_open(const char *base_filename,\n\t\t\t struct dentry *parent,\n\t\t\t size_t subbuf_size,\n\t\t\t size_t n_subbufs,\n\t\t\t struct rchan_callbacks *cb,\n\t\t\t void *private_data)\n{\n\tunsigned int i;\n\tstruct rchan *chan;\n\tstruct rchan_buf *buf;\n\n\tif (!(subbuf_size && n_subbufs))\n\t\treturn NULL;\n\tif (subbuf_size > UINT_MAX / n_subbufs)\n\t\treturn NULL;\n\n\tchan = kzalloc(sizeof(struct rchan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn NULL;\n\n\tchan->buf = alloc_percpu(struct rchan_buf *);\n\tchan->version = RELAYFS_CHANNEL_VERSION;\n\tchan->n_subbufs = n_subbufs;\n\tchan->subbuf_size = subbuf_size;\n\tchan->alloc_size = PAGE_ALIGN(subbuf_size * n_subbufs);\n\tchan->parent = parent;\n\tchan->private_data = private_data;\n\tif (base_filename) {\n\t\tchan->has_base_filename = 1;\n\t\tstrlcpy(chan->base_filename, base_filename, NAME_MAX);\n\t}\n\tsetup_callbacks(chan, cb);\n\tkref_init(&chan->kref);\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_online_cpu(i) {\n\t\tbuf = relay_open_buf(chan, i);\n\t\tif (!buf)\n\t\t\tgoto free_bufs;\n\t\t*per_cpu_ptr(chan->buf, i) = buf;\n\t}\n\tlist_add(&chan->list, &relay_channels);\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn chan;\n\nfree_bufs:\n\tfor_each_possible_cpu(i) {\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_close_buf(buf);\n\t}\n\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(relay_channels_mutex);",
      "static LIST_HEAD(relay_channels);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&chan->kref",
            "relay_destroy_channel"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_close_buf",
          "args": [
            "buf"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "relay_close_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "491-497",
          "snippet": "static void relay_close_buf(struct rchan_buf *buf)\n{\n\tbuf->finalized = 1;\n\tirq_work_sync(&buf->wakeup_work);\n\tbuf->chan->cb->remove_buf_file(buf->dentry);\n\tkref_put(&buf->kref, relay_remove_buf);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_close_buf(struct rchan_buf *buf)\n{\n\tbuf->finalized = 1;\n\tirq_work_sync(&buf->wakeup_work);\n\tbuf->chan->cb->remove_buf_file(buf->dentry);\n\tkref_put(&buf->kref, relay_remove_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "i"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&chan->list",
            "&relay_channels"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "i"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_open_buf",
          "args": [
            "chan",
            "i"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "relay_open_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "442-481",
          "snippet": "static struct rchan_buf *relay_open_buf(struct rchan *chan, unsigned int cpu)\n{\n \tstruct rchan_buf *buf = NULL;\n\tstruct dentry *dentry;\n\n \tif (chan->is_global)\n\t\treturn *per_cpu_ptr(chan->buf, 0);\n\n\tbuf = relay_create_buf(chan);\n\tif (!buf)\n\t\treturn NULL;\n\n\tif (chan->has_base_filename) {\n\t\tdentry = relay_create_buf_file(chan, buf, cpu);\n\t\tif (!dentry)\n\t\t\tgoto free_buf;\n\t\trelay_set_buf_dentry(buf, dentry);\n\t} else {\n\t\t/* Only retrieve global info, nothing more, nothing less */\n\t\tdentry = chan->cb->create_buf_file(NULL, NULL,\n\t\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t\t   &chan->is_global);\n\t\tif (WARN_ON(dentry))\n\t\t\tgoto free_buf;\n\t}\n\n \tbuf->cpu = cpu;\n \t__relay_reset(buf, 1);\n\n \tif(chan->is_global) {\n\t\t*per_cpu_ptr(chan->buf, 0) = buf;\n \t\tbuf->cpu = 0;\n  \t}\n\n\treturn buf;\n\nfree_buf:\n \trelay_destroy_buf(buf);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct rchan_buf *relay_open_buf(struct rchan *chan, unsigned int cpu)\n{\n \tstruct rchan_buf *buf = NULL;\n\tstruct dentry *dentry;\n\n \tif (chan->is_global)\n\t\treturn *per_cpu_ptr(chan->buf, 0);\n\n\tbuf = relay_create_buf(chan);\n\tif (!buf)\n\t\treturn NULL;\n\n\tif (chan->has_base_filename) {\n\t\tdentry = relay_create_buf_file(chan, buf, cpu);\n\t\tif (!dentry)\n\t\t\tgoto free_buf;\n\t\trelay_set_buf_dentry(buf, dentry);\n\t} else {\n\t\t/* Only retrieve global info, nothing more, nothing less */\n\t\tdentry = chan->cb->create_buf_file(NULL, NULL,\n\t\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t\t   &chan->is_global);\n\t\tif (WARN_ON(dentry))\n\t\t\tgoto free_buf;\n\t}\n\n \tbuf->cpu = cpu;\n \t__relay_reset(buf, 1);\n\n \tif(chan->is_global) {\n\t\t*per_cpu_ptr(chan->buf, 0) = buf;\n \t\tbuf->cpu = 0;\n  \t}\n\n\treturn buf;\n\nfree_buf:\n \trelay_destroy_buf(buf);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&chan->kref"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_callbacks",
          "args": [
            "chan",
            "cb"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "setup_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "499-518",
          "snippet": "static void setup_callbacks(struct rchan *chan,\n\t\t\t\t   struct rchan_callbacks *cb)\n{\n\tif (!cb) {\n\t\tchan->cb = &default_channel_callbacks;\n\t\treturn;\n\t}\n\n\tif (!cb->subbuf_start)\n\t\tcb->subbuf_start = subbuf_start_default_callback;\n\tif (!cb->buf_mapped)\n\t\tcb->buf_mapped = buf_mapped_default_callback;\n\tif (!cb->buf_unmapped)\n\t\tcb->buf_unmapped = buf_unmapped_default_callback;\n\tif (!cb->create_buf_file)\n\t\tcb->create_buf_file = create_buf_file_default_callback;\n\tif (!cb->remove_buf_file)\n\t\tcb->remove_buf_file = remove_buf_file_default_callback;\n\tchan->cb = cb;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rchan_callbacks default_channel_callbacks = {\n\t.subbuf_start = subbuf_start_default_callback,\n\t.buf_mapped = buf_mapped_default_callback,\n\t.buf_unmapped = buf_unmapped_default_callback,\n\t.create_buf_file = create_buf_file_default_callback,\n\t.remove_buf_file = remove_buf_file_default_callback,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct rchan_callbacks default_channel_callbacks = {\n\t.subbuf_start = subbuf_start_default_callback,\n\t.buf_mapped = buf_mapped_default_callback,\n\t.buf_unmapped = buf_unmapped_default_callback,\n\t.create_buf_file = create_buf_file_default_callback,\n\t.remove_buf_file = remove_buf_file_default_callback,\n};\n\nstatic void setup_callbacks(struct rchan *chan,\n\t\t\t\t   struct rchan_callbacks *cb)\n{\n\tif (!cb) {\n\t\tchan->cb = &default_channel_callbacks;\n\t\treturn;\n\t}\n\n\tif (!cb->subbuf_start)\n\t\tcb->subbuf_start = subbuf_start_default_callback;\n\tif (!cb->buf_mapped)\n\t\tcb->buf_mapped = buf_mapped_default_callback;\n\tif (!cb->buf_unmapped)\n\t\tcb->buf_unmapped = buf_unmapped_default_callback;\n\tif (!cb->create_buf_file)\n\t\tcb->create_buf_file = create_buf_file_default_callback;\n\tif (!cb->remove_buf_file)\n\t\tcb->remove_buf_file = remove_buf_file_default_callback;\n\tchan->cb = cb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "chan->base_filename",
            "base_filename",
            "NAME_MAX"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "subbuf_size * n_subbufs"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "struct rchan_buf *"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct rchan)",
            "GFP_KERNEL"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\nstatic LIST_HEAD(relay_channels);\n\nstruct rchan *relay_open(const char *base_filename,\n\t\t\t struct dentry *parent,\n\t\t\t size_t subbuf_size,\n\t\t\t size_t n_subbufs,\n\t\t\t struct rchan_callbacks *cb,\n\t\t\t void *private_data)\n{\n\tunsigned int i;\n\tstruct rchan *chan;\n\tstruct rchan_buf *buf;\n\n\tif (!(subbuf_size && n_subbufs))\n\t\treturn NULL;\n\tif (subbuf_size > UINT_MAX / n_subbufs)\n\t\treturn NULL;\n\n\tchan = kzalloc(sizeof(struct rchan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn NULL;\n\n\tchan->buf = alloc_percpu(struct rchan_buf *);\n\tchan->version = RELAYFS_CHANNEL_VERSION;\n\tchan->n_subbufs = n_subbufs;\n\tchan->subbuf_size = subbuf_size;\n\tchan->alloc_size = PAGE_ALIGN(subbuf_size * n_subbufs);\n\tchan->parent = parent;\n\tchan->private_data = private_data;\n\tif (base_filename) {\n\t\tchan->has_base_filename = 1;\n\t\tstrlcpy(chan->base_filename, base_filename, NAME_MAX);\n\t}\n\tsetup_callbacks(chan, cb);\n\tkref_init(&chan->kref);\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_online_cpu(i) {\n\t\tbuf = relay_open_buf(chan, i);\n\t\tif (!buf)\n\t\t\tgoto free_bufs;\n\t\t*per_cpu_ptr(chan->buf, i) = buf;\n\t}\n\tlist_add(&chan->list, &relay_channels);\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn chan;\n\nfree_bufs:\n\tfor_each_possible_cpu(i) {\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_close_buf(buf);\n\t}\n\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n\treturn NULL;\n}"
  },
  {
    "function_name": "relay_prepare_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "520-539",
    "snippet": "int relay_prepare_cpu(unsigned int cpu)\n{\n\tstruct rchan *chan;\n\tstruct rchan_buf *buf;\n\n\tmutex_lock(&relay_channels_mutex);\n\tlist_for_each_entry(chan, &relay_channels, list) {\n\t\tif ((buf = *per_cpu_ptr(chan->buf, cpu)))\n\t\t\tcontinue;\n\t\tbuf = relay_open_buf(chan, cpu);\n\t\tif (!buf) {\n\t\t\tpr_err(\"relay: cpu %d buffer creation failed\\n\", cpu);\n\t\t\tmutex_unlock(&relay_channels_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t*per_cpu_ptr(chan->buf, cpu) = buf;\n\t}\n\tmutex_unlock(&relay_channels_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(relay_channels_mutex);",
      "static LIST_HEAD(relay_channels);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "cpu"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"relay: cpu %d buffer creation failed\\n\"",
            "cpu"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_open_buf",
          "args": [
            "chan",
            "cpu"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "relay_open_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "442-481",
          "snippet": "static struct rchan_buf *relay_open_buf(struct rchan *chan, unsigned int cpu)\n{\n \tstruct rchan_buf *buf = NULL;\n\tstruct dentry *dentry;\n\n \tif (chan->is_global)\n\t\treturn *per_cpu_ptr(chan->buf, 0);\n\n\tbuf = relay_create_buf(chan);\n\tif (!buf)\n\t\treturn NULL;\n\n\tif (chan->has_base_filename) {\n\t\tdentry = relay_create_buf_file(chan, buf, cpu);\n\t\tif (!dentry)\n\t\t\tgoto free_buf;\n\t\trelay_set_buf_dentry(buf, dentry);\n\t} else {\n\t\t/* Only retrieve global info, nothing more, nothing less */\n\t\tdentry = chan->cb->create_buf_file(NULL, NULL,\n\t\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t\t   &chan->is_global);\n\t\tif (WARN_ON(dentry))\n\t\t\tgoto free_buf;\n\t}\n\n \tbuf->cpu = cpu;\n \t__relay_reset(buf, 1);\n\n \tif(chan->is_global) {\n\t\t*per_cpu_ptr(chan->buf, 0) = buf;\n \t\tbuf->cpu = 0;\n  \t}\n\n\treturn buf;\n\nfree_buf:\n \trelay_destroy_buf(buf);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct rchan_buf *relay_open_buf(struct rchan *chan, unsigned int cpu)\n{\n \tstruct rchan_buf *buf = NULL;\n\tstruct dentry *dentry;\n\n \tif (chan->is_global)\n\t\treturn *per_cpu_ptr(chan->buf, 0);\n\n\tbuf = relay_create_buf(chan);\n\tif (!buf)\n\t\treturn NULL;\n\n\tif (chan->has_base_filename) {\n\t\tdentry = relay_create_buf_file(chan, buf, cpu);\n\t\tif (!dentry)\n\t\t\tgoto free_buf;\n\t\trelay_set_buf_dentry(buf, dentry);\n\t} else {\n\t\t/* Only retrieve global info, nothing more, nothing less */\n\t\tdentry = chan->cb->create_buf_file(NULL, NULL,\n\t\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t\t   &chan->is_global);\n\t\tif (WARN_ON(dentry))\n\t\t\tgoto free_buf;\n\t}\n\n \tbuf->cpu = cpu;\n \t__relay_reset(buf, 1);\n\n \tif(chan->is_global) {\n\t\t*per_cpu_ptr(chan->buf, 0) = buf;\n \t\tbuf->cpu = 0;\n  \t}\n\n\treturn buf;\n\nfree_buf:\n \trelay_destroy_buf(buf);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "cpu"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "chan",
            "&relay_channels",
            "list"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\nstatic LIST_HEAD(relay_channels);\n\nint relay_prepare_cpu(unsigned int cpu)\n{\n\tstruct rchan *chan;\n\tstruct rchan_buf *buf;\n\n\tmutex_lock(&relay_channels_mutex);\n\tlist_for_each_entry(chan, &relay_channels, list) {\n\t\tif ((buf = *per_cpu_ptr(chan->buf, cpu)))\n\t\t\tcontinue;\n\t\tbuf = relay_open_buf(chan, cpu);\n\t\tif (!buf) {\n\t\t\tpr_err(\"relay: cpu %d buffer creation failed\\n\", cpu);\n\t\t\tmutex_unlock(&relay_channels_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t*per_cpu_ptr(chan->buf, cpu) = buf;\n\t}\n\tmutex_unlock(&relay_channels_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "499-518",
    "snippet": "static void setup_callbacks(struct rchan *chan,\n\t\t\t\t   struct rchan_callbacks *cb)\n{\n\tif (!cb) {\n\t\tchan->cb = &default_channel_callbacks;\n\t\treturn;\n\t}\n\n\tif (!cb->subbuf_start)\n\t\tcb->subbuf_start = subbuf_start_default_callback;\n\tif (!cb->buf_mapped)\n\t\tcb->buf_mapped = buf_mapped_default_callback;\n\tif (!cb->buf_unmapped)\n\t\tcb->buf_unmapped = buf_unmapped_default_callback;\n\tif (!cb->create_buf_file)\n\t\tcb->create_buf_file = create_buf_file_default_callback;\n\tif (!cb->remove_buf_file)\n\t\tcb->remove_buf_file = remove_buf_file_default_callback;\n\tchan->cb = cb;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rchan_callbacks default_channel_callbacks = {\n\t.subbuf_start = subbuf_start_default_callback,\n\t.buf_mapped = buf_mapped_default_callback,\n\t.buf_unmapped = buf_unmapped_default_callback,\n\t.create_buf_file = create_buf_file_default_callback,\n\t.remove_buf_file = remove_buf_file_default_callback,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct rchan_callbacks default_channel_callbacks = {\n\t.subbuf_start = subbuf_start_default_callback,\n\t.buf_mapped = buf_mapped_default_callback,\n\t.buf_unmapped = buf_unmapped_default_callback,\n\t.create_buf_file = create_buf_file_default_callback,\n\t.remove_buf_file = remove_buf_file_default_callback,\n};\n\nstatic void setup_callbacks(struct rchan *chan,\n\t\t\t\t   struct rchan_callbacks *cb)\n{\n\tif (!cb) {\n\t\tchan->cb = &default_channel_callbacks;\n\t\treturn;\n\t}\n\n\tif (!cb->subbuf_start)\n\t\tcb->subbuf_start = subbuf_start_default_callback;\n\tif (!cb->buf_mapped)\n\t\tcb->buf_mapped = buf_mapped_default_callback;\n\tif (!cb->buf_unmapped)\n\t\tcb->buf_unmapped = buf_unmapped_default_callback;\n\tif (!cb->create_buf_file)\n\t\tcb->create_buf_file = create_buf_file_default_callback;\n\tif (!cb->remove_buf_file)\n\t\tcb->remove_buf_file = remove_buf_file_default_callback;\n\tchan->cb = cb;\n}"
  },
  {
    "function_name": "relay_close_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "491-497",
    "snippet": "static void relay_close_buf(struct rchan_buf *buf)\n{\n\tbuf->finalized = 1;\n\tirq_work_sync(&buf->wakeup_work);\n\tbuf->chan->cb->remove_buf_file(buf->dentry);\n\tkref_put(&buf->kref, relay_remove_buf);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&buf->kref",
            "relay_remove_buf"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->chan->cb->remove_buf_file",
          "args": [
            "buf->dentry"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_sync",
          "args": [
            "&buf->wakeup_work"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "188-194",
          "snippet": "void irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\n\twhile (work->flags & IRQ_WORK_BUSY)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\n\twhile (work->flags & IRQ_WORK_BUSY)\n\t\tcpu_relax();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_close_buf(struct rchan_buf *buf)\n{\n\tbuf->finalized = 1;\n\tirq_work_sync(&buf->wakeup_work);\n\tbuf->chan->cb->remove_buf_file(buf->dentry);\n\tkref_put(&buf->kref, relay_remove_buf);\n}"
  },
  {
    "function_name": "relay_open_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "442-481",
    "snippet": "static struct rchan_buf *relay_open_buf(struct rchan *chan, unsigned int cpu)\n{\n \tstruct rchan_buf *buf = NULL;\n\tstruct dentry *dentry;\n\n \tif (chan->is_global)\n\t\treturn *per_cpu_ptr(chan->buf, 0);\n\n\tbuf = relay_create_buf(chan);\n\tif (!buf)\n\t\treturn NULL;\n\n\tif (chan->has_base_filename) {\n\t\tdentry = relay_create_buf_file(chan, buf, cpu);\n\t\tif (!dentry)\n\t\t\tgoto free_buf;\n\t\trelay_set_buf_dentry(buf, dentry);\n\t} else {\n\t\t/* Only retrieve global info, nothing more, nothing less */\n\t\tdentry = chan->cb->create_buf_file(NULL, NULL,\n\t\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t\t   &chan->is_global);\n\t\tif (WARN_ON(dentry))\n\t\t\tgoto free_buf;\n\t}\n\n \tbuf->cpu = cpu;\n \t__relay_reset(buf, 1);\n\n \tif(chan->is_global) {\n\t\t*per_cpu_ptr(chan->buf, 0) = buf;\n \t\tbuf->cpu = 0;\n  \t}\n\n\treturn buf;\n\nfree_buf:\n \trelay_destroy_buf(buf);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_destroy_buf",
          "args": [
            "buf"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "relay_destroy_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "207-222",
          "snippet": "static void relay_destroy_buf(struct rchan_buf *buf)\n{\n\tstruct rchan *chan = buf->chan;\n\tunsigned int i;\n\n\tif (likely(buf->start)) {\n\t\tvunmap(buf->start);\n\t\tfor (i = 0; i < buf->page_count; i++)\n\t\t\t__free_page(buf->page_array[i]);\n\t\trelay_free_page_array(buf->page_array);\n\t}\n\t*per_cpu_ptr(chan->buf, buf->cpu) = NULL;\n\tkfree(buf->padding);\n\tkfree(buf);\n\tkref_put(&chan->kref, relay_destroy_channel);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_destroy_buf(struct rchan_buf *buf)\n{\n\tstruct rchan *chan = buf->chan;\n\tunsigned int i;\n\n\tif (likely(buf->start)) {\n\t\tvunmap(buf->start);\n\t\tfor (i = 0; i < buf->page_count; i++)\n\t\t\t__free_page(buf->page_array[i]);\n\t\trelay_free_page_array(buf->page_array);\n\t}\n\t*per_cpu_ptr(chan->buf, buf->cpu) = NULL;\n\tkfree(buf->padding);\n\tkfree(buf);\n\tkref_put(&chan->kref, relay_destroy_channel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "0"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__relay_reset",
          "args": [
            "buf",
            "1"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "__relay_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "351-374",
          "snippet": "static void __relay_reset(struct rchan_buf *buf, unsigned int init)\n{\n\tsize_t i;\n\n\tif (init) {\n\t\tinit_waitqueue_head(&buf->read_wait);\n\t\tkref_init(&buf->kref);\n\t\tinit_irq_work(&buf->wakeup_work, wakeup_readers);\n\t} else {\n\t\tirq_work_sync(&buf->wakeup_work);\n\t}\n\n\tbuf->subbufs_produced = 0;\n\tbuf->subbufs_consumed = 0;\n\tbuf->bytes_consumed = 0;\n\tbuf->finalized = 0;\n\tbuf->data = buf->start;\n\tbuf->offset = 0;\n\n\tfor (i = 0; i < buf->chan->n_subbufs; i++)\n\t\tbuf->padding[i] = 0;\n\n\tbuf->chan->cb->subbuf_start(buf, buf->data, NULL, 0);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void __relay_reset(struct rchan_buf *buf, unsigned int init)\n{\n\tsize_t i;\n\n\tif (init) {\n\t\tinit_waitqueue_head(&buf->read_wait);\n\t\tkref_init(&buf->kref);\n\t\tinit_irq_work(&buf->wakeup_work, wakeup_readers);\n\t} else {\n\t\tirq_work_sync(&buf->wakeup_work);\n\t}\n\n\tbuf->subbufs_produced = 0;\n\tbuf->subbufs_consumed = 0;\n\tbuf->bytes_consumed = 0;\n\tbuf->finalized = 0;\n\tbuf->data = buf->start;\n\tbuf->offset = 0;\n\n\tfor (i = 0; i < buf->chan->n_subbufs; i++)\n\t\tbuf->padding[i] = 0;\n\n\tbuf->chan->cb->subbuf_start(buf, buf->data, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "dentry"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chan->cb->create_buf_file",
          "args": [
            "NULL",
            "NULL",
            "S_IRUSR",
            "buf",
            "&chan->is_global"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_set_buf_dentry",
          "args": [
            "buf",
            "dentry"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "relay_set_buf_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "408-413",
          "snippet": "static inline void relay_set_buf_dentry(struct rchan_buf *buf,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\tbuf->dentry = dentry;\n\td_inode(buf->dentry)->i_size = buf->early_bytes;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic inline void relay_set_buf_dentry(struct rchan_buf *buf,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\tbuf->dentry = dentry;\n\td_inode(buf->dentry)->i_size = buf->early_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_create_buf_file",
          "args": [
            "chan",
            "buf",
            "cpu"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "relay_create_buf_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "415-435",
          "snippet": "static struct dentry *relay_create_buf_file(struct rchan *chan,\n\t\t\t\t\t    struct rchan_buf *buf,\n\t\t\t\t\t    unsigned int cpu)\n{\n\tstruct dentry *dentry;\n\tchar *tmpname;\n\n\ttmpname = kzalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!tmpname)\n\t\treturn NULL;\n\tsnprintf(tmpname, NAME_MAX, \"%s%d\", chan->base_filename, cpu);\n\n\t/* Create file in fs */\n\tdentry = chan->cb->create_buf_file(tmpname, chan->parent,\n\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t   &chan->is_global);\n\n\tkfree(tmpname);\n\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct dentry *relay_create_buf_file(struct rchan *chan,\n\t\t\t\t\t    struct rchan_buf *buf,\n\t\t\t\t\t    unsigned int cpu)\n{\n\tstruct dentry *dentry;\n\tchar *tmpname;\n\n\ttmpname = kzalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!tmpname)\n\t\treturn NULL;\n\tsnprintf(tmpname, NAME_MAX, \"%s%d\", chan->base_filename, cpu);\n\n\t/* Create file in fs */\n\tdentry = chan->cb->create_buf_file(tmpname, chan->parent,\n\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t   &chan->is_global);\n\n\tkfree(tmpname);\n\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_create_buf",
          "args": [
            "chan"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "relay_create_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "162-189",
          "snippet": "static struct rchan_buf *relay_create_buf(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\n\tif (chan->n_subbufs > KMALLOC_MAX_SIZE / sizeof(size_t *))\n\t\treturn NULL;\n\n\tbuf = kzalloc(sizeof(struct rchan_buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->padding = kmalloc_array(chan->n_subbufs, sizeof(size_t *),\n\t\t\t\t     GFP_KERNEL);\n\tif (!buf->padding)\n\t\tgoto free_buf;\n\n\tbuf->start = relay_alloc_buf(buf, &chan->alloc_size);\n\tif (!buf->start)\n\t\tgoto free_buf;\n\n\tbuf->chan = chan;\n\tkref_get(&buf->chan->kref);\n\treturn buf;\n\nfree_buf:\n\tkfree(buf->padding);\n\tkfree(buf);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct rchan_buf *relay_create_buf(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\n\tif (chan->n_subbufs > KMALLOC_MAX_SIZE / sizeof(size_t *))\n\t\treturn NULL;\n\n\tbuf = kzalloc(sizeof(struct rchan_buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->padding = kmalloc_array(chan->n_subbufs, sizeof(size_t *),\n\t\t\t\t     GFP_KERNEL);\n\tif (!buf->padding)\n\t\tgoto free_buf;\n\n\tbuf->start = relay_alloc_buf(buf, &chan->alloc_size);\n\tif (!buf->start)\n\t\tgoto free_buf;\n\n\tbuf->chan = chan;\n\tkref_get(&buf->chan->kref);\n\treturn buf;\n\nfree_buf:\n\tkfree(buf->padding);\n\tkfree(buf);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "0"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct rchan_buf *relay_open_buf(struct rchan *chan, unsigned int cpu)\n{\n \tstruct rchan_buf *buf = NULL;\n\tstruct dentry *dentry;\n\n \tif (chan->is_global)\n\t\treturn *per_cpu_ptr(chan->buf, 0);\n\n\tbuf = relay_create_buf(chan);\n\tif (!buf)\n\t\treturn NULL;\n\n\tif (chan->has_base_filename) {\n\t\tdentry = relay_create_buf_file(chan, buf, cpu);\n\t\tif (!dentry)\n\t\t\tgoto free_buf;\n\t\trelay_set_buf_dentry(buf, dentry);\n\t} else {\n\t\t/* Only retrieve global info, nothing more, nothing less */\n\t\tdentry = chan->cb->create_buf_file(NULL, NULL,\n\t\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t\t   &chan->is_global);\n\t\tif (WARN_ON(dentry))\n\t\t\tgoto free_buf;\n\t}\n\n \tbuf->cpu = cpu;\n \t__relay_reset(buf, 1);\n\n \tif(chan->is_global) {\n\t\t*per_cpu_ptr(chan->buf, 0) = buf;\n \t\tbuf->cpu = 0;\n  \t}\n\n\treturn buf;\n\nfree_buf:\n \trelay_destroy_buf(buf);\n\treturn NULL;\n}"
  },
  {
    "function_name": "relay_create_buf_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "415-435",
    "snippet": "static struct dentry *relay_create_buf_file(struct rchan *chan,\n\t\t\t\t\t    struct rchan_buf *buf,\n\t\t\t\t\t    unsigned int cpu)\n{\n\tstruct dentry *dentry;\n\tchar *tmpname;\n\n\ttmpname = kzalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!tmpname)\n\t\treturn NULL;\n\tsnprintf(tmpname, NAME_MAX, \"%s%d\", chan->base_filename, cpu);\n\n\t/* Create file in fs */\n\tdentry = chan->cb->create_buf_file(tmpname, chan->parent,\n\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t   &chan->is_global);\n\n\tkfree(tmpname);\n\n\treturn dentry;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpname"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chan->cb->create_buf_file",
          "args": [
            "tmpname",
            "chan->parent",
            "S_IRUSR",
            "buf",
            "&chan->is_global"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmpname",
            "NAME_MAX",
            "\"%s%d\"",
            "chan->base_filename",
            "cpu"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "NAME_MAX + 1",
            "GFP_KERNEL"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct dentry *relay_create_buf_file(struct rchan *chan,\n\t\t\t\t\t    struct rchan_buf *buf,\n\t\t\t\t\t    unsigned int cpu)\n{\n\tstruct dentry *dentry;\n\tchar *tmpname;\n\n\ttmpname = kzalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!tmpname)\n\t\treturn NULL;\n\tsnprintf(tmpname, NAME_MAX, \"%s%d\", chan->base_filename, cpu);\n\n\t/* Create file in fs */\n\tdentry = chan->cb->create_buf_file(tmpname, chan->parent,\n\t\t\t\t\t   S_IRUSR, buf,\n\t\t\t\t\t   &chan->is_global);\n\n\tkfree(tmpname);\n\n\treturn dentry;\n}"
  },
  {
    "function_name": "relay_set_buf_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "408-413",
    "snippet": "static inline void relay_set_buf_dentry(struct rchan_buf *buf,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\tbuf->dentry = dentry;\n\td_inode(buf->dentry)->i_size = buf->early_bytes;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "buf->dentry"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic inline void relay_set_buf_dentry(struct rchan_buf *buf,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\tbuf->dentry = dentry;\n\td_inode(buf->dentry)->i_size = buf->early_bytes;\n}"
  },
  {
    "function_name": "relay_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "387-405",
    "snippet": "void relay_reset(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0))) {\n\t\t__relay_reset(buf, 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\t__relay_reset(buf, 0);\n\tmutex_unlock(&relay_channels_mutex);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(relay_channels_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__relay_reset",
          "args": [
            "buf",
            "0"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "__relay_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "351-374",
          "snippet": "static void __relay_reset(struct rchan_buf *buf, unsigned int init)\n{\n\tsize_t i;\n\n\tif (init) {\n\t\tinit_waitqueue_head(&buf->read_wait);\n\t\tkref_init(&buf->kref);\n\t\tinit_irq_work(&buf->wakeup_work, wakeup_readers);\n\t} else {\n\t\tirq_work_sync(&buf->wakeup_work);\n\t}\n\n\tbuf->subbufs_produced = 0;\n\tbuf->subbufs_consumed = 0;\n\tbuf->bytes_consumed = 0;\n\tbuf->finalized = 0;\n\tbuf->data = buf->start;\n\tbuf->offset = 0;\n\n\tfor (i = 0; i < buf->chan->n_subbufs; i++)\n\t\tbuf->padding[i] = 0;\n\n\tbuf->chan->cb->subbuf_start(buf, buf->data, NULL, 0);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void __relay_reset(struct rchan_buf *buf, unsigned int init)\n{\n\tsize_t i;\n\n\tif (init) {\n\t\tinit_waitqueue_head(&buf->read_wait);\n\t\tkref_init(&buf->kref);\n\t\tinit_irq_work(&buf->wakeup_work, wakeup_readers);\n\t} else {\n\t\tirq_work_sync(&buf->wakeup_work);\n\t}\n\n\tbuf->subbufs_produced = 0;\n\tbuf->subbufs_consumed = 0;\n\tbuf->bytes_consumed = 0;\n\tbuf->finalized = 0;\n\tbuf->data = buf->start;\n\tbuf->offset = 0;\n\n\tfor (i = 0; i < buf->chan->n_subbufs; i++)\n\t\tbuf->padding[i] = 0;\n\n\tbuf->chan->cb->subbuf_start(buf, buf->data, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "i"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&relay_channels_mutex"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "0"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\n\nvoid relay_reset(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0))) {\n\t\t__relay_reset(buf, 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\t__relay_reset(buf, 0);\n\tmutex_unlock(&relay_channels_mutex);\n}"
  },
  {
    "function_name": "__relay_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "351-374",
    "snippet": "static void __relay_reset(struct rchan_buf *buf, unsigned int init)\n{\n\tsize_t i;\n\n\tif (init) {\n\t\tinit_waitqueue_head(&buf->read_wait);\n\t\tkref_init(&buf->kref);\n\t\tinit_irq_work(&buf->wakeup_work, wakeup_readers);\n\t} else {\n\t\tirq_work_sync(&buf->wakeup_work);\n\t}\n\n\tbuf->subbufs_produced = 0;\n\tbuf->subbufs_consumed = 0;\n\tbuf->bytes_consumed = 0;\n\tbuf->finalized = 0;\n\tbuf->data = buf->start;\n\tbuf->offset = 0;\n\n\tfor (i = 0; i < buf->chan->n_subbufs; i++)\n\t\tbuf->padding[i] = 0;\n\n\tbuf->chan->cb->subbuf_start(buf, buf->data, NULL, 0);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buf->chan->cb->subbuf_start",
          "args": [
            "buf",
            "buf->data",
            "NULL",
            "0"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_sync",
          "args": [
            "&buf->wakeup_work"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "188-194",
          "snippet": "void irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\n\twhile (work->flags & IRQ_WORK_BUSY)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\n\twhile (work->flags & IRQ_WORK_BUSY)\n\t\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&buf->wakeup_work",
            "wakeup_readers"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&buf->kref"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&buf->read_wait"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void __relay_reset(struct rchan_buf *buf, unsigned int init)\n{\n\tsize_t i;\n\n\tif (init) {\n\t\tinit_waitqueue_head(&buf->read_wait);\n\t\tkref_init(&buf->kref);\n\t\tinit_irq_work(&buf->wakeup_work, wakeup_readers);\n\t} else {\n\t\tirq_work_sync(&buf->wakeup_work);\n\t}\n\n\tbuf->subbufs_produced = 0;\n\tbuf->subbufs_consumed = 0;\n\tbuf->bytes_consumed = 0;\n\tbuf->finalized = 0;\n\tbuf->data = buf->start;\n\tbuf->offset = 0;\n\n\tfor (i = 0; i < buf->chan->n_subbufs; i++)\n\t\tbuf->padding[i] = 0;\n\n\tbuf->chan->cb->subbuf_start(buf, buf->data, NULL, 0);\n}"
  },
  {
    "function_name": "wakeup_readers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "336-342",
    "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&buf->read_wait"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structrchan_buf",
            "wakeup_work"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
  },
  {
    "function_name": "remove_buf_file_default_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "316-319",
    "snippet": "static int remove_buf_file_default_callback(struct dentry *dentry)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic int remove_buf_file_default_callback(struct dentry *dentry)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "create_buf_file_default_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "304-311",
    "snippet": "static struct dentry *create_buf_file_default_callback(const char *filename,\n\t\t\t\t\t\t       struct dentry *parent,\n\t\t\t\t\t\t       umode_t mode,\n\t\t\t\t\t\t       struct rchan_buf *buf,\n\t\t\t\t\t\t       int *is_global)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct dentry *create_buf_file_default_callback(const char *filename,\n\t\t\t\t\t\t       struct dentry *parent,\n\t\t\t\t\t\t       umode_t mode,\n\t\t\t\t\t\t       struct rchan_buf *buf,\n\t\t\t\t\t\t       int *is_global)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "buf_unmapped_default_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "296-299",
    "snippet": "static void buf_unmapped_default_callback(struct rchan_buf *buf,\n\t\t\t\t\t  struct file *filp)\n{\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void buf_unmapped_default_callback(struct rchan_buf *buf,\n\t\t\t\t\t  struct file *filp)\n{\n}"
  },
  {
    "function_name": "buf_mapped_default_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "288-291",
    "snippet": "static void buf_mapped_default_callback(struct rchan_buf *buf,\n\t\t\t\t\tstruct file *filp)\n{\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void buf_mapped_default_callback(struct rchan_buf *buf,\n\t\t\t\t\tstruct file *filp)\n{\n}"
  },
  {
    "function_name": "subbuf_start_default_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "274-283",
    "snippet": "static int subbuf_start_default_callback (struct rchan_buf *buf,\n\t\t\t\t\t  void *subbuf,\n\t\t\t\t\t  void *prev_subbuf,\n\t\t\t\t\t  size_t prev_padding)\n{\n\tif (relay_buf_full(buf))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_buf_full",
          "args": [
            "buf"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "relay_buf_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "255-259",
          "snippet": "int relay_buf_full(struct rchan_buf *buf)\n{\n\tsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\n\treturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nint relay_buf_full(struct rchan_buf *buf)\n{\n\tsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\n\treturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic int subbuf_start_default_callback (struct rchan_buf *buf,\n\t\t\t\t\t  void *subbuf,\n\t\t\t\t\t  void *prev_subbuf,\n\t\t\t\t\t  size_t prev_padding)\n{\n\tif (relay_buf_full(buf))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "relay_buf_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "255-259",
    "snippet": "int relay_buf_full(struct rchan_buf *buf)\n{\n\tsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\n\treturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nint relay_buf_full(struct rchan_buf *buf)\n{\n\tsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\n\treturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\n}"
  },
  {
    "function_name": "relay_buf_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "244-247",
    "snippet": "static int relay_buf_empty(struct rchan_buf *buf)\n{\n\treturn (buf->subbufs_produced - buf->subbufs_consumed) ? 0 : 1;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic int relay_buf_empty(struct rchan_buf *buf)\n{\n\treturn (buf->subbufs_produced - buf->subbufs_consumed) ? 0 : 1;\n}"
  },
  {
    "function_name": "relay_remove_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "232-236",
    "snippet": "static void relay_remove_buf(struct kref *kref)\n{\n\tstruct rchan_buf *buf = container_of(kref, struct rchan_buf, kref);\n\trelay_destroy_buf(buf);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_destroy_buf",
          "args": [
            "buf"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "relay_destroy_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "207-222",
          "snippet": "static void relay_destroy_buf(struct rchan_buf *buf)\n{\n\tstruct rchan *chan = buf->chan;\n\tunsigned int i;\n\n\tif (likely(buf->start)) {\n\t\tvunmap(buf->start);\n\t\tfor (i = 0; i < buf->page_count; i++)\n\t\t\t__free_page(buf->page_array[i]);\n\t\trelay_free_page_array(buf->page_array);\n\t}\n\t*per_cpu_ptr(chan->buf, buf->cpu) = NULL;\n\tkfree(buf->padding);\n\tkfree(buf);\n\tkref_put(&chan->kref, relay_destroy_channel);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_destroy_buf(struct rchan_buf *buf)\n{\n\tstruct rchan *chan = buf->chan;\n\tunsigned int i;\n\n\tif (likely(buf->start)) {\n\t\tvunmap(buf->start);\n\t\tfor (i = 0; i < buf->page_count; i++)\n\t\t\t__free_page(buf->page_array[i]);\n\t\trelay_free_page_array(buf->page_array);\n\t}\n\t*per_cpu_ptr(chan->buf, buf->cpu) = NULL;\n\tkfree(buf->padding);\n\tkfree(buf);\n\tkref_put(&chan->kref, relay_destroy_channel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structrchan_buf",
            "kref"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_remove_buf(struct kref *kref)\n{\n\tstruct rchan_buf *buf = container_of(kref, struct rchan_buf, kref);\n\trelay_destroy_buf(buf);\n}"
  },
  {
    "function_name": "relay_destroy_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "207-222",
    "snippet": "static void relay_destroy_buf(struct rchan_buf *buf)\n{\n\tstruct rchan *chan = buf->chan;\n\tunsigned int i;\n\n\tif (likely(buf->start)) {\n\t\tvunmap(buf->start);\n\t\tfor (i = 0; i < buf->page_count; i++)\n\t\t\t__free_page(buf->page_array[i]);\n\t\trelay_free_page_array(buf->page_array);\n\t}\n\t*per_cpu_ptr(chan->buf, buf->cpu) = NULL;\n\tkfree(buf->padding);\n\tkfree(buf);\n\tkref_put(&chan->kref, relay_destroy_channel);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&chan->kref",
            "relay_destroy_channel"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "chan->buf",
            "buf->cpu"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_free_page_array",
          "args": [
            "buf->page_array"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "relay_free_page_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "82-85",
          "snippet": "static void relay_free_page_array(struct page **array)\n{\n\tkvfree(array);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_free_page_array(struct page **array)\n{\n\tkvfree(array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "buf->page_array[i]"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vunmap",
          "args": [
            "buf->start"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "buf->start"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_destroy_buf(struct rchan_buf *buf)\n{\n\tstruct rchan *chan = buf->chan;\n\tunsigned int i;\n\n\tif (likely(buf->start)) {\n\t\tvunmap(buf->start);\n\t\tfor (i = 0; i < buf->page_count; i++)\n\t\t\t__free_page(buf->page_array[i]);\n\t\trelay_free_page_array(buf->page_array);\n\t}\n\t*per_cpu_ptr(chan->buf, buf->cpu) = NULL;\n\tkfree(buf->padding);\n\tkfree(buf);\n\tkref_put(&chan->kref, relay_destroy_channel);\n}"
  },
  {
    "function_name": "relay_destroy_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "197-201",
    "snippet": "static void relay_destroy_channel(struct kref *kref)\n{\n\tstruct rchan *chan = container_of(kref, struct rchan, kref);\n\tkfree(chan);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "chan"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structrchan",
            "kref"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_destroy_channel(struct kref *kref)\n{\n\tstruct rchan *chan = container_of(kref, struct rchan, kref);\n\tkfree(chan);\n}"
  },
  {
    "function_name": "relay_create_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "162-189",
    "snippet": "static struct rchan_buf *relay_create_buf(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\n\tif (chan->n_subbufs > KMALLOC_MAX_SIZE / sizeof(size_t *))\n\t\treturn NULL;\n\n\tbuf = kzalloc(sizeof(struct rchan_buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->padding = kmalloc_array(chan->n_subbufs, sizeof(size_t *),\n\t\t\t\t     GFP_KERNEL);\n\tif (!buf->padding)\n\t\tgoto free_buf;\n\n\tbuf->start = relay_alloc_buf(buf, &chan->alloc_size);\n\tif (!buf->start)\n\t\tgoto free_buf;\n\n\tbuf->chan = chan;\n\tkref_get(&buf->chan->kref);\n\treturn buf;\n\nfree_buf:\n\tkfree(buf->padding);\n\tkfree(buf);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&buf->chan->kref"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/autogroup.c",
          "lines": "43-47",
          "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_alloc_buf",
          "args": [
            "buf",
            "&chan->alloc_size"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "relay_alloc_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "123-154",
          "snippet": "static void *relay_alloc_buf(struct rchan_buf *buf, size_t *size)\n{\n\tvoid *mem;\n\tunsigned int i, j, n_pages;\n\n\t*size = PAGE_ALIGN(*size);\n\tn_pages = *size >> PAGE_SHIFT;\n\n\tbuf->page_array = relay_alloc_page_array(n_pages);\n\tif (!buf->page_array)\n\t\treturn NULL;\n\n\tfor (i = 0; i < n_pages; i++) {\n\t\tbuf->page_array[i] = alloc_page(GFP_KERNEL);\n\t\tif (unlikely(!buf->page_array[i]))\n\t\t\tgoto depopulate;\n\t\tset_page_private(buf->page_array[i], (unsigned long)buf);\n\t}\n\tmem = vmap(buf->page_array, n_pages, VM_MAP, PAGE_KERNEL);\n\tif (!mem)\n\t\tgoto depopulate;\n\n\tmemset(mem, 0, *size);\n\tbuf->page_count = n_pages;\n\treturn mem;\n\ndepopulate:\n\tfor (j = 0; j < i; j++)\n\t\t__free_page(buf->page_array[j]);\n\trelay_free_page_array(buf->page_array);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void *relay_alloc_buf(struct rchan_buf *buf, size_t *size)\n{\n\tvoid *mem;\n\tunsigned int i, j, n_pages;\n\n\t*size = PAGE_ALIGN(*size);\n\tn_pages = *size >> PAGE_SHIFT;\n\n\tbuf->page_array = relay_alloc_page_array(n_pages);\n\tif (!buf->page_array)\n\t\treturn NULL;\n\n\tfor (i = 0; i < n_pages; i++) {\n\t\tbuf->page_array[i] = alloc_page(GFP_KERNEL);\n\t\tif (unlikely(!buf->page_array[i]))\n\t\t\tgoto depopulate;\n\t\tset_page_private(buf->page_array[i], (unsigned long)buf);\n\t}\n\tmem = vmap(buf->page_array, n_pages, VM_MAP, PAGE_KERNEL);\n\tif (!mem)\n\t\tgoto depopulate;\n\n\tmemset(mem, 0, *size);\n\tbuf->page_count = n_pages;\n\treturn mem;\n\ndepopulate:\n\tfor (j = 0; j < i; j++)\n\t\t__free_page(buf->page_array[j]);\n\trelay_free_page_array(buf->page_array);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "chan->n_subbufs",
            "sizeof(size_t *)",
            "GFP_KERNEL"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct rchan_buf)",
            "GFP_KERNEL"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct rchan_buf *relay_create_buf(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\n\tif (chan->n_subbufs > KMALLOC_MAX_SIZE / sizeof(size_t *))\n\t\treturn NULL;\n\n\tbuf = kzalloc(sizeof(struct rchan_buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->padding = kmalloc_array(chan->n_subbufs, sizeof(size_t *),\n\t\t\t\t     GFP_KERNEL);\n\tif (!buf->padding)\n\t\tgoto free_buf;\n\n\tbuf->start = relay_alloc_buf(buf, &chan->alloc_size);\n\tif (!buf->start)\n\t\tgoto free_buf;\n\n\tbuf->chan = chan;\n\tkref_get(&buf->chan->kref);\n\treturn buf;\n\nfree_buf:\n\tkfree(buf->padding);\n\tkfree(buf);\n\treturn NULL;\n}"
  },
  {
    "function_name": "relay_alloc_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "123-154",
    "snippet": "static void *relay_alloc_buf(struct rchan_buf *buf, size_t *size)\n{\n\tvoid *mem;\n\tunsigned int i, j, n_pages;\n\n\t*size = PAGE_ALIGN(*size);\n\tn_pages = *size >> PAGE_SHIFT;\n\n\tbuf->page_array = relay_alloc_page_array(n_pages);\n\tif (!buf->page_array)\n\t\treturn NULL;\n\n\tfor (i = 0; i < n_pages; i++) {\n\t\tbuf->page_array[i] = alloc_page(GFP_KERNEL);\n\t\tif (unlikely(!buf->page_array[i]))\n\t\t\tgoto depopulate;\n\t\tset_page_private(buf->page_array[i], (unsigned long)buf);\n\t}\n\tmem = vmap(buf->page_array, n_pages, VM_MAP, PAGE_KERNEL);\n\tif (!mem)\n\t\tgoto depopulate;\n\n\tmemset(mem, 0, *size);\n\tbuf->page_count = n_pages;\n\treturn mem;\n\ndepopulate:\n\tfor (j = 0; j < i; j++)\n\t\t__free_page(buf->page_array[j]);\n\trelay_free_page_array(buf->page_array);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_free_page_array",
          "args": [
            "buf->page_array"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "relay_free_page_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "82-85",
          "snippet": "static void relay_free_page_array(struct page **array)\n{\n\tkvfree(array);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_free_page_array(struct page **array)\n{\n\tkvfree(array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "buf->page_array[j]"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mem",
            "0",
            "*size"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmap",
          "args": [
            "buf->page_array",
            "n_pages",
            "VM_MAP",
            "PAGE_KERNEL"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "buf->page_array[i]",
            "(unsigned long)buf"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buf->page_array[i]"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "relay_alloc_page_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "71-77",
          "snippet": "static struct page **relay_alloc_page_array(unsigned int n_pages)\n{\n\tconst size_t pa_size = n_pages * sizeof(struct page *);\n\tif (pa_size > PAGE_SIZE)\n\t\treturn vzalloc(pa_size);\n\treturn kzalloc(pa_size, GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct page **relay_alloc_page_array(unsigned int n_pages)\n{\n\tconst size_t pa_size = n_pages * sizeof(struct page *);\n\tif (pa_size > PAGE_SIZE)\n\t\treturn vzalloc(pa_size);\n\treturn kzalloc(pa_size, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "*size"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void *relay_alloc_buf(struct rchan_buf *buf, size_t *size)\n{\n\tvoid *mem;\n\tunsigned int i, j, n_pages;\n\n\t*size = PAGE_ALIGN(*size);\n\tn_pages = *size >> PAGE_SHIFT;\n\n\tbuf->page_array = relay_alloc_page_array(n_pages);\n\tif (!buf->page_array)\n\t\treturn NULL;\n\n\tfor (i = 0; i < n_pages; i++) {\n\t\tbuf->page_array[i] = alloc_page(GFP_KERNEL);\n\t\tif (unlikely(!buf->page_array[i]))\n\t\t\tgoto depopulate;\n\t\tset_page_private(buf->page_array[i], (unsigned long)buf);\n\t}\n\tmem = vmap(buf->page_array, n_pages, VM_MAP, PAGE_KERNEL);\n\tif (!mem)\n\t\tgoto depopulate;\n\n\tmemset(mem, 0, *size);\n\tbuf->page_count = n_pages;\n\treturn mem;\n\ndepopulate:\n\tfor (j = 0; j < i; j++)\n\t\t__free_page(buf->page_array[j]);\n\trelay_free_page_array(buf->page_array);\n\treturn NULL;\n}"
  },
  {
    "function_name": "relay_mmap_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "96-113",
    "snippet": "static int relay_mmap_buf(struct rchan_buf *buf, struct vm_area_struct *vma)\n{\n\tunsigned long length = vma->vm_end - vma->vm_start;\n\tstruct file *filp = vma->vm_file;\n\n\tif (!buf)\n\t\treturn -EBADF;\n\n\tif (length != (unsigned long)buf->chan->alloc_size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &relay_file_mmap_ops;\n\tvma->vm_flags |= VM_DONTEXPAND;\n\tvma->vm_private_data = buf;\n\tbuf->chan->cb->buf_mapped(buf, filp);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct relay_file_mmap_ops = {\n\t.fault = relay_buf_fault,\n\t.close = relay_file_mmap_close,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "buf->chan->cb->buf_mapped",
          "args": [
            "buf",
            "filp"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic const struct vm_operations_struct relay_file_mmap_ops = {\n\t.fault = relay_buf_fault,\n\t.close = relay_file_mmap_close,\n};\n\nstatic int relay_mmap_buf(struct rchan_buf *buf, struct vm_area_struct *vma)\n{\n\tunsigned long length = vma->vm_end - vma->vm_start;\n\tstruct file *filp = vma->vm_file;\n\n\tif (!buf)\n\t\treturn -EBADF;\n\n\tif (length != (unsigned long)buf->chan->alloc_size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &relay_file_mmap_ops;\n\tvma->vm_flags |= VM_DONTEXPAND;\n\tvma->vm_private_data = buf;\n\tbuf->chan->cb->buf_mapped(buf, filp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "relay_free_page_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "82-85",
    "snippet": "static void relay_free_page_array(struct page **array)\n{\n\tkvfree(array);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "array"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_free_page_array(struct page **array)\n{\n\tkvfree(array);\n}"
  },
  {
    "function_name": "relay_alloc_page_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "71-77",
    "snippet": "static struct page **relay_alloc_page_array(unsigned int n_pages)\n{\n\tconst size_t pa_size = n_pages * sizeof(struct page *);\n\tif (pa_size > PAGE_SIZE)\n\t\treturn vzalloc(pa_size);\n\treturn kzalloc(pa_size, GFP_KERNEL);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "pa_size",
            "GFP_KERNEL"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "pa_size"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic struct page **relay_alloc_page_array(unsigned int n_pages)\n{\n\tconst size_t pa_size = n_pages * sizeof(struct page *);\n\tif (pa_size > PAGE_SIZE)\n\t\treturn vzalloc(pa_size);\n\treturn kzalloc(pa_size, GFP_KERNEL);\n}"
  },
  {
    "function_name": "relay_buf_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "42-58",
    "snippet": "static vm_fault_t relay_buf_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tstruct rchan_buf *buf = vmf->vma->vm_private_data;\n\tpgoff_t pgoff = vmf->pgoff;\n\n\tif (!buf)\n\t\treturn VM_FAULT_OOM;\n\n\tpage = vmalloc_to_page(buf->start + (pgoff << PAGE_SHIFT));\n\tif (!page)\n\t\treturn VM_FAULT_SIGBUS;\n\tget_page(page);\n\tvmf->page = page;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "buf->start + (pgoff << PAGE_SHIFT)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic vm_fault_t relay_buf_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tstruct rchan_buf *buf = vmf->vma->vm_private_data;\n\tpgoff_t pgoff = vmf->pgoff;\n\n\tif (!buf)\n\t\treturn VM_FAULT_OOM;\n\n\tpage = vmalloc_to_page(buf->start + (pgoff << PAGE_SHIFT));\n\tif (!page)\n\t\treturn VM_FAULT_SIGBUS;\n\tget_page(page);\n\tvmf->page = page;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "relay_file_mmap_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
    "lines": "33-37",
    "snippet": "static void relay_file_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct rchan_buf *buf = vma->vm_private_data;\n\tbuf->chan->cb->buf_unmapped(buf, vma->vm_file);\n}",
    "includes": [
      "#include <linux/splice.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/relay.h>",
      "#include <linux/string.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/stddef.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buf->chan->cb->buf_unmapped",
          "args": [
            "buf",
            "vma->vm_file"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void relay_file_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct rchan_buf *buf = vma->vm_private_data;\n\tbuf->chan->cb->buf_unmapped(buf, vma->vm_file);\n}"
  }
]