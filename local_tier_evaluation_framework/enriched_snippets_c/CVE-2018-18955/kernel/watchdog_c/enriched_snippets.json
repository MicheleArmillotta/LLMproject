[
  {
    "function_name": "lockup_detector_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "769-780",
    "snippet": "void __init lockup_detector_init(void)\n{\n\tif (tick_nohz_full_enabled())\n\t\tpr_info(\"Disabling watchdog on nohz_full cores by default\\n\");\n\n\tcpumask_copy(&watchdog_cpumask,\n\t\t     housekeeping_cpumask(HK_FLAG_TIMER));\n\n\tif (!watchdog_nmi_probe())\n\t\tnmi_watchdog_available = true;\n\tlockup_detector_setup();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask watchdog_cpumask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockup_detector_setup",
          "args": [],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "614-617",
          "snippet": "static inline void lockup_detector_setup(void)\n{\n\tlockup_detector_reconfigure();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic inline void lockup_detector_setup(void)\n{\n\tlockup_detector_reconfigure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_probe",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "117-120",
          "snippet": "__init watchdog_nmi_probe(void)\n{\n\treturn hardlockup_detector_perf_init();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n__init watchdog_nmi_probe(void)\n{\n\treturn hardlockup_detector_perf_init();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&watchdog_cpumask",
            "housekeeping_cpumask(HK_FLAG_TIMER)"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_TIMER"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/isolation.c",
          "lines": "25-31",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Disabling watchdog on nohz_full cores by default\\n\""
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_enabled",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nvoid __init lockup_detector_init(void)\n{\n\tif (tick_nohz_full_enabled())\n\t\tpr_info(\"Disabling watchdog on nohz_full cores by default\\n\");\n\n\tcpumask_copy(&watchdog_cpumask,\n\t\t     housekeeping_cpumask(HK_FLAG_TIMER));\n\n\tif (!watchdog_nmi_probe())\n\t\tnmi_watchdog_available = true;\n\tlockup_detector_setup();\n}"
  },
  {
    "function_name": "proc_watchdog_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "753-766",
    "snippet": "int proc_watchdog_cpumask(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err;\n\n\tmutex_lock(&watchdog_mutex);\n\n\terr = proc_do_large_bitmap(table, write, buffer, lenp, ppos);\n\tif (!err && write)\n\t\tproc_watchdog_update();\n\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_watchdog_update",
          "args": [],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "652-657",
          "snippet": "static void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask watchdog_cpumask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nstatic void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_do_large_bitmap",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "proc_do_large_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3057-3178",
          "snippet": "int proc_do_large_bitmap(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err = 0;\n\tbool first = 1;\n\tsize_t left = *lenp;\n\tunsigned long bitmap_len = table->maxlen;\n\tunsigned long *bitmap = *(unsigned long **) table->data;\n\tunsigned long *tmp_bitmap = NULL;\n\tchar tr_a[] = { '-', ',', '\\n' }, tr_b[] = { ',', '\\n', 0 }, c;\n\n\tif (!bitmap || !bitmap_len || !left || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tchar *kbuf, *p;\n\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\n\t\tp = kbuf = memdup_user_nul(buffer, left);\n\t\tif (IS_ERR(kbuf))\n\t\t\treturn PTR_ERR(kbuf);\n\n\t\ttmp_bitmap = kcalloc(BITS_TO_LONGS(bitmap_len),\n\t\t\t\t     sizeof(unsigned long),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!tmp_bitmap) {\n\t\t\tkfree(kbuf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tproc_skip_char(&p, &left, '\\n');\n\t\twhile (!err && left) {\n\t\t\tunsigned long val_a, val_b;\n\t\t\tbool neg;\n\n\t\t\terr = proc_get_long(&p, &left, &val_a, &neg, tr_a,\n\t\t\t\t\t     sizeof(tr_a), &c);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (val_a >= bitmap_len || neg) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval_b = val_a;\n\t\t\tif (left) {\n\t\t\t\tp++;\n\t\t\t\tleft--;\n\t\t\t}\n\n\t\t\tif (c == '-') {\n\t\t\t\terr = proc_get_long(&p, &left, &val_b,\n\t\t\t\t\t\t     &neg, tr_b, sizeof(tr_b),\n\t\t\t\t\t\t     &c);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tif (val_b >= bitmap_len || neg ||\n\t\t\t\t    val_a > val_b) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (left) {\n\t\t\t\t\tp++;\n\t\t\t\t\tleft--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbitmap_set(tmp_bitmap, val_a, val_b - val_a + 1);\n\t\t\tfirst = 0;\n\t\t\tproc_skip_char(&p, &left, '\\n');\n\t\t}\n\t\tkfree(kbuf);\n\t} else {\n\t\tunsigned long bit_a, bit_b = 0;\n\n\t\twhile (left) {\n\t\t\tbit_a = find_next_bit(bitmap, bitmap_len, bit_b);\n\t\t\tif (bit_a >= bitmap_len)\n\t\t\t\tbreak;\n\t\t\tbit_b = find_next_zero_bit(bitmap, bitmap_len,\n\t\t\t\t\t\t   bit_a + 1) - 1;\n\n\t\t\tif (!first) {\n\t\t\t\terr = proc_put_char(&buffer, &left, ',');\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = proc_put_long(&buffer, &left, bit_a, false);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (bit_a != bit_b) {\n\t\t\t\terr = proc_put_char(&buffer, &left, '-');\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\terr = proc_put_long(&buffer, &left, bit_b, false);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfirst = 0; bit_b++;\n\t\t}\n\t\tif (!err)\n\t\t\terr = proc_put_char(&buffer, &left, '\\n');\n\t}\n\n\tif (!err) {\n\t\tif (write) {\n\t\t\tif (*ppos)\n\t\t\t\tbitmap_or(bitmap, bitmap, tmp_bitmap, bitmap_len);\n\t\t\telse\n\t\t\t\tbitmap_copy(bitmap, tmp_bitmap, bitmap_len);\n\t\t}\n\t\t*lenp -= left;\n\t\t*ppos += *lenp;\n\t}\n\n\tkfree(tmp_bitmap);\n\treturn err;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_do_large_bitmap(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err = 0;\n\tbool first = 1;\n\tsize_t left = *lenp;\n\tunsigned long bitmap_len = table->maxlen;\n\tunsigned long *bitmap = *(unsigned long **) table->data;\n\tunsigned long *tmp_bitmap = NULL;\n\tchar tr_a[] = { '-', ',', '\\n' }, tr_b[] = { ',', '\\n', 0 }, c;\n\n\tif (!bitmap || !bitmap_len || !left || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tchar *kbuf, *p;\n\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\n\t\tp = kbuf = memdup_user_nul(buffer, left);\n\t\tif (IS_ERR(kbuf))\n\t\t\treturn PTR_ERR(kbuf);\n\n\t\ttmp_bitmap = kcalloc(BITS_TO_LONGS(bitmap_len),\n\t\t\t\t     sizeof(unsigned long),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!tmp_bitmap) {\n\t\t\tkfree(kbuf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tproc_skip_char(&p, &left, '\\n');\n\t\twhile (!err && left) {\n\t\t\tunsigned long val_a, val_b;\n\t\t\tbool neg;\n\n\t\t\terr = proc_get_long(&p, &left, &val_a, &neg, tr_a,\n\t\t\t\t\t     sizeof(tr_a), &c);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (val_a >= bitmap_len || neg) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval_b = val_a;\n\t\t\tif (left) {\n\t\t\t\tp++;\n\t\t\t\tleft--;\n\t\t\t}\n\n\t\t\tif (c == '-') {\n\t\t\t\terr = proc_get_long(&p, &left, &val_b,\n\t\t\t\t\t\t     &neg, tr_b, sizeof(tr_b),\n\t\t\t\t\t\t     &c);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tif (val_b >= bitmap_len || neg ||\n\t\t\t\t    val_a > val_b) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (left) {\n\t\t\t\t\tp++;\n\t\t\t\t\tleft--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbitmap_set(tmp_bitmap, val_a, val_b - val_a + 1);\n\t\t\tfirst = 0;\n\t\t\tproc_skip_char(&p, &left, '\\n');\n\t\t}\n\t\tkfree(kbuf);\n\t} else {\n\t\tunsigned long bit_a, bit_b = 0;\n\n\t\twhile (left) {\n\t\t\tbit_a = find_next_bit(bitmap, bitmap_len, bit_b);\n\t\t\tif (bit_a >= bitmap_len)\n\t\t\t\tbreak;\n\t\t\tbit_b = find_next_zero_bit(bitmap, bitmap_len,\n\t\t\t\t\t\t   bit_a + 1) - 1;\n\n\t\t\tif (!first) {\n\t\t\t\terr = proc_put_char(&buffer, &left, ',');\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = proc_put_long(&buffer, &left, bit_a, false);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (bit_a != bit_b) {\n\t\t\t\terr = proc_put_char(&buffer, &left, '-');\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\terr = proc_put_long(&buffer, &left, bit_b, false);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfirst = 0; bit_b++;\n\t\t}\n\t\tif (!err)\n\t\t\terr = proc_put_char(&buffer, &left, '\\n');\n\t}\n\n\tif (!err) {\n\t\tif (write) {\n\t\t\tif (*ppos)\n\t\t\t\tbitmap_or(bitmap, bitmap, tmp_bitmap, bitmap_len);\n\t\t\telse\n\t\t\t\tbitmap_copy(bitmap, tmp_bitmap, bitmap_len);\n\t\t}\n\t\t*lenp -= left;\n\t\t*ppos += *lenp;\n\t}\n\n\tkfree(tmp_bitmap);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nint proc_watchdog_cpumask(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err;\n\n\tmutex_lock(&watchdog_mutex);\n\n\terr = proc_do_large_bitmap(table, write, buffer, lenp, ppos);\n\tif (!err && write)\n\t\tproc_watchdog_update();\n\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "proc_watchdog_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "730-745",
    "snippet": "int proc_watchdog_thresh(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old;\n\n\tmutex_lock(&watchdog_mutex);\n\n\told = READ_ONCE(watchdog_thresh);\n\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (!err && write && old != READ_ONCE(watchdog_thresh))\n\t\tproc_watchdog_update();\n\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_watchdog_update",
          "args": [],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "652-657",
          "snippet": "static void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask watchdog_cpumask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nstatic void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "watchdog_thresh"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3200-3204",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "watchdog_thresh"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nint proc_watchdog_thresh(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old;\n\n\tmutex_lock(&watchdog_mutex);\n\n\told = READ_ONCE(watchdog_thresh);\n\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (!err && write && old != READ_ONCE(watchdog_thresh))\n\t\tproc_watchdog_update();\n\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "proc_soft_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "720-725",
    "snippet": "int proc_soft_watchdog(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn proc_watchdog_common(SOFT_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_watchdog_common",
          "args": [
            "SOFT_WATCHDOG_ENABLED",
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "671-693",
          "snippet": "static int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);",
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint proc_soft_watchdog(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn proc_watchdog_common(SOFT_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "proc_nmi_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "708-715",
    "snippet": "int proc_nmi_watchdog(struct ctl_table *table, int write,\n\t\t      void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (!nmi_watchdog_available && write)\n\t\treturn -ENOTSUPP;\n\treturn proc_watchdog_common(NMI_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_watchdog_common",
          "args": [
            "NMI_WATCHDOG_ENABLED",
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "671-693",
          "snippet": "static int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);",
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint proc_nmi_watchdog(struct ctl_table *table, int write,\n\t\t      void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (!nmi_watchdog_available && write)\n\t\treturn -ENOTSUPP;\n\treturn proc_watchdog_common(NMI_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "proc_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "698-703",
    "snippet": "int proc_watchdog(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn proc_watchdog_common(NMI_WATCHDOG_ENABLED|SOFT_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_watchdog_common",
          "args": [
            "NMI_WATCHDOG_ENABLED|SOFT_WATCHDOG_ENABLED",
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "671-693",
          "snippet": "static int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);",
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint proc_watchdog(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn proc_watchdog_common(NMI_WATCHDOG_ENABLED|SOFT_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "proc_watchdog_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "671-693",
    "snippet": "static int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);",
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_watchdog_update",
          "args": [],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "652-657",
          "snippet": "static void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask watchdog_cpumask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nstatic void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*param"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3200-3204",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*param"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "proc_watchdog_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "652-657",
    "snippet": "static void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask watchdog_cpumask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockup_detector_reconfigure",
          "args": [],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_reconfigure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "606-613",
          "snippet": "static void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "&watchdog_cpumask",
            "&watchdog_cpumask",
            "cpu_possible_mask"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nstatic void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}"
  },
  {
    "function_name": "lockup_detector_soft_poweroff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "644-647",
    "snippet": "void lockup_detector_soft_poweroff(void)\n{\n\twatchdog_enabled = 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nvoid lockup_detector_soft_poweroff(void)\n{\n\twatchdog_enabled = 0;\n}"
  },
  {
    "function_name": "lockup_detector_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "631-636",
    "snippet": "void lockup_detector_cleanup(void)\n{\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_cleanup();\n\tmutex_unlock(&watchdog_mutex);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockup_detector_cleanup",
          "args": [],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "__lockup_detector_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "620-624",
          "snippet": "static void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nstatic void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nvoid lockup_detector_cleanup(void)\n{\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_cleanup();\n\tmutex_unlock(&watchdog_mutex);\n}"
  },
  {
    "function_name": "__lockup_detector_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "620-624",
    "snippet": "static void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hardlockup_detector_perf_cleanup",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_detector_perf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "222-238",
          "snippet": "void hardlockup_detector_perf_cleanup(void)\n{\n\tint cpu;\n\n\tfor_each_cpu(cpu, &dead_events_mask) {\n\t\tstruct perf_event *event = per_cpu(dead_event, cpu);\n\n\t\t/*\n\t\t * Required because for_each_cpu() reports  unconditionally\n\t\t * CPU0 as set on UP kernels. Sigh.\n\t\t */\n\t\tif (event)\n\t\t\tperf_event_release_kernel(event);\n\t\tper_cpu(dead_event, cpu) = NULL;\n\t}\n\tcpumask_clear(&dead_events_mask);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, dead_event);",
            "static struct cpumask dead_events_mask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, dead_event);\nstatic struct cpumask dead_events_mask;\n\nvoid hardlockup_detector_perf_cleanup(void)\n{\n\tint cpu;\n\n\tfor_each_cpu(cpu, &dead_events_mask) {\n\t\tstruct perf_event *event = per_cpu(dead_event, cpu);\n\n\t\t/*\n\t\t * Required because for_each_cpu() reports  unconditionally\n\t\t * CPU0 as set on UP kernels. Sigh.\n\t\t */\n\t\tif (event)\n\t\t\tperf_event_release_kernel(event);\n\t\tper_cpu(dead_event, cpu) = NULL;\n\t}\n\tcpumask_clear(&dead_events_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nstatic void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}"
  },
  {
    "function_name": "lockup_detector_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "614-617",
    "snippet": "static inline void lockup_detector_setup(void)\n{\n\tlockup_detector_reconfigure();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockup_detector_reconfigure",
          "args": [],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_reconfigure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "606-613",
          "snippet": "static void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic inline void lockup_detector_setup(void)\n{\n\tlockup_detector_reconfigure();\n}"
  },
  {
    "function_name": "lockup_detector_reconfigure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "606-613",
    "snippet": "static void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_start",
          "args": [],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "143-143",
          "snippet": "void __weak watchdog_nmi_start(void) { }",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_start(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "lockup_detector_update_enable",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_update_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "151-160",
          "snippet": "static void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_stop",
          "args": [],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "130-130",
          "snippet": "void __weak watchdog_nmi_stop(void) { }",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_stop(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "lockup_detector_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "587-603",
    "snippet": "static __init void lockup_detector_setup(void)\n{\n\t/*\n\t * If sysctl is off and watchdog got disabled on the command line,\n\t * nothing to do here.\n\t */\n\tlockup_detector_update_enable();\n\n\tif (!IS_ENABLED(CONFIG_SYSCTL) &&\n\t    !(watchdog_enabled && watchdog_thresh))\n\t\treturn;\n\n\tmutex_lock(&watchdog_mutex);\n\tlockup_detector_reconfigure();\n\tsoftlockup_initialized = true;\n\tmutex_unlock(&watchdog_mutex);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);",
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockup_detector_reconfigure",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_reconfigure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "606-613",
          "snippet": "static void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SYSCTL"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockup_detector_update_enable",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_update_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "151-160",
          "snippet": "static void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nunsigned long __read_mostly watchdog_enabled;\n\nstatic __init void lockup_detector_setup(void)\n{\n\t/*\n\t * If sysctl is off and watchdog got disabled on the command line,\n\t * nothing to do here.\n\t */\n\tlockup_detector_update_enable();\n\n\tif (!IS_ENABLED(CONFIG_SYSCTL) &&\n\t    !(watchdog_enabled && watchdog_thresh))\n\t\treturn;\n\n\tmutex_lock(&watchdog_mutex);\n\tlockup_detector_reconfigure();\n\tsoftlockup_initialized = true;\n\tmutex_unlock(&watchdog_mutex);\n}"
  },
  {
    "function_name": "lockup_detector_reconfigure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "560-578",
    "snippet": "static void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\n\tsoftlockup_stop_all();\n\tset_sample_period();\n\tlockup_detector_update_enable();\n\tif (watchdog_enabled && watchdog_thresh)\n\t\tsoftlockup_start_all();\n\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n\t/*\n\t * Must be called outside the cpus locked section to prevent\n\t * recursive locking in the perf code.\n\t */\n\t__lockup_detector_cleanup();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lockup_detector_cleanup",
          "args": [],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "__lockup_detector_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "620-624",
          "snippet": "static void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nstatic void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_start",
          "args": [],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "143-143",
          "snippet": "void __weak watchdog_nmi_start(void) { }",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_start(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "softlockup_start_all",
          "args": [],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_start_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "539-546",
          "snippet": "static void softlockup_start_all(void)\n{\n\tint cpu;\n\n\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask watchdog_allowed_mask",
            "struct cpumask watchdog_cpumask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_allowed_mask;\nstruct cpumask watchdog_cpumask;\n\nstatic void softlockup_start_all(void)\n{\n\tint cpu;\n\n\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockup_detector_update_enable",
          "args": [],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_update_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "151-160",
          "snippet": "static void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sample_period",
          "args": [],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "set_sample_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "237-248",
          "snippet": "static void set_sample_period(void)\n{\n\t/*\n\t * convert watchdog_thresh from seconds to ns\n\t * the divide by 5 is to give hrtimer several chances (two\n\t * or three with the current relation between the soft\n\t * and hard thresholds) to increment before the\n\t * hardlockup detector generates a warning\n\t */\n\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / 5);\n\twatchdog_update_hrtimer_threshold(sample_period);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void set_sample_period(void)\n{\n\t/*\n\t * convert watchdog_thresh from seconds to ns\n\t * the divide by 5 is to give hrtimer several chances (two\n\t * or three with the current relation between the soft\n\t * and hard thresholds) to increment before the\n\t * hardlockup detector generates a warning\n\t */\n\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / 5);\n\twatchdog_update_hrtimer_threshold(sample_period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "softlockup_stop_all",
          "args": [],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_stop_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "520-531",
          "snippet": "static void softlockup_stop_all(void)\n{\n\tint cpu;\n\n\tif (!softlockup_initialized)\n\t\treturn;\n\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);\n\n\tcpumask_clear(&watchdog_allowed_mask);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask watchdog_allowed_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_allowed_mask;\n\nstatic void softlockup_stop_all(void)\n{\n\tint cpu;\n\n\tif (!softlockup_initialized)\n\t\treturn;\n\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);\n\n\tcpumask_clear(&watchdog_allowed_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_stop",
          "args": [],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "130-130",
          "snippet": "void __weak watchdog_nmi_stop(void) { }",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_stop(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\n\tsoftlockup_stop_all();\n\tset_sample_period();\n\tlockup_detector_update_enable();\n\tif (watchdog_enabled && watchdog_thresh)\n\t\tsoftlockup_start_all();\n\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n\t/*\n\t * Must be called outside the cpus locked section to prevent\n\t * recursive locking in the perf code.\n\t */\n\t__lockup_detector_cleanup();\n}"
  },
  {
    "function_name": "lockup_detector_offline_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "554-558",
    "snippet": "int lockup_detector_offline_cpu(unsigned int cpu)\n{\n\twatchdog_disable(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_disable",
          "args": [
            "cpu"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "498-512",
          "snippet": "static void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint lockup_detector_offline_cpu(unsigned int cpu)\n{\n\twatchdog_disable(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "lockup_detector_online_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "548-552",
    "snippet": "int lockup_detector_online_cpu(unsigned int cpu)\n{\n\twatchdog_enable(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_enable",
          "args": [
            "cpu"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "472-496",
          "snippet": "static void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED);\n\n\t/* Initialize timestamp */\n\t__touch_watchdog();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED);\n\n\t/* Initialize timestamp */\n\t__touch_watchdog();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint lockup_detector_online_cpu(unsigned int cpu)\n{\n\twatchdog_enable(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "softlockup_start_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "539-546",
    "snippet": "static void softlockup_start_all(void)\n{\n\tint cpu;\n\n\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask watchdog_allowed_mask",
      "struct cpumask watchdog_cpumask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_on_cpu",
          "args": [
            "cpu",
            "softlockup_start_fn",
            "NULL",
            "false"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_on_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "95-109",
          "snippet": "int smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tint ret;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tif (phys)\n\t\thypervisor_pin_vcpu(0);\n\tret = func(par);\n\tif (phys)\n\t\thypervisor_pin_vcpu(-1);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tint ret;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tif (phys)\n\t\thypervisor_pin_vcpu(0);\n\tret = func(par);\n\tif (phys)\n\t\thypervisor_pin_vcpu(-1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&watchdog_allowed_mask"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&watchdog_allowed_mask",
            "&watchdog_cpumask"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_allowed_mask;\nstruct cpumask watchdog_cpumask;\n\nstatic void softlockup_start_all(void)\n{\n\tint cpu;\n\n\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);\n}"
  },
  {
    "function_name": "softlockup_start_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "533-537",
    "snippet": "static int softlockup_start_fn(void *data)\n{\n\twatchdog_enable(smp_processor_id());\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_enable",
          "args": [
            "smp_processor_id()"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "472-496",
          "snippet": "static void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED);\n\n\t/* Initialize timestamp */\n\t__touch_watchdog();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED);\n\n\t/* Initialize timestamp */\n\t__touch_watchdog();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int softlockup_start_fn(void *data)\n{\n\twatchdog_enable(smp_processor_id());\n\treturn 0;\n}"
  },
  {
    "function_name": "softlockup_stop_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "520-531",
    "snippet": "static void softlockup_stop_all(void)\n{\n\tint cpu;\n\n\tif (!softlockup_initialized)\n\t\treturn;\n\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);\n\n\tcpumask_clear(&watchdog_allowed_mask);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask watchdog_allowed_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "&watchdog_allowed_mask"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_on_cpu",
          "args": [
            "cpu",
            "softlockup_stop_fn",
            "NULL",
            "false"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_on_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "95-109",
          "snippet": "int smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tint ret;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tif (phys)\n\t\thypervisor_pin_vcpu(0);\n\tret = func(par);\n\tif (phys)\n\t\thypervisor_pin_vcpu(-1);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tint ret;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tif (phys)\n\t\thypervisor_pin_vcpu(0);\n\tret = func(par);\n\tif (phys)\n\t\thypervisor_pin_vcpu(-1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&watchdog_allowed_mask"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_allowed_mask;\n\nstatic void softlockup_stop_all(void)\n{\n\tint cpu;\n\n\tif (!softlockup_initialized)\n\t\treturn;\n\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);\n\n\tcpumask_clear(&watchdog_allowed_mask);\n}"
  },
  {
    "function_name": "softlockup_stop_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "514-518",
    "snippet": "static int softlockup_stop_fn(void *data)\n{\n\twatchdog_disable(smp_processor_id());\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_disable",
          "args": [
            "smp_processor_id()"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "498-512",
          "snippet": "static void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int softlockup_stop_fn(void *data)\n{\n\twatchdog_disable(smp_processor_id());\n\treturn 0;\n}"
  },
  {
    "function_name": "watchdog_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "498-512",
    "snippet": "static void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "this_cpu_ptr(&softlockup_completion)"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_completion"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "hrtimer"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_disable",
          "args": [
            "cpu"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "111-114",
          "snippet": "void __weak watchdog_nmi_disable(unsigned int cpu)\n{\n\thardlockup_detector_perf_disable();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_disable(unsigned int cpu)\n{\n\thardlockup_detector_perf_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu != smp_processor_id()"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&watchdog_hrtimer"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}"
  },
  {
    "function_name": "watchdog_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "472-496",
    "snippet": "static void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED);\n\n\t/* Initialize timestamp */\n\t__touch_watchdog();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_nmi_enable",
          "args": [
            "cpu"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "105-109",
          "snippet": "int __weak watchdog_nmi_enable(unsigned int cpu)\n{\n\thardlockup_detector_perf_enable();\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nint __weak watchdog_nmi_enable(unsigned int cpu)\n{\n\thardlockup_detector_perf_enable();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__touch_watchdog",
          "args": [],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__touch_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "251-254",
          "snippet": "static void __touch_watchdog(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void __touch_watchdog(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "hrtimer",
            "ns_to_ktime(sample_period)",
            "HRTIMER_MODE_REL_PINNED"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "sample_period"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "hrtimer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "done"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "done"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu != smp_processor_id()"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_completion"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&watchdog_hrtimer"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED);\n\n\t/* Initialize timestamp */\n\t__touch_watchdog();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}"
  },
  {
    "function_name": "watchdog_timer_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "355-470",
    "snippet": "static enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)\n{\n\tunsigned long touch_ts = __this_cpu_read(watchdog_touch_ts);\n\tstruct pt_regs *regs = get_irq_regs();\n\tint duration;\n\tint softlockup_all_cpu_backtrace = sysctl_softlockup_all_cpu_backtrace;\n\n\tif (!watchdog_enabled)\n\t\treturn HRTIMER_NORESTART;\n\n\t/* kick the hardlockup detector */\n\twatchdog_interrupt_count();\n\n\t/* kick the softlockup detector */\n\tif (completion_done(this_cpu_ptr(&softlockup_completion))) {\n\t\treinit_completion(this_cpu_ptr(&softlockup_completion));\n\t\tstop_one_cpu_nowait(smp_processor_id(),\n\t\t\t\tsoftlockup_fn, NULL,\n\t\t\t\tthis_cpu_ptr(&softlockup_stop_work));\n\t}\n\n\t/* .. and repeat */\n\thrtimer_forward_now(hrtimer, ns_to_ktime(sample_period));\n\n\tif (touch_ts == 0) {\n\t\tif (unlikely(__this_cpu_read(softlockup_touch_sync))) {\n\t\t\t/*\n\t\t\t * If the time stamp was touched atomically\n\t\t\t * make sure the scheduler tick is up to date.\n\t\t\t */\n\t\t\t__this_cpu_write(softlockup_touch_sync, false);\n\t\t\tsched_clock_tick();\n\t\t}\n\n\t\t/* Clear the guest paused flag on watchdog reset */\n\t\tkvm_check_and_clear_guest_paused();\n\t\t__touch_watchdog();\n\t\treturn HRTIMER_RESTART;\n\t}\n\n\t/* check for a softlockup\n\t * This is done by making sure a high priority task is\n\t * being scheduled.  The task touches the watchdog to\n\t * indicate it is getting cpu time.  If it hasn't then\n\t * this is a good indication some task is hogging the cpu\n\t */\n\tduration = is_softlockup(touch_ts);\n\tif (unlikely(duration)) {\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like a soft lockup, check to see if the host\n\t\t * stopped the vm before we issue the warning\n\t\t */\n\t\tif (kvm_check_and_clear_guest_paused())\n\t\t\treturn HRTIMER_RESTART;\n\n\t\t/* only warn once */\n\t\tif (__this_cpu_read(soft_watchdog_warn) == true) {\n\t\t\t/*\n\t\t\t * When multiple processes are causing softlockups the\n\t\t\t * softlockup detector only warns on the first one\n\t\t\t * because the code relies on a full quiet cycle to\n\t\t\t * re-arm.  The second process prevents the quiet cycle\n\t\t\t * and never gets reported.  Use task pointers to detect\n\t\t\t * this.\n\t\t\t */\n\t\t\tif (__this_cpu_read(softlockup_task_ptr_saved) !=\n\t\t\t    current) {\n\t\t\t\t__this_cpu_write(soft_watchdog_warn, false);\n\t\t\t\t__touch_watchdog();\n\t\t\t}\n\t\t\treturn HRTIMER_RESTART;\n\t\t}\n\n\t\tif (softlockup_all_cpu_backtrace) {\n\t\t\t/* Prevent multiple soft-lockup reports if one cpu is already\n\t\t\t * engaged in dumping cpu back traces\n\t\t\t */\n\t\t\tif (test_and_set_bit(0, &soft_lockup_nmi_warn)) {\n\t\t\t\t/* Someone else will report us. Let's give up */\n\t\t\t\t__this_cpu_write(soft_watchdog_warn, true);\n\t\t\t\treturn HRTIMER_RESTART;\n\t\t\t}\n\t\t}\n\n\t\tpr_emerg(\"BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\\n\",\n\t\t\tsmp_processor_id(), duration,\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t\t__this_cpu_write(softlockup_task_ptr_saved, current);\n\t\tprint_modules();\n\t\tprint_irqtrace_events(current);\n\t\tif (regs)\n\t\t\tshow_regs(regs);\n\t\telse\n\t\t\tdump_stack();\n\n\t\tif (softlockup_all_cpu_backtrace) {\n\t\t\t/* Avoid generating two back traces for current\n\t\t\t * given that one is already made above\n\t\t\t */\n\t\t\ttrigger_allbutself_cpu_backtrace();\n\n\t\t\tclear_bit(0, &soft_lockup_nmi_warn);\n\t\t\t/* Barrier to sync with other cpus */\n\t\t\tsmp_mb__after_atomic();\n\t\t}\n\n\t\tadd_taint(TAINT_SOFTLOCKUP, LOCKDEP_STILL_OK);\n\t\tif (softlockup_panic)\n\t\t\tpanic(\"softlockup: hung tasks\");\n\t\t__this_cpu_write(soft_watchdog_warn, true);\n\t} else\n\t\t__this_cpu_write(soft_watchdog_warn, false);\n\n\treturn HRTIMER_RESTART;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "soft_watchdog_warn",
            "false"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "soft_watchdog_warn",
            "true"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"softlockup: hung tasks\""
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_panic_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "181-185",
          "snippet": "static int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_SOFTLOCKUP",
            "LOCKDEP_STILL_OK"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "add_taint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "386-392",
          "snippet": "void add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\n\nvoid add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "0",
            "&soft_lockup_nmi_warn"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_allbutself_cpu_backtrace",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "current"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2606-2621",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_modules",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "print_modules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4377-4394",
          "snippet": "void print_modules(void)\n{\n\tstruct module *mod;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\n\tprintk(KERN_DEFAULT \"Modules linked in:\");\n\t/* Most callers should already have preempt disabled, but make sure */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tpr_cont(\" %s%s\", mod->name, module_flags(mod, buf));\n\t}\n\tpreempt_enable();\n\tif (last_unloaded_module[0])\n\t\tpr_cont(\" [last unloaded: %s]\", last_unloaded_module);\n\tpr_cont(\"\\n\");\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define MODULE_FLAGS_BUF_SIZE (TAINT_FLAGS_COUNT + 4)"
          ],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static char last_unloaded_module[MODULE_NAME_LEN+1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\n#define MODULE_FLAGS_BUF_SIZE (TAINT_FLAGS_COUNT + 4)\n\nstatic LIST_HEAD(modules);\nstatic char last_unloaded_module[MODULE_NAME_LEN+1];\n\nvoid print_modules(void)\n{\n\tstruct module *mod;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\n\tprintk(KERN_DEFAULT \"Modules linked in:\");\n\t/* Most callers should already have preempt disabled, but make sure */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tpr_cont(\" %s%s\", mod->name, module_flags(mod, buf));\n\t}\n\tpreempt_enable();\n\tif (last_unloaded_module[0])\n\t\tpr_cont(\" [last unloaded: %s]\", last_unloaded_module);\n\tpr_cont(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "softlockup_task_ptr_saved",
            "current"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\\n\"",
            "smp_processor_id()",
            "duration",
            "current->comm",
            "task_pid_nr(current)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "soft_watchdog_warn",
            "true"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&soft_lockup_nmi_warn"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__touch_watchdog",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "__touch_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "251-254",
          "snippet": "static void __touch_watchdog(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void __touch_watchdog(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "soft_watchdog_warn",
            "false"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "softlockup_task_ptr_saved"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "soft_watchdog_warn"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_and_clear_guest_paused",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "duration"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_softlockup",
          "args": [
            "touch_ts"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "is_softlockup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "304-314",
          "snippet": "static int is_softlockup(unsigned long touch_ts)\n{\n\tunsigned long now = get_timestamp();\n\n\tif ((watchdog_enabled & SOFT_WATCHDOG_ENABLED) && watchdog_thresh){\n\t\t/* Warn about unreasonable delays. */\n\t\tif (time_after(now, touch_ts + get_softlockup_thresh()))\n\t\t\treturn now - touch_ts;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int is_softlockup(unsigned long touch_ts)\n{\n\tunsigned long now = get_timestamp();\n\n\tif ((watchdog_enabled & SOFT_WATCHDOG_ENABLED) && watchdog_thresh){\n\t\t/* Warn about unreasonable delays. */\n\t\tif (time_after(now, touch_ts + get_softlockup_thresh()))\n\t\t\treturn now - touch_ts;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_and_clear_guest_paused",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_tick",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_tick_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "405-420",
          "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "softlockup_touch_sync",
            "false"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__this_cpu_read(softlockup_touch_sync)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "softlockup_touch_sync"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_forward_now",
          "args": [
            "hrtimer",
            "ns_to_ktime(sample_period)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "sample_period"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_one_cpu_nowait",
          "args": [
            "smp_processor_id()",
            "softlockup_fn",
            "NULL",
            "this_cpu_ptr(&softlockup_stop_work)"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "stop_one_cpu_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "356-361",
          "snippet": "bool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,\n\t\t\tstruct cpu_stop_work *work_buf)\n{\n\t*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, };\n\treturn cpu_stop_queue_work(cpu, work_buf);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nbool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,\n\t\t\tstruct cpu_stop_work *work_buf)\n{\n\t*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, };\n\treturn cpu_stop_queue_work(cpu, work_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_stop_work"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinit_completion",
          "args": [
            "this_cpu_ptr(&softlockup_completion)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_completion"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completion_done",
          "args": [
            "this_cpu_ptr(&softlockup_completion)"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "completion_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "313-328",
          "snippet": "bool completion_done(struct completion *x)\n{\n\tunsigned long flags;\n\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\t/*\n\t * If ->done, we need to wait for complete() to release ->wait.lock\n\t * otherwise we can end up freeing the completion before complete()\n\t * is done referencing it.\n\t */\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn true;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool completion_done(struct completion *x)\n{\n\tunsigned long flags;\n\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\t/*\n\t * If ->done, we need to wait for complete() to release ->wait.lock\n\t * otherwise we can end up freeing the completion before complete()\n\t * is done referencing it.\n\t */\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_completion"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchdog_interrupt_count",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_interrupt_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "328-331",
          "snippet": "static void watchdog_interrupt_count(void)\n{\n\t__this_cpu_inc(hrtimer_interrupts);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void watchdog_interrupt_count(void)\n{\n\t__this_cpu_inc(hrtimer_interrupts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "watchdog_touch_ts"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)\n{\n\tunsigned long touch_ts = __this_cpu_read(watchdog_touch_ts);\n\tstruct pt_regs *regs = get_irq_regs();\n\tint duration;\n\tint softlockup_all_cpu_backtrace = sysctl_softlockup_all_cpu_backtrace;\n\n\tif (!watchdog_enabled)\n\t\treturn HRTIMER_NORESTART;\n\n\t/* kick the hardlockup detector */\n\twatchdog_interrupt_count();\n\n\t/* kick the softlockup detector */\n\tif (completion_done(this_cpu_ptr(&softlockup_completion))) {\n\t\treinit_completion(this_cpu_ptr(&softlockup_completion));\n\t\tstop_one_cpu_nowait(smp_processor_id(),\n\t\t\t\tsoftlockup_fn, NULL,\n\t\t\t\tthis_cpu_ptr(&softlockup_stop_work));\n\t}\n\n\t/* .. and repeat */\n\thrtimer_forward_now(hrtimer, ns_to_ktime(sample_period));\n\n\tif (touch_ts == 0) {\n\t\tif (unlikely(__this_cpu_read(softlockup_touch_sync))) {\n\t\t\t/*\n\t\t\t * If the time stamp was touched atomically\n\t\t\t * make sure the scheduler tick is up to date.\n\t\t\t */\n\t\t\t__this_cpu_write(softlockup_touch_sync, false);\n\t\t\tsched_clock_tick();\n\t\t}\n\n\t\t/* Clear the guest paused flag on watchdog reset */\n\t\tkvm_check_and_clear_guest_paused();\n\t\t__touch_watchdog();\n\t\treturn HRTIMER_RESTART;\n\t}\n\n\t/* check for a softlockup\n\t * This is done by making sure a high priority task is\n\t * being scheduled.  The task touches the watchdog to\n\t * indicate it is getting cpu time.  If it hasn't then\n\t * this is a good indication some task is hogging the cpu\n\t */\n\tduration = is_softlockup(touch_ts);\n\tif (unlikely(duration)) {\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like a soft lockup, check to see if the host\n\t\t * stopped the vm before we issue the warning\n\t\t */\n\t\tif (kvm_check_and_clear_guest_paused())\n\t\t\treturn HRTIMER_RESTART;\n\n\t\t/* only warn once */\n\t\tif (__this_cpu_read(soft_watchdog_warn) == true) {\n\t\t\t/*\n\t\t\t * When multiple processes are causing softlockups the\n\t\t\t * softlockup detector only warns on the first one\n\t\t\t * because the code relies on a full quiet cycle to\n\t\t\t * re-arm.  The second process prevents the quiet cycle\n\t\t\t * and never gets reported.  Use task pointers to detect\n\t\t\t * this.\n\t\t\t */\n\t\t\tif (__this_cpu_read(softlockup_task_ptr_saved) !=\n\t\t\t    current) {\n\t\t\t\t__this_cpu_write(soft_watchdog_warn, false);\n\t\t\t\t__touch_watchdog();\n\t\t\t}\n\t\t\treturn HRTIMER_RESTART;\n\t\t}\n\n\t\tif (softlockup_all_cpu_backtrace) {\n\t\t\t/* Prevent multiple soft-lockup reports if one cpu is already\n\t\t\t * engaged in dumping cpu back traces\n\t\t\t */\n\t\t\tif (test_and_set_bit(0, &soft_lockup_nmi_warn)) {\n\t\t\t\t/* Someone else will report us. Let's give up */\n\t\t\t\t__this_cpu_write(soft_watchdog_warn, true);\n\t\t\t\treturn HRTIMER_RESTART;\n\t\t\t}\n\t\t}\n\n\t\tpr_emerg(\"BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\\n\",\n\t\t\tsmp_processor_id(), duration,\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t\t__this_cpu_write(softlockup_task_ptr_saved, current);\n\t\tprint_modules();\n\t\tprint_irqtrace_events(current);\n\t\tif (regs)\n\t\t\tshow_regs(regs);\n\t\telse\n\t\t\tdump_stack();\n\n\t\tif (softlockup_all_cpu_backtrace) {\n\t\t\t/* Avoid generating two back traces for current\n\t\t\t * given that one is already made above\n\t\t\t */\n\t\t\ttrigger_allbutself_cpu_backtrace();\n\n\t\t\tclear_bit(0, &soft_lockup_nmi_warn);\n\t\t\t/* Barrier to sync with other cpus */\n\t\t\tsmp_mb__after_atomic();\n\t\t}\n\n\t\tadd_taint(TAINT_SOFTLOCKUP, LOCKDEP_STILL_OK);\n\t\tif (softlockup_panic)\n\t\t\tpanic(\"softlockup: hung tasks\");\n\t\t__this_cpu_write(soft_watchdog_warn, true);\n\t} else\n\t\t__this_cpu_write(soft_watchdog_warn, false);\n\n\treturn HRTIMER_RESTART;\n}"
  },
  {
    "function_name": "softlockup_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "344-352",
    "snippet": "static int softlockup_fn(void *data)\n{\n\t__this_cpu_write(soft_lockup_hrtimer_cnt,\n\t\t\t __this_cpu_read(hrtimer_interrupts));\n\t__touch_watchdog();\n\tcomplete(this_cpu_ptr(&softlockup_completion));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "this_cpu_ptr(&softlockup_completion)"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_completion"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__touch_watchdog",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "__touch_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "251-254",
          "snippet": "static void __touch_watchdog(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void __touch_watchdog(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "soft_lockup_hrtimer_cnt",
            "__this_cpu_read(hrtimer_interrupts)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "hrtimer_interrupts"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int softlockup_fn(void *data)\n{\n\t__this_cpu_write(soft_lockup_hrtimer_cnt,\n\t\t\t __this_cpu_read(hrtimer_interrupts));\n\t__touch_watchdog();\n\tcomplete(this_cpu_ptr(&softlockup_completion));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "watchdog_interrupt_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "328-331",
    "snippet": "static void watchdog_interrupt_count(void)\n{\n\t__this_cpu_inc(hrtimer_interrupts);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "hrtimer_interrupts"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void watchdog_interrupt_count(void)\n{\n\t__this_cpu_inc(hrtimer_interrupts);\n}"
  },
  {
    "function_name": "is_hardlockup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "317-326",
    "snippet": "bool is_hardlockup(void)\n{\n\tunsigned long hrint = __this_cpu_read(hrtimer_interrupts);\n\n\tif (__this_cpu_read(hrtimer_interrupts_saved) == hrint)\n\t\treturn true;\n\n\t__this_cpu_write(hrtimer_interrupts_saved, hrint);\n\treturn false;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "hrtimer_interrupts_saved",
            "hrint"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "hrtimer_interrupts_saved"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "hrtimer_interrupts"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nbool is_hardlockup(void)\n{\n\tunsigned long hrint = __this_cpu_read(hrtimer_interrupts);\n\n\tif (__this_cpu_read(hrtimer_interrupts_saved) == hrint)\n\t\treturn true;\n\n\t__this_cpu_write(hrtimer_interrupts_saved, hrint);\n\treturn false;\n}"
  },
  {
    "function_name": "is_softlockup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "304-314",
    "snippet": "static int is_softlockup(unsigned long touch_ts)\n{\n\tunsigned long now = get_timestamp();\n\n\tif ((watchdog_enabled & SOFT_WATCHDOG_ENABLED) && watchdog_thresh){\n\t\t/* Warn about unreasonable delays. */\n\t\tif (time_after(now, touch_ts + get_softlockup_thresh()))\n\t\t\treturn now - touch_ts;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "now",
            "touch_ts + get_softlockup_thresh()"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_softlockup_thresh",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "get_softlockup_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "222-225",
          "snippet": "static int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_timestamp",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "get_timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "232-235",
          "snippet": "static unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int is_softlockup(unsigned long touch_ts)\n{\n\tunsigned long now = get_timestamp();\n\n\tif ((watchdog_enabled & SOFT_WATCHDOG_ENABLED) && watchdog_thresh){\n\t\t/* Warn about unreasonable delays. */\n\t\tif (time_after(now, touch_ts + get_softlockup_thresh()))\n\t\t\treturn now - touch_ts;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "touch_softlockup_watchdog_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "298-302",
    "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_touch_ts, 0);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "watchdog_touch_ts",
            "0"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "softlockup_touch_sync",
            "true"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_touch_ts, 0);\n}"
  },
  {
    "function_name": "touch_all_softlockup_watchdogs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "280-296",
    "snippet": "void touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t/*\n\t * watchdog_mutex cannpt be taken here, as this might be called\n\t * from (soft)interrupt context, so the access to\n\t * watchdog_allowed_cpumask might race with a concurrent update.\n\t *\n\t * The watchdog time stamp can race against a concurrent real\n\t * update as well, the only side effect might be a cycle delay for\n\t * the softlockup check.\n\t */\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tper_cpu(watchdog_touch_ts, cpu) = 0;\n\twq_watchdog_touch(-1);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);",
      "struct cpumask watchdog_allowed_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_watchdog_touch",
          "args": [
            "-1"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_touch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5577-5583",
          "snippet": "notrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\telse\n\t\twq_watchdog_touched = jiffies;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nnotrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\telse\n\t\twq_watchdog_touched = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "watchdog_touch_ts",
            "cpu"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&watchdog_allowed_mask"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nstruct cpumask watchdog_allowed_mask;\n\nvoid touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t/*\n\t * watchdog_mutex cannpt be taken here, as this might be called\n\t * from (soft)interrupt context, so the access to\n\t * watchdog_allowed_cpumask might race with a concurrent update.\n\t *\n\t * The watchdog time stamp can race against a concurrent real\n\t * update as well, the only side effect might be a cycle delay for\n\t * the softlockup check.\n\t */\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tper_cpu(watchdog_touch_ts, cpu) = 0;\n\twq_watchdog_touch(-1);\n}"
  },
  {
    "function_name": "touch_softlockup_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "273-277",
    "snippet": "notrace void touch_softlockup_watchdog(void)\n{\n\ttouch_softlockup_watchdog_sched();\n\twq_watchdog_touch(raw_smp_processor_id());\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_watchdog_touch",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_touch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5577-5583",
          "snippet": "notrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\telse\n\t\twq_watchdog_touched = jiffies;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nnotrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\telse\n\t\twq_watchdog_touched = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog_sched",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "264-271",
          "snippet": "notrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's timestamp\n\t * gets zeroed here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_touch_ts, 0);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's timestamp\n\t * gets zeroed here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_touch_ts, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nnotrace void touch_softlockup_watchdog(void)\n{\n\ttouch_softlockup_watchdog_sched();\n\twq_watchdog_touch(raw_smp_processor_id());\n}"
  },
  {
    "function_name": "touch_softlockup_watchdog_sched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "264-271",
    "snippet": "notrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's timestamp\n\t * gets zeroed here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_touch_ts, 0);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_cpu_write",
          "args": [
            "watchdog_touch_ts",
            "0"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's timestamp\n\t * gets zeroed here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_touch_ts, 0);\n}"
  },
  {
    "function_name": "__touch_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "251-254",
    "snippet": "static void __touch_watchdog(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "watchdog_touch_ts",
            "get_timestamp()"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_timestamp",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "get_timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "232-235",
          "snippet": "static unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void __touch_watchdog(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n}"
  },
  {
    "function_name": "set_sample_period",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "237-248",
    "snippet": "static void set_sample_period(void)\n{\n\t/*\n\t * convert watchdog_thresh from seconds to ns\n\t * the divide by 5 is to give hrtimer several chances (two\n\t * or three with the current relation between the soft\n\t * and hard thresholds) to increment before the\n\t * hardlockup detector generates a warning\n\t */\n\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / 5);\n\twatchdog_update_hrtimer_threshold(sample_period);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_update_hrtimer_threshold",
          "args": [
            "sample_period"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_update_hrtimer_threshold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "50-74",
          "snippet": "void watchdog_update_hrtimer_threshold(u64 period)\n{\n\t/*\n\t * The hrtimer runs with a period of (watchdog_threshold * 2) / 5\n\t *\n\t * So it runs effectively with 2.5 times the rate of the NMI\n\t * watchdog. That means the hrtimer should fire 2-3 times before\n\t * the NMI watchdog expires. The NMI watchdog on x86 is based on\n\t * unhalted CPU cycles, so if Turbo-Mode is enabled the CPU cycles\n\t * might run way faster than expected and the NMI fires in a\n\t * smaller period than the one deduced from the nominal CPU\n\t * frequency. Depending on the Turbo-Mode factor this might be fast\n\t * enough to get the NMI period smaller than the hrtimer watchdog\n\t * period and trigger false positives.\n\t *\n\t * The sample threshold is used to check in the NMI handler whether\n\t * the minimum time between two NMI samples has elapsed. That\n\t * prevents false positives.\n\t *\n\t * Set this to 4/5 of the actual watchdog threshold period so the\n\t * hrtimer is guaranteed to fire at least once within the real\n\t * watchdog threshold.\n\t */\n\twatchdog_hrtimer_sample_threshold = period * 2;\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nvoid watchdog_update_hrtimer_threshold(u64 period)\n{\n\t/*\n\t * The hrtimer runs with a period of (watchdog_threshold * 2) / 5\n\t *\n\t * So it runs effectively with 2.5 times the rate of the NMI\n\t * watchdog. That means the hrtimer should fire 2-3 times before\n\t * the NMI watchdog expires. The NMI watchdog on x86 is based on\n\t * unhalted CPU cycles, so if Turbo-Mode is enabled the CPU cycles\n\t * might run way faster than expected and the NMI fires in a\n\t * smaller period than the one deduced from the nominal CPU\n\t * frequency. Depending on the Turbo-Mode factor this might be fast\n\t * enough to get the NMI period smaller than the hrtimer watchdog\n\t * period and trigger false positives.\n\t *\n\t * The sample threshold is used to check in the NMI handler whether\n\t * the minimum time between two NMI samples has elapsed. That\n\t * prevents false positives.\n\t *\n\t * Set this to 4/5 of the actual watchdog threshold period so the\n\t * hrtimer is guaranteed to fire at least once within the real\n\t * watchdog threshold.\n\t */\n\twatchdog_hrtimer_sample_threshold = period * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_softlockup_thresh",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "get_softlockup_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "222-225",
          "snippet": "static int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void set_sample_period(void)\n{\n\t/*\n\t * convert watchdog_thresh from seconds to ns\n\t * the divide by 5 is to give hrtimer several chances (two\n\t * or three with the current relation between the soft\n\t * and hard thresholds) to increment before the\n\t * hardlockup detector generates a warning\n\t */\n\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / 5);\n\twatchdog_update_hrtimer_threshold(sample_period);\n}"
  },
  {
    "function_name": "get_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "232-235",
    "snippet": "static unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "running_clock",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "running_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "478-481",
          "snippet": "u64 __weak running_clock(void)\n{\n\treturn local_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nu64 __weak running_clock(void)\n{\n\treturn local_clock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}"
  },
  {
    "function_name": "get_softlockup_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "222-225",
    "snippet": "static int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}"
  },
  {
    "function_name": "softlockup_all_cpu_backtrace_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "205-209",
    "snippet": "static int __init softlockup_all_cpu_backtrace_setup(char *str)\n{\n\tsysctl_softlockup_all_cpu_backtrace = !!simple_strtol(str, NULL, 0);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "str",
            "NULL",
            "0"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init softlockup_all_cpu_backtrace_setup(char *str)\n{\n\tsysctl_softlockup_all_cpu_backtrace = !!simple_strtol(str, NULL, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "nosoftlockup_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "195-199",
    "snippet": "static int __init nosoftlockup_setup(char *str)\n{\n\tsoft_watchdog_user_enabled = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init nosoftlockup_setup(char *str)\n{\n\tsoft_watchdog_user_enabled = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "nowatchdog_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "188-192",
    "snippet": "static int __init nowatchdog_setup(char *str)\n{\n\twatchdog_user_enabled = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init nowatchdog_setup(char *str)\n{\n\twatchdog_user_enabled = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "softlockup_panic_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "181-185",
    "snippet": "static int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "NULL",
            "0"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "lockup_detector_update_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "151-160",
    "snippet": "static void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}"
  },
  {
    "function_name": "watchdog_nmi_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "143-143",
    "snippet": "void __weak watchdog_nmi_start(void) { }",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __weak"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_start(void) { }"
  },
  {
    "function_name": "watchdog_nmi_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "130-130",
    "snippet": "void __weak watchdog_nmi_stop(void) { }",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __weak"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_stop(void) { }"
  },
  {
    "function_name": "watchdog_nmi_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "117-120",
    "snippet": "__init watchdog_nmi_probe(void)\n{\n\treturn hardlockup_detector_perf_init();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hardlockup_detector_perf_init",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_detector_perf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "284-295",
          "snippet": "int __init hardlockup_detector_perf_init(void)\n{\n\tint ret = hardlockup_detector_event_create();\n\n\tif (ret) {\n\t\tpr_info(\"Perf NMI watchdog permanently disabled\\n\");\n\t} else {\n\t\tperf_event_release_kernel(this_cpu_read(watchdog_ev));\n\t\tthis_cpu_write(watchdog_ev, NULL);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, watchdog_ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, watchdog_ev);\n\nint __init hardlockup_detector_perf_init(void)\n{\n\tint ret = hardlockup_detector_event_create();\n\n\tif (ret) {\n\t\tpr_info(\"Perf NMI watchdog permanently disabled\\n\");\n\t} else {\n\t\tperf_event_release_kernel(this_cpu_read(watchdog_ev));\n\t\tthis_cpu_write(watchdog_ev, NULL);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n__init watchdog_nmi_probe(void)\n{\n\treturn hardlockup_detector_perf_init();\n}"
  },
  {
    "function_name": "watchdog_nmi_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "111-114",
    "snippet": "void __weak watchdog_nmi_disable(unsigned int cpu)\n{\n\thardlockup_detector_perf_disable();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __weak"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hardlockup_detector_perf_disable",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_detector_perf_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "204-215",
          "snippet": "void hardlockup_detector_perf_disable(void)\n{\n\tstruct perf_event *event = this_cpu_read(watchdog_ev);\n\n\tif (event) {\n\t\tperf_event_disable(event);\n\t\tthis_cpu_write(watchdog_ev, NULL);\n\t\tthis_cpu_write(dead_event, event);\n\t\tcpumask_set_cpu(smp_processor_id(), &dead_events_mask);\n\t\tatomic_dec(&watchdog_cpus);\n\t}\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, watchdog_ev);",
            "static DEFINE_PER_CPU(struct perf_event *, dead_event);",
            "static struct cpumask dead_events_mask;",
            "static atomic_t watchdog_cpus = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, watchdog_ev);\nstatic DEFINE_PER_CPU(struct perf_event *, dead_event);\nstatic struct cpumask dead_events_mask;\nstatic atomic_t watchdog_cpus = ATOMIC_INIT(0);\n\nvoid hardlockup_detector_perf_disable(void)\n{\n\tstruct perf_event *event = this_cpu_read(watchdog_ev);\n\n\tif (event) {\n\t\tperf_event_disable(event);\n\t\tthis_cpu_write(watchdog_ev, NULL);\n\t\tthis_cpu_write(dead_event, event);\n\t\tcpumask_set_cpu(smp_processor_id(), &dead_events_mask);\n\t\tatomic_dec(&watchdog_cpus);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_disable(unsigned int cpu)\n{\n\thardlockup_detector_perf_disable();\n}"
  },
  {
    "function_name": "watchdog_nmi_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "105-109",
    "snippet": "int __weak watchdog_nmi_enable(unsigned int cpu)\n{\n\thardlockup_detector_perf_enable();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __weak"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hardlockup_detector_perf_enable",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_detector_perf_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "189-199",
          "snippet": "void hardlockup_detector_perf_enable(void)\n{\n\tif (hardlockup_detector_event_create())\n\t\treturn;\n\n\t/* use original value for check */\n\tif (!atomic_fetch_inc(&watchdog_cpus))\n\t\tpr_info(\"Enabled. Permanently consumes one hw-PMU counter.\\n\");\n\n\tperf_event_enable(this_cpu_read(watchdog_ev));\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, watchdog_ev);",
            "static atomic_t watchdog_cpus = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, watchdog_ev);\nstatic atomic_t watchdog_cpus = ATOMIC_INIT(0);\n\nvoid hardlockup_detector_perf_enable(void)\n{\n\tif (hardlockup_detector_event_create())\n\t\treturn;\n\n\t/* use original value for check */\n\tif (!atomic_fetch_inc(&watchdog_cpus))\n\t\tpr_info(\"Enabled. Permanently consumes one hw-PMU counter.\\n\");\n\n\tperf_event_enable(this_cpu_read(watchdog_ev));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nint __weak watchdog_nmi_enable(unsigned int cpu)\n{\n\thardlockup_detector_perf_enable();\n\treturn 0;\n}"
  },
  {
    "function_name": "hardlockup_all_cpu_backtrace_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "88-92",
    "snippet": "static int __init hardlockup_all_cpu_backtrace_setup(char *str)\n{\n\tsysctl_hardlockup_all_cpu_backtrace = !!simple_strtol(str, NULL, 0);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "str",
            "NULL",
            "0"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_all_cpu_backtrace_setup(char *str)\n{\n\tsysctl_hardlockup_all_cpu_backtrace = !!simple_strtol(str, NULL, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "hardlockup_panic_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "71-82",
    "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"1\"",
            "1"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"0\"",
            "1"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"nopanic\"",
            "7"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"panic\"",
            "5"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "hardlockup_detector_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
    "lines": "66-69",
    "snippet": "void __init hardlockup_detector_disable(void)\n{\n\tnmi_watchdog_user_enabled = 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nvoid __init hardlockup_detector_disable(void)\n{\n\tnmi_watchdog_user_enabled = 0;\n}"
  }
]