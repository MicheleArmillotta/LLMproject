[
  {
    "function_name": "proc_sched_set_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "1001-1006",
    "snippet": "void proc_sched_set_task(struct task_struct *p)\n{\n#ifdef CONFIG_SCHEDSTATS\n\tmemset(&p->se.statistics, 0, sizeof(p->se.statistics));\n#endif\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&p->se.statistics",
            "0",
            "sizeof(p->se.statistics)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid proc_sched_set_task(struct task_struct *p)\n{\n#ifdef CONFIG_SCHEDSTATS\n\tmemset(&p->se.statistics, 0, sizeof(p->se.statistics));\n#endif\n}"
  },
  {
    "function_name": "proc_sched_show_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "876-999",
    "snippet": "void proc_sched_show_task(struct task_struct *p, struct pid_namespace *ns,\n\t\t\t\t\t\t  struct seq_file *m)\n{\n\tunsigned long nr_switches;\n\n\tSEQ_printf(m, \"%s (%d, #threads: %d)\\n\", p->comm, task_pid_nr_ns(p, ns),\n\t\t\t\t\t\tget_nr_threads(p));\n\tSEQ_printf(m,\n\t\t\"---------------------------------------------------------\"\n\t\t\"----------\\n\");\n#define __P(F) \\\n\tSEQ_printf(m, \"%-45s:%21Ld\\n\", #F, (long long)F)\n#define P(F) \\\n\tSEQ_printf(m, \"%-45s:%21Ld\\n\", #F, (long long)p->F)\n#define P_SCHEDSTAT(F) \\\n\tSEQ_printf(m, \"%-45s:%21Ld\\n\", #F, (long long)schedstat_val(p->F))\n#define __PN(F) \\\n\tSEQ_printf(m, \"%-45s:%14Ld.%06ld\\n\", #F, SPLIT_NS((long long)F))\n#define PN(F) \\\n\tSEQ_printf(m, \"%-45s:%14Ld.%06ld\\n\", #F, SPLIT_NS((long long)p->F))\n#define PN_SCHEDSTAT(F) \\\n\tSEQ_printf(m, \"%-45s:%14Ld.%06ld\\n\", #F, SPLIT_NS((long long)schedstat_val(p->F)))\n\n\tPN(se.exec_start);\n\tPN(se.vruntime);\n\tPN(se.sum_exec_runtime);\n\n\tnr_switches = p->nvcsw + p->nivcsw;\n\n\tP(se.nr_migrations);\n\n\tif (schedstat_enabled()) {\n\t\tu64 avg_atom, avg_per_cpu;\n\n\t\tPN_SCHEDSTAT(se.statistics.sum_sleep_runtime);\n\t\tPN_SCHEDSTAT(se.statistics.wait_start);\n\t\tPN_SCHEDSTAT(se.statistics.sleep_start);\n\t\tPN_SCHEDSTAT(se.statistics.block_start);\n\t\tPN_SCHEDSTAT(se.statistics.sleep_max);\n\t\tPN_SCHEDSTAT(se.statistics.block_max);\n\t\tPN_SCHEDSTAT(se.statistics.exec_max);\n\t\tPN_SCHEDSTAT(se.statistics.slice_max);\n\t\tPN_SCHEDSTAT(se.statistics.wait_max);\n\t\tPN_SCHEDSTAT(se.statistics.wait_sum);\n\t\tP_SCHEDSTAT(se.statistics.wait_count);\n\t\tPN_SCHEDSTAT(se.statistics.iowait_sum);\n\t\tP_SCHEDSTAT(se.statistics.iowait_count);\n\t\tP_SCHEDSTAT(se.statistics.nr_migrations_cold);\n\t\tP_SCHEDSTAT(se.statistics.nr_failed_migrations_affine);\n\t\tP_SCHEDSTAT(se.statistics.nr_failed_migrations_running);\n\t\tP_SCHEDSTAT(se.statistics.nr_failed_migrations_hot);\n\t\tP_SCHEDSTAT(se.statistics.nr_forced_migrations);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_sync);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_migrate);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_local);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_remote);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_affine);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_affine_attempts);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_passive);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_idle);\n\n\t\tavg_atom = p->se.sum_exec_runtime;\n\t\tif (nr_switches)\n\t\t\tavg_atom = div64_ul(avg_atom, nr_switches);\n\t\telse\n\t\t\tavg_atom = -1LL;\n\n\t\tavg_per_cpu = p->se.sum_exec_runtime;\n\t\tif (p->se.nr_migrations) {\n\t\t\tavg_per_cpu = div64_u64(avg_per_cpu,\n\t\t\t\t\t\tp->se.nr_migrations);\n\t\t} else {\n\t\t\tavg_per_cpu = -1LL;\n\t\t}\n\n\t\t__PN(avg_atom);\n\t\t__PN(avg_per_cpu);\n\t}\n\n\t__P(nr_switches);\n\tSEQ_printf(m, \"%-45s:%21Ld\\n\",\n\t\t   \"nr_voluntary_switches\", (long long)p->nvcsw);\n\tSEQ_printf(m, \"%-45s:%21Ld\\n\",\n\t\t   \"nr_involuntary_switches\", (long long)p->nivcsw);\n\n\tP(se.load.weight);\n\tP(se.runnable_weight);\n#ifdef CONFIG_SMP\n\tP(se.avg.load_sum);\n\tP(se.avg.runnable_load_sum);\n\tP(se.avg.util_sum);\n\tP(se.avg.load_avg);\n\tP(se.avg.runnable_load_avg);\n\tP(se.avg.util_avg);\n\tP(se.avg.last_update_time);\n\tP(se.avg.util_est.ewma);\n\tP(se.avg.util_est.enqueued);\n#endif\n\tP(policy);\n\tP(prio);\n\tif (p->policy == SCHED_DEADLINE) {\n\t\tP(dl.runtime);\n\t\tP(dl.deadline);\n\t}\n#undef PN_SCHEDSTAT\n#undef PN\n#undef __PN\n#undef P_SCHEDSTAT\n#undef P\n#undef __P\n\n\t{\n\t\tunsigned int this_cpu = raw_smp_processor_id();\n\t\tu64 t0, t1;\n\n\t\tt0 = cpu_clock(this_cpu);\n\t\tt1 = cpu_clock(this_cpu);\n\t\tSEQ_printf(m, \"%-45s:%21Ld\\n\",\n\t\t\t   \"clock-delta\", (long long)(t1-t0));\n\t}\n\n\tsched_show_numa(p, m);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_show_numa",
          "args": [
            "p",
            "m"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_numa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "851-874",
          "snippet": "static void sched_show_numa(struct task_struct *p, struct seq_file *m)\n{\n#ifdef CONFIG_NUMA_BALANCING\n\tstruct mempolicy *pol;\n\n\tif (p->mm)\n\t\tP(mm->numa_scan_seq);\n\n\ttask_lock(p);\n\tpol = p->mempolicy;\n\tif (pol && !(pol->flags & MPOL_F_MORON))\n\t\tpol = NULL;\n\tmpol_get(pol);\n\ttask_unlock(p);\n\n\tP(numa_pages_migrated);\n\tP(numa_preferred_nid);\n\tP(total_numa_faults);\n\tSEQ_printf(m, \"current_node=%d, numa_group_id=%d\\n\",\n\t\t\ttask_node(p), task_numa_group_id(p));\n\tshow_numa_stats(p, m);\n\tmpol_put(pol);\n#endif\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_show_numa(struct task_struct *p, struct seq_file *m)\n{\n#ifdef CONFIG_NUMA_BALANCING\n\tstruct mempolicy *pol;\n\n\tif (p->mm)\n\t\tP(mm->numa_scan_seq);\n\n\ttask_lock(p);\n\tpol = p->mempolicy;\n\tif (pol && !(pol->flags & MPOL_F_MORON))\n\t\tpol = NULL;\n\tmpol_get(pol);\n\ttask_unlock(p);\n\n\tP(numa_pages_migrated);\n\tP(numa_preferred_nid);\n\tP(total_numa_faults);\n\tSEQ_printf(m, \"current_node=%d, numa_group_id=%d\\n\",\n\t\t\ttask_node(p), task_numa_group_id(p));\n\tshow_numa_stats(p, m);\n\tmpol_put(pol);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"%-45s:%21Ld\\n\"",
            "\"clock-delta\"",
            "(long long)(t1-t0)"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock",
          "args": [
            "this_cpu"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_event_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "9268-9285",
          "snippet": "static int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\nstatic DEVICE_ATTR_RO(type);\n\nstatic int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "dl.deadline"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "dl.runtime"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "prio"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "policy"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.avg.util_est.enqueued"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.avg.util_est.ewma"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.avg.last_update_time"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.avg.util_avg"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.avg.runnable_load_avg"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.avg.load_avg"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.avg.util_sum"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.avg.runnable_load_sum"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.avg.load_sum"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.runnable_weight"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.load.weight"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "nr_switches"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PN",
          "args": [
            "avg_per_cpu"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PN",
          "args": [
            "avg_atom"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "avg_per_cpu",
            "p->se.nr_migrations"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_ul",
          "args": [
            "avg_atom",
            "nr_switches"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_wakeups_idle"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_wakeups_passive"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_wakeups_affine_attempts"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_wakeups_affine"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_wakeups_remote"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_wakeups_local"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_wakeups_migrate"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_wakeups_sync"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_wakeups"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_forced_migrations"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_failed_migrations_hot"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_failed_migrations_running"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_failed_migrations_affine"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.nr_migrations_cold"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.iowait_count"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.iowait_sum"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se.statistics.wait_count"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.wait_sum"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.wait_max"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.slice_max"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.exec_max"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.block_max"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.sleep_max"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.block_start"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.sleep_start"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.wait_start"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se.statistics.sum_sleep_runtime"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2231-2237",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se.nr_migrations"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "se.sum_exec_runtime"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "se.vruntime"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "se.exec_start"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_threads",
          "args": [
            "p"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "p",
            "ns"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid proc_sched_show_task(struct task_struct *p, struct pid_namespace *ns,\n\t\t\t\t\t\t  struct seq_file *m)\n{\n\tunsigned long nr_switches;\n\n\tSEQ_printf(m, \"%s (%d, #threads: %d)\\n\", p->comm, task_pid_nr_ns(p, ns),\n\t\t\t\t\t\tget_nr_threads(p));\n\tSEQ_printf(m,\n\t\t\"---------------------------------------------------------\"\n\t\t\"----------\\n\");\n#define __P(F) \\\n\tSEQ_printf(m, \"%-45s:%21Ld\\n\", #F, (long long)F)\n#define P(F) \\\n\tSEQ_printf(m, \"%-45s:%21Ld\\n\", #F, (long long)p->F)\n#define P_SCHEDSTAT(F) \\\n\tSEQ_printf(m, \"%-45s:%21Ld\\n\", #F, (long long)schedstat_val(p->F))\n#define __PN(F) \\\n\tSEQ_printf(m, \"%-45s:%14Ld.%06ld\\n\", #F, SPLIT_NS((long long)F))\n#define PN(F) \\\n\tSEQ_printf(m, \"%-45s:%14Ld.%06ld\\n\", #F, SPLIT_NS((long long)p->F))\n#define PN_SCHEDSTAT(F) \\\n\tSEQ_printf(m, \"%-45s:%14Ld.%06ld\\n\", #F, SPLIT_NS((long long)schedstat_val(p->F)))\n\n\tPN(se.exec_start);\n\tPN(se.vruntime);\n\tPN(se.sum_exec_runtime);\n\n\tnr_switches = p->nvcsw + p->nivcsw;\n\n\tP(se.nr_migrations);\n\n\tif (schedstat_enabled()) {\n\t\tu64 avg_atom, avg_per_cpu;\n\n\t\tPN_SCHEDSTAT(se.statistics.sum_sleep_runtime);\n\t\tPN_SCHEDSTAT(se.statistics.wait_start);\n\t\tPN_SCHEDSTAT(se.statistics.sleep_start);\n\t\tPN_SCHEDSTAT(se.statistics.block_start);\n\t\tPN_SCHEDSTAT(se.statistics.sleep_max);\n\t\tPN_SCHEDSTAT(se.statistics.block_max);\n\t\tPN_SCHEDSTAT(se.statistics.exec_max);\n\t\tPN_SCHEDSTAT(se.statistics.slice_max);\n\t\tPN_SCHEDSTAT(se.statistics.wait_max);\n\t\tPN_SCHEDSTAT(se.statistics.wait_sum);\n\t\tP_SCHEDSTAT(se.statistics.wait_count);\n\t\tPN_SCHEDSTAT(se.statistics.iowait_sum);\n\t\tP_SCHEDSTAT(se.statistics.iowait_count);\n\t\tP_SCHEDSTAT(se.statistics.nr_migrations_cold);\n\t\tP_SCHEDSTAT(se.statistics.nr_failed_migrations_affine);\n\t\tP_SCHEDSTAT(se.statistics.nr_failed_migrations_running);\n\t\tP_SCHEDSTAT(se.statistics.nr_failed_migrations_hot);\n\t\tP_SCHEDSTAT(se.statistics.nr_forced_migrations);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_sync);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_migrate);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_local);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_remote);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_affine);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_affine_attempts);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_passive);\n\t\tP_SCHEDSTAT(se.statistics.nr_wakeups_idle);\n\n\t\tavg_atom = p->se.sum_exec_runtime;\n\t\tif (nr_switches)\n\t\t\tavg_atom = div64_ul(avg_atom, nr_switches);\n\t\telse\n\t\t\tavg_atom = -1LL;\n\n\t\tavg_per_cpu = p->se.sum_exec_runtime;\n\t\tif (p->se.nr_migrations) {\n\t\t\tavg_per_cpu = div64_u64(avg_per_cpu,\n\t\t\t\t\t\tp->se.nr_migrations);\n\t\t} else {\n\t\t\tavg_per_cpu = -1LL;\n\t\t}\n\n\t\t__PN(avg_atom);\n\t\t__PN(avg_per_cpu);\n\t}\n\n\t__P(nr_switches);\n\tSEQ_printf(m, \"%-45s:%21Ld\\n\",\n\t\t   \"nr_voluntary_switches\", (long long)p->nvcsw);\n\tSEQ_printf(m, \"%-45s:%21Ld\\n\",\n\t\t   \"nr_involuntary_switches\", (long long)p->nivcsw);\n\n\tP(se.load.weight);\n\tP(se.runnable_weight);\n#ifdef CONFIG_SMP\n\tP(se.avg.load_sum);\n\tP(se.avg.runnable_load_sum);\n\tP(se.avg.util_sum);\n\tP(se.avg.load_avg);\n\tP(se.avg.runnable_load_avg);\n\tP(se.avg.util_avg);\n\tP(se.avg.last_update_time);\n\tP(se.avg.util_est.ewma);\n\tP(se.avg.util_est.enqueued);\n#endif\n\tP(policy);\n\tP(prio);\n\tif (p->policy == SCHED_DEADLINE) {\n\t\tP(dl.runtime);\n\t\tP(dl.deadline);\n\t}\n#undef PN_SCHEDSTAT\n#undef PN\n#undef __PN\n#undef P_SCHEDSTAT\n#undef P\n#undef __P\n\n\t{\n\t\tunsigned int this_cpu = raw_smp_processor_id();\n\t\tu64 t0, t1;\n\n\t\tt0 = cpu_clock(this_cpu);\n\t\tt1 = cpu_clock(this_cpu);\n\t\tSEQ_printf(m, \"%-45s:%21Ld\\n\",\n\t\t\t   \"clock-delta\", (long long)(t1-t0));\n\t}\n\n\tsched_show_numa(p, m);\n}"
  },
  {
    "function_name": "sched_show_numa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "851-874",
    "snippet": "static void sched_show_numa(struct task_struct *p, struct seq_file *m)\n{\n#ifdef CONFIG_NUMA_BALANCING\n\tstruct mempolicy *pol;\n\n\tif (p->mm)\n\t\tP(mm->numa_scan_seq);\n\n\ttask_lock(p);\n\tpol = p->mempolicy;\n\tif (pol && !(pol->flags & MPOL_F_MORON))\n\t\tpol = NULL;\n\tmpol_get(pol);\n\ttask_unlock(p);\n\n\tP(numa_pages_migrated);\n\tP(numa_preferred_nid);\n\tP(total_numa_faults);\n\tSEQ_printf(m, \"current_node=%d, numa_group_id=%d\\n\",\n\t\t\ttask_node(p), task_numa_group_id(p));\n\tshow_numa_stats(p, m);\n\tmpol_put(pol);\n#endif\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "pol"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_numa_stats",
          "args": [
            "p",
            "m"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"current_node=%d, numa_group_id=%d\\n\"",
            "task_node(p)",
            "task_numa_group_id(p)"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_numa_group_id",
          "args": [
            "p"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "task_numa_group_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "1203-1206",
          "snippet": "pid_t task_numa_group_id(struct task_struct *p)\n{\n\treturn p->numa_group ? p->numa_group->gid : 0;\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\npid_t task_numa_group_id(struct task_struct *p)\n{\n\treturn p->numa_group ? p->numa_group->gid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_node",
          "args": [
            "p"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "total_numa_faults"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "numa_preferred_nid"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "numa_pages_migrated"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "p"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_get",
          "args": [
            "pol"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "p"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "mm->numa_scan_seq"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_show_numa(struct task_struct *p, struct seq_file *m)\n{\n#ifdef CONFIG_NUMA_BALANCING\n\tstruct mempolicy *pol;\n\n\tif (p->mm)\n\t\tP(mm->numa_scan_seq);\n\n\ttask_lock(p);\n\tpol = p->mempolicy;\n\tif (pol && !(pol->flags & MPOL_F_MORON))\n\t\tpol = NULL;\n\tmpol_get(pol);\n\ttask_unlock(p);\n\n\tP(numa_pages_migrated);\n\tP(numa_preferred_nid);\n\tP(total_numa_faults);\n\tSEQ_printf(m, \"current_node=%d, numa_group_id=%d\\n\",\n\t\t\ttask_node(p), task_numa_group_id(p));\n\tshow_numa_stats(p, m);\n\tmpol_put(pol);\n#endif\n}"
  },
  {
    "function_name": "print_numa_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "841-847",
    "snippet": "void print_numa_stats(struct seq_file *m, int node, unsigned long tsf,\n\t\tunsigned long tpf, unsigned long gsf, unsigned long gpf)\n{\n\tSEQ_printf(m, \"numa_faults node=%d \", node);\n\tSEQ_printf(m, \"task_private=%lu task_shared=%lu \", tpf, tsf);\n\tSEQ_printf(m, \"group_private=%lu group_shared=%lu\\n\", gpf, gsf);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"group_private=%lu group_shared=%lu\\n\"",
            "gpf",
            "gsf"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid print_numa_stats(struct seq_file *m, int node, unsigned long tsf,\n\t\tunsigned long tpf, unsigned long gsf, unsigned long gpf)\n{\n\tSEQ_printf(m, \"numa_faults node=%d \", node);\n\tSEQ_printf(m, \"task_private=%lu task_shared=%lu \", tpf, tsf);\n\tSEQ_printf(m, \"group_private=%lu group_shared=%lu\\n\", gpf, gsf);\n}"
  },
  {
    "function_name": "init_sched_debug_procfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "825-830",
    "snippet": "static int __init init_sched_debug_procfs(void)\n{\n\tif (!proc_create_seq(\"sched_debug\", 0444, NULL, &sched_debug_sops))\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations sched_debug_sops = {\n\t.start\t\t= sched_debug_start,\n\t.next\t\t= sched_debug_next,\n\t.stop\t\t= sched_debug_stop,\n\t.show\t\t= sched_debug_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_seq",
          "args": [
            "\"sched_debug\"",
            "0444",
            "NULL",
            "&sched_debug_sops"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic const struct seq_operations sched_debug_sops = {\n\t.start\t\t= sched_debug_start,\n\t.next\t\t= sched_debug_next,\n\t.stop\t\t= sched_debug_stop,\n\t.show\t\t= sched_debug_show,\n};\n\nstatic int __init init_sched_debug_procfs(void)\n{\n\tif (!proc_create_seq(\"sched_debug\", 0444, NULL, &sched_debug_sops))\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_debug_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "814-816",
    "snippet": "static void sched_debug_stop(struct seq_file *file, void *data)\n{\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_debug_stop(struct seq_file *file, void *data)\n{\n}"
  },
  {
    "function_name": "sched_debug_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "808-812",
    "snippet": "static void *sched_debug_next(struct seq_file *file, void *data, loff_t *offset)\n{\n\t(*offset)++;\n\treturn sched_debug_start(file, offset);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_debug_start",
          "args": [
            "file",
            "offset"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "sched_debug_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "786-806",
          "snippet": "static void *sched_debug_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void *sched_debug_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void *sched_debug_next(struct seq_file *file, void *data, loff_t *offset)\n{\n\t(*offset)++;\n\treturn sched_debug_start(file, offset);\n}"
  },
  {
    "function_name": "sched_debug_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "786-806",
    "snippet": "static void *sched_debug_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "n - 1",
            "cpu_online_mask"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void *sched_debug_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "sysrq_sched_debug_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "769-777",
    "snippet": "void sysrq_sched_debug_show(void)\n{\n\tint cpu;\n\n\tsched_debug_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu);\n\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_debug_header",
          "args": [
            "NULL"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "sched_debug_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "705-755",
          "snippet": "static void sched_debug_header(struct seq_file *m)\n{\n\tu64 ktime, sched_clk, cpu_clk;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tktime = ktime_to_ns(ktime_get());\n\tsched_clk = sched_clock();\n\tcpu_clk = local_clock();\n\tlocal_irq_restore(flags);\n\n\tSEQ_printf(m, \"Sched Debug Version: v0.11, %s %.*s\\n\",\n\t\tinit_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version);\n\n#define P(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(ktime);\n\tPN(sched_clk);\n\tPN(cpu_clk);\n\tP(jiffies);\n#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK\n\tP(sched_clock_stable());\n#endif\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"sysctl_sched\\n\");\n\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(sysctl_sched_latency);\n\tPN(sysctl_sched_min_granularity);\n\tPN(sysctl_sched_wakeup_granularity);\n\tP(sysctl_sched_child_runs_first);\n\tP(sysctl_sched_features);\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"  .%-40s: %d (%s)\\n\",\n\t\t\"sysctl_sched_tunable_scaling\",\n\t\tsysctl_sched_tunable_scaling,\n\t\tsched_tunable_scaling_names[sysctl_sched_tunable_scaling]);\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *sched_tunable_scaling_names[] = {\n\t\"none\",\n\t\"logaritmic\",\n\t\"linear\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic const char *sched_tunable_scaling_names[] = {\n\t\"none\",\n\t\"logaritmic\",\n\t\"linear\"\n};\n\nstatic void sched_debug_header(struct seq_file *m)\n{\n\tu64 ktime, sched_clk, cpu_clk;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tktime = ktime_to_ns(ktime_get());\n\tsched_clk = sched_clock();\n\tcpu_clk = local_clock();\n\tlocal_irq_restore(flags);\n\n\tSEQ_printf(m, \"Sched Debug Version: v0.11, %s %.*s\\n\",\n\t\tinit_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version);\n\n#define P(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(ktime);\n\tPN(sched_clk);\n\tPN(cpu_clk);\n\tP(jiffies);\n#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK\n\tP(sched_clock_stable());\n#endif\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"sysctl_sched\\n\");\n\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(sysctl_sched_latency);\n\tPN(sysctl_sched_min_granularity);\n\tPN(sysctl_sched_wakeup_granularity);\n\tP(sysctl_sched_child_runs_first);\n\tP(sysctl_sched_features);\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"  .%-40s: %d (%s)\\n\",\n\t\t\"sysctl_sched_tunable_scaling\",\n\t\tsysctl_sched_tunable_scaling,\n\t\tsched_tunable_scaling_names[sysctl_sched_tunable_scaling]);\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid sysrq_sched_debug_show(void)\n{\n\tint cpu;\n\n\tsched_debug_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu);\n\n}"
  },
  {
    "function_name": "sched_debug_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "757-767",
    "snippet": "static int sched_debug_show(struct seq_file *m, void *v)\n{\n\tint cpu = (unsigned long)(v - 2);\n\n\tif (cpu != -1)\n\t\tprint_cpu(m, cpu);\n\telse\n\t\tsched_debug_header(m);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_debug_header",
          "args": [
            "m"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "sched_debug_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "705-755",
          "snippet": "static void sched_debug_header(struct seq_file *m)\n{\n\tu64 ktime, sched_clk, cpu_clk;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tktime = ktime_to_ns(ktime_get());\n\tsched_clk = sched_clock();\n\tcpu_clk = local_clock();\n\tlocal_irq_restore(flags);\n\n\tSEQ_printf(m, \"Sched Debug Version: v0.11, %s %.*s\\n\",\n\t\tinit_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version);\n\n#define P(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(ktime);\n\tPN(sched_clk);\n\tPN(cpu_clk);\n\tP(jiffies);\n#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK\n\tP(sched_clock_stable());\n#endif\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"sysctl_sched\\n\");\n\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(sysctl_sched_latency);\n\tPN(sysctl_sched_min_granularity);\n\tPN(sysctl_sched_wakeup_granularity);\n\tP(sysctl_sched_child_runs_first);\n\tP(sysctl_sched_features);\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"  .%-40s: %d (%s)\\n\",\n\t\t\"sysctl_sched_tunable_scaling\",\n\t\tsysctl_sched_tunable_scaling,\n\t\tsched_tunable_scaling_names[sysctl_sched_tunable_scaling]);\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *sched_tunable_scaling_names[] = {\n\t\"none\",\n\t\"logaritmic\",\n\t\"linear\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic const char *sched_tunable_scaling_names[] = {\n\t\"none\",\n\t\"logaritmic\",\n\t\"linear\"\n};\n\nstatic void sched_debug_header(struct seq_file *m)\n{\n\tu64 ktime, sched_clk, cpu_clk;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tktime = ktime_to_ns(ktime_get());\n\tsched_clk = sched_clock();\n\tcpu_clk = local_clock();\n\tlocal_irq_restore(flags);\n\n\tSEQ_printf(m, \"Sched Debug Version: v0.11, %s %.*s\\n\",\n\t\tinit_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version);\n\n#define P(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(ktime);\n\tPN(sched_clk);\n\tPN(cpu_clk);\n\tP(jiffies);\n#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK\n\tP(sched_clock_stable());\n#endif\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"sysctl_sched\\n\");\n\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(sysctl_sched_latency);\n\tPN(sysctl_sched_min_granularity);\n\tPN(sysctl_sched_wakeup_granularity);\n\tP(sysctl_sched_child_runs_first);\n\tP(sysctl_sched_features);\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"  .%-40s: %d (%s)\\n\",\n\t\t\"sysctl_sched_tunable_scaling\",\n\t\tsysctl_sched_tunable_scaling,\n\t\tsched_tunable_scaling_names[sysctl_sched_tunable_scaling]);\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cpu",
          "args": [
            "m",
            "cpu"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "627-697",
          "snippet": "static void print_cpu(struct seq_file *m, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n#ifdef CONFIG_X86\n\t{\n\t\tunsigned int freq = cpu_khz ? : 1;\n\n\t\tSEQ_printf(m, \"cpu#%d, %u.%03u MHz\\n\",\n\t\t\t   cpu, freq / 1000, (freq % 1000));\n\t}\n#else\n\tSEQ_printf(m, \"cpu#%d\\n\", cpu);\n#endif\n\n#define P(x)\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (sizeof(rq->x) == 4)\t\t\t\t\t\t\\\n\t\tSEQ_printf(m, \"  .%-30s: %ld\\n\", #x, (long)(rq->x));\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tSEQ_printf(m, \"  .%-30s: %Ld\\n\", #x, (long long)(rq->x));\\\n} while (0)\n\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", #x, SPLIT_NS(rq->x))\n\n\tP(nr_running);\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"load\",\n\t\t   rq->load.weight);\n\tP(nr_switches);\n\tP(nr_load_updates);\n\tP(nr_uninterruptible);\n\tPN(next_balance);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"curr->pid\", (long)(task_pid_nr(rq->curr)));\n\tPN(clock);\n\tPN(clock_task);\n\tP(cpu_load[0]);\n\tP(cpu_load[1]);\n\tP(cpu_load[2]);\n\tP(cpu_load[3]);\n\tP(cpu_load[4]);\n#undef P\n#undef PN\n\n#ifdef CONFIG_SMP\n#define P64(n) SEQ_printf(m, \"  .%-30s: %Ld\\n\", #n, rq->n);\n\tP64(avg_idle);\n\tP64(max_idle_balance_cost);\n#undef P64\n#endif\n\n#define P(n) SEQ_printf(m, \"  .%-30s: %d\\n\", #n, schedstat_val(rq->n));\n\tif (schedstat_enabled()) {\n\t\tP(yld_count);\n\t\tP(sched_count);\n\t\tP(sched_goidle);\n\t\tP(ttwu_count);\n\t\tP(ttwu_local);\n\t}\n#undef P\n\n\tspin_lock_irqsave(&sched_debug_lock, flags);\n\tprint_cfs_stats(m, cpu);\n\tprint_rt_stats(m, cpu);\n\tprint_dl_stats(m, cpu);\n\n\tprint_rq(m, rq, cpu);\n\tspin_unlock_irqrestore(&sched_debug_lock, flags);\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sched_debug_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic DEFINE_SPINLOCK(sched_debug_lock);\n\nstatic void print_cpu(struct seq_file *m, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n#ifdef CONFIG_X86\n\t{\n\t\tunsigned int freq = cpu_khz ? : 1;\n\n\t\tSEQ_printf(m, \"cpu#%d, %u.%03u MHz\\n\",\n\t\t\t   cpu, freq / 1000, (freq % 1000));\n\t}\n#else\n\tSEQ_printf(m, \"cpu#%d\\n\", cpu);\n#endif\n\n#define P(x)\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (sizeof(rq->x) == 4)\t\t\t\t\t\t\\\n\t\tSEQ_printf(m, \"  .%-30s: %ld\\n\", #x, (long)(rq->x));\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tSEQ_printf(m, \"  .%-30s: %Ld\\n\", #x, (long long)(rq->x));\\\n} while (0)\n\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", #x, SPLIT_NS(rq->x))\n\n\tP(nr_running);\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"load\",\n\t\t   rq->load.weight);\n\tP(nr_switches);\n\tP(nr_load_updates);\n\tP(nr_uninterruptible);\n\tPN(next_balance);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"curr->pid\", (long)(task_pid_nr(rq->curr)));\n\tPN(clock);\n\tPN(clock_task);\n\tP(cpu_load[0]);\n\tP(cpu_load[1]);\n\tP(cpu_load[2]);\n\tP(cpu_load[3]);\n\tP(cpu_load[4]);\n#undef P\n#undef PN\n\n#ifdef CONFIG_SMP\n#define P64(n) SEQ_printf(m, \"  .%-30s: %Ld\\n\", #n, rq->n);\n\tP64(avg_idle);\n\tP64(max_idle_balance_cost);\n#undef P64\n#endif\n\n#define P(n) SEQ_printf(m, \"  .%-30s: %d\\n\", #n, schedstat_val(rq->n));\n\tif (schedstat_enabled()) {\n\t\tP(yld_count);\n\t\tP(sched_count);\n\t\tP(sched_goidle);\n\t\tP(ttwu_count);\n\t\tP(ttwu_local);\n\t}\n#undef P\n\n\tspin_lock_irqsave(&sched_debug_lock, flags);\n\tprint_cfs_stats(m, cpu);\n\tprint_rt_stats(m, cpu);\n\tprint_dl_stats(m, cpu);\n\n\tprint_rq(m, rq, cpu);\n\tspin_unlock_irqrestore(&sched_debug_lock, flags);\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int sched_debug_show(struct seq_file *m, void *v)\n{\n\tint cpu = (unsigned long)(v - 2);\n\n\tif (cpu != -1)\n\t\tprint_cpu(m, cpu);\n\telse\n\t\tsched_debug_header(m);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_debug_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "705-755",
    "snippet": "static void sched_debug_header(struct seq_file *m)\n{\n\tu64 ktime, sched_clk, cpu_clk;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tktime = ktime_to_ns(ktime_get());\n\tsched_clk = sched_clock();\n\tcpu_clk = local_clock();\n\tlocal_irq_restore(flags);\n\n\tSEQ_printf(m, \"Sched Debug Version: v0.11, %s %.*s\\n\",\n\t\tinit_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version);\n\n#define P(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(ktime);\n\tPN(sched_clk);\n\tPN(cpu_clk);\n\tP(jiffies);\n#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK\n\tP(sched_clock_stable());\n#endif\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"sysctl_sched\\n\");\n\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(sysctl_sched_latency);\n\tPN(sysctl_sched_min_granularity);\n\tPN(sysctl_sched_wakeup_granularity);\n\tP(sysctl_sched_child_runs_first);\n\tP(sysctl_sched_features);\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"  .%-40s: %d (%s)\\n\",\n\t\t\"sysctl_sched_tunable_scaling\",\n\t\tsysctl_sched_tunable_scaling,\n\t\tsched_tunable_scaling_names[sysctl_sched_tunable_scaling]);\n\tSEQ_printf(m, \"\\n\");\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *sched_tunable_scaling_names[] = {\n\t\"none\",\n\t\"logaritmic\",\n\t\"linear\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "sysctl_sched_features"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "sysctl_sched_child_runs_first"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "sysctl_sched_wakeup_granularity"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "sysctl_sched_min_granularity"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "sysctl_sched_latency"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "sched_clock_stable()"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "188-196",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "jiffies"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "cpu_clk"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "sched_clk"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "ktime"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "init_utsname()->version",
            "\" \""
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_get()"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic const char *sched_tunable_scaling_names[] = {\n\t\"none\",\n\t\"logaritmic\",\n\t\"linear\"\n};\n\nstatic void sched_debug_header(struct seq_file *m)\n{\n\tu64 ktime, sched_clk, cpu_clk;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tktime = ktime_to_ns(ktime_get());\n\tsched_clk = sched_clock();\n\tcpu_clk = local_clock();\n\tlocal_irq_restore(flags);\n\n\tSEQ_printf(m, \"Sched Debug Version: v0.11, %s %.*s\\n\",\n\t\tinit_utsname()->release,\n\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\tinit_utsname()->version);\n\n#define P(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(ktime);\n\tPN(sched_clk);\n\tPN(cpu_clk);\n\tP(jiffies);\n#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK\n\tP(sched_clock_stable());\n#endif\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"sysctl_sched\\n\");\n\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld\\n\", #x, (long long)(x))\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-40s: %Ld.%06ld\\n\", #x, SPLIT_NS(x))\n\tPN(sysctl_sched_latency);\n\tPN(sysctl_sched_min_granularity);\n\tPN(sysctl_sched_wakeup_granularity);\n\tP(sysctl_sched_child_runs_first);\n\tP(sysctl_sched_features);\n#undef PN\n#undef P\n\n\tSEQ_printf(m, \"  .%-40s: %d (%s)\\n\",\n\t\t\"sysctl_sched_tunable_scaling\",\n\t\tsysctl_sched_tunable_scaling,\n\t\tsched_tunable_scaling_names[sysctl_sched_tunable_scaling]);\n\tSEQ_printf(m, \"\\n\");\n}"
  },
  {
    "function_name": "print_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "627-697",
    "snippet": "static void print_cpu(struct seq_file *m, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n#ifdef CONFIG_X86\n\t{\n\t\tunsigned int freq = cpu_khz ? : 1;\n\n\t\tSEQ_printf(m, \"cpu#%d, %u.%03u MHz\\n\",\n\t\t\t   cpu, freq / 1000, (freq % 1000));\n\t}\n#else\n\tSEQ_printf(m, \"cpu#%d\\n\", cpu);\n#endif\n\n#define P(x)\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (sizeof(rq->x) == 4)\t\t\t\t\t\t\\\n\t\tSEQ_printf(m, \"  .%-30s: %ld\\n\", #x, (long)(rq->x));\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tSEQ_printf(m, \"  .%-30s: %Ld\\n\", #x, (long long)(rq->x));\\\n} while (0)\n\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", #x, SPLIT_NS(rq->x))\n\n\tP(nr_running);\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"load\",\n\t\t   rq->load.weight);\n\tP(nr_switches);\n\tP(nr_load_updates);\n\tP(nr_uninterruptible);\n\tPN(next_balance);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"curr->pid\", (long)(task_pid_nr(rq->curr)));\n\tPN(clock);\n\tPN(clock_task);\n\tP(cpu_load[0]);\n\tP(cpu_load[1]);\n\tP(cpu_load[2]);\n\tP(cpu_load[3]);\n\tP(cpu_load[4]);\n#undef P\n#undef PN\n\n#ifdef CONFIG_SMP\n#define P64(n) SEQ_printf(m, \"  .%-30s: %Ld\\n\", #n, rq->n);\n\tP64(avg_idle);\n\tP64(max_idle_balance_cost);\n#undef P64\n#endif\n\n#define P(n) SEQ_printf(m, \"  .%-30s: %d\\n\", #n, schedstat_val(rq->n));\n\tif (schedstat_enabled()) {\n\t\tP(yld_count);\n\t\tP(sched_count);\n\t\tP(sched_goidle);\n\t\tP(ttwu_count);\n\t\tP(ttwu_local);\n\t}\n#undef P\n\n\tspin_lock_irqsave(&sched_debug_lock, flags);\n\tprint_cfs_stats(m, cpu);\n\tprint_rt_stats(m, cpu);\n\tprint_dl_stats(m, cpu);\n\n\tprint_rq(m, rq, cpu);\n\tspin_unlock_irqrestore(&sched_debug_lock, flags);\n\tSEQ_printf(m, \"\\n\");\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sched_debug_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sched_debug_lock",
            "flags"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_rq",
          "args": [
            "m",
            "rq",
            "cpu"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "print_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "475-494",
          "snippet": "static void print_rq(struct seq_file *m, struct rq *rq, int rq_cpu)\n{\n\tstruct task_struct *g, *p;\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"runnable tasks:\\n\");\n\tSEQ_printf(m, \" S           task   PID         tree-key  switches  prio\"\n\t\t   \"     wait-time             sum-exec        sum-sleep\\n\");\n\tSEQ_printf(m, \"-------------------------------------------------------\"\n\t\t   \"----------------------------------------------------\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (task_cpu(p) != rq_cpu)\n\t\t\tcontinue;\n\n\t\tprint_task(m, rq, p);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void print_rq(struct seq_file *m, struct rq *rq, int rq_cpu)\n{\n\tstruct task_struct *g, *p;\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"runnable tasks:\\n\");\n\tSEQ_printf(m, \" S           task   PID         tree-key  switches  prio\"\n\t\t   \"     wait-time             sum-exec        sum-sleep\\n\");\n\tSEQ_printf(m, \"-------------------------------------------------------\"\n\t\t   \"----------------------------------------------------\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (task_cpu(p) != rq_cpu)\n\t\t\tcontinue;\n\n\t\tprint_task(m, rq, p);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_dl_stats",
          "args": [
            "m",
            "cpu"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "print_dl_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2753-2756",
          "snippet": "void print_dl_stats(struct seq_file *m, int cpu)\n{\n\tprint_dl_rq(m, cpu, &cpu_rq(cpu)->dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid print_dl_stats(struct seq_file *m, int cpu)\n{\n\tprint_dl_rq(m, cpu, &cpu_rq(cpu)->dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_rt_stats",
          "args": [
            "m",
            "cpu"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "print_rt_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2721-2730",
          "snippet": "void print_rt_stats(struct seq_file *m, int cpu)\n{\n\trt_rq_iter_t iter;\n\tstruct rt_rq *rt_rq;\n\n\trcu_read_lock();\n\tfor_each_rt_rq(rt_rq, iter, cpu_rq(cpu))\n\t\tprint_rt_rq(m, cpu, rt_rq);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_top_rt_rq(struct rt_rq *rt_rq);",
            "static void dequeue_top_rt_rq(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_top_rt_rq(struct rt_rq *rt_rq);\nstatic void dequeue_top_rt_rq(struct rt_rq *rt_rq);\n\nvoid print_rt_stats(struct seq_file *m, int cpu)\n{\n\trt_rq_iter_t iter;\n\tstruct rt_rq *rt_rq;\n\n\trcu_read_lock();\n\tfor_each_rt_rq(rt_rq, iter, cpu_rq(cpu))\n\t\tprint_rt_rq(m, cpu, rt_rq);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cfs_stats",
          "args": [
            "m",
            "cpu"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&sched_debug_lock",
            "flags"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "ttwu_local"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "ttwu_count"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "sched_goidle"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "sched_count"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "yld_count"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2231-2237",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "P64",
          "args": [
            "max_idle_balance_cost"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P64",
          "args": [
            "avg_idle"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "cpu_load[4]"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "cpu_load[3]"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "cpu_load[2]"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "cpu_load[1]"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "cpu_load[0]"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "clock_task"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "clock"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "rq->curr"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "next_balance"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nr_uninterruptible"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nr_load_updates"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nr_switches"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nr_running"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic DEFINE_SPINLOCK(sched_debug_lock);\n\nstatic void print_cpu(struct seq_file *m, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n#ifdef CONFIG_X86\n\t{\n\t\tunsigned int freq = cpu_khz ? : 1;\n\n\t\tSEQ_printf(m, \"cpu#%d, %u.%03u MHz\\n\",\n\t\t\t   cpu, freq / 1000, (freq % 1000));\n\t}\n#else\n\tSEQ_printf(m, \"cpu#%d\\n\", cpu);\n#endif\n\n#define P(x)\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (sizeof(rq->x) == 4)\t\t\t\t\t\t\\\n\t\tSEQ_printf(m, \"  .%-30s: %ld\\n\", #x, (long)(rq->x));\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tSEQ_printf(m, \"  .%-30s: %Ld\\n\", #x, (long long)(rq->x));\\\n} while (0)\n\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", #x, SPLIT_NS(rq->x))\n\n\tP(nr_running);\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"load\",\n\t\t   rq->load.weight);\n\tP(nr_switches);\n\tP(nr_load_updates);\n\tP(nr_uninterruptible);\n\tPN(next_balance);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"curr->pid\", (long)(task_pid_nr(rq->curr)));\n\tPN(clock);\n\tPN(clock_task);\n\tP(cpu_load[0]);\n\tP(cpu_load[1]);\n\tP(cpu_load[2]);\n\tP(cpu_load[3]);\n\tP(cpu_load[4]);\n#undef P\n#undef PN\n\n#ifdef CONFIG_SMP\n#define P64(n) SEQ_printf(m, \"  .%-30s: %Ld\\n\", #n, rq->n);\n\tP64(avg_idle);\n\tP64(max_idle_balance_cost);\n#undef P64\n#endif\n\n#define P(n) SEQ_printf(m, \"  .%-30s: %d\\n\", #n, schedstat_val(rq->n));\n\tif (schedstat_enabled()) {\n\t\tP(yld_count);\n\t\tP(sched_count);\n\t\tP(sched_goidle);\n\t\tP(ttwu_count);\n\t\tP(ttwu_local);\n\t}\n#undef P\n\n\tspin_lock_irqsave(&sched_debug_lock, flags);\n\tprint_cfs_stats(m, cpu);\n\tprint_rt_stats(m, cpu);\n\tprint_dl_stats(m, cpu);\n\n\tprint_rq(m, rq, cpu);\n\tspin_unlock_irqrestore(&sched_debug_lock, flags);\n\tSEQ_printf(m, \"\\n\");\n}"
  },
  {
    "function_name": "print_dl_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "604-625",
    "snippet": "void print_dl_rq(struct seq_file *m, int cpu, struct dl_rq *dl_rq)\n{\n\tstruct dl_bw *dl_bw;\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"dl_rq[%d]:\\n\", cpu);\n\n#define PU(x) \\\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", #x, (unsigned long)(dl_rq->x))\n\n\tPU(dl_nr_running);\n#ifdef CONFIG_SMP\n\tPU(dl_nr_migratory);\n\tdl_bw = &cpu_rq(cpu)->rd->dl_bw;\n#else\n\tdl_bw = &dl_rq->dl_bw;\n#endif\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->bw\", dl_bw->bw);\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->total_bw\", dl_bw->total_bw);\n\n#undef PU\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"  .%-30s: %lld\\n\"",
            "\"dl_bw->total_bw\"",
            "dl_bw->total_bw"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "dl_nr_migratory"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "dl_nr_running"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid print_dl_rq(struct seq_file *m, int cpu, struct dl_rq *dl_rq)\n{\n\tstruct dl_bw *dl_bw;\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"dl_rq[%d]:\\n\", cpu);\n\n#define PU(x) \\\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", #x, (unsigned long)(dl_rq->x))\n\n\tPU(dl_nr_running);\n#ifdef CONFIG_SMP\n\tPU(dl_nr_migratory);\n\tdl_bw = &cpu_rq(cpu)->rd->dl_bw;\n#else\n\tdl_bw = &dl_rq->dl_bw;\n#endif\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->bw\", dl_bw->bw);\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->total_bw\", dl_bw->total_bw);\n\n#undef PU\n}"
  },
  {
    "function_name": "print_rt_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "574-602",
    "snippet": "void print_rt_rq(struct seq_file *m, int cpu, struct rt_rq *rt_rq)\n{\n#ifdef CONFIG_RT_GROUP_SCHED\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"rt_rq[%d]:%s\\n\", cpu, task_group_path(rt_rq->tg));\n#else\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"rt_rq[%d]:\\n\", cpu);\n#endif\n\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-30s: %Ld\\n\", #x, (long long)(rt_rq->x))\n#define PU(x) \\\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", #x, (unsigned long)(rt_rq->x))\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", #x, SPLIT_NS(rt_rq->x))\n\n\tPU(rt_nr_running);\n#ifdef CONFIG_SMP\n\tPU(rt_nr_migratory);\n#endif\n\tP(rt_throttled);\n\tPN(rt_time);\n\tPN(rt_runtime);\n\n#undef PN\n#undef PU\n#undef P\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "rt_runtime"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "rt_time"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "rt_throttled"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "rt_nr_migratory"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PU",
          "args": [
            "rt_nr_running"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"rt_rq[%d]:\\n\"",
            "cpu"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_group_path",
          "args": [
            "rt_rq->tg"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "435-443",
          "snippet": "static char *task_group_path(struct task_group *tg)\n{\n\tif (autogroup_path(tg, group_path, PATH_MAX))\n\t\treturn group_path;\n\n\tcgroup_path(tg->css.cgroup, group_path, PATH_MAX);\n\n\treturn group_path;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic char *task_group_path(struct task_group *tg)\n{\n\tif (autogroup_path(tg, group_path, PATH_MAX))\n\t\treturn group_path;\n\n\tcgroup_path(tg->css.cgroup, group_path, PATH_MAX);\n\n\treturn group_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid print_rt_rq(struct seq_file *m, int cpu, struct rt_rq *rt_rq)\n{\n#ifdef CONFIG_RT_GROUP_SCHED\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"rt_rq[%d]:%s\\n\", cpu, task_group_path(rt_rq->tg));\n#else\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"rt_rq[%d]:\\n\", cpu);\n#endif\n\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-30s: %Ld\\n\", #x, (long long)(rt_rq->x))\n#define PU(x) \\\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", #x, (unsigned long)(rt_rq->x))\n#define PN(x) \\\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", #x, SPLIT_NS(rt_rq->x))\n\n\tPU(rt_nr_running);\n#ifdef CONFIG_SMP\n\tPU(rt_nr_migratory);\n#endif\n\tP(rt_throttled);\n\tPN(rt_time);\n\tPN(rt_runtime);\n\n#undef PN\n#undef PU\n#undef P\n}"
  },
  {
    "function_name": "print_cfs_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "496-572",
    "snippet": "void print_cfs_rq(struct seq_file *m, int cpu, struct cfs_rq *cfs_rq)\n{\n\ts64 MIN_vruntime = -1, min_vruntime, max_vruntime = -1,\n\t\tspread, rq0_min_vruntime, spread0;\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_entity *last;\n\tunsigned long flags;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"cfs_rq[%d]:%s\\n\", cpu, task_group_path(cfs_rq->tg));\n#else\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"cfs_rq[%d]:\\n\", cpu);\n#endif\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"exec_clock\",\n\t\t\tSPLIT_NS(cfs_rq->exec_clock));\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\tif (rb_first_cached(&cfs_rq->tasks_timeline))\n\t\tMIN_vruntime = (__pick_first_entity(cfs_rq))->vruntime;\n\tlast = __pick_last_entity(cfs_rq);\n\tif (last)\n\t\tmax_vruntime = last->vruntime;\n\tmin_vruntime = cfs_rq->min_vruntime;\n\trq0_min_vruntime = cpu_rq(0)->cfs.min_vruntime;\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"MIN_vruntime\",\n\t\t\tSPLIT_NS(MIN_vruntime));\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"min_vruntime\",\n\t\t\tSPLIT_NS(min_vruntime));\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"max_vruntime\",\n\t\t\tSPLIT_NS(max_vruntime));\n\tspread = max_vruntime - MIN_vruntime;\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"spread\",\n\t\t\tSPLIT_NS(spread));\n\tspread0 = min_vruntime - rq0_min_vruntime;\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"spread0\",\n\t\t\tSPLIT_NS(spread0));\n\tSEQ_printf(m, \"  .%-30s: %d\\n\", \"nr_spread_over\",\n\t\t\tcfs_rq->nr_spread_over);\n\tSEQ_printf(m, \"  .%-30s: %d\\n\", \"nr_running\", cfs_rq->nr_running);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"load\", cfs_rq->load.weight);\n#ifdef CONFIG_SMP\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"runnable_weight\", cfs_rq->runnable_weight);\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"load_avg\",\n\t\t\tcfs_rq->avg.load_avg);\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"runnable_load_avg\",\n\t\t\tcfs_rq->avg.runnable_load_avg);\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"util_avg\",\n\t\t\tcfs_rq->avg.util_avg);\n\tSEQ_printf(m, \"  .%-30s: %u\\n\", \"util_est_enqueued\",\n\t\t\tcfs_rq->avg.util_est.enqueued);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"removed.load_avg\",\n\t\t\tcfs_rq->removed.load_avg);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"removed.util_avg\",\n\t\t\tcfs_rq->removed.util_avg);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"removed.runnable_sum\",\n\t\t\tcfs_rq->removed.runnable_sum);\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"tg_load_avg_contrib\",\n\t\t\tcfs_rq->tg_load_avg_contrib);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"tg_load_avg\",\n\t\t\tatomic_long_read(&cfs_rq->tg->load_avg));\n#endif\n#endif\n#ifdef CONFIG_CFS_BANDWIDTH\n\tSEQ_printf(m, \"  .%-30s: %d\\n\", \"throttled\",\n\t\t\tcfs_rq->throttled);\n\tSEQ_printf(m, \"  .%-30s: %d\\n\", \"throttle_count\",\n\t\t\tcfs_rq->throttle_count);\n#endif\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tprint_cfs_group_stats(m, cpu, cfs_rq->tg);\n#endif\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_cfs_group_stats",
          "args": [
            "m",
            "cpu",
            "cfs_rq->tg"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "print_cfs_group_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "388-429",
          "snippet": "static void print_cfs_group_stats(struct seq_file *m, int cpu, struct task_group *tg)\n{\n\tstruct sched_entity *se = tg->se[cpu];\n\n#define P(F)\t\tSEQ_printf(m, \"  .%-30s: %lld\\n\",\t#F, (long long)F)\n#define P_SCHEDSTAT(F)\tSEQ_printf(m, \"  .%-30s: %lld\\n\",\t#F, (long long)schedstat_val(F))\n#define PN(F)\t\tSEQ_printf(m, \"  .%-30s: %lld.%06ld\\n\", #F, SPLIT_NS((long long)F))\n#define PN_SCHEDSTAT(F)\tSEQ_printf(m, \"  .%-30s: %lld.%06ld\\n\", #F, SPLIT_NS((long long)schedstat_val(F)))\n\n\tif (!se)\n\t\treturn;\n\n\tPN(se->exec_start);\n\tPN(se->vruntime);\n\tPN(se->sum_exec_runtime);\n\n\tif (schedstat_enabled()) {\n\t\tPN_SCHEDSTAT(se->statistics.wait_start);\n\t\tPN_SCHEDSTAT(se->statistics.sleep_start);\n\t\tPN_SCHEDSTAT(se->statistics.block_start);\n\t\tPN_SCHEDSTAT(se->statistics.sleep_max);\n\t\tPN_SCHEDSTAT(se->statistics.block_max);\n\t\tPN_SCHEDSTAT(se->statistics.exec_max);\n\t\tPN_SCHEDSTAT(se->statistics.slice_max);\n\t\tPN_SCHEDSTAT(se->statistics.wait_max);\n\t\tPN_SCHEDSTAT(se->statistics.wait_sum);\n\t\tP_SCHEDSTAT(se->statistics.wait_count);\n\t}\n\n\tP(se->load.weight);\n\tP(se->runnable_weight);\n#ifdef CONFIG_SMP\n\tP(se->avg.load_avg);\n\tP(se->avg.util_avg);\n\tP(se->avg.runnable_load_avg);\n#endif\n\n#undef PN_SCHEDSTAT\n#undef PN\n#undef P_SCHEDSTAT\n#undef P\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void print_cfs_group_stats(struct seq_file *m, int cpu, struct task_group *tg)\n{\n\tstruct sched_entity *se = tg->se[cpu];\n\n#define P(F)\t\tSEQ_printf(m, \"  .%-30s: %lld\\n\",\t#F, (long long)F)\n#define P_SCHEDSTAT(F)\tSEQ_printf(m, \"  .%-30s: %lld\\n\",\t#F, (long long)schedstat_val(F))\n#define PN(F)\t\tSEQ_printf(m, \"  .%-30s: %lld.%06ld\\n\", #F, SPLIT_NS((long long)F))\n#define PN_SCHEDSTAT(F)\tSEQ_printf(m, \"  .%-30s: %lld.%06ld\\n\", #F, SPLIT_NS((long long)schedstat_val(F)))\n\n\tif (!se)\n\t\treturn;\n\n\tPN(se->exec_start);\n\tPN(se->vruntime);\n\tPN(se->sum_exec_runtime);\n\n\tif (schedstat_enabled()) {\n\t\tPN_SCHEDSTAT(se->statistics.wait_start);\n\t\tPN_SCHEDSTAT(se->statistics.sleep_start);\n\t\tPN_SCHEDSTAT(se->statistics.block_start);\n\t\tPN_SCHEDSTAT(se->statistics.sleep_max);\n\t\tPN_SCHEDSTAT(se->statistics.block_max);\n\t\tPN_SCHEDSTAT(se->statistics.exec_max);\n\t\tPN_SCHEDSTAT(se->statistics.slice_max);\n\t\tPN_SCHEDSTAT(se->statistics.wait_max);\n\t\tPN_SCHEDSTAT(se->statistics.wait_sum);\n\t\tP_SCHEDSTAT(se->statistics.wait_count);\n\t}\n\n\tP(se->load.weight);\n\tP(se->runnable_weight);\n#ifdef CONFIG_SMP\n\tP(se->avg.load_avg);\n\tP(se->avg.util_avg);\n\tP(se->avg.runnable_load_avg);\n#endif\n\n#undef PN_SCHEDSTAT\n#undef PN\n#undef P_SCHEDSTAT\n#undef P\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"  .%-30s: %d\\n\"",
            "\"throttle_count\"",
            "cfs_rq->throttle_count"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&cfs_rq->tg->load_avg"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPLIT_NS",
          "args": [
            "spread0"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPLIT_NS",
          "args": [
            "spread"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPLIT_NS",
          "args": [
            "max_vruntime"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPLIT_NS",
          "args": [
            "min_vruntime"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPLIT_NS",
          "args": [
            "MIN_vruntime"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rq->lock",
            "flags"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "0"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pick_last_entity",
          "args": [
            "cfs_rq"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "__pick_last_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "587-595",
          "snippet": "struct sched_entity *__pick_last_entity(struct cfs_rq *cfs_rq)\n{\n\tstruct rb_node *last = rb_last(&cfs_rq->tasks_timeline.rb_root);\n\n\tif (!last)\n\t\treturn NULL;\n\n\treturn rb_entry(last, struct sched_entity, run_node);\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstruct sched_entity *__pick_last_entity(struct cfs_rq *cfs_rq)\n{\n\tstruct rb_node *last = rb_last(&cfs_rq->tasks_timeline.rb_root);\n\n\tif (!last)\n\t\treturn NULL;\n\n\treturn rb_entry(last, struct sched_entity, run_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pick_first_entity",
          "args": [
            "cfs_rq"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "__pick_first_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "566-574",
          "snippet": "struct sched_entity *__pick_first_entity(struct cfs_rq *cfs_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&cfs_rq->tasks_timeline);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_entity, run_node);\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstruct sched_entity *__pick_first_entity(struct cfs_rq *cfs_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&cfs_rq->tasks_timeline);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_entity, run_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first_cached",
          "args": [
            "&cfs_rq->tasks_timeline"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rq->lock",
            "flags"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPLIT_NS",
          "args": [
            "cfs_rq->exec_clock"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_group_path",
          "args": [
            "cfs_rq->tg"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "435-443",
          "snippet": "static char *task_group_path(struct task_group *tg)\n{\n\tif (autogroup_path(tg, group_path, PATH_MAX))\n\t\treturn group_path;\n\n\tcgroup_path(tg->css.cgroup, group_path, PATH_MAX);\n\n\treturn group_path;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic char *task_group_path(struct task_group *tg)\n{\n\tif (autogroup_path(tg, group_path, PATH_MAX))\n\t\treturn group_path;\n\n\tcgroup_path(tg->css.cgroup, group_path, PATH_MAX);\n\n\treturn group_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid print_cfs_rq(struct seq_file *m, int cpu, struct cfs_rq *cfs_rq)\n{\n\ts64 MIN_vruntime = -1, min_vruntime, max_vruntime = -1,\n\t\tspread, rq0_min_vruntime, spread0;\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_entity *last;\n\tunsigned long flags;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"cfs_rq[%d]:%s\\n\", cpu, task_group_path(cfs_rq->tg));\n#else\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"cfs_rq[%d]:\\n\", cpu);\n#endif\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"exec_clock\",\n\t\t\tSPLIT_NS(cfs_rq->exec_clock));\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\tif (rb_first_cached(&cfs_rq->tasks_timeline))\n\t\tMIN_vruntime = (__pick_first_entity(cfs_rq))->vruntime;\n\tlast = __pick_last_entity(cfs_rq);\n\tif (last)\n\t\tmax_vruntime = last->vruntime;\n\tmin_vruntime = cfs_rq->min_vruntime;\n\trq0_min_vruntime = cpu_rq(0)->cfs.min_vruntime;\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"MIN_vruntime\",\n\t\t\tSPLIT_NS(MIN_vruntime));\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"min_vruntime\",\n\t\t\tSPLIT_NS(min_vruntime));\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"max_vruntime\",\n\t\t\tSPLIT_NS(max_vruntime));\n\tspread = max_vruntime - MIN_vruntime;\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"spread\",\n\t\t\tSPLIT_NS(spread));\n\tspread0 = min_vruntime - rq0_min_vruntime;\n\tSEQ_printf(m, \"  .%-30s: %Ld.%06ld\\n\", \"spread0\",\n\t\t\tSPLIT_NS(spread0));\n\tSEQ_printf(m, \"  .%-30s: %d\\n\", \"nr_spread_over\",\n\t\t\tcfs_rq->nr_spread_over);\n\tSEQ_printf(m, \"  .%-30s: %d\\n\", \"nr_running\", cfs_rq->nr_running);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"load\", cfs_rq->load.weight);\n#ifdef CONFIG_SMP\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"runnable_weight\", cfs_rq->runnable_weight);\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"load_avg\",\n\t\t\tcfs_rq->avg.load_avg);\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"runnable_load_avg\",\n\t\t\tcfs_rq->avg.runnable_load_avg);\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"util_avg\",\n\t\t\tcfs_rq->avg.util_avg);\n\tSEQ_printf(m, \"  .%-30s: %u\\n\", \"util_est_enqueued\",\n\t\t\tcfs_rq->avg.util_est.enqueued);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"removed.load_avg\",\n\t\t\tcfs_rq->removed.load_avg);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"removed.util_avg\",\n\t\t\tcfs_rq->removed.util_avg);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"removed.runnable_sum\",\n\t\t\tcfs_rq->removed.runnable_sum);\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", \"tg_load_avg_contrib\",\n\t\t\tcfs_rq->tg_load_avg_contrib);\n\tSEQ_printf(m, \"  .%-30s: %ld\\n\", \"tg_load_avg\",\n\t\t\tatomic_long_read(&cfs_rq->tg->load_avg));\n#endif\n#endif\n#ifdef CONFIG_CFS_BANDWIDTH\n\tSEQ_printf(m, \"  .%-30s: %d\\n\", \"throttled\",\n\t\t\tcfs_rq->throttled);\n\tSEQ_printf(m, \"  .%-30s: %d\\n\", \"throttle_count\",\n\t\t\tcfs_rq->throttle_count);\n#endif\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tprint_cfs_group_stats(m, cpu, cfs_rq->tg);\n#endif\n}"
  },
  {
    "function_name": "print_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "475-494",
    "snippet": "static void print_rq(struct seq_file *m, struct rq *rq, int rq_cpu)\n{\n\tstruct task_struct *g, *p;\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"runnable tasks:\\n\");\n\tSEQ_printf(m, \" S           task   PID         tree-key  switches  prio\"\n\t\t   \"     wait-time             sum-exec        sum-sleep\\n\");\n\tSEQ_printf(m, \"-------------------------------------------------------\"\n\t\t   \"----------------------------------------------------\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (task_cpu(p) != rq_cpu)\n\t\t\tcontinue;\n\n\t\tprint_task(m, rq, p);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_task",
          "args": [
            "m",
            "rq",
            "p"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "print_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "446-473",
          "snippet": "static void\nprint_task(struct seq_file *m, struct rq *rq, struct task_struct *p)\n{\n\tif (rq->curr == p)\n\t\tSEQ_printf(m, \">R\");\n\telse\n\t\tSEQ_printf(m, \" %c\", task_state_to_char(p));\n\n\tSEQ_printf(m, \"%15s %5d %9Ld.%06ld %9Ld %5d \",\n\t\tp->comm, task_pid_nr(p),\n\t\tSPLIT_NS(p->se.vruntime),\n\t\t(long long)(p->nvcsw + p->nivcsw),\n\t\tp->prio);\n\n\tSEQ_printf(m, \"%9Ld.%06ld %9Ld.%06ld %9Ld.%06ld\",\n\t\tSPLIT_NS(schedstat_val_or_zero(p->se.statistics.wait_sum)),\n\t\tSPLIT_NS(p->se.sum_exec_runtime),\n\t\tSPLIT_NS(schedstat_val_or_zero(p->se.statistics.sum_sleep_runtime)));\n\n#ifdef CONFIG_NUMA_BALANCING\n\tSEQ_printf(m, \" %d %d\", task_node(p), task_numa_group_id(p));\n#endif\n#ifdef CONFIG_CGROUP_SCHED\n\tSEQ_printf(m, \" %s\", task_group_path(task_group(p)));\n#endif\n\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void\nprint_task(struct seq_file *m, struct rq *rq, struct task_struct *p)\n{\n\tif (rq->curr == p)\n\t\tSEQ_printf(m, \">R\");\n\telse\n\t\tSEQ_printf(m, \" %c\", task_state_to_char(p));\n\n\tSEQ_printf(m, \"%15s %5d %9Ld.%06ld %9Ld %5d \",\n\t\tp->comm, task_pid_nr(p),\n\t\tSPLIT_NS(p->se.vruntime),\n\t\t(long long)(p->nvcsw + p->nivcsw),\n\t\tp->prio);\n\n\tSEQ_printf(m, \"%9Ld.%06ld %9Ld.%06ld %9Ld.%06ld\",\n\t\tSPLIT_NS(schedstat_val_or_zero(p->se.statistics.wait_sum)),\n\t\tSPLIT_NS(p->se.sum_exec_runtime),\n\t\tSPLIT_NS(schedstat_val_or_zero(p->se.statistics.sum_sleep_runtime)));\n\n#ifdef CONFIG_NUMA_BALANCING\n\tSEQ_printf(m, \" %d %d\", task_node(p), task_numa_group_id(p));\n#endif\n#ifdef CONFIG_CGROUP_SCHED\n\tSEQ_printf(m, \" %s\", task_group_path(task_group(p)));\n#endif\n\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"-------------------------------------------------------\"\n\t\t   \"----------------------------------------------------\\n\""
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void print_rq(struct seq_file *m, struct rq *rq, int rq_cpu)\n{\n\tstruct task_struct *g, *p;\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"runnable tasks:\\n\");\n\tSEQ_printf(m, \" S           task   PID         tree-key  switches  prio\"\n\t\t   \"     wait-time             sum-exec        sum-sleep\\n\");\n\tSEQ_printf(m, \"-------------------------------------------------------\"\n\t\t   \"----------------------------------------------------\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (task_cpu(p) != rq_cpu)\n\t\t\tcontinue;\n\n\t\tprint_task(m, rq, p);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "print_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "446-473",
    "snippet": "static void\nprint_task(struct seq_file *m, struct rq *rq, struct task_struct *p)\n{\n\tif (rq->curr == p)\n\t\tSEQ_printf(m, \">R\");\n\telse\n\t\tSEQ_printf(m, \" %c\", task_state_to_char(p));\n\n\tSEQ_printf(m, \"%15s %5d %9Ld.%06ld %9Ld %5d \",\n\t\tp->comm, task_pid_nr(p),\n\t\tSPLIT_NS(p->se.vruntime),\n\t\t(long long)(p->nvcsw + p->nivcsw),\n\t\tp->prio);\n\n\tSEQ_printf(m, \"%9Ld.%06ld %9Ld.%06ld %9Ld.%06ld\",\n\t\tSPLIT_NS(schedstat_val_or_zero(p->se.statistics.wait_sum)),\n\t\tSPLIT_NS(p->se.sum_exec_runtime),\n\t\tSPLIT_NS(schedstat_val_or_zero(p->se.statistics.sum_sleep_runtime)));\n\n#ifdef CONFIG_NUMA_BALANCING\n\tSEQ_printf(m, \" %d %d\", task_node(p), task_numa_group_id(p));\n#endif\n#ifdef CONFIG_CGROUP_SCHED\n\tSEQ_printf(m, \" %s\", task_group_path(task_group(p)));\n#endif\n\n\tSEQ_printf(m, \"\\n\");\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_group_path",
          "args": [
            "task_group(p)"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "435-443",
          "snippet": "static char *task_group_path(struct task_group *tg)\n{\n\tif (autogroup_path(tg, group_path, PATH_MAX))\n\t\treturn group_path;\n\n\tcgroup_path(tg->css.cgroup, group_path, PATH_MAX);\n\n\treturn group_path;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic char *task_group_path(struct task_group *tg)\n{\n\tif (autogroup_path(tg, group_path, PATH_MAX))\n\t\treturn group_path;\n\n\tcgroup_path(tg->css.cgroup, group_path, PATH_MAX);\n\n\treturn group_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_numa_group_id",
          "args": [
            "p"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "task_numa_group_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "1203-1206",
          "snippet": "pid_t task_numa_group_id(struct task_struct *p)\n{\n\treturn p->numa_group ? p->numa_group->gid : 0;\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\npid_t task_numa_group_id(struct task_struct *p)\n{\n\treturn p->numa_group ? p->numa_group->gid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_node",
          "args": [
            "p"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPLIT_NS",
          "args": [
            "schedstat_val_or_zero(p->se.statistics.sum_sleep_runtime)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_val_or_zero",
          "args": [
            "p->se.statistics.sum_sleep_runtime"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPLIT_NS",
          "args": [
            "p->se.sum_exec_runtime"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPLIT_NS",
          "args": [
            "schedstat_val_or_zero(p->se.statistics.wait_sum)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_val_or_zero",
          "args": [
            "p->se.statistics.wait_sum"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPLIT_NS",
          "args": [
            "p->se.vruntime"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "p"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_state_to_char",
          "args": [
            "p"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void\nprint_task(struct seq_file *m, struct rq *rq, struct task_struct *p)\n{\n\tif (rq->curr == p)\n\t\tSEQ_printf(m, \">R\");\n\telse\n\t\tSEQ_printf(m, \" %c\", task_state_to_char(p));\n\n\tSEQ_printf(m, \"%15s %5d %9Ld.%06ld %9Ld %5d \",\n\t\tp->comm, task_pid_nr(p),\n\t\tSPLIT_NS(p->se.vruntime),\n\t\t(long long)(p->nvcsw + p->nivcsw),\n\t\tp->prio);\n\n\tSEQ_printf(m, \"%9Ld.%06ld %9Ld.%06ld %9Ld.%06ld\",\n\t\tSPLIT_NS(schedstat_val_or_zero(p->se.statistics.wait_sum)),\n\t\tSPLIT_NS(p->se.sum_exec_runtime),\n\t\tSPLIT_NS(schedstat_val_or_zero(p->se.statistics.sum_sleep_runtime)));\n\n#ifdef CONFIG_NUMA_BALANCING\n\tSEQ_printf(m, \" %d %d\", task_node(p), task_numa_group_id(p));\n#endif\n#ifdef CONFIG_CGROUP_SCHED\n\tSEQ_printf(m, \" %s\", task_group_path(task_group(p)));\n#endif\n\n\tSEQ_printf(m, \"\\n\");\n}"
  },
  {
    "function_name": "task_group_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "435-443",
    "snippet": "static char *task_group_path(struct task_group *tg)\n{\n\tif (autogroup_path(tg, group_path, PATH_MAX))\n\t\treturn group_path;\n\n\tcgroup_path(tg->css.cgroup, group_path, PATH_MAX);\n\n\treturn group_path;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_path",
          "args": [
            "tg->css.cgroup",
            "group_path",
            "PATH_MAX"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_path_from_kernfs_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5454-5464",
          "snippet": "void cgroup_path_from_kernfs_id(const union kernfs_node_id *id,\n\t\t\t\t\tchar *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\n\nvoid cgroup_path_from_kernfs_id(const union kernfs_node_id *id,\n\t\t\t\t\tchar *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autogroup_path",
          "args": [
            "tg",
            "group_path",
            "PATH_MAX"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/autogroup.h",
          "lines": "55-58",
          "snippet": "static inline int autogroup_path(struct task_group *tg, char *buf, int buflen)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int autogroup_path(struct task_group *tg, char *buf, int buflen)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic char *task_group_path(struct task_group *tg)\n{\n\tif (autogroup_path(tg, group_path, PATH_MAX))\n\t\treturn group_path;\n\n\tcgroup_path(tg->css.cgroup, group_path, PATH_MAX);\n\n\treturn group_path;\n}"
  },
  {
    "function_name": "print_cfs_group_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "388-429",
    "snippet": "static void print_cfs_group_stats(struct seq_file *m, int cpu, struct task_group *tg)\n{\n\tstruct sched_entity *se = tg->se[cpu];\n\n#define P(F)\t\tSEQ_printf(m, \"  .%-30s: %lld\\n\",\t#F, (long long)F)\n#define P_SCHEDSTAT(F)\tSEQ_printf(m, \"  .%-30s: %lld\\n\",\t#F, (long long)schedstat_val(F))\n#define PN(F)\t\tSEQ_printf(m, \"  .%-30s: %lld.%06ld\\n\", #F, SPLIT_NS((long long)F))\n#define PN_SCHEDSTAT(F)\tSEQ_printf(m, \"  .%-30s: %lld.%06ld\\n\", #F, SPLIT_NS((long long)schedstat_val(F)))\n\n\tif (!se)\n\t\treturn;\n\n\tPN(se->exec_start);\n\tPN(se->vruntime);\n\tPN(se->sum_exec_runtime);\n\n\tif (schedstat_enabled()) {\n\t\tPN_SCHEDSTAT(se->statistics.wait_start);\n\t\tPN_SCHEDSTAT(se->statistics.sleep_start);\n\t\tPN_SCHEDSTAT(se->statistics.block_start);\n\t\tPN_SCHEDSTAT(se->statistics.sleep_max);\n\t\tPN_SCHEDSTAT(se->statistics.block_max);\n\t\tPN_SCHEDSTAT(se->statistics.exec_max);\n\t\tPN_SCHEDSTAT(se->statistics.slice_max);\n\t\tPN_SCHEDSTAT(se->statistics.wait_max);\n\t\tPN_SCHEDSTAT(se->statistics.wait_sum);\n\t\tP_SCHEDSTAT(se->statistics.wait_count);\n\t}\n\n\tP(se->load.weight);\n\tP(se->runnable_weight);\n#ifdef CONFIG_SMP\n\tP(se->avg.load_avg);\n\tP(se->avg.util_avg);\n\tP(se->avg.runnable_load_avg);\n#endif\n\n#undef PN_SCHEDSTAT\n#undef PN\n#undef P_SCHEDSTAT\n#undef P\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se->avg.runnable_load_avg"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se->avg.util_avg"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se->avg.load_avg"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se->runnable_weight"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "se->load.weight"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_SCHEDSTAT",
          "args": [
            "se->statistics.wait_count"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se->statistics.wait_sum"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se->statistics.wait_max"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se->statistics.slice_max"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se->statistics.exec_max"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se->statistics.block_max"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se->statistics.sleep_max"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se->statistics.block_start"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se->statistics.sleep_start"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN_SCHEDSTAT",
          "args": [
            "se->statistics.wait_start"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2231-2237",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "se->sum_exec_runtime"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "se->vruntime"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PN",
          "args": [
            "se->exec_start"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void print_cfs_group_stats(struct seq_file *m, int cpu, struct task_group *tg)\n{\n\tstruct sched_entity *se = tg->se[cpu];\n\n#define P(F)\t\tSEQ_printf(m, \"  .%-30s: %lld\\n\",\t#F, (long long)F)\n#define P_SCHEDSTAT(F)\tSEQ_printf(m, \"  .%-30s: %lld\\n\",\t#F, (long long)schedstat_val(F))\n#define PN(F)\t\tSEQ_printf(m, \"  .%-30s: %lld.%06ld\\n\", #F, SPLIT_NS((long long)F))\n#define PN_SCHEDSTAT(F)\tSEQ_printf(m, \"  .%-30s: %lld.%06ld\\n\", #F, SPLIT_NS((long long)schedstat_val(F)))\n\n\tif (!se)\n\t\treturn;\n\n\tPN(se->exec_start);\n\tPN(se->vruntime);\n\tPN(se->sum_exec_runtime);\n\n\tif (schedstat_enabled()) {\n\t\tPN_SCHEDSTAT(se->statistics.wait_start);\n\t\tPN_SCHEDSTAT(se->statistics.sleep_start);\n\t\tPN_SCHEDSTAT(se->statistics.block_start);\n\t\tPN_SCHEDSTAT(se->statistics.sleep_max);\n\t\tPN_SCHEDSTAT(se->statistics.block_max);\n\t\tPN_SCHEDSTAT(se->statistics.exec_max);\n\t\tPN_SCHEDSTAT(se->statistics.slice_max);\n\t\tPN_SCHEDSTAT(se->statistics.wait_max);\n\t\tPN_SCHEDSTAT(se->statistics.wait_sum);\n\t\tP_SCHEDSTAT(se->statistics.wait_count);\n\t}\n\n\tP(se->load.weight);\n\tP(se->runnable_weight);\n#ifdef CONFIG_SMP\n\tP(se->avg.load_avg);\n\tP(se->avg.util_avg);\n\tP(se->avg.runnable_load_avg);\n#endif\n\n#undef PN_SCHEDSTAT\n#undef PN\n#undef P_SCHEDSTAT\n#undef P\n}"
  },
  {
    "function_name": "unregister_sched_domain_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "379-383",
    "snippet": "void unregister_sched_domain_sysctl(void)\n{\n\tunregister_sysctl_table(sd_sysctl_header);\n\tsd_sysctl_header = NULL;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_sysctl_table",
          "args": [
            "sd_sysctl_header"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid unregister_sched_domain_sysctl(void)\n{\n\tunregister_sysctl_table(sd_sysctl_header);\n\tsd_sysctl_header = NULL;\n}"
  },
  {
    "function_name": "dirty_sched_domain_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "372-376",
    "snippet": "void dirty_sched_domain_sysctl(int cpu)\n{\n\tif (cpumask_available(sd_sysctl_cpus))\n\t\t__cpumask_set_cpu(cpu, sd_sysctl_cpus);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpumask_set_cpu",
          "args": [
            "cpu",
            "sd_sysctl_cpus"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "sd_sysctl_cpus"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid dirty_sched_domain_sysctl(int cpu)\n{\n\tif (cpumask_available(sd_sysctl_cpus))\n\t\t__cpumask_set_cpu(cpu, sd_sysctl_cpus);\n}"
  },
  {
    "function_name": "register_sched_domain_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "314-370",
    "snippet": "void register_sched_domain_sysctl(void)\n{\n\tstatic struct ctl_table *cpu_entries;\n\tstatic struct ctl_table **cpu_idx;\n\tchar buf[32];\n\tint i;\n\n\tif (!cpu_entries) {\n\t\tcpu_entries = sd_alloc_ctl_entry(num_possible_cpus() + 1);\n\t\tif (!cpu_entries)\n\t\t\treturn;\n\n\t\tWARN_ON(sd_ctl_dir[0].child);\n\t\tsd_ctl_dir[0].child = cpu_entries;\n\t}\n\n\tif (!cpu_idx) {\n\t\tstruct ctl_table *e = cpu_entries;\n\n\t\tcpu_idx = kcalloc(nr_cpu_ids, sizeof(struct ctl_table*), GFP_KERNEL);\n\t\tif (!cpu_idx)\n\t\t\treturn;\n\n\t\t/* deal with sparse possible map */\n\t\tfor_each_possible_cpu(i) {\n\t\t\tcpu_idx[i] = e;\n\t\t\te++;\n\t\t}\n\t}\n\n\tif (!cpumask_available(sd_sysctl_cpus)) {\n\t\tif (!alloc_cpumask_var(&sd_sysctl_cpus, GFP_KERNEL))\n\t\t\treturn;\n\n\t\t/* init to possible to not have holes in @cpu_entries */\n\t\tcpumask_copy(sd_sysctl_cpus, cpu_possible_mask);\n\t}\n\n\tfor_each_cpu(i, sd_sysctl_cpus) {\n\t\tstruct ctl_table *e = cpu_idx[i];\n\n\t\tif (e->child)\n\t\t\tsd_free_ctl_entry(&e->child);\n\n\t\tif (!e->procname) {\n\t\t\tsnprintf(buf, 32, \"cpu%d\", i);\n\t\t\te->procname = kstrdup(buf, GFP_KERNEL);\n\t\t}\n\t\te->mode = 0555;\n\t\te->child = sd_alloc_ctl_cpu_table(i);\n\n\t\t__cpumask_clear_cpu(i, sd_sysctl_cpus);\n\t}\n\n\tWARN_ON(sd_sysctl_header);\n\tsd_sysctl_header = register_sysctl_table(sd_ctl_root);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_table",
          "args": [
            "sd_ctl_root"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sd_sysctl_header"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpumask_clear_cpu",
          "args": [
            "i",
            "sd_sysctl_cpus"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_alloc_ctl_cpu_table",
          "args": [
            "i"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "sd_alloc_ctl_cpu_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "286-309",
          "snippet": "static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu)\n{\n\tstruct ctl_table *entry, *table;\n\tstruct sched_domain *sd;\n\tint domain_num = 0, i;\n\tchar buf[32];\n\n\tfor_each_domain(cpu, sd)\n\t\tdomain_num++;\n\tentry = table = sd_alloc_ctl_entry(domain_num + 1);\n\tif (table == NULL)\n\t\treturn NULL;\n\n\ti = 0;\n\tfor_each_domain(cpu, sd) {\n\t\tsnprintf(buf, 32, \"domain%d\", i);\n\t\tentry->procname = kstrdup(buf, GFP_KERNEL);\n\t\tentry->mode = 0555;\n\t\tentry->child = sd_alloc_ctl_domain_table(sd);\n\t\tentry++;\n\t\ti++;\n\t}\n\treturn table;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic struct ctl_table *sd_alloc_ctl_cpu_table(int cpu)\n{\n\tstruct ctl_table *entry, *table;\n\tstruct sched_domain *sd;\n\tint domain_num = 0, i;\n\tchar buf[32];\n\n\tfor_each_domain(cpu, sd)\n\t\tdomain_num++;\n\tentry = table = sd_alloc_ctl_entry(domain_num + 1);\n\tif (table == NULL)\n\t\treturn NULL;\n\n\ti = 0;\n\tfor_each_domain(cpu, sd) {\n\t\tsnprintf(buf, 32, \"domain%d\", i);\n\t\tentry->procname = kstrdup(buf, GFP_KERNEL);\n\t\tentry->mode = 0555;\n\t\tentry->child = sd_alloc_ctl_domain_table(sd);\n\t\tentry++;\n\t\ti++;\n\t}\n\treturn table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "buf",
            "GFP_KERNEL"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "32",
            "\"cpu%d\"",
            "i"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_free_ctl_entry",
          "args": [
            "&e->child"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "sd_free_ctl_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "218-237",
          "snippet": "static void sd_free_ctl_entry(struct ctl_table **tablep)\n{\n\tstruct ctl_table *entry;\n\n\t/*\n\t * In the intermediate directories, both the child directory and\n\t * procname are dynamically allocated and could fail but the mode\n\t * will always be set. In the lowest directory the names are\n\t * static strings and all have proc handlers.\n\t */\n\tfor (entry = *tablep; entry->mode; entry++) {\n\t\tif (entry->child)\n\t\t\tsd_free_ctl_entry(&entry->child);\n\t\tif (entry->proc_handler == NULL)\n\t\t\tkfree(entry->procname);\n\t}\n\n\tkfree(*tablep);\n\t*tablep = NULL;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void sd_free_ctl_entry(struct ctl_table **tablep)\n{\n\tstruct ctl_table *entry;\n\n\t/*\n\t * In the intermediate directories, both the child directory and\n\t * procname are dynamically allocated and could fail but the mode\n\t * will always be set. In the lowest directory the names are\n\t * static strings and all have proc handlers.\n\t */\n\tfor (entry = *tablep; entry->mode; entry++) {\n\t\tif (entry->child)\n\t\t\tsd_free_ctl_entry(&entry->child);\n\t\tif (entry->proc_handler == NULL)\n\t\t\tkfree(entry->procname);\n\t}\n\n\tkfree(*tablep);\n\t*tablep = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "sd_sysctl_cpus"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "sd_sysctl_cpus",
            "cpu_possible_mask"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&sd_sysctl_cpus",
            "GFP_KERNEL"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "sd_sysctl_cpus"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_cpu_ids",
            "sizeof(struct ctl_table*)",
            "GFP_KERNEL"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sd_ctl_dir[0].child"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_alloc_ctl_entry",
          "args": [
            "num_possible_cpus() + 1"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "sd_alloc_ctl_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "210-216",
          "snippet": "static struct ctl_table *sd_alloc_ctl_entry(int n)\n{\n\tstruct ctl_table *entry =\n\t\tkcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);\n\n\treturn entry;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic struct ctl_table *sd_alloc_ctl_entry(int n)\n{\n\tstruct ctl_table *entry =\n\t\tkcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid register_sched_domain_sysctl(void)\n{\n\tstatic struct ctl_table *cpu_entries;\n\tstatic struct ctl_table **cpu_idx;\n\tchar buf[32];\n\tint i;\n\n\tif (!cpu_entries) {\n\t\tcpu_entries = sd_alloc_ctl_entry(num_possible_cpus() + 1);\n\t\tif (!cpu_entries)\n\t\t\treturn;\n\n\t\tWARN_ON(sd_ctl_dir[0].child);\n\t\tsd_ctl_dir[0].child = cpu_entries;\n\t}\n\n\tif (!cpu_idx) {\n\t\tstruct ctl_table *e = cpu_entries;\n\n\t\tcpu_idx = kcalloc(nr_cpu_ids, sizeof(struct ctl_table*), GFP_KERNEL);\n\t\tif (!cpu_idx)\n\t\t\treturn;\n\n\t\t/* deal with sparse possible map */\n\t\tfor_each_possible_cpu(i) {\n\t\t\tcpu_idx[i] = e;\n\t\t\te++;\n\t\t}\n\t}\n\n\tif (!cpumask_available(sd_sysctl_cpus)) {\n\t\tif (!alloc_cpumask_var(&sd_sysctl_cpus, GFP_KERNEL))\n\t\t\treturn;\n\n\t\t/* init to possible to not have holes in @cpu_entries */\n\t\tcpumask_copy(sd_sysctl_cpus, cpu_possible_mask);\n\t}\n\n\tfor_each_cpu(i, sd_sysctl_cpus) {\n\t\tstruct ctl_table *e = cpu_idx[i];\n\n\t\tif (e->child)\n\t\t\tsd_free_ctl_entry(&e->child);\n\n\t\tif (!e->procname) {\n\t\t\tsnprintf(buf, 32, \"cpu%d\", i);\n\t\t\te->procname = kstrdup(buf, GFP_KERNEL);\n\t\t}\n\t\te->mode = 0555;\n\t\te->child = sd_alloc_ctl_cpu_table(i);\n\n\t\t__cpumask_clear_cpu(i, sd_sysctl_cpus);\n\t}\n\n\tWARN_ON(sd_sysctl_header);\n\tsd_sysctl_header = register_sysctl_table(sd_ctl_root);\n}"
  },
  {
    "function_name": "sd_alloc_ctl_cpu_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "286-309",
    "snippet": "static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu)\n{\n\tstruct ctl_table *entry, *table;\n\tstruct sched_domain *sd;\n\tint domain_num = 0, i;\n\tchar buf[32];\n\n\tfor_each_domain(cpu, sd)\n\t\tdomain_num++;\n\tentry = table = sd_alloc_ctl_entry(domain_num + 1);\n\tif (table == NULL)\n\t\treturn NULL;\n\n\ti = 0;\n\tfor_each_domain(cpu, sd) {\n\t\tsnprintf(buf, 32, \"domain%d\", i);\n\t\tentry->procname = kstrdup(buf, GFP_KERNEL);\n\t\tentry->mode = 0555;\n\t\tentry->child = sd_alloc_ctl_domain_table(sd);\n\t\tentry++;\n\t\ti++;\n\t}\n\treturn table;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sd_alloc_ctl_domain_table",
          "args": [
            "sd"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "sd_alloc_ctl_domain_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "260-284",
          "snippet": "static struct ctl_table *\nsd_alloc_ctl_domain_table(struct sched_domain *sd)\n{\n\tstruct ctl_table *table = sd_alloc_ctl_entry(14);\n\n\tif (table == NULL)\n\t\treturn NULL;\n\n\tset_table_entry(&table[0] , \"min_interval\",\t   &sd->min_interval,\t     sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[1] , \"max_interval\",\t   &sd->max_interval,\t     sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[2] , \"busy_idx\",\t\t   &sd->busy_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[3] , \"idle_idx\",\t\t   &sd->idle_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[4] , \"newidle_idx\",\t   &sd->newidle_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[5] , \"wake_idx\",\t\t   &sd->wake_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[6] , \"forkexec_idx\",\t   &sd->forkexec_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[7] , \"busy_factor\",\t   &sd->busy_factor,\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[8] , \"imbalance_pct\",\t   &sd->imbalance_pct,\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[9] , \"cache_nice_tries\",\t   &sd->cache_nice_tries,    sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[10], \"flags\",\t\t   &sd->flags,\t\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[11], \"max_newidle_lb_cost\", &sd->max_newidle_lb_cost, sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[12], \"name\",\t\t   sd->name,\t\tCORENAME_MAX_SIZE, 0444, proc_dostring,\t\t false);\n\t/* &table[13] is terminator */\n\n\treturn table;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic struct ctl_table *\nsd_alloc_ctl_domain_table(struct sched_domain *sd)\n{\n\tstruct ctl_table *table = sd_alloc_ctl_entry(14);\n\n\tif (table == NULL)\n\t\treturn NULL;\n\n\tset_table_entry(&table[0] , \"min_interval\",\t   &sd->min_interval,\t     sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[1] , \"max_interval\",\t   &sd->max_interval,\t     sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[2] , \"busy_idx\",\t\t   &sd->busy_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[3] , \"idle_idx\",\t\t   &sd->idle_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[4] , \"newidle_idx\",\t   &sd->newidle_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[5] , \"wake_idx\",\t\t   &sd->wake_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[6] , \"forkexec_idx\",\t   &sd->forkexec_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[7] , \"busy_factor\",\t   &sd->busy_factor,\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[8] , \"imbalance_pct\",\t   &sd->imbalance_pct,\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[9] , \"cache_nice_tries\",\t   &sd->cache_nice_tries,    sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[10], \"flags\",\t\t   &sd->flags,\t\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[11], \"max_newidle_lb_cost\", &sd->max_newidle_lb_cost, sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[12], \"name\",\t\t   sd->name,\t\tCORENAME_MAX_SIZE, 0444, proc_dostring,\t\t false);\n\t/* &table[13] is terminator */\n\n\treturn table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "buf",
            "GFP_KERNEL"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "32",
            "\"domain%d\"",
            "i"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_domain",
          "args": [
            "cpu",
            "sd"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_alloc_ctl_entry",
          "args": [
            "domain_num + 1"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "sd_alloc_ctl_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "210-216",
          "snippet": "static struct ctl_table *sd_alloc_ctl_entry(int n)\n{\n\tstruct ctl_table *entry =\n\t\tkcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);\n\n\treturn entry;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic struct ctl_table *sd_alloc_ctl_entry(int n)\n{\n\tstruct ctl_table *entry =\n\t\tkcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_domain",
          "args": [
            "cpu",
            "sd"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic struct ctl_table *sd_alloc_ctl_cpu_table(int cpu)\n{\n\tstruct ctl_table *entry, *table;\n\tstruct sched_domain *sd;\n\tint domain_num = 0, i;\n\tchar buf[32];\n\n\tfor_each_domain(cpu, sd)\n\t\tdomain_num++;\n\tentry = table = sd_alloc_ctl_entry(domain_num + 1);\n\tif (table == NULL)\n\t\treturn NULL;\n\n\ti = 0;\n\tfor_each_domain(cpu, sd) {\n\t\tsnprintf(buf, 32, \"domain%d\", i);\n\t\tentry->procname = kstrdup(buf, GFP_KERNEL);\n\t\tentry->mode = 0555;\n\t\tentry->child = sd_alloc_ctl_domain_table(sd);\n\t\tentry++;\n\t\ti++;\n\t}\n\treturn table;\n}"
  },
  {
    "function_name": "sd_alloc_ctl_domain_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "260-284",
    "snippet": "static struct ctl_table *\nsd_alloc_ctl_domain_table(struct sched_domain *sd)\n{\n\tstruct ctl_table *table = sd_alloc_ctl_entry(14);\n\n\tif (table == NULL)\n\t\treturn NULL;\n\n\tset_table_entry(&table[0] , \"min_interval\",\t   &sd->min_interval,\t     sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[1] , \"max_interval\",\t   &sd->max_interval,\t     sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[2] , \"busy_idx\",\t\t   &sd->busy_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[3] , \"idle_idx\",\t\t   &sd->idle_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[4] , \"newidle_idx\",\t   &sd->newidle_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[5] , \"wake_idx\",\t\t   &sd->wake_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[6] , \"forkexec_idx\",\t   &sd->forkexec_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[7] , \"busy_factor\",\t   &sd->busy_factor,\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[8] , \"imbalance_pct\",\t   &sd->imbalance_pct,\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[9] , \"cache_nice_tries\",\t   &sd->cache_nice_tries,    sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[10], \"flags\",\t\t   &sd->flags,\t\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[11], \"max_newidle_lb_cost\", &sd->max_newidle_lb_cost, sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[12], \"name\",\t\t   sd->name,\t\tCORENAME_MAX_SIZE, 0444, proc_dostring,\t\t false);\n\t/* &table[13] is terminator */\n\n\treturn table;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_table_entry",
          "args": [
            "&table[12]",
            "\"name\"",
            "sd->name",
            "CORENAME_MAX_SIZE",
            "0444",
            "proc_dostring",
            "false"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "set_table_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "242-258",
          "snippet": "static void\nset_table_entry(struct ctl_table *entry,\n\t\tconst char *procname, void *data, int maxlen,\n\t\tumode_t mode, proc_handler *proc_handler,\n\t\tbool load_idx)\n{\n\tentry->procname = procname;\n\tentry->data = data;\n\tentry->maxlen = maxlen;\n\tentry->mode = mode;\n\tentry->proc_handler = proc_handler;\n\n\tif (load_idx) {\n\t\tentry->extra1 = &min_load_idx;\n\t\tentry->extra2 = &max_load_idx;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void\nset_table_entry(struct ctl_table *entry,\n\t\tconst char *procname, void *data, int maxlen,\n\t\tumode_t mode, proc_handler *proc_handler,\n\t\tbool load_idx)\n{\n\tentry->procname = procname;\n\tentry->data = data;\n\tentry->maxlen = maxlen;\n\tentry->mode = mode;\n\tentry->proc_handler = proc_handler;\n\n\tif (load_idx) {\n\t\tentry->extra1 = &min_load_idx;\n\t\tentry->extra2 = &max_load_idx;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_alloc_ctl_entry",
          "args": [
            "14"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "sd_alloc_ctl_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "210-216",
          "snippet": "static struct ctl_table *sd_alloc_ctl_entry(int n)\n{\n\tstruct ctl_table *entry =\n\t\tkcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);\n\n\treturn entry;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic struct ctl_table *sd_alloc_ctl_entry(int n)\n{\n\tstruct ctl_table *entry =\n\t\tkcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic struct ctl_table *\nsd_alloc_ctl_domain_table(struct sched_domain *sd)\n{\n\tstruct ctl_table *table = sd_alloc_ctl_entry(14);\n\n\tif (table == NULL)\n\t\treturn NULL;\n\n\tset_table_entry(&table[0] , \"min_interval\",\t   &sd->min_interval,\t     sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[1] , \"max_interval\",\t   &sd->max_interval,\t     sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[2] , \"busy_idx\",\t\t   &sd->busy_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[3] , \"idle_idx\",\t\t   &sd->idle_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[4] , \"newidle_idx\",\t   &sd->newidle_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[5] , \"wake_idx\",\t\t   &sd->wake_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[6] , \"forkexec_idx\",\t   &sd->forkexec_idx,\t     sizeof(int) , 0644, proc_dointvec_minmax,   true );\n\tset_table_entry(&table[7] , \"busy_factor\",\t   &sd->busy_factor,\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[8] , \"imbalance_pct\",\t   &sd->imbalance_pct,\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[9] , \"cache_nice_tries\",\t   &sd->cache_nice_tries,    sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[10], \"flags\",\t\t   &sd->flags,\t\t     sizeof(int) , 0644, proc_dointvec_minmax,   false);\n\tset_table_entry(&table[11], \"max_newidle_lb_cost\", &sd->max_newidle_lb_cost, sizeof(long), 0644, proc_doulongvec_minmax, false);\n\tset_table_entry(&table[12], \"name\",\t\t   sd->name,\t\tCORENAME_MAX_SIZE, 0444, proc_dostring,\t\t false);\n\t/* &table[13] is terminator */\n\n\treturn table;\n}"
  },
  {
    "function_name": "set_table_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "242-258",
    "snippet": "static void\nset_table_entry(struct ctl_table *entry,\n\t\tconst char *procname, void *data, int maxlen,\n\t\tumode_t mode, proc_handler *proc_handler,\n\t\tbool load_idx)\n{\n\tentry->procname = procname;\n\tentry->data = data;\n\tentry->maxlen = maxlen;\n\tentry->mode = mode;\n\tentry->proc_handler = proc_handler;\n\n\tif (load_idx) {\n\t\tentry->extra1 = &min_load_idx;\n\t\tentry->extra2 = &max_load_idx;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void\nset_table_entry(struct ctl_table *entry,\n\t\tconst char *procname, void *data, int maxlen,\n\t\tumode_t mode, proc_handler *proc_handler,\n\t\tbool load_idx)\n{\n\tentry->procname = procname;\n\tentry->data = data;\n\tentry->maxlen = maxlen;\n\tentry->mode = mode;\n\tentry->proc_handler = proc_handler;\n\n\tif (load_idx) {\n\t\tentry->extra1 = &min_load_idx;\n\t\tentry->extra2 = &max_load_idx;\n\t}\n}"
  },
  {
    "function_name": "sd_free_ctl_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "218-237",
    "snippet": "static void sd_free_ctl_entry(struct ctl_table **tablep)\n{\n\tstruct ctl_table *entry;\n\n\t/*\n\t * In the intermediate directories, both the child directory and\n\t * procname are dynamically allocated and could fail but the mode\n\t * will always be set. In the lowest directory the names are\n\t * static strings and all have proc handlers.\n\t */\n\tfor (entry = *tablep; entry->mode; entry++) {\n\t\tif (entry->child)\n\t\t\tsd_free_ctl_entry(&entry->child);\n\t\tif (entry->proc_handler == NULL)\n\t\t\tkfree(entry->procname);\n\t}\n\n\tkfree(*tablep);\n\t*tablep = NULL;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*tablep"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_free_ctl_entry",
          "args": [
            "&entry->child"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "sd_free_ctl_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "218-237",
          "snippet": "static void sd_free_ctl_entry(struct ctl_table **tablep)\n{\n\tstruct ctl_table *entry;\n\n\t/*\n\t * In the intermediate directories, both the child directory and\n\t * procname are dynamically allocated and could fail but the mode\n\t * will always be set. In the lowest directory the names are\n\t * static strings and all have proc handlers.\n\t */\n\tfor (entry = *tablep; entry->mode; entry++) {\n\t\tif (entry->child)\n\t\t\tsd_free_ctl_entry(&entry->child);\n\t\tif (entry->proc_handler == NULL)\n\t\t\tkfree(entry->procname);\n\t}\n\n\tkfree(*tablep);\n\t*tablep = NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void sd_free_ctl_entry(struct ctl_table **tablep)\n{\n\tstruct ctl_table *entry;\n\n\t/*\n\t * In the intermediate directories, both the child directory and\n\t * procname are dynamically allocated and could fail but the mode\n\t * will always be set. In the lowest directory the names are\n\t * static strings and all have proc handlers.\n\t */\n\tfor (entry = *tablep; entry->mode; entry++) {\n\t\tif (entry->child)\n\t\t\tsd_free_ctl_entry(&entry->child);\n\t\tif (entry->proc_handler == NULL)\n\t\t\tkfree(entry->procname);\n\t}\n\n\tkfree(*tablep);\n\t*tablep = NULL;\n}"
  },
  {
    "function_name": "sd_alloc_ctl_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "210-216",
    "snippet": "static struct ctl_table *sd_alloc_ctl_entry(int n)\n{\n\tstruct ctl_table *entry =\n\t\tkcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);\n\n\treturn entry;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "n",
            "sizeof(struct ctl_table)",
            "GFP_KERNEL"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic struct ctl_table *sd_alloc_ctl_entry(int n)\n{\n\tstruct ctl_table *entry =\n\t\tkcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);\n\n\treturn entry;\n}"
  },
  {
    "function_name": "sched_init_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "177-186",
    "snippet": "static __init int sched_init_debug(void)\n{\n\tdebugfs_create_file(\"sched_features\", 0644, NULL, NULL,\n\t\t\t&sched_feat_fops);\n\n\tdebugfs_create_bool(\"sched_debug\", 0644, NULL,\n\t\t\t&sched_debug_enabled);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations sched_feat_fops = {\n\t.open\t\t= sched_feat_open,\n\t.write\t\t= sched_feat_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};",
      "__read_mostly bool sched_debug_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_bool",
          "args": [
            "\"sched_debug\"",
            "0644",
            "NULL",
            "&sched_debug_enabled"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"sched_features\"",
            "0644",
            "NULL",
            "NULL",
            "&sched_feat_fops"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic const struct file_operations sched_feat_fops = {\n\t.open\t\t= sched_feat_open,\n\t.write\t\t= sched_feat_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n__read_mostly bool sched_debug_enabled;\n\nstatic __init int sched_init_debug(void)\n{\n\tdebugfs_create_file(\"sched_features\", 0644, NULL, NULL,\n\t\t\t&sched_feat_fops);\n\n\tdebugfs_create_bool(\"sched_debug\", 0644, NULL,\n\t\t\t&sched_debug_enabled);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_feat_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "162-165",
    "snippet": "static int sched_feat_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, sched_feat_show, NULL);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "filp",
            "sched_feat_show",
            "NULL"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int sched_feat_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, sched_feat_show, NULL);\n}"
  },
  {
    "function_name": "sched_feat_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "129-160",
    "snippet": "static ssize_t\nsched_feat_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tchar *cmp;\n\tint ret;\n\tstruct inode *inode;\n\n\tif (cnt > 63)\n\t\tcnt = 63;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\tcmp = strstrip(buf);\n\n\t/* Ensure the static_key remains in a consistent state */\n\tinode = file_inode(filp);\n\tcpus_read_lock();\n\tinode_lock(inode);\n\tret = sched_feat_set(cmp);\n\tinode_unlock(inode);\n\tcpus_read_unlock();\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_feat_set",
          "args": [
            "cmp"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "sched_feat_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "104-127",
          "snippet": "static int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const sched_feat_names[] = {\n#include \"features.h\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic const char * const sched_feat_names[] = {\n#include \"features.h\"\n};\n\nstatic int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&buf",
            "ubuf",
            "cnt"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic ssize_t\nsched_feat_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tchar *cmp;\n\tint ret;\n\tstruct inode *inode;\n\n\tif (cnt > 63)\n\t\tcnt = 63;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\tcmp = strstrip(buf);\n\n\t/* Ensure the static_key remains in a consistent state */\n\tinode = file_inode(filp);\n\tcpus_read_lock();\n\tinode_lock(inode);\n\tret = sched_feat_set(cmp);\n\tinode_unlock(inode);\n\tcpus_read_unlock();\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "sched_feat_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "104-127",
    "snippet": "static int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const sched_feat_names[] = {\n#include \"features.h\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_feat_enable",
          "args": [
            "i"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "sched_feat_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "101-101",
          "snippet": "static void sched_feat_enable(int i) { }",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_feat_enable(int i) { }"
        }
      },
      {
        "call_info": {
          "callee": "sched_feat_disable",
          "args": [
            "i"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "sched_feat_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "100-100",
          "snippet": "static void sched_feat_disable(int i) { }",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_feat_disable(int i) { }"
        }
      },
      {
        "call_info": {
          "callee": "match_string",
          "args": [
            "sched_feat_names",
            "__SCHED_FEAT_NR",
            "cmp"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cmp",
            "\"NO_\"",
            "3"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic const char * const sched_feat_names[] = {\n#include \"features.h\"\n};\n\nstatic int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_feat_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "101-101",
    "snippet": "static void sched_feat_enable(int i) { }",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_feat_enable(int i) { }"
  },
  {
    "function_name": "sched_feat_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "100-100",
    "snippet": "static void sched_feat_disable(int i) { }",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_feat_disable(int i) { }"
  },
  {
    "function_name": "sched_feat_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "95-98",
    "snippet": "static void sched_feat_enable(int i)\n{\n\tstatic_key_enable_cpuslocked(&sched_feat_keys[i]);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_enable_cpuslocked",
          "args": [
            "&sched_feat_keys[i]"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_enable_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "151-171",
          "snippet": "void static_key_enable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) > 0) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 1);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_read(&key->enabled) == 0) {\n\t\tatomic_set(&key->enabled, -1);\n\t\tjump_label_update(key);\n\t\t/*\n\t\t * See static_key_slow_inc().\n\t\t */\n\t\tatomic_set_release(&key->enabled, 1);\n\t}\n\tjump_label_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_enable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) > 0) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 1);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_read(&key->enabled) == 0) {\n\t\tatomic_set(&key->enabled, -1);\n\t\tjump_label_update(key);\n\t\t/*\n\t\t * See static_key_slow_inc().\n\t\t */\n\t\tatomic_set_release(&key->enabled, 1);\n\t}\n\tjump_label_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_feat_enable(int i)\n{\n\tstatic_key_enable_cpuslocked(&sched_feat_keys[i]);\n}"
  },
  {
    "function_name": "sched_feat_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "90-93",
    "snippet": "static void sched_feat_disable(int i)\n{\n\tstatic_key_disable_cpuslocked(&sched_feat_keys[i]);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_disable_cpuslocked",
          "args": [
            "&sched_feat_keys[i]"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_disable_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "182-196",
          "snippet": "void static_key_disable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) != 1) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 0);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_cmpxchg(&key->enabled, 1, 0))\n\t\tjump_label_update(key);\n\tjump_label_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_disable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) != 1) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 0);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_cmpxchg(&key->enabled, 1, 0))\n\t\tjump_label_update(key);\n\tjump_label_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_feat_disable(int i)\n{\n\tstatic_key_disable_cpuslocked(&sched_feat_keys[i]);\n}"
  },
  {
    "function_name": "sched_feat_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "62-74",
    "snippet": "static int sched_feat_show(struct seq_file *m, void *v)\n{\n\tint i;\n\n\tfor (i = 0; i < __SCHED_FEAT_NR; i++) {\n\t\tif (!(sysctl_sched_features & (1UL << i)))\n\t\t\tseq_puts(m, \"NO_\");\n\t\tseq_printf(m, \"%s \", sched_feat_names[i]);\n\t}\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const sched_feat_names[] = {\n#include \"features.h\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s \"",
            "sched_feat_names[i]"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic const char * const sched_feat_names[] = {\n#include \"features.h\"\n};\n\nstatic int sched_feat_show(struct seq_file *m, void *v)\n{\n\tint i;\n\n\tfor (i = 0; i < __SCHED_FEAT_NR; i++) {\n\t\tif (!(sysctl_sched_features & (1UL << i)))\n\t\t\tseq_puts(m, \"NO_\");\n\t\tseq_printf(m, \"%s \", sched_feat_names[i]);\n\t}\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nsec_low",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "43-49",
    "snippet": "static unsigned long nsec_low(unsigned long long nsec)\n{\n\tif ((long long)nsec < 0)\n\t\tnsec = -nsec;\n\n\treturn do_div(nsec, 1000000);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "nsec",
            "1000000"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic unsigned long nsec_low(unsigned long long nsec)\n{\n\tif ((long long)nsec < 0)\n\t\tnsec = -nsec;\n\n\treturn do_div(nsec, 1000000);\n}"
  },
  {
    "function_name": "nsec_high",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
    "lines": "31-41",
    "snippet": "static long long nsec_high(unsigned long long nsec)\n{\n\tif ((long long)nsec < 0) {\n\t\tnsec = -nsec;\n\t\tdo_div(nsec, 1000000);\n\t\treturn -nsec;\n\t}\n\tdo_div(nsec, 1000000);\n\n\treturn nsec;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "nsec",
            "1000000"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "nsec",
            "1000000"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic long long nsec_high(unsigned long long nsec)\n{\n\tif ((long long)nsec < 0) {\n\t\tnsec = -nsec;\n\t\tdo_div(nsec, 1000000);\n\t\treturn -nsec;\n\t}\n\tdo_div(nsec, 1000000);\n\n\treturn nsec;\n}"
  }
]