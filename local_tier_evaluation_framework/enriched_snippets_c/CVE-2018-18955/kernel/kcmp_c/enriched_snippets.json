[
  {
    "function_name": "kcmp_cookies_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
    "lines": "245-255",
    "snippet": "static __init int kcmp_cookies_init(void)\n{\n\tint i;\n\n\tget_random_bytes(cookies, sizeof(cookies));\n\n\tfor (i = 0; i < KCMP_TYPES; i++)\n\t\tcookies[i][1] |= (~(~0UL >>  1) | 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long cookies[KCMP_TYPES][2]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "cookies",
            "sizeof(cookies)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic unsigned long cookies[KCMP_TYPES][2];\n\nstatic __init int kcmp_cookies_init(void)\n{\n\tint i;\n\n\tget_random_bytes(cookies, sizeof(cookies));\n\n\tfor (i = 0; i < KCMP_TYPES; i++)\n\t\tcookies[i][1] |= (~(~0UL >>  1) | 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kcmp_epoll_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
    "lines": "143-149",
    "snippet": "static int kcmp_epoll_target(struct task_struct *task1,\n\t\t\t     struct task_struct *task2,\n\t\t\t     unsigned long idx1,\n\t\t\t     struct kcmp_epoll_slot __user *uslot)\n{\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int kcmp_epoll_target(struct task_struct *task1,\n\t\t\t     struct task_struct *task2,\n\t\t\t     unsigned long idx1,\n\t\t\t     struct kcmp_epoll_slot __user *uslot)\n{\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "kcmp_epoll_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
    "lines": "103-141",
    "snippet": "static int kcmp_epoll_target(struct task_struct *task1,\n\t\t\t     struct task_struct *task2,\n\t\t\t     unsigned long idx1,\n\t\t\t     struct kcmp_epoll_slot __user *uslot)\n{\n\tstruct file *filp, *filp_epoll, *filp_tgt;\n\tstruct kcmp_epoll_slot slot;\n\tstruct files_struct *files;\n\n\tif (copy_from_user(&slot, uslot, sizeof(slot)))\n\t\treturn -EFAULT;\n\n\tfilp = get_file_raw_ptr(task1, idx1);\n\tif (!filp)\n\t\treturn -EBADF;\n\n\tfiles = get_files_struct(task2);\n\tif (!files)\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\tfilp_epoll = fcheck_files(files, slot.efd);\n\tif (filp_epoll)\n\t\tget_file(filp_epoll);\n\telse\n\t\tfilp_tgt = ERR_PTR(-EBADF);\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\n\n\tif (filp_epoll) {\n\t\tfilp_tgt = get_epoll_tfile_raw_ptr(filp_epoll, slot.tfd, slot.toff);\n\t\tfput(filp_epoll);\n\t}\n\n\tif (IS_ERR(filp_tgt))\n\t\treturn PTR_ERR(filp_tgt);\n\n\treturn kcmp_ptr(filp, filp_tgt, KCMP_FILE);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcmp_ptr",
          "args": [
            "filp",
            "filp_tgt",
            "KCMP_FILE"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "kcmp_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
          "lines": "50-58",
          "snippet": "static int kcmp_ptr(void *v1, void *v2, enum kcmp_type type)\n{\n\tlong t1, t2;\n\n\tt1 = kptr_obfuscate((long)v1, type);\n\tt2 = kptr_obfuscate((long)v2, type);\n\n\treturn (t1 < t2) | ((t1 > t2) << 1);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/file.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/list.h>",
            "#include <linux/capability.h>",
            "#include <linux/kcmp.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/cache.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int kcmp_ptr(void *v1, void *v2, enum kcmp_type type)\n{\n\tlong t1, t2;\n\n\tt1 = kptr_obfuscate((long)v1, type);\n\tt2 = kptr_obfuscate((long)v2, type);\n\n\treturn (t1 < t2) | ((t1 > t2) << 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filp_tgt"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filp_tgt"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp_epoll"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_epoll_tfile_raw_ptr",
          "args": [
            "filp_epoll",
            "slot.tfd",
            "slot.toff"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "files"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "filp_epoll"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_file_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "416-425",
          "snippet": "int bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcheck_files",
          "args": [
            "files",
            "slot.efd"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_files_struct",
          "args": [
            "task2"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file_raw_ptr",
          "args": [
            "task1",
            "idx1"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "get_file_raw_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
          "lines": "61-76",
          "snippet": "static struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file = NULL;\n\n\ttask_lock(task);\n\trcu_read_lock();\n\n\tif (task->files)\n\t\tfile = fcheck_files(task->files, idx);\n\n\trcu_read_unlock();\n\ttask_unlock(task);\n\n\treturn file;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/file.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/list.h>",
            "#include <linux/capability.h>",
            "#include <linux/kcmp.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/cache.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file = NULL;\n\n\ttask_lock(task);\n\trcu_read_lock();\n\n\tif (task->files)\n\t\tfile = fcheck_files(task->files, idx);\n\n\trcu_read_unlock();\n\ttask_unlock(task);\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&slot",
            "uslot",
            "sizeof(slot)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int kcmp_epoll_target(struct task_struct *task1,\n\t\t\t     struct task_struct *task2,\n\t\t\t     unsigned long idx1,\n\t\t\t     struct kcmp_epoll_slot __user *uslot)\n{\n\tstruct file *filp, *filp_epoll, *filp_tgt;\n\tstruct kcmp_epoll_slot slot;\n\tstruct files_struct *files;\n\n\tif (copy_from_user(&slot, uslot, sizeof(slot)))\n\t\treturn -EFAULT;\n\n\tfilp = get_file_raw_ptr(task1, idx1);\n\tif (!filp)\n\t\treturn -EBADF;\n\n\tfiles = get_files_struct(task2);\n\tif (!files)\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\tfilp_epoll = fcheck_files(files, slot.efd);\n\tif (filp_epoll)\n\t\tget_file(filp_epoll);\n\telse\n\t\tfilp_tgt = ERR_PTR(-EBADF);\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\n\n\tif (filp_epoll) {\n\t\tfilp_tgt = get_epoll_tfile_raw_ptr(filp_epoll, slot.tfd, slot.toff);\n\t\tfput(filp_epoll);\n\t}\n\n\tif (IS_ERR(filp_tgt))\n\t\treturn PTR_ERR(filp_tgt);\n\n\treturn kcmp_ptr(filp, filp_tgt, KCMP_FILE);\n}"
  },
  {
    "function_name": "kcmp_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
    "lines": "85-100",
    "snippet": "static int kcmp_lock(struct mutex *m1, struct mutex *m2)\n{\n\tint err;\n\n\tif (m2 > m1)\n\t\tswap(m1, m2);\n\n\terr = mutex_lock_killable(m1);\n\tif (!err && likely(m1 != m2)) {\n\t\terr = mutex_lock_killable_nested(m2, SINGLE_DEPTH_NESTING);\n\t\tif (err)\n\t\t\tmutex_unlock(m1);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "m1"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable_nested",
          "args": [
            "m2",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_killable_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1099-1103",
          "snippet": "int __sched\nmutex_lock_killable_nested(struct mutex *lock, unsigned int subclass)\n{\n\treturn __mutex_lock(lock, TASK_KILLABLE, subclass, NULL, _RET_IP_);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nmutex_lock_killable_nested(struct mutex *lock, unsigned int subclass)\n{\n\treturn __mutex_lock(lock, TASK_KILLABLE, subclass, NULL, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "m1 != m2"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable",
          "args": [
            "m1"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "__mutex_lock_killable_slowpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1336-1340",
          "snippet": "__sched\n__mutex_lock_killable_slowpath(struct mutex *lock)\n{\n\treturn __mutex_lock(lock, TASK_KILLABLE, 0, NULL, _RET_IP_);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__mutex_lock_killable_slowpath(struct mutex *lock)\n{\n\treturn __mutex_lock(lock, TASK_KILLABLE, 0, NULL, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "m1",
            "m2"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "963-1008",
          "snippet": "static int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kmalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(tmp, 0, sizeof(*tmp));\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kmalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(tmp, 0, sizeof(*tmp));\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int kcmp_lock(struct mutex *m1, struct mutex *m2)\n{\n\tint err;\n\n\tif (m2 > m1)\n\t\tswap(m1, m2);\n\n\terr = mutex_lock_killable(m1);\n\tif (!err && likely(m1 != m2)) {\n\t\terr = mutex_lock_killable_nested(m2, SINGLE_DEPTH_NESTING);\n\t\tif (err)\n\t\t\tmutex_unlock(m1);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "kcmp_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
    "lines": "78-83",
    "snippet": "static void kcmp_unlock(struct mutex *m1, struct mutex *m2)\n{\n\tif (likely(m2 != m1))\n\t\tmutex_unlock(m2);\n\tmutex_unlock(m1);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "m1"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "m2 != m1"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void kcmp_unlock(struct mutex *m1, struct mutex *m2)\n{\n\tif (likely(m2 != m1))\n\t\tmutex_unlock(m2);\n\tmutex_unlock(m1);\n}"
  },
  {
    "function_name": "get_file_raw_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
    "lines": "61-76",
    "snippet": "static struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file = NULL;\n\n\ttask_lock(task);\n\trcu_read_lock();\n\n\tif (task->files)\n\t\tfile = fcheck_files(task->files, idx);\n\n\trcu_read_unlock();\n\ttask_unlock(task);\n\n\treturn file;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcheck_files",
          "args": [
            "task->files",
            "idx"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file = NULL;\n\n\ttask_lock(task);\n\trcu_read_lock();\n\n\tif (task->files)\n\t\tfile = fcheck_files(task->files, idx);\n\n\trcu_read_unlock();\n\ttask_unlock(task);\n\n\treturn file;\n}"
  },
  {
    "function_name": "kcmp_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
    "lines": "50-58",
    "snippet": "static int kcmp_ptr(void *v1, void *v2, enum kcmp_type type)\n{\n\tlong t1, t2;\n\n\tt1 = kptr_obfuscate((long)v1, type);\n\tt2 = kptr_obfuscate((long)v2, type);\n\n\treturn (t1 < t2) | ((t1 > t2) << 1);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kptr_obfuscate",
          "args": [
            "(long)v2",
            "type"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "kptr_obfuscate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
          "lines": "39-42",
          "snippet": "static long kptr_obfuscate(long v, int type)\n{\n\treturn (v ^ cookies[type][0]) * cookies[type][1];\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/file.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/list.h>",
            "#include <linux/capability.h>",
            "#include <linux/kcmp.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/cache.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long cookies[KCMP_TYPES][2]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic unsigned long cookies[KCMP_TYPES][2];\n\nstatic long kptr_obfuscate(long v, int type)\n{\n\treturn (v ^ cookies[type][0]) * cookies[type][1];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int kcmp_ptr(void *v1, void *v2, enum kcmp_type type)\n{\n\tlong t1, t2;\n\n\tt1 = kptr_obfuscate((long)v1, type);\n\tt2 = kptr_obfuscate((long)v2, type);\n\n\treturn (t1 < t2) | ((t1 > t2) << 1);\n}"
  },
  {
    "function_name": "kptr_obfuscate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
    "lines": "39-42",
    "snippet": "static long kptr_obfuscate(long v, int type)\n{\n\treturn (v ^ cookies[type][0]) * cookies[type][1];\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long cookies[KCMP_TYPES][2]"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic unsigned long cookies[KCMP_TYPES][2];\n\nstatic long kptr_obfuscate(long v, int type)\n{\n\treturn (v ^ cookies[type][0]) * cookies[type][1];\n}"
  },
  {
    "function_name": "kcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kcmp.c",
    "lines": "152-243",
    "snippet": "SYSCALL_DEFINE5(kcmp, pid_t, pid1, pid_t, pid2, int, type,\n\t\tunsigned long, idx1, unsigned long, idx2)\n{\n\tstruct task_struct *task1, *task2;\n\tint ret;\n\n\trcu_read_lock();\n\n\t/*\n\t * Tasks are looked up in caller's PID namespace only.\n\t */\n\ttask1 = find_task_by_vpid(pid1);\n\ttask2 = find_task_by_vpid(pid2);\n\tif (!task1 || !task2)\n\t\tgoto err_no_task;\n\n\tget_task_struct(task1);\n\tget_task_struct(task2);\n\n\trcu_read_unlock();\n\n\t/*\n\t * One should have enough rights to inspect task details.\n\t */\n\tret = kcmp_lock(&task1->signal->cred_guard_mutex,\n\t\t\t&task2->signal->cred_guard_mutex);\n\tif (ret)\n\t\tgoto err;\n\tif (!ptrace_may_access(task1, PTRACE_MODE_READ_REALCREDS) ||\n\t    !ptrace_may_access(task2, PTRACE_MODE_READ_REALCREDS)) {\n\t\tret = -EPERM;\n\t\tgoto err_unlock;\n\t}\n\n\tswitch (type) {\n\tcase KCMP_FILE: {\n\t\tstruct file *filp1, *filp2;\n\n\t\tfilp1 = get_file_raw_ptr(task1, idx1);\n\t\tfilp2 = get_file_raw_ptr(task2, idx2);\n\n\t\tif (filp1 && filp2)\n\t\t\tret = kcmp_ptr(filp1, filp2, KCMP_FILE);\n\t\telse\n\t\t\tret = -EBADF;\n\t\tbreak;\n\t}\n\tcase KCMP_VM:\n\t\tret = kcmp_ptr(task1->mm, task2->mm, KCMP_VM);\n\t\tbreak;\n\tcase KCMP_FILES:\n\t\tret = kcmp_ptr(task1->files, task2->files, KCMP_FILES);\n\t\tbreak;\n\tcase KCMP_FS:\n\t\tret = kcmp_ptr(task1->fs, task2->fs, KCMP_FS);\n\t\tbreak;\n\tcase KCMP_SIGHAND:\n\t\tret = kcmp_ptr(task1->sighand, task2->sighand, KCMP_SIGHAND);\n\t\tbreak;\n\tcase KCMP_IO:\n\t\tret = kcmp_ptr(task1->io_context, task2->io_context, KCMP_IO);\n\t\tbreak;\n\tcase KCMP_SYSVSEM:\n#ifdef CONFIG_SYSVIPC\n\t\tret = kcmp_ptr(task1->sysvsem.undo_list,\n\t\t\t       task2->sysvsem.undo_list,\n\t\t\t       KCMP_SYSVSEM);\n#else\n\t\tret = -EOPNOTSUPP;\n#endif\n\t\tbreak;\n\tcase KCMP_EPOLL_TFD:\n\t\tret = kcmp_epoll_target(task1, task2, idx1, (void *)idx2);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nerr_unlock:\n\tkcmp_unlock(&task1->signal->cred_guard_mutex,\n\t\t    &task2->signal->cred_guard_mutex);\nerr:\n\tput_task_struct(task1);\n\tput_task_struct(task2);\n\n\treturn ret;\n\nerr_no_task:\n\trcu_read_unlock();\n\treturn -ESRCH;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE5(kcmp, pid_t, pid1, pid_t, pid2, int, type,\n\t\tunsigned long, idx1, unsigned long, idx2)\n{\n\tstruct task_struct *task1, *task2;\n\tint ret;\n\n\trcu_read_lock();\n\n\t/*\n\t * Tasks are looked up in caller's PID namespace only.\n\t */\n\ttask1 = find_task_by_vpid(pid1);\n\ttask2 = find_task_by_vpid(pid2);\n\tif (!task1 || !task2)\n\t\tgoto err_no_task;\n\n\tget_task_struct(task1);\n\tget_task_struct(task2);\n\n\trcu_read_unlock();\n\n\t/*\n\t * One should have enough rights to inspect task details.\n\t */\n\tret = kcmp_lock(&task1->signal->cred_guard_mutex,\n\t\t\t&task2->signal->cred_guard_mutex);\n\tif (ret)\n\t\tgoto err;\n\tif (!ptrace_may_access(task1, PTRACE_MODE_READ_REALCREDS) ||\n\t    !ptrace_may_access(task2, PTRACE_MODE_READ_REALCREDS)) {\n\t\tret = -EPERM;\n\t\tgoto err_unlock;\n\t}\n\n\tswitch (type) {\n\tcase KCMP_FILE: {\n\t\tstruct file *filp1, *filp2;\n\n\t\tfilp1 = get_file_raw_ptr(task1, idx1);\n\t\tfilp2 = get_file_raw_ptr(task2, idx2);\n\n\t\tif (filp1 && filp2)\n\t\t\tret = kcmp_ptr(filp1, filp2, KCMP_FILE);\n\t\telse\n\t\t\tret = -EBADF;\n\t\tbreak;\n\t}\n\tcase KCMP_VM:\n\t\tret = kcmp_ptr(task1->mm, task2->mm, KCMP_VM);\n\t\tbreak;\n\tcase KCMP_FILES:\n\t\tret = kcmp_ptr(task1->files, task2->files, KCMP_FILES);\n\t\tbreak;\n\tcase KCMP_FS:\n\t\tret = kcmp_ptr(task1->fs, task2->fs, KCMP_FS);\n\t\tbreak;\n\tcase KCMP_SIGHAND:\n\t\tret = kcmp_ptr(task1->sighand, task2->sighand, KCMP_SIGHAND);\n\t\tbreak;\n\tcase KCMP_IO:\n\t\tret = kcmp_ptr(task1->io_context, task2->io_context, KCMP_IO);\n\t\tbreak;\n\tcase KCMP_SYSVSEM:\n#ifdef CONFIG_SYSVIPC\n\t\tret = kcmp_ptr(task1->sysvsem.undo_list,\n\t\t\t       task2->sysvsem.undo_list,\n\t\t\t       KCMP_SYSVSEM);\n#else\n\t\tret = -EOPNOTSUPP;\n#endif\n\t\tbreak;\n\tcase KCMP_EPOLL_TFD:\n\t\tret = kcmp_epoll_target(task1, task2, idx1, (void *)idx2);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nerr_unlock:\n\tkcmp_unlock(&task1->signal->cred_guard_mutex,\n\t\t    &task2->signal->cred_guard_mutex);\nerr:\n\tput_task_struct(task1);\n\tput_task_struct(task2);\n\n\treturn ret;\n\nerr_no_task:\n\trcu_read_unlock();\n\treturn -ESRCH;\n}"
  }
]