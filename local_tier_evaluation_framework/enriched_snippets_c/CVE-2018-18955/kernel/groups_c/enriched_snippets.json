[
  {
    "function_name": "in_egroup_p",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "231-239",
    "snippet": "int in_egroup_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->egid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "groups_search",
          "args": [
            "cred->group_info",
            "grp"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "groups_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
          "lines": "97-116",
          "snippet": "int groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sort.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "grp",
            "cred->egid"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint in_egroup_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->egid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}"
  },
  {
    "function_name": "in_group_p",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "219-227",
    "snippet": "int in_group_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->fsgid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "groups_search",
          "args": [
            "cred->group_info",
            "grp"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "groups_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
          "lines": "97-116",
          "snippet": "int groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sort.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "grp",
            "cred->fsgid"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint in_group_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->fsgid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}"
  },
  {
    "function_name": "may_setgroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "177-183",
    "snippet": "bool may_setgroups(void)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\treturn ns_capable(user_ns, CAP_SETGID) &&\n\t\tuserns_may_setgroups(user_ns);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userns_may_setgroups",
          "args": [
            "user_ns"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "userns_may_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "1202-1216",
          "snippet": "bool userns_may_setgroups(const struct user_namespace *ns)\n{\n\tbool allowed;\n\n\tmutex_lock(&userns_state_mutex);\n\t/* It is not safe to use setgroups until a gid mapping in\n\t * the user namespace has been established.\n\t */\n\tallowed = ns->gid_map.nr_extents != 0;\n\t/* Is setgroups allowed? */\n\tallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);\n\tmutex_unlock(&userns_state_mutex);\n\n\treturn allowed;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(userns_state_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(userns_state_mutex);\n\nbool userns_may_setgroups(const struct user_namespace *ns)\n{\n\tbool allowed;\n\n\tmutex_lock(&userns_state_mutex);\n\t/* It is not safe to use setgroups until a gid mapping in\n\t * the user namespace has been established.\n\t */\n\tallowed = ns->gid_map.nr_extents != 0;\n\t/* Is setgroups allowed? */\n\tallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);\n\tmutex_unlock(&userns_state_mutex);\n\n\treturn allowed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SETGID"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nbool may_setgroups(void)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\treturn ns_capable(user_ns, CAP_SETGID) &&\n\t\tuserns_may_setgroups(user_ns);\n}"
  },
  {
    "function_name": "set_current_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "139-149",
    "snippet": "int set_current_groups(struct group_info *group_info)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tset_groups(new, group_info);\n\treturn commit_creds(new);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "commit_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "423-490",
          "snippet": "int commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(task);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(task);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user)\n\t\tatomic_inc(&new->user->processes);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user)\n\t\tatomic_dec(&old->user->processes);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(task);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(task);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user)\n\t\tatomic_inc(&new->user->processes);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user)\n\t\tatomic_dec(&old->user->processes);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_groups",
          "args": [
            "new",
            "group_info"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "set_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
          "lines": "123-128",
          "snippet": "void set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sort.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nvoid set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "244-286",
          "snippet": "struct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cred_jar;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint set_current_groups(struct group_info *group_info)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tset_groups(new, group_info);\n\treturn commit_creds(new);\n}"
  },
  {
    "function_name": "set_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "123-128",
    "snippet": "void set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_group_info",
          "args": [
            "group_info"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_group_info",
          "args": [
            "new->group_info"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nvoid set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}"
  },
  {
    "function_name": "groups_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "97-116",
    "snippet": "int groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_lt",
          "args": [
            "grp",
            "group_info->gid[mid]"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_gt",
          "args": [
            "grp",
            "group_info->gid[mid]"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "groups_sort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "89-93",
    "snippet": "void groups_sort(struct group_info *group_info)\n{\n\tsort(group_info->gid, group_info->ngroups, sizeof(*group_info->gid),\n\t     gid_cmp, NULL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "group_info->gid",
            "group_info->ngroups",
            "sizeof(*group_info->gid)",
            "gid_cmp",
            "NULL"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "986-1033",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nvoid groups_sort(struct group_info *group_info)\n{\n\tsort(group_info->gid, group_info->ngroups, sizeof(*group_info->gid),\n\t     gid_cmp, NULL);\n}"
  },
  {
    "function_name": "gid_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "81-87",
    "snippet": "static int gid_cmp(const void *_a, const void *_b)\n{\n\tkgid_t a = *(kgid_t *)_a;\n\tkgid_t b = *(kgid_t *)_b;\n\n\treturn gid_gt(a, b) - gid_lt(a, b);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_lt",
          "args": [
            "a",
            "b"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_gt",
          "args": [
            "a",
            "b"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nstatic int gid_cmp(const void *_a, const void *_b)\n{\n\tkgid_t a = *(kgid_t *)_a;\n\tkgid_t b = *(kgid_t *)_b;\n\n\treturn gid_gt(a, b) - gid_lt(a, b);\n}"
  },
  {
    "function_name": "groups_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "59-79",
    "snippet": "static int groups_from_user(struct group_info *group_info,\n    gid_t __user *grouplist)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tkgid_t kgid;\n\t\tif (get_user(gid, grouplist+i))\n\t\t\treturn -EFAULT;\n\n\t\tkgid = make_kgid(user_ns, gid);\n\t\tif (!gid_valid(kgid))\n\t\t\treturn -EINVAL;\n\n\t\tgroup_info->gid[i] = kgid;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "kgid"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "user_ns",
            "gid"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "make_kgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "460-464",
          "snippet": "kgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "gid",
            "grouplist+i"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nstatic int groups_from_user(struct group_info *group_info,\n    gid_t __user *grouplist)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tkgid_t kgid;\n\t\tif (get_user(gid, grouplist+i))\n\t\t\treturn -EFAULT;\n\n\t\tkgid = make_kgid(user_ns, gid);\n\t\tif (!gid_valid(kgid))\n\t\t\treturn -EINVAL;\n\n\t\tgroup_info->gid[i] = kgid;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "groups_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "42-56",
    "snippet": "static int groups_to_user(gid_t __user *grouplist,\n\t\t\t  const struct group_info *group_info)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tgid = from_kgid_munged(user_ns, group_info->gid[i]);\n\t\tif (put_user(gid, grouplist+i))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "gid",
            "grouplist+i"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "user_ns",
            "group_info->gid[i]"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "503-511",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nstatic int groups_to_user(gid_t __user *grouplist,\n\t\t\t  const struct group_info *group_info)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tgid = from_kgid_munged(user_ns, group_info->gid[i]);\n\t\tif (put_user(gid, grouplist+i))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "groups_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "34-37",
    "snippet": "void groups_free(struct group_info *group_info)\n{\n\tkvfree(group_info);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "group_info"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nvoid groups_free(struct group_info *group_info)\n{\n\tkvfree(group_info);\n}"
  },
  {
    "function_name": "groups_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "15-30",
    "snippet": "struct group_info *groups_alloc(int gidsetsize)\n{\n\tstruct group_info *gi;\n\tunsigned int len;\n\n\tlen = sizeof(struct group_info) + sizeof(kgid_t) * gidsetsize;\n\tgi = kmalloc(len, GFP_KERNEL_ACCOUNT|__GFP_NOWARN|__GFP_NORETRY);\n\tif (!gi)\n\t\tgi = __vmalloc(len, GFP_KERNEL_ACCOUNT, PAGE_KERNEL);\n\tif (!gi)\n\t\treturn NULL;\n\n\tatomic_set(&gi->usage, 1);\n\tgi->ngroups = gidsetsize;\n\treturn gi;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&gi->usage",
            "1"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "len",
            "GFP_KERNEL_ACCOUNT",
            "PAGE_KERNEL"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL_ACCOUNT|__GFP_NOWARN|__GFP_NORETRY"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nstruct group_info *groups_alloc(int gidsetsize)\n{\n\tstruct group_info *gi;\n\tunsigned int len;\n\n\tlen = sizeof(struct group_info) + sizeof(kgid_t) * gidsetsize;\n\tgi = kmalloc(len, GFP_KERNEL_ACCOUNT|__GFP_NOWARN|__GFP_NORETRY);\n\tif (!gi)\n\t\tgi = __vmalloc(len, GFP_KERNEL_ACCOUNT, PAGE_KERNEL);\n\tif (!gi)\n\t\treturn NULL;\n\n\tatomic_set(&gi->usage, 1);\n\tgi->ngroups = gidsetsize;\n\treturn gi;\n}"
  },
  {
    "function_name": "getgroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "153-175",
    "snippet": "SYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif (gidsetsize < 0)\n\t\treturn -EINVAL;\n\n\t/* no need to grab task_lock here; it cannot change */\n\ti = cred->group_info->ngroups;\n\tif (gidsetsize) {\n\t\tif (i > gidsetsize) {\n\t\t\ti = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (groups_to_user(grouplist, cred->group_info)) {\n\t\t\ti = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn i;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nSYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif (gidsetsize < 0)\n\t\treturn -EINVAL;\n\n\t/* no need to grab task_lock here; it cannot change */\n\ti = cred->group_info->ngroups;\n\tif (gidsetsize) {\n\t\tif (i > gidsetsize) {\n\t\t\ti = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (groups_to_user(grouplist, cred->group_info)) {\n\t\t\ti = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn i;\n}"
  },
  {
    "function_name": "setgroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
    "lines": "190-214",
    "snippet": "SYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tstruct group_info *group_info;\n\tint retval;\n\n\tif (!may_setgroups())\n\t\treturn -EPERM;\n\tif ((unsigned)gidsetsize > NGROUPS_MAX)\n\t\treturn -EINVAL;\n\n\tgroup_info = groups_alloc(gidsetsize);\n\tif (!group_info)\n\t\treturn -ENOMEM;\n\tretval = groups_from_user(group_info, grouplist);\n\tif (retval) {\n\t\tput_group_info(group_info);\n\t\treturn retval;\n\t}\n\n\tgroups_sort(group_info);\n\tretval = set_current_groups(group_info);\n\tput_group_info(group_info);\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nSYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tstruct group_info *group_info;\n\tint retval;\n\n\tif (!may_setgroups())\n\t\treturn -EPERM;\n\tif ((unsigned)gidsetsize > NGROUPS_MAX)\n\t\treturn -EINVAL;\n\n\tgroup_info = groups_alloc(gidsetsize);\n\tif (!group_info)\n\t\treturn -ENOMEM;\n\tretval = groups_from_user(group_info, grouplist);\n\tif (retval) {\n\t\tput_group_info(group_info);\n\t\treturn retval;\n\t}\n\n\tgroups_sort(group_info);\n\tretval = set_current_groups(group_info);\n\tput_group_info(group_info);\n\n\treturn retval;\n}"
  }
]