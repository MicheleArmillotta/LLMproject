[
  {
    "function_name": "woken_wake_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "434-441",
    "snippet": "int woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\t/* Pairs with the smp_store_mb() in wait_woken(). */\n\tsmp_mb(); /* C */\n\twq_entry->flags |= WQ_FLAG_WOKEN;\n\n\treturn default_wake_function(wq_entry, mode, sync, key);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_wake_function",
          "args": [
            "wq_entry",
            "mode",
            "sync",
            "key"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "default_wake_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3707-3711",
          "snippet": "int default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\t/* Pairs with the smp_store_mb() in wait_woken(). */\n\tsmp_mb(); /* C */\n\twq_entry->flags |= WQ_FLAG_WOKEN;\n\n\treturn default_wake_function(wq_entry, mode, sync, key);\n}"
  },
  {
    "function_name": "wait_woken",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "409-431",
    "snippet": "long wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout)\n{\n\t/*\n\t * The below executes an smp_mb(), which matches with the full barrier\n\t * executed by the try_to_wake_up() in woken_wake_function() such that\n\t * either we see the store to wq_entry->flags in woken_wake_function()\n\t * or woken_wake_function() sees our store to current->state.\n\t */\n\tset_current_state(mode); /* A */\n\tif (!(wq_entry->flags & WQ_FLAG_WOKEN) && !is_kthread_should_stop())\n\t\ttimeout = schedule_timeout(timeout);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * The below executes an smp_mb(), which matches with the smp_mb() (C)\n\t * in woken_wake_function() such that either we see the wait condition\n\t * being true or the store to wq_entry->flags in woken_wake_function()\n\t * follows ours in the coherence order.\n\t */\n\tsmp_store_mb(wq_entry->flags, wq_entry->flags & ~WQ_FLAG_WOKEN); /* B */\n\n\treturn timeout;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "wq_entry->flags",
            "wq_entry->flags & ~WQ_FLAG_WOKEN"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "timeout"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5119-5129",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_kthread_should_stop",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "is_kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "384-387",
          "snippet": "static inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "mode"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nlong wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout)\n{\n\t/*\n\t * The below executes an smp_mb(), which matches with the full barrier\n\t * executed by the try_to_wake_up() in woken_wake_function() such that\n\t * either we see the store to wq_entry->flags in woken_wake_function()\n\t * or woken_wake_function() sees our store to current->state.\n\t */\n\tset_current_state(mode); /* A */\n\tif (!(wq_entry->flags & WQ_FLAG_WOKEN) && !is_kthread_should_stop())\n\t\ttimeout = schedule_timeout(timeout);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * The below executes an smp_mb(), which matches with the smp_mb() (C)\n\t * in woken_wake_function() such that either we see the wait condition\n\t * being true or the store to wq_entry->flags in woken_wake_function()\n\t * follows ours in the coherence order.\n\t */\n\tsmp_store_mb(wq_entry->flags, wq_entry->flags & ~WQ_FLAG_WOKEN); /* B */\n\n\treturn timeout;\n}"
  },
  {
    "function_name": "is_kthread_should_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "384-387",
    "snippet": "static inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "is_kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "384-387",
          "snippet": "static inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}"
  },
  {
    "function_name": "autoremove_wake_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "373-381",
    "snippet": "int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init(&wq_entry->entry);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_wake_function",
          "args": [
            "wq_entry",
            "mode",
            "sync",
            "key"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "default_wake_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3707-3711",
          "snippet": "int default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init(&wq_entry->entry);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "finish_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "347-370",
    "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
  },
  {
    "function_name": "do_wait_intr_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "321-335",
    "snippet": "int do_wait_intr_irq(wait_queue_head_t *wq, wait_queue_entry_t *wait)\n{\n\tif (likely(list_empty(&wait->entry)))\n\t\t__add_wait_queue_entry_tail(wq, wait);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tspin_unlock_irq(&wq->lock);\n\tschedule();\n\tspin_lock_irq(&wq->lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&wq->lock"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5132-5139",
          "snippet": "void io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&wq->lock"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "wq",
            "wait"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "list_empty(&wait->entry)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wait->entry"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint do_wait_intr_irq(wait_queue_head_t *wq, wait_queue_entry_t *wait)\n{\n\tif (likely(list_empty(&wait->entry)))\n\t\t__add_wait_queue_entry_tail(wq, wait);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tspin_unlock_irq(&wq->lock);\n\tschedule();\n\tspin_lock_irq(&wq->lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_wait_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "304-318",
    "snippet": "int do_wait_intr(wait_queue_head_t *wq, wait_queue_entry_t *wait)\n{\n\tif (likely(list_empty(&wait->entry)))\n\t\t__add_wait_queue_entry_tail(wq, wait);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tspin_unlock(&wq->lock);\n\tschedule();\n\tspin_lock(&wq->lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wq->lock"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5132-5139",
          "snippet": "void io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wq->lock"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "wq",
            "wait"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "list_empty(&wait->entry)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wait->entry"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint do_wait_intr(wait_queue_head_t *wq, wait_queue_entry_t *wait)\n{\n\tif (likely(list_empty(&wait->entry)))\n\t\t__add_wait_queue_entry_tail(wq, wait);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tspin_unlock(&wq->lock);\n\tschedule();\n\tspin_lock(&wq->lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "prepare_to_wait_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "261-294",
    "snippet": "long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (unlikely(signal_pending_state(state, current))) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "signal_pending_state(state, current)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "state",
            "current"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (unlikely(signal_pending_state(state, current))) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "init_wait_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "252-258",
    "snippet": "void init_wait_entry(struct wait_queue_entry *wq_entry, int flags)\n{\n\twq_entry->flags = flags;\n\twq_entry->private = current;\n\twq_entry->func = autoremove_wake_function;\n\tINIT_LIST_HEAD(&wq_entry->entry);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid init_wait_entry(struct wait_queue_entry *wq_entry, int flags)\n{\n\twq_entry->flags = flags;\n\twq_entry->private = current;\n\twq_entry->func = autoremove_wake_function;\n\tINIT_LIST_HEAD(&wq_entry->entry);\n}"
  },
  {
    "function_name": "prepare_to_wait_exclusive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "238-249",
    "snippet": "void\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
  },
  {
    "function_name": "prepare_to_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "224-235",
    "snippet": "void\nprepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid\nprepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
  },
  {
    "function_name": "__wake_up_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "206-209",
    "snippet": "void __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode, int nr_exclusive)\n{\n\t__wake_up_sync_key(wq_head, mode, nr_exclusive, NULL);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_sync_key",
          "args": [
            "wq_head",
            "mode",
            "nr_exclusive",
            "NULL"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_sync_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "188-200",
          "snippet": "void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\tint wake_flags = 1; /* XXX WF_SYNC */\n\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\tif (unlikely(nr_exclusive != 1))\n\t\twake_flags = 0;\n\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\tint wake_flags = 1; /* XXX WF_SYNC */\n\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\tif (unlikely(nr_exclusive != 1))\n\t\twake_flags = 0;\n\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode, int nr_exclusive)\n{\n\t__wake_up_sync_key(wq_head, mode, nr_exclusive, NULL);\n}"
  },
  {
    "function_name": "__wake_up_sync_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "188-200",
    "snippet": "void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\tint wake_flags = 1; /* XXX WF_SYNC */\n\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\tif (unlikely(nr_exclusive != 1))\n\t\twake_flags = 0;\n\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common_lock",
          "args": [
            "wq_head",
            "mode",
            "nr_exclusive",
            "wake_flags",
            "key"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "109-130",
          "snippet": "static void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &bookmark);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &bookmark);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr_exclusive != 1"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!wq_head"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\tint wake_flags = 1; /* XXX WF_SYNC */\n\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\tif (unlikely(nr_exclusive != 1))\n\t\twake_flags = 0;\n\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);\n}"
  },
  {
    "function_name": "__wake_up_locked_key_bookmark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "164-168",
    "snippet": "void __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common",
          "args": [
            "wq_head",
            "mode",
            "1",
            "0",
            "key",
            "bookmark"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "65-107",
          "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAITQUEUE_WALK_BREAK_CNT 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}"
  },
  {
    "function_name": "__wake_up_locked_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "158-161",
    "snippet": "void __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, NULL);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common",
          "args": [
            "wq_head",
            "mode",
            "1",
            "0",
            "key",
            "NULL"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "65-107",
          "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAITQUEUE_WALK_BREAK_CNT 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, NULL);\n}"
  },
  {
    "function_name": "__wake_up_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "152-155",
    "snippet": "void __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr)\n{\n\t__wake_up_common(wq_head, mode, nr, 0, NULL, NULL);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common",
          "args": [
            "wq_head",
            "mode",
            "nr",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "65-107",
          "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAITQUEUE_WALK_BREAK_CNT 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr)\n{\n\t__wake_up_common(wq_head, mode, nr, 0, NULL, NULL);\n}"
  },
  {
    "function_name": "__wake_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "142-146",
    "snippet": "void __wake_up(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common_lock",
          "args": [
            "wq_head",
            "mode",
            "nr_exclusive",
            "0",
            "key"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "109-130",
          "snippet": "static void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &bookmark);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &bookmark);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);\n}"
  },
  {
    "function_name": "__wake_up_common_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "109-130",
    "snippet": "static void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &bookmark);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_up_common",
          "args": [
            "wq_head",
            "mode",
            "nr_exclusive",
            "wake_flags",
            "key",
            "&bookmark"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "65-107",
          "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAITQUEUE_WALK_BREAK_CNT 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bookmark.entry"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &bookmark);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
  },
  {
    "function_name": "__wake_up_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "65-107",
    "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define WAITQUEUE_WALK_BREAK_CNT 64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bookmark->entry",
            "&next->entry"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curr->func",
          "args": [
            "curr",
            "mode",
            "wake_flags",
            "key"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_from",
          "args": [
            "curr",
            "next",
            "&wq_head->head",
            "entry"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&wq_head->head",
            "wait_queue_entry_t",
            "entry"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&bookmark->entry"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "bookmark",
            "entry"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_head->lock"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
  },
  {
    "function_name": "remove_wait_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "39-46",
    "snippet": "void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
  },
  {
    "function_name": "add_wait_queue_exclusive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "28-36",
    "snippet": "void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
  },
  {
    "function_name": "add_wait_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "17-25",
    "snippet": "void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
  },
  {
    "function_name": "__init_waitqueue_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
    "lines": "8-13",
    "snippet": "void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *key)\n{\n\tspin_lock_init(&wq_head->lock);\n\tlockdep_set_class_and_name(&wq_head->lock, key, name);\n\tINIT_LIST_HEAD(&wq_head->head);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq_head->head"
          ],
          "line": 12
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class_and_name",
          "args": [
            "&wq_head->lock",
            "key",
            "name"
          ],
          "line": 11
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&wq_head->lock"
          ],
          "line": 10
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *key)\n{\n\tspin_lock_init(&wq_head->lock);\n\tlockdep_set_class_and_name(&wq_head->lock, key, name);\n\tINIT_LIST_HEAD(&wq_head->head);\n}"
  }
]