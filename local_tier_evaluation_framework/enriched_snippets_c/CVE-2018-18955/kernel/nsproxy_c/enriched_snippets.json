[
  {
    "function_name": "nsproxy_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
    "lines": "273-277",
    "snippet": "int __init nsproxy_cache_init(void)\n{\n\tnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nsproxy_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "nsproxy",
            "SLAB_PANIC"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nint __init nsproxy_cache_init(void)\n{\n\tnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC);\n\treturn 0;\n}"
  },
  {
    "function_name": "exit_task_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
    "lines": "232-235",
    "snippet": "void exit_task_namespaces(struct task_struct *p)\n{\n\tswitch_task_namespaces(p, NULL);\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "switch_task_namespaces",
          "args": [
            "p",
            "NULL"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "switch_task_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
          "lines": "217-230",
          "snippet": "void switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns && atomic_dec_and_test(&ns->count))\n\t\tfree_nsproxy(ns);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns && atomic_dec_and_test(&ns->count))\n\t\tfree_nsproxy(ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid exit_task_namespaces(struct task_struct *p)\n{\n\tswitch_task_namespaces(p, NULL);\n}"
  },
  {
    "function_name": "switch_task_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
    "lines": "217-230",
    "snippet": "void switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns && atomic_dec_and_test(&ns->count))\n\t\tfree_nsproxy(ns);\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_nsproxy",
          "args": [
            "ns"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "free_nsproxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
          "lines": "173-186",
          "snippet": "void free_nsproxy(struct nsproxy *ns)\n{\n\tif (ns->mnt_ns)\n\t\tput_mnt_ns(ns->mnt_ns);\n\tif (ns->uts_ns)\n\t\tput_uts_ns(ns->uts_ns);\n\tif (ns->ipc_ns)\n\t\tput_ipc_ns(ns->ipc_ns);\n\tif (ns->pid_ns_for_children)\n\t\tput_pid_ns(ns->pid_ns_for_children);\n\tput_cgroup_ns(ns->cgroup_ns);\n\tput_net(ns->net_ns);\n\tkmem_cache_free(nsproxy_cachep, ns);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nsproxy_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nvoid free_nsproxy(struct nsproxy *ns)\n{\n\tif (ns->mnt_ns)\n\t\tput_mnt_ns(ns->mnt_ns);\n\tif (ns->uts_ns)\n\t\tput_uts_ns(ns->uts_ns);\n\tif (ns->ipc_ns)\n\t\tput_ipc_ns(ns->ipc_ns);\n\tif (ns->pid_ns_for_children)\n\t\tput_pid_ns(ns->pid_ns_for_children);\n\tput_cgroup_ns(ns->cgroup_ns);\n\tput_net(ns->net_ns);\n\tkmem_cache_free(nsproxy_cachep, ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ns->count"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "p"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "p"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns && atomic_dec_and_test(&ns->count))\n\t\tfree_nsproxy(ns);\n}"
  },
  {
    "function_name": "unshare_nsproxy_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
    "lines": "192-215",
    "snippet": "int unshare_nsproxy_namespaces(unsigned long unshare_flags,\n\tstruct nsproxy **new_nsp, struct cred *new_cred, struct fs_struct *new_fs)\n{\n\tstruct user_namespace *user_ns;\n\tint err = 0;\n\n\tif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP)))\n\t\treturn 0;\n\n\tuser_ns = new_cred ? new_cred->user_ns : current_user_ns();\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,\n\t\t\t\t\t new_fs ? new_fs : current->fs);\n\tif (IS_ERR(*new_nsp)) {\n\t\terr = PTR_ERR(*new_nsp);\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*new_nsp"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*new_nsp"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_new_namespaces",
          "args": [
            "unshare_flags",
            "current",
            "user_ns",
            "new_fs ? new_fs : current->fs"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
          "lines": "64-132",
          "snippet": "static struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\treturn new_nsp;\n\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nsproxy_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\treturn new_nsp;\n\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint unshare_nsproxy_namespaces(unsigned long unshare_flags,\n\tstruct nsproxy **new_nsp, struct cred *new_cred, struct fs_struct *new_fs)\n{\n\tstruct user_namespace *user_ns;\n\tint err = 0;\n\n\tif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP)))\n\t\treturn 0;\n\n\tuser_ns = new_cred ? new_cred->user_ns : current_user_ns();\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,\n\t\t\t\t\t new_fs ? new_fs : current->fs);\n\tif (IS_ERR(*new_nsp)) {\n\t\terr = PTR_ERR(*new_nsp);\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "free_nsproxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
    "lines": "173-186",
    "snippet": "void free_nsproxy(struct nsproxy *ns)\n{\n\tif (ns->mnt_ns)\n\t\tput_mnt_ns(ns->mnt_ns);\n\tif (ns->uts_ns)\n\t\tput_uts_ns(ns->uts_ns);\n\tif (ns->ipc_ns)\n\t\tput_ipc_ns(ns->ipc_ns);\n\tif (ns->pid_ns_for_children)\n\t\tput_pid_ns(ns->pid_ns_for_children);\n\tput_cgroup_ns(ns->cgroup_ns);\n\tput_net(ns->net_ns);\n\tkmem_cache_free(nsproxy_cachep, ns);\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nsproxy_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nsproxy_cachep",
            "ns"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "ns->net_ns"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "ns->cgroup_ns"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "ns->pid_ns_for_children"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "167-177",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ipc_ns",
          "args": [
            "ns->ipc_ns"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_uts_ns",
          "args": [
            "ns->uts_ns"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "ns->mnt_ns"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nvoid free_nsproxy(struct nsproxy *ns)\n{\n\tif (ns->mnt_ns)\n\t\tput_mnt_ns(ns->mnt_ns);\n\tif (ns->uts_ns)\n\t\tput_uts_ns(ns->uts_ns);\n\tif (ns->ipc_ns)\n\t\tput_ipc_ns(ns->ipc_ns);\n\tif (ns->pid_ns_for_children)\n\t\tput_pid_ns(ns->pid_ns_for_children);\n\tput_cgroup_ns(ns->cgroup_ns);\n\tput_net(ns->net_ns);\n\tkmem_cache_free(nsproxy_cachep, ns);\n}"
  },
  {
    "function_name": "copy_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
    "lines": "138-171",
    "snippet": "int copy_namespaces(unsigned long flags, struct task_struct *tsk)\n{\n\tstruct nsproxy *old_ns = tsk->nsproxy;\n\tstruct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);\n\tstruct nsproxy *new_ns;\n\n\tif (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t      CLONE_NEWPID | CLONE_NEWNET |\n\t\t\t      CLONE_NEWCGROUP)))) {\n\t\tget_nsproxy(old_ns);\n\t\treturn 0;\n\t}\n\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * CLONE_NEWIPC must detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM\n\t * means share undolist with parent, so we must forbid using\n\t * it along with CLONE_NEWIPC.\n\t */\n\tif ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==\n\t\t(CLONE_NEWIPC | CLONE_SYSVSEM)) \n\t\treturn -EINVAL;\n\n\tnew_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);\n\tif (IS_ERR(new_ns))\n\t\treturn  PTR_ERR(new_ns);\n\n\ttsk->nsproxy = new_ns;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_ns"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_ns"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_new_namespaces",
          "args": [
            "flags",
            "tsk",
            "user_ns",
            "tsk->fs"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
          "lines": "64-132",
          "snippet": "static struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\treturn new_nsp;\n\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nsproxy_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\treturn new_nsp;\n\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nsproxy",
          "args": [
            "old_ns"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t      CLONE_NEWPID | CLONE_NEWNET |\n\t\t\t      CLONE_NEWCGROUP))"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "tsk",
            "user_ns"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_namespaces(unsigned long flags, struct task_struct *tsk)\n{\n\tstruct nsproxy *old_ns = tsk->nsproxy;\n\tstruct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);\n\tstruct nsproxy *new_ns;\n\n\tif (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t      CLONE_NEWPID | CLONE_NEWNET |\n\t\t\t      CLONE_NEWCGROUP)))) {\n\t\tget_nsproxy(old_ns);\n\t\treturn 0;\n\t}\n\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * CLONE_NEWIPC must detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM\n\t * means share undolist with parent, so we must forbid using\n\t * it along with CLONE_NEWIPC.\n\t */\n\tif ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==\n\t\t(CLONE_NEWIPC | CLONE_SYSVSEM)) \n\t\treturn -EINVAL;\n\n\tnew_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);\n\tif (IS_ERR(new_ns))\n\t\treturn  PTR_ERR(new_ns);\n\n\ttsk->nsproxy = new_ns;\n\treturn 0;\n}"
  },
  {
    "function_name": "create_new_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
    "lines": "64-132",
    "snippet": "static struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\treturn new_nsp;\n\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nsproxy_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nsproxy_cachep",
            "new_nsp"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "new_nsp->mnt_ns"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_uts_ns",
          "args": [
            "new_nsp->uts_ns"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ipc_ns",
          "args": [
            "new_nsp->ipc_ns"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "new_nsp->pid_ns_for_children"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "167-177",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "new_nsp->cgroup_ns"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->net_ns"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->net_ns"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_net_ns",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->net_ns"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->cgroup_ns"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->cgroup_ns"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_cgroup_ns",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->cgroup_ns"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "copy_cgroup_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
          "lines": "50-91",
          "snippet": "struct cgroup_namespace *copy_cgroup_ns(unsigned long flags,\n\t\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\t\tstruct cgroup_namespace *old_ns)\n{\n\tstruct cgroup_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tstruct css_set *cset;\n\n\tBUG_ON(!old_ns);\n\n\tif (!(flags & CLONE_NEWCGROUP)) {\n\t\tget_cgroup_ns(old_ns);\n\t\treturn old_ns;\n\t}\n\n\t/* Allow only sysadmin to create cgroup namespace. */\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tucounts = inc_cgroup_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* It is not safe to take cgroup_mutex here */\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tnew_ns = alloc_cgroup_ns();\n\tif (IS_ERR(new_ns)) {\n\t\tput_css_set(cset);\n\t\tdec_cgroup_namespaces(ucounts);\n\t\treturn new_ns;\n\t}\n\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->root_cset = cset;\n\n\treturn new_ns;\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_namespace *copy_cgroup_ns(unsigned long flags,\n\t\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\t\tstruct cgroup_namespace *old_ns)\n{\n\tstruct cgroup_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tstruct css_set *cset;\n\n\tBUG_ON(!old_ns);\n\n\tif (!(flags & CLONE_NEWCGROUP)) {\n\t\tget_cgroup_ns(old_ns);\n\t\treturn old_ns;\n\t}\n\n\t/* Allow only sysadmin to create cgroup namespace. */\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tucounts = inc_cgroup_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* It is not safe to take cgroup_mutex here */\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tnew_ns = alloc_cgroup_ns();\n\tif (IS_ERR(new_ns)) {\n\t\tput_css_set(cset);\n\t\tdec_cgroup_namespaces(ucounts);\n\t\treturn new_ns;\n\t}\n\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->root_cset = cset;\n\n\treturn new_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->pid_ns_for_children"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->pid_ns_for_children"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_pid_ns",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->pid_ns_for_children"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "copy_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "149-157",
          "snippet": "struct pid_namespace *copy_pid_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct pid_namespace *old_ns)\n{\n\tif (!(flags & CLONE_NEWPID))\n\t\treturn get_pid_ns(old_ns);\n\tif (task_active_pid_ns(current) != old_ns)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn create_pid_namespace(user_ns, old_ns);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstruct pid_namespace *copy_pid_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct pid_namespace *old_ns)\n{\n\tif (!(flags & CLONE_NEWPID))\n\t\treturn get_pid_ns(old_ns);\n\tif (task_active_pid_ns(current) != old_ns)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn create_pid_namespace(user_ns, old_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->ipc_ns"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->ipc_ns"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_ipcs",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->ipc_ns"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->uts_ns"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->uts_ns"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_utsname",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->uts_ns"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "copy_utsname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/utsname.c",
          "lines": "93-108",
          "snippet": "struct uts_namespace *copy_utsname(unsigned long flags,\n\tstruct user_namespace *user_ns, struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *new_ns;\n\n\tBUG_ON(!old_ns);\n\tget_uts_ns(old_ns);\n\n\tif (!(flags & CLONE_NEWUTS))\n\t\treturn old_ns;\n\n\tnew_ns = clone_uts_ns(user_ns, old_ns);\n\n\tput_uts_ns(old_ns);\n\treturn new_ns;\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstruct uts_namespace *copy_utsname(unsigned long flags,\n\tstruct user_namespace *user_ns, struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *new_ns;\n\n\tBUG_ON(!old_ns);\n\tget_uts_ns(old_ns);\n\n\tif (!(flags & CLONE_NEWUTS))\n\t\treturn old_ns;\n\n\tnew_ns = clone_uts_ns(user_ns, old_ns);\n\n\tput_uts_ns(old_ns);\n\treturn new_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->mnt_ns"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->mnt_ns"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_mnt_ns",
          "args": [
            "flags",
            "tsk->nsproxy->mnt_ns",
            "user_ns",
            "new_fs"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_nsproxy",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "create_nsproxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
          "lines": "49-57",
          "snippet": "static inline struct nsproxy *create_nsproxy(void)\n{\n\tstruct nsproxy *nsproxy;\n\n\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\n\tif (nsproxy)\n\t\tatomic_set(&nsproxy->count, 1);\n\treturn nsproxy;\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nsproxy_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic inline struct nsproxy *create_nsproxy(void)\n{\n\tstruct nsproxy *nsproxy;\n\n\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\n\tif (nsproxy)\n\t\tatomic_set(&nsproxy->count, 1);\n\treturn nsproxy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\treturn new_nsp;\n\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "create_nsproxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
    "lines": "49-57",
    "snippet": "static inline struct nsproxy *create_nsproxy(void)\n{\n\tstruct nsproxy *nsproxy;\n\n\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\n\tif (nsproxy)\n\t\tatomic_set(&nsproxy->count, 1);\n\treturn nsproxy;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nsproxy_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nsproxy->count",
            "1"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "nsproxy_cachep",
            "GFP_KERNEL"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic inline struct nsproxy *create_nsproxy(void)\n{\n\tstruct nsproxy *nsproxy;\n\n\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\n\tif (nsproxy)\n\t\tatomic_set(&nsproxy->count, 1);\n\treturn nsproxy;\n}"
  },
  {
    "function_name": "setns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/nsproxy.c",
    "lines": "237-271",
    "snippet": "SYSCALL_DEFINE2(setns, int, fd, int, nstype)\n{\n\tstruct task_struct *tsk = current;\n\tstruct nsproxy *new_nsproxy;\n\tstruct file *file;\n\tstruct ns_common *ns;\n\tint err;\n\n\tfile = proc_ns_fget(fd);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\terr = -EINVAL;\n\tns = get_proc_ns(file_inode(file));\n\tif (nstype && (ns->ops->type != nstype))\n\t\tgoto out;\n\n\tnew_nsproxy = create_new_namespaces(0, tsk, current_user_ns(), tsk->fs);\n\tif (IS_ERR(new_nsproxy)) {\n\t\terr = PTR_ERR(new_nsproxy);\n\t\tgoto out;\n\t}\n\n\terr = ns->ops->install(new_nsproxy, ns);\n\tif (err) {\n\t\tfree_nsproxy(new_nsproxy);\n\t\tgoto out;\n\t}\n\tswitch_task_namespaces(tsk, new_nsproxy);\n\n\tperf_event_namespaces(tsk);\nout:\n\tfput(file);\n\treturn err;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(setns, int, fd, int, nstype)\n{\n\tstruct task_struct *tsk = current;\n\tstruct nsproxy *new_nsproxy;\n\tstruct file *file;\n\tstruct ns_common *ns;\n\tint err;\n\n\tfile = proc_ns_fget(fd);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\terr = -EINVAL;\n\tns = get_proc_ns(file_inode(file));\n\tif (nstype && (ns->ops->type != nstype))\n\t\tgoto out;\n\n\tnew_nsproxy = create_new_namespaces(0, tsk, current_user_ns(), tsk->fs);\n\tif (IS_ERR(new_nsproxy)) {\n\t\terr = PTR_ERR(new_nsproxy);\n\t\tgoto out;\n\t}\n\n\terr = ns->ops->install(new_nsproxy, ns);\n\tif (err) {\n\t\tfree_nsproxy(new_nsproxy);\n\t\tgoto out;\n\t}\n\tswitch_task_namespaces(tsk, new_nsproxy);\n\n\tperf_event_namespaces(tsk);\nout:\n\tfput(file);\n\treturn err;\n}"
  }
]