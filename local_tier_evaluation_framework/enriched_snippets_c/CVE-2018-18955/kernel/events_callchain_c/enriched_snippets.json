[
  {
    "function_name": "perf_event_max_stack_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "239-260",
    "snippet": "int perf_event_max_stack_handler(struct ctl_table *table, int write,\n\t\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *value = table->data;\n\tint new_value = *value, ret;\n\tstruct ctl_table new_table = *table;\n\n\tnew_table.data = &new_value;\n\tret = proc_dointvec_minmax(&new_table, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\n\tmutex_lock(&callchain_mutex);\n\tif (atomic_read(&nr_callchain_events))\n\t\tret = -EBUSY;\n\telse\n\t\t*value = new_value;\n\n\tmutex_unlock(&callchain_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t nr_callchain_events;",
      "static DEFINE_MUTEX(callchain_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&callchain_mutex"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nr_callchain_events"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&callchain_mutex"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "&new_table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3200-3204",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic atomic_t nr_callchain_events;\nstatic DEFINE_MUTEX(callchain_mutex);\n\nint perf_event_max_stack_handler(struct ctl_table *table, int write,\n\t\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *value = table->data;\n\tint new_value = *value, ret;\n\tstruct ctl_table new_table = *table;\n\n\tnew_table.data = &new_value;\n\tret = proc_dointvec_minmax(&new_table, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\n\tmutex_lock(&callchain_mutex);\n\tif (atomic_read(&nr_callchain_events))\n\t\tret = -EBUSY;\n\telse\n\t\t*value = new_value;\n\n\tmutex_unlock(&callchain_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_perf_callchain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "178-233",
    "snippet": "struct perf_callchain_entry *\nget_perf_callchain(struct pt_regs *regs, u32 init_nr, bool kernel, bool user,\n\t\t   u32 max_stack, bool crosstask, bool add_mark)\n{\n\tstruct perf_callchain_entry *entry;\n\tstruct perf_callchain_entry_ctx ctx;\n\tint rctx;\n\n\tentry = get_callchain_entry(&rctx);\n\tif (rctx == -1)\n\t\treturn NULL;\n\n\tif (!entry)\n\t\tgoto exit_put;\n\n\tctx.entry     = entry;\n\tctx.max_stack = max_stack;\n\tctx.nr\t      = entry->nr = init_nr;\n\tctx.contexts       = 0;\n\tctx.contexts_maxed = false;\n\n\tif (kernel && !user_mode(regs)) {\n\t\tif (add_mark)\n\t\t\tperf_callchain_store_context(&ctx, PERF_CONTEXT_KERNEL);\n\t\tperf_callchain_kernel(&ctx, regs);\n\t}\n\n\tif (user) {\n\t\tif (!user_mode(regs)) {\n\t\t\tif  (current->mm)\n\t\t\t\tregs = task_pt_regs(current);\n\t\t\telse\n\t\t\t\tregs = NULL;\n\t\t}\n\n\t\tif (regs) {\n\t\t\tmm_segment_t fs;\n\n\t\t\tif (crosstask)\n\t\t\t\tgoto exit_put;\n\n\t\t\tif (add_mark)\n\t\t\t\tperf_callchain_store_context(&ctx, PERF_CONTEXT_USER);\n\n\t\t\tfs = get_fs();\n\t\t\tset_fs(USER_DS);\n\t\t\tperf_callchain_user(&ctx, regs);\n\t\t\tset_fs(fs);\n\t\t}\n\t}\n\nexit_put:\n\tput_callchain_entry(rctx);\n\n\treturn entry;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_callchain_entry",
          "args": [
            "rctx"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "put_callchain_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "172-176",
          "snippet": "static void\nput_callchain_entry(int rctx)\n{\n\tput_recursion_context(this_cpu_ptr(callchain_recursion), rctx);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, callchain_recursion[PERF_NR_CONTEXTS]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic DEFINE_PER_CPU(int, callchain_recursion[PERF_NR_CONTEXTS]);\n\nstatic void\nput_callchain_entry(int rctx)\n{\n\tput_recursion_context(this_cpu_ptr(callchain_recursion), rctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "fs"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_callchain_user",
          "args": [
            "&ctx",
            "regs"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "perf_callchain_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "44-47",
          "snippet": "__weak void perf_callchain_user(struct perf_callchain_entry_ctx *entry,\n\t\t\t\tstruct pt_regs *regs)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\n__weak void perf_callchain_user(struct perf_callchain_entry_ctx *entry,\n\t\t\t\tstruct pt_regs *regs)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "USER_DS"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_callchain_store_context",
          "args": [
            "&ctx",
            "PERF_CONTEXT_USER"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pt_regs",
          "args": [
            "current"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_callchain_kernel",
          "args": [
            "&ctx",
            "regs"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "perf_callchain_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "39-42",
          "snippet": "__weak void perf_callchain_kernel(struct perf_callchain_entry_ctx *entry,\n\t\t\t\t  struct pt_regs *regs)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\n__weak void perf_callchain_kernel(struct perf_callchain_entry_ctx *entry,\n\t\t\t\t  struct pt_regs *regs)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_callchain_store_context",
          "args": [
            "&ctx",
            "PERF_CONTEXT_KERNEL"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_callchain_entry",
          "args": [
            "&rctx"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "get_callchain_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "153-170",
          "snippet": "static struct perf_callchain_entry *get_callchain_entry(int *rctx)\n{\n\tint cpu;\n\tstruct callchain_cpus_entries *entries;\n\n\t*rctx = get_recursion_context(this_cpu_ptr(callchain_recursion));\n\tif (*rctx == -1)\n\t\treturn NULL;\n\n\tentries = rcu_dereference(callchain_cpus_entries);\n\tif (!entries)\n\t\treturn NULL;\n\n\tcpu = smp_processor_id();\n\n\treturn (((void *)entries->cpu_entries[cpu]) +\n\t\t(*rctx * perf_callchain_entry__sizeof()));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, callchain_recursion[PERF_NR_CONTEXTS]);",
            "static struct callchain_cpus_entries *callchain_cpus_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic DEFINE_PER_CPU(int, callchain_recursion[PERF_NR_CONTEXTS]);\nstatic struct callchain_cpus_entries *callchain_cpus_entries;\n\nstatic struct perf_callchain_entry *get_callchain_entry(int *rctx)\n{\n\tint cpu;\n\tstruct callchain_cpus_entries *entries;\n\n\t*rctx = get_recursion_context(this_cpu_ptr(callchain_recursion));\n\tif (*rctx == -1)\n\t\treturn NULL;\n\n\tentries = rcu_dereference(callchain_cpus_entries);\n\tif (!entries)\n\t\treturn NULL;\n\n\tcpu = smp_processor_id();\n\n\treturn (((void *)entries->cpu_entries[cpu]) +\n\t\t(*rctx * perf_callchain_entry__sizeof()));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstruct perf_callchain_entry *\nget_perf_callchain(struct pt_regs *regs, u32 init_nr, bool kernel, bool user,\n\t\t   u32 max_stack, bool crosstask, bool add_mark)\n{\n\tstruct perf_callchain_entry *entry;\n\tstruct perf_callchain_entry_ctx ctx;\n\tint rctx;\n\n\tentry = get_callchain_entry(&rctx);\n\tif (rctx == -1)\n\t\treturn NULL;\n\n\tif (!entry)\n\t\tgoto exit_put;\n\n\tctx.entry     = entry;\n\tctx.max_stack = max_stack;\n\tctx.nr\t      = entry->nr = init_nr;\n\tctx.contexts       = 0;\n\tctx.contexts_maxed = false;\n\n\tif (kernel && !user_mode(regs)) {\n\t\tif (add_mark)\n\t\t\tperf_callchain_store_context(&ctx, PERF_CONTEXT_KERNEL);\n\t\tperf_callchain_kernel(&ctx, regs);\n\t}\n\n\tif (user) {\n\t\tif (!user_mode(regs)) {\n\t\t\tif  (current->mm)\n\t\t\t\tregs = task_pt_regs(current);\n\t\t\telse\n\t\t\t\tregs = NULL;\n\t\t}\n\n\t\tif (regs) {\n\t\t\tmm_segment_t fs;\n\n\t\t\tif (crosstask)\n\t\t\t\tgoto exit_put;\n\n\t\t\tif (add_mark)\n\t\t\t\tperf_callchain_store_context(&ctx, PERF_CONTEXT_USER);\n\n\t\t\tfs = get_fs();\n\t\t\tset_fs(USER_DS);\n\t\t\tperf_callchain_user(&ctx, regs);\n\t\t\tset_fs(fs);\n\t\t}\n\t}\n\nexit_put:\n\tput_callchain_entry(rctx);\n\n\treturn entry;\n}"
  },
  {
    "function_name": "put_callchain_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "172-176",
    "snippet": "static void\nput_callchain_entry(int rctx)\n{\n\tput_recursion_context(this_cpu_ptr(callchain_recursion), rctx);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, callchain_recursion[PERF_NR_CONTEXTS]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_recursion_context",
          "args": [
            "this_cpu_ptr(callchain_recursion)",
            "rctx"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "put_recursion_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "226-230",
          "snippet": "static inline void put_recursion_context(int *recursion, int rctx)\n{\n\tbarrier();\n\trecursion[rctx]--;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline void put_recursion_context(int *recursion, int rctx)\n{\n\tbarrier();\n\trecursion[rctx]--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "callchain_recursion"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic DEFINE_PER_CPU(int, callchain_recursion[PERF_NR_CONTEXTS]);\n\nstatic void\nput_callchain_entry(int rctx)\n{\n\tput_recursion_context(this_cpu_ptr(callchain_recursion), rctx);\n}"
  },
  {
    "function_name": "get_callchain_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "153-170",
    "snippet": "static struct perf_callchain_entry *get_callchain_entry(int *rctx)\n{\n\tint cpu;\n\tstruct callchain_cpus_entries *entries;\n\n\t*rctx = get_recursion_context(this_cpu_ptr(callchain_recursion));\n\tif (*rctx == -1)\n\t\treturn NULL;\n\n\tentries = rcu_dereference(callchain_cpus_entries);\n\tif (!entries)\n\t\treturn NULL;\n\n\tcpu = smp_processor_id();\n\n\treturn (((void *)entries->cpu_entries[cpu]) +\n\t\t(*rctx * perf_callchain_entry__sizeof()));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, callchain_recursion[PERF_NR_CONTEXTS]);",
      "static struct callchain_cpus_entries *callchain_cpus_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_callchain_entry__sizeof",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "perf_callchain_entry__sizeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "26-31",
          "snippet": "static inline size_t perf_callchain_entry__sizeof(void)\n{\n\treturn (sizeof(struct perf_callchain_entry) +\n\t\tsizeof(__u64) * (sysctl_perf_event_max_stack +\n\t\t\t\t sysctl_perf_event_max_contexts_per_stack));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_perf_event_max_stack",
            "int sysctl_perf_event_max_contexts_per_stack"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nint sysctl_perf_event_max_stack;\nint sysctl_perf_event_max_contexts_per_stack;\n\nstatic inline size_t perf_callchain_entry__sizeof(void)\n{\n\treturn (sizeof(struct perf_callchain_entry) +\n\t\tsizeof(__u64) * (sysctl_perf_event_max_stack +\n\t\t\t\t sysctl_perf_event_max_contexts_per_stack));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "callchain_cpus_entries"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_recursion_context",
          "args": [
            "this_cpu_ptr(callchain_recursion)"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "get_recursion_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "204-224",
          "snippet": "static inline int get_recursion_context(int *recursion)\n{\n\tint rctx;\n\n\tif (unlikely(in_nmi()))\n\t\trctx = 3;\n\telse if (in_irq())\n\t\trctx = 2;\n\telse if (in_softirq())\n\t\trctx = 1;\n\telse\n\t\trctx = 0;\n\n\tif (recursion[rctx])\n\t\treturn -1;\n\n\trecursion[rctx]++;\n\tbarrier();\n\n\treturn rctx;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline int get_recursion_context(int *recursion)\n{\n\tint rctx;\n\n\tif (unlikely(in_nmi()))\n\t\trctx = 3;\n\telse if (in_irq())\n\t\trctx = 2;\n\telse if (in_softirq())\n\t\trctx = 1;\n\telse\n\t\trctx = 0;\n\n\tif (recursion[rctx])\n\t\treturn -1;\n\n\trecursion[rctx]++;\n\tbarrier();\n\n\treturn rctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "callchain_recursion"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic DEFINE_PER_CPU(int, callchain_recursion[PERF_NR_CONTEXTS]);\nstatic struct callchain_cpus_entries *callchain_cpus_entries;\n\nstatic struct perf_callchain_entry *get_callchain_entry(int *rctx)\n{\n\tint cpu;\n\tstruct callchain_cpus_entries *entries;\n\n\t*rctx = get_recursion_context(this_cpu_ptr(callchain_recursion));\n\tif (*rctx == -1)\n\t\treturn NULL;\n\n\tentries = rcu_dereference(callchain_cpus_entries);\n\tif (!entries)\n\t\treturn NULL;\n\n\tcpu = smp_processor_id();\n\n\treturn (((void *)entries->cpu_entries[cpu]) +\n\t\t(*rctx * perf_callchain_entry__sizeof()));\n}"
  },
  {
    "function_name": "put_callchain_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "145-151",
    "snippet": "void put_callchain_buffers(void)\n{\n\tif (atomic_dec_and_mutex_lock(&nr_callchain_events, &callchain_mutex)) {\n\t\trelease_callchain_buffers();\n\t\tmutex_unlock(&callchain_mutex);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t nr_callchain_events;",
      "static DEFINE_MUTEX(callchain_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&callchain_mutex"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_callchain_buffers",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "release_callchain_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "62-69",
          "snippet": "static void release_callchain_buffers(void)\n{\n\tstruct callchain_cpus_entries *entries;\n\n\tentries = callchain_cpus_entries;\n\tRCU_INIT_POINTER(callchain_cpus_entries, NULL);\n\tcall_rcu(&entries->rcu_head, release_callchain_buffers_rcu);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callchain_cpus_entries *callchain_cpus_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic struct callchain_cpus_entries *callchain_cpus_entries;\n\nstatic void release_callchain_buffers(void)\n{\n\tstruct callchain_cpus_entries *entries;\n\n\tentries = callchain_cpus_entries;\n\tRCU_INIT_POINTER(callchain_cpus_entries, NULL);\n\tcall_rcu(&entries->rcu_head, release_callchain_buffers_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_mutex_lock",
          "args": [
            "&nr_callchain_events",
            "&callchain_mutex"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_dec_and_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1430-1444",
          "snippet": "int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)\n{\n\t/* dec if we can't possibly hit 0 */\n\tif (atomic_add_unless(cnt, -1, 1))\n\t\treturn 0;\n\t/* we might hit 0, so take the lock */\n\tmutex_lock(lock);\n\tif (!atomic_dec_and_test(cnt)) {\n\t\t/* when we actually did the dec, we didn't hit 0 */\n\t\tmutex_unlock(lock);\n\t\treturn 0;\n\t}\n\t/* we hit 0, and we hold the lock */\n\treturn 1;\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)\n{\n\t/* dec if we can't possibly hit 0 */\n\tif (atomic_add_unless(cnt, -1, 1))\n\t\treturn 0;\n\t/* we might hit 0, so take the lock */\n\tmutex_lock(lock);\n\tif (!atomic_dec_and_test(cnt)) {\n\t\t/* when we actually did the dec, we didn't hit 0 */\n\t\tmutex_unlock(lock);\n\t\treturn 0;\n\t}\n\t/* we hit 0, and we hold the lock */\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic atomic_t nr_callchain_events;\nstatic DEFINE_MUTEX(callchain_mutex);\n\nvoid put_callchain_buffers(void)\n{\n\tif (atomic_dec_and_mutex_lock(&nr_callchain_events, &callchain_mutex)) {\n\t\trelease_callchain_buffers();\n\t\tmutex_unlock(&callchain_mutex);\n\t}\n}"
  },
  {
    "function_name": "get_callchain_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "109-143",
    "snippet": "int get_callchain_buffers(int event_max_stack)\n{\n\tint err = 0;\n\tint count;\n\n\tmutex_lock(&callchain_mutex);\n\n\tcount = atomic_inc_return(&nr_callchain_events);\n\tif (WARN_ON_ONCE(count < 1)) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * If requesting per event more than the global cap,\n\t * return a different error to help userspace figure\n\t * this out.\n\t *\n\t * And also do it here so that we have &callchain_mutex held.\n\t */\n\tif (event_max_stack > sysctl_perf_event_max_stack) {\n\t\terr = -EOVERFLOW;\n\t\tgoto exit;\n\t}\n\n\tif (count == 1)\n\t\terr = alloc_callchain_buffers();\nexit:\n\tif (err)\n\t\tatomic_dec(&nr_callchain_events);\n\n\tmutex_unlock(&callchain_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_perf_event_max_stack",
      "static atomic_t nr_callchain_events;",
      "static DEFINE_MUTEX(callchain_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&callchain_mutex"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&nr_callchain_events"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_callchain_buffers",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_callchain_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "71-107",
          "snippet": "static int alloc_callchain_buffers(void)\n{\n\tint cpu;\n\tint size;\n\tstruct callchain_cpus_entries *entries;\n\n\t/*\n\t * We can't use the percpu allocation API for data that can be\n\t * accessed from NMI. Use a temporary manual per cpu allocation\n\t * until that gets sorted out.\n\t */\n\tsize = offsetof(struct callchain_cpus_entries, cpu_entries[nr_cpu_ids]);\n\n\tentries = kzalloc(size, GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tsize = perf_callchain_entry__sizeof() * PERF_NR_CONTEXTS;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tentries->cpu_entries[cpu] = kmalloc_node(size, GFP_KERNEL,\n\t\t\t\t\t\t\t cpu_to_node(cpu));\n\t\tif (!entries->cpu_entries[cpu])\n\t\t\tgoto fail;\n\t}\n\n\trcu_assign_pointer(callchain_cpus_entries, entries);\n\n\treturn 0;\n\nfail:\n\tfor_each_possible_cpu(cpu)\n\t\tkfree(entries->cpu_entries[cpu]);\n\tkfree(entries);\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callchain_cpus_entries *callchain_cpus_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic struct callchain_cpus_entries *callchain_cpus_entries;\n\nstatic int alloc_callchain_buffers(void)\n{\n\tint cpu;\n\tint size;\n\tstruct callchain_cpus_entries *entries;\n\n\t/*\n\t * We can't use the percpu allocation API for data that can be\n\t * accessed from NMI. Use a temporary manual per cpu allocation\n\t * until that gets sorted out.\n\t */\n\tsize = offsetof(struct callchain_cpus_entries, cpu_entries[nr_cpu_ids]);\n\n\tentries = kzalloc(size, GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tsize = perf_callchain_entry__sizeof() * PERF_NR_CONTEXTS;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tentries->cpu_entries[cpu] = kmalloc_node(size, GFP_KERNEL,\n\t\t\t\t\t\t\t cpu_to_node(cpu));\n\t\tif (!entries->cpu_entries[cpu])\n\t\t\tgoto fail;\n\t}\n\n\trcu_assign_pointer(callchain_cpus_entries, entries);\n\n\treturn 0;\n\nfail:\n\tfor_each_possible_cpu(cpu)\n\t\tkfree(entries->cpu_entries[cpu]);\n\tkfree(entries);\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "count < 1"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&nr_callchain_events"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&callchain_mutex"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nint sysctl_perf_event_max_stack;\nstatic atomic_t nr_callchain_events;\nstatic DEFINE_MUTEX(callchain_mutex);\n\nint get_callchain_buffers(int event_max_stack)\n{\n\tint err = 0;\n\tint count;\n\n\tmutex_lock(&callchain_mutex);\n\n\tcount = atomic_inc_return(&nr_callchain_events);\n\tif (WARN_ON_ONCE(count < 1)) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * If requesting per event more than the global cap,\n\t * return a different error to help userspace figure\n\t * this out.\n\t *\n\t * And also do it here so that we have &callchain_mutex held.\n\t */\n\tif (event_max_stack > sysctl_perf_event_max_stack) {\n\t\terr = -EOVERFLOW;\n\t\tgoto exit;\n\t}\n\n\tif (count == 1)\n\t\terr = alloc_callchain_buffers();\nexit:\n\tif (err)\n\t\tatomic_dec(&nr_callchain_events);\n\n\tmutex_unlock(&callchain_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "alloc_callchain_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "71-107",
    "snippet": "static int alloc_callchain_buffers(void)\n{\n\tint cpu;\n\tint size;\n\tstruct callchain_cpus_entries *entries;\n\n\t/*\n\t * We can't use the percpu allocation API for data that can be\n\t * accessed from NMI. Use a temporary manual per cpu allocation\n\t * until that gets sorted out.\n\t */\n\tsize = offsetof(struct callchain_cpus_entries, cpu_entries[nr_cpu_ids]);\n\n\tentries = kzalloc(size, GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tsize = perf_callchain_entry__sizeof() * PERF_NR_CONTEXTS;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tentries->cpu_entries[cpu] = kmalloc_node(size, GFP_KERNEL,\n\t\t\t\t\t\t\t cpu_to_node(cpu));\n\t\tif (!entries->cpu_entries[cpu])\n\t\t\tgoto fail;\n\t}\n\n\trcu_assign_pointer(callchain_cpus_entries, entries);\n\n\treturn 0;\n\nfail:\n\tfor_each_possible_cpu(cpu)\n\t\tkfree(entries->cpu_entries[cpu]);\n\tkfree(entries);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct callchain_cpus_entries *callchain_cpus_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entries"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "callchain_cpus_entries",
            "entries"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "size",
            "GFP_KERNEL",
            "cpu_to_node(cpu)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_callchain_entry__sizeof",
          "args": [],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "perf_callchain_entry__sizeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "26-31",
          "snippet": "static inline size_t perf_callchain_entry__sizeof(void)\n{\n\treturn (sizeof(struct perf_callchain_entry) +\n\t\tsizeof(__u64) * (sysctl_perf_event_max_stack +\n\t\t\t\t sysctl_perf_event_max_contexts_per_stack));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_perf_event_max_stack",
            "int sysctl_perf_event_max_contexts_per_stack"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nint sysctl_perf_event_max_stack;\nint sysctl_perf_event_max_contexts_per_stack;\n\nstatic inline size_t perf_callchain_entry__sizeof(void)\n{\n\treturn (sizeof(struct perf_callchain_entry) +\n\t\tsizeof(__u64) * (sysctl_perf_event_max_stack +\n\t\t\t\t sysctl_perf_event_max_contexts_per_stack));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic struct callchain_cpus_entries *callchain_cpus_entries;\n\nstatic int alloc_callchain_buffers(void)\n{\n\tint cpu;\n\tint size;\n\tstruct callchain_cpus_entries *entries;\n\n\t/*\n\t * We can't use the percpu allocation API for data that can be\n\t * accessed from NMI. Use a temporary manual per cpu allocation\n\t * until that gets sorted out.\n\t */\n\tsize = offsetof(struct callchain_cpus_entries, cpu_entries[nr_cpu_ids]);\n\n\tentries = kzalloc(size, GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tsize = perf_callchain_entry__sizeof() * PERF_NR_CONTEXTS;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tentries->cpu_entries[cpu] = kmalloc_node(size, GFP_KERNEL,\n\t\t\t\t\t\t\t cpu_to_node(cpu));\n\t\tif (!entries->cpu_entries[cpu])\n\t\t\tgoto fail;\n\t}\n\n\trcu_assign_pointer(callchain_cpus_entries, entries);\n\n\treturn 0;\n\nfail:\n\tfor_each_possible_cpu(cpu)\n\t\tkfree(entries->cpu_entries[cpu]);\n\tkfree(entries);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "release_callchain_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "62-69",
    "snippet": "static void release_callchain_buffers(void)\n{\n\tstruct callchain_cpus_entries *entries;\n\n\tentries = callchain_cpus_entries;\n\tRCU_INIT_POINTER(callchain_cpus_entries, NULL);\n\tcall_rcu(&entries->rcu_head, release_callchain_buffers_rcu);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct callchain_cpus_entries *callchain_cpus_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&entries->rcu_head",
            "release_callchain_buffers_rcu"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "callchain_cpus_entries",
            "NULL"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic struct callchain_cpus_entries *callchain_cpus_entries;\n\nstatic void release_callchain_buffers(void)\n{\n\tstruct callchain_cpus_entries *entries;\n\n\tentries = callchain_cpus_entries;\n\tRCU_INIT_POINTER(callchain_cpus_entries, NULL);\n\tcall_rcu(&entries->rcu_head, release_callchain_buffers_rcu);\n}"
  },
  {
    "function_name": "release_callchain_buffers_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "49-60",
    "snippet": "static void release_callchain_buffers_rcu(struct rcu_head *head)\n{\n\tstruct callchain_cpus_entries *entries;\n\tint cpu;\n\n\tentries = container_of(head, struct callchain_cpus_entries, rcu_head);\n\n\tfor_each_possible_cpu(cpu)\n\t\tkfree(entries->cpu_entries[cpu]);\n\n\tkfree(entries);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct callchain_cpus_entries *callchain_cpus_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entries"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structcallchain_cpus_entries",
            "rcu_head"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic struct callchain_cpus_entries *callchain_cpus_entries;\n\nstatic void release_callchain_buffers_rcu(struct rcu_head *head)\n{\n\tstruct callchain_cpus_entries *entries;\n\tint cpu;\n\n\tentries = container_of(head, struct callchain_cpus_entries, rcu_head);\n\n\tfor_each_possible_cpu(cpu)\n\t\tkfree(entries->cpu_entries[cpu]);\n\n\tkfree(entries);\n}"
  },
  {
    "function_name": "perf_callchain_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "44-47",
    "snippet": "__weak void perf_callchain_user(struct perf_callchain_entry_ctx *entry,\n\t\t\t\tstruct pt_regs *regs)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\n__weak void perf_callchain_user(struct perf_callchain_entry_ctx *entry,\n\t\t\t\tstruct pt_regs *regs)\n{\n}"
  },
  {
    "function_name": "perf_callchain_kernel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "39-42",
    "snippet": "__weak void perf_callchain_kernel(struct perf_callchain_entry_ctx *entry,\n\t\t\t\t  struct pt_regs *regs)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\n__weak void perf_callchain_kernel(struct perf_callchain_entry_ctx *entry,\n\t\t\t\t  struct pt_regs *regs)\n{\n}"
  },
  {
    "function_name": "perf_callchain_entry__sizeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
    "lines": "26-31",
    "snippet": "static inline size_t perf_callchain_entry__sizeof(void)\n{\n\treturn (sizeof(struct perf_callchain_entry) +\n\t\tsizeof(__u64) * (sysctl_perf_event_max_stack +\n\t\t\t\t sysctl_perf_event_max_contexts_per_stack));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_perf_event_max_stack",
      "int sysctl_perf_event_max_contexts_per_stack"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nint sysctl_perf_event_max_stack;\nint sysctl_perf_event_max_contexts_per_stack;\n\nstatic inline size_t perf_callchain_entry__sizeof(void)\n{\n\treturn (sizeof(struct perf_callchain_entry) +\n\t\tsizeof(__u64) * (sysctl_perf_event_max_stack +\n\t\t\t\t sysctl_perf_event_max_contexts_per_stack));\n}"
  }
]