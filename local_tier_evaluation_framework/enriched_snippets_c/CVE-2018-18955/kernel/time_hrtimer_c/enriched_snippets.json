[
  {
    "function_name": "schedule_hrtimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "2023-2027",
    "snippet": "int __sched schedule_hrtimeout(ktime_t *expires,\n\t\t\t       const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range(expires, 0, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_hrtimeout_range",
          "args": [
            "expires",
            "0",
            "mode"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_hrtimeout_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1989-1994",
          "snippet": "int __sched schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      CLOCK_MONOTONIC);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      CLOCK_MONOTONIC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched schedule_hrtimeout(ktime_t *expires,\n\t\t\t       const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range(expires, 0, mode);\n}"
  },
  {
    "function_name": "schedule_hrtimeout_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1989-1994",
    "snippet": "int __sched schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      CLOCK_MONOTONIC);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_hrtimeout_range_clock",
          "args": [
            "expires",
            "delta",
            "mode",
            "CLOCK_MONOTONIC"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_hrtimeout_range_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1916-1955",
          "snippet": "int __sched\nschedule_hrtimeout_range_clock(ktime_t *expires, u64 delta,\n\t\t\t       const enum hrtimer_mode mode, clockid_t clock_id)\n{\n\tstruct hrtimer_sleeper t;\n\n\t/*\n\t * Optimize when a zero timeout value is given. It does not\n\t * matter whether this is an absolute or a relative time.\n\t */\n\tif (expires && *expires == 0) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * A NULL parameter means \"infinite\"\n\t */\n\tif (!expires) {\n\t\tschedule();\n\t\treturn -EINTR;\n\t}\n\n\thrtimer_init_on_stack(&t.timer, clock_id, mode);\n\thrtimer_set_expires_range_ns(&t.timer, *expires, delta);\n\n\thrtimer_init_sleeper(&t, current);\n\n\thrtimer_start_expires(&t.timer, mode);\n\n\tif (likely(t.task))\n\t\tschedule();\n\n\thrtimer_cancel(&t.timer);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn !t.task ? 0 : -EINTR;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched\nschedule_hrtimeout_range_clock(ktime_t *expires, u64 delta,\n\t\t\t       const enum hrtimer_mode mode, clockid_t clock_id)\n{\n\tstruct hrtimer_sleeper t;\n\n\t/*\n\t * Optimize when a zero timeout value is given. It does not\n\t * matter whether this is an absolute or a relative time.\n\t */\n\tif (expires && *expires == 0) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * A NULL parameter means \"infinite\"\n\t */\n\tif (!expires) {\n\t\tschedule();\n\t\treturn -EINTR;\n\t}\n\n\thrtimer_init_on_stack(&t.timer, clock_id, mode);\n\thrtimer_set_expires_range_ns(&t.timer, *expires, delta);\n\n\thrtimer_init_sleeper(&t, current);\n\n\thrtimer_start_expires(&t.timer, mode);\n\n\tif (likely(t.task))\n\t\tschedule();\n\n\thrtimer_cancel(&t.timer);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn !t.task ? 0 : -EINTR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      CLOCK_MONOTONIC);\n}"
  },
  {
    "function_name": "schedule_hrtimeout_range_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1916-1955",
    "snippet": "int __sched\nschedule_hrtimeout_range_clock(ktime_t *expires, u64 delta,\n\t\t\t       const enum hrtimer_mode mode, clockid_t clock_id)\n{\n\tstruct hrtimer_sleeper t;\n\n\t/*\n\t * Optimize when a zero timeout value is given. It does not\n\t * matter whether this is an absolute or a relative time.\n\t */\n\tif (expires && *expires == 0) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * A NULL parameter means \"infinite\"\n\t */\n\tif (!expires) {\n\t\tschedule();\n\t\treturn -EINTR;\n\t}\n\n\thrtimer_init_on_stack(&t.timer, clock_id, mode);\n\thrtimer_set_expires_range_ns(&t.timer, *expires, delta);\n\n\thrtimer_init_sleeper(&t, current);\n\n\thrtimer_start_expires(&t.timer, mode);\n\n\tif (likely(t.task))\n\t\tschedule();\n\n\thrtimer_cancel(&t.timer);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn !t.task ? 0 : -EINTR;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&t.timer"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "440-443",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&t.timer"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "t.task"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "&t.timer",
            "mode"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_sleeper",
          "args": [
            "&t",
            "current"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1651-1655",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires_range_ns",
          "args": [
            "&t.timer",
            "*expires",
            "delta"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_on_stack",
          "args": [
            "&t.timer",
            "clock_id",
            "mode"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "432-437",
          "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched\nschedule_hrtimeout_range_clock(ktime_t *expires, u64 delta,\n\t\t\t       const enum hrtimer_mode mode, clockid_t clock_id)\n{\n\tstruct hrtimer_sleeper t;\n\n\t/*\n\t * Optimize when a zero timeout value is given. It does not\n\t * matter whether this is an absolute or a relative time.\n\t */\n\tif (expires && *expires == 0) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * A NULL parameter means \"infinite\"\n\t */\n\tif (!expires) {\n\t\tschedule();\n\t\treturn -EINTR;\n\t}\n\n\thrtimer_init_on_stack(&t.timer, clock_id, mode);\n\thrtimer_set_expires_range_ns(&t.timer, *expires, delta);\n\n\thrtimer_init_sleeper(&t, current);\n\n\thrtimer_start_expires(&t.timer, mode);\n\n\tif (likely(t.task))\n\t\tschedule();\n\n\thrtimer_cancel(&t.timer);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn !t.task ? 0 : -EINTR;\n}"
  },
  {
    "function_name": "hrtimers_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1903-1907",
    "snippet": "void __init hrtimers_init(void)\n{\n\thrtimers_prepare_cpu(smp_processor_id());\n\topen_softirq(HRTIMER_SOFTIRQ, hrtimer_run_softirq);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "open_softirq",
          "args": [
            "HRTIMER_SOFTIRQ",
            "hrtimer_run_softirq"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "open_softirq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "455-458",
          "snippet": "void open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct softirq_action softirq_vec[NR_SOFTIRQS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS];\n\nvoid open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimers_prepare_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimers_prepare_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1803-1822",
          "snippet": "int hrtimers_prepare_cpu(unsigned int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tcpu_base->clock_base[i].cpu_base = cpu_base;\n\t\ttimerqueue_init_head(&cpu_base->clock_base[i].active);\n\t}\n\n\tcpu_base->cpu = cpu;\n\tcpu_base->active_bases = 0;\n\tcpu_base->hres_active = 0;\n\tcpu_base->hang_detected = 0;\n\tcpu_base->next_timer = NULL;\n\tcpu_base->softirq_next_timer = NULL;\n\tcpu_base->expires_next = KTIME_MAX;\n\tcpu_base->softirq_expires_next = KTIME_MAX;\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nint hrtimers_prepare_cpu(unsigned int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tcpu_base->clock_base[i].cpu_base = cpu_base;\n\t\ttimerqueue_init_head(&cpu_base->clock_base[i].active);\n\t}\n\n\tcpu_base->cpu = cpu;\n\tcpu_base->active_bases = 0;\n\tcpu_base->hres_active = 0;\n\tcpu_base->hang_detected = 0;\n\tcpu_base->next_timer = NULL;\n\tcpu_base->softirq_next_timer = NULL;\n\tcpu_base->expires_next = KTIME_MAX;\n\tcpu_base->softirq_expires_next = KTIME_MAX;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid __init hrtimers_init(void)\n{\n\thrtimers_prepare_cpu(smp_processor_id());\n\topen_softirq(HRTIMER_SOFTIRQ, hrtimer_run_softirq);\n}"
  },
  {
    "function_name": "hrtimers_dead_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1856-1899",
    "snippet": "int hrtimers_dead_cpu(unsigned int scpu)\n{\n\tstruct hrtimer_cpu_base *old_base, *new_base;\n\tint i;\n\n\tBUG_ON(cpu_online(scpu));\n\ttick_cancel_sched_timer(scpu);\n\n\t/*\n\t * this BH disable ensures that raise_softirq_irqoff() does\n\t * not wakeup ksoftirqd (and acquire the pi-lock) while\n\t * holding the cpu_base lock\n\t */\n\tlocal_bh_disable();\n\tlocal_irq_disable();\n\told_base = &per_cpu(hrtimer_bases, scpu);\n\tnew_base = this_cpu_ptr(&hrtimer_bases);\n\t/*\n\t * The caller is globally serialized and nobody else\n\t * takes two locks at once, deadlock is not possible.\n\t */\n\traw_spin_lock(&new_base->lock);\n\traw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tmigrate_hrtimer_list(&old_base->clock_base[i],\n\t\t\t\t     &new_base->clock_base[i]);\n\t}\n\n\t/*\n\t * The migration might have changed the first expiring softirq\n\t * timer on this CPU. Update it.\n\t */\n\thrtimer_update_softirq_timer(new_base, false);\n\n\traw_spin_unlock(&old_base->lock);\n\traw_spin_unlock(&new_base->lock);\n\n\t/* Check, if we got expired work to do */\n\t__hrtimer_peek_ahead_timers();\n\tlocal_irq_enable();\n\tlocal_bh_enable();\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "159-163",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hrtimer_peek_ahead_timers",
          "args": [],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_peek_ahead_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1594-1594",
          "snippet": "static inline void __hrtimer_peek_ahead_timers(void) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void __hrtimer_peek_ahead_timers(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&new_base->lock"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_softirq_timer",
          "args": [
            "new_base",
            "false"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_softirq_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1045-1068",
          "snippet": "static void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nstatic void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_hrtimer_list",
          "args": [
            "&old_base->clock_base[i]",
            "&new_base->clock_base[i]"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_hrtimer_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1826-1854",
          "snippet": "static void migrate_hrtimer_list(struct hrtimer_clock_base *old_base,\n\t\t\t\tstruct hrtimer_clock_base *new_base)\n{\n\tstruct hrtimer *timer;\n\tstruct timerqueue_node *node;\n\n\twhile ((node = timerqueue_getnext(&old_base->active))) {\n\t\ttimer = container_of(node, struct hrtimer, node);\n\t\tBUG_ON(hrtimer_callback_running(timer));\n\t\tdebug_deactivate(timer);\n\n\t\t/*\n\t\t * Mark it as ENQUEUED not INACTIVE otherwise the\n\t\t * timer could be seen as !active and just vanish away\n\t\t * under us on another CPU\n\t\t */\n\t\t__remove_hrtimer(timer, old_base, HRTIMER_STATE_ENQUEUED, 0);\n\t\ttimer->base = new_base;\n\t\t/*\n\t\t * Enqueue the timers on the new cpu. This does not\n\t\t * reprogram the event device in case the timer\n\t\t * expires before the earliest on this CPU, but we run\n\t\t * hrtimer_interrupt after we migrated everything to\n\t\t * sort out already expired timers and reprogram the\n\t\t * event device.\n\t\t */\n\t\tenqueue_hrtimer(timer, new_base, HRTIMER_MODE_ABS);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void migrate_hrtimer_list(struct hrtimer_clock_base *old_base,\n\t\t\t\tstruct hrtimer_clock_base *new_base)\n{\n\tstruct hrtimer *timer;\n\tstruct timerqueue_node *node;\n\n\twhile ((node = timerqueue_getnext(&old_base->active))) {\n\t\ttimer = container_of(node, struct hrtimer, node);\n\t\tBUG_ON(hrtimer_callback_running(timer));\n\t\tdebug_deactivate(timer);\n\n\t\t/*\n\t\t * Mark it as ENQUEUED not INACTIVE otherwise the\n\t\t * timer could be seen as !active and just vanish away\n\t\t * under us on another CPU\n\t\t */\n\t\t__remove_hrtimer(timer, old_base, HRTIMER_STATE_ENQUEUED, 0);\n\t\ttimer->base = new_base;\n\t\t/*\n\t\t * Enqueue the timers on the new cpu. This does not\n\t\t * reprogram the event device in case the timer\n\t\t * expires before the earliest on this CPU, but we run\n\t\t * hrtimer_interrupt after we migrated everything to\n\t\t * sort out already expired timers and reprogram the\n\t\t * event device.\n\t\t */\n\t\tenqueue_hrtimer(timer, new_base, HRTIMER_MODE_ABS);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_nested",
          "args": [
            "&old_base->lock",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "351-356",
          "snippet": "void __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&new_base->lock"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hrtimer_bases",
            "scpu"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_cancel_sched_timer",
          "args": [
            "scpu"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "tick_cancel_sched_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.h",
          "lines": "81-81",
          "snippet": "static inline void tick_cancel_sched_timer(int cpu) { }",
          "includes": [
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n\nstatic inline void tick_cancel_sched_timer(int cpu) { }"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpu_online(scpu)"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "scpu"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nint hrtimers_dead_cpu(unsigned int scpu)\n{\n\tstruct hrtimer_cpu_base *old_base, *new_base;\n\tint i;\n\n\tBUG_ON(cpu_online(scpu));\n\ttick_cancel_sched_timer(scpu);\n\n\t/*\n\t * this BH disable ensures that raise_softirq_irqoff() does\n\t * not wakeup ksoftirqd (and acquire the pi-lock) while\n\t * holding the cpu_base lock\n\t */\n\tlocal_bh_disable();\n\tlocal_irq_disable();\n\told_base = &per_cpu(hrtimer_bases, scpu);\n\tnew_base = this_cpu_ptr(&hrtimer_bases);\n\t/*\n\t * The caller is globally serialized and nobody else\n\t * takes two locks at once, deadlock is not possible.\n\t */\n\traw_spin_lock(&new_base->lock);\n\traw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tmigrate_hrtimer_list(&old_base->clock_base[i],\n\t\t\t\t     &new_base->clock_base[i]);\n\t}\n\n\t/*\n\t * The migration might have changed the first expiring softirq\n\t * timer on this CPU. Update it.\n\t */\n\thrtimer_update_softirq_timer(new_base, false);\n\n\traw_spin_unlock(&old_base->lock);\n\traw_spin_unlock(&new_base->lock);\n\n\t/* Check, if we got expired work to do */\n\t__hrtimer_peek_ahead_timers();\n\tlocal_irq_enable();\n\tlocal_bh_enable();\n\treturn 0;\n}"
  },
  {
    "function_name": "migrate_hrtimer_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1826-1854",
    "snippet": "static void migrate_hrtimer_list(struct hrtimer_clock_base *old_base,\n\t\t\t\tstruct hrtimer_clock_base *new_base)\n{\n\tstruct hrtimer *timer;\n\tstruct timerqueue_node *node;\n\n\twhile ((node = timerqueue_getnext(&old_base->active))) {\n\t\ttimer = container_of(node, struct hrtimer, node);\n\t\tBUG_ON(hrtimer_callback_running(timer));\n\t\tdebug_deactivate(timer);\n\n\t\t/*\n\t\t * Mark it as ENQUEUED not INACTIVE otherwise the\n\t\t * timer could be seen as !active and just vanish away\n\t\t * under us on another CPU\n\t\t */\n\t\t__remove_hrtimer(timer, old_base, HRTIMER_STATE_ENQUEUED, 0);\n\t\ttimer->base = new_base;\n\t\t/*\n\t\t * Enqueue the timers on the new cpu. This does not\n\t\t * reprogram the event device in case the timer\n\t\t * expires before the earliest on this CPU, but we run\n\t\t * hrtimer_interrupt after we migrated everything to\n\t\t * sort out already expired timers and reprogram the\n\t\t * event device.\n\t\t */\n\t\tenqueue_hrtimer(timer, new_base, HRTIMER_MODE_ABS);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enqueue_hrtimer",
          "args": [
            "timer",
            "new_base",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_hrtimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "950-961",
          "snippet": "static int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\ttimer->state = HRTIMER_STATE_ENQUEUED;\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\ttimer->state = HRTIMER_STATE_ENQUEUED;\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_hrtimer",
          "args": [
            "timer",
            "old_base",
            "HRTIMER_STATE_ENQUEUED",
            "0"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_hrtimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "973-997",
          "snippet": "static void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\ttimer->state = newstate;\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superflous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\ttimer->state = newstate;\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superflous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_deactivate",
          "args": [
            "timer"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "debug_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "469-473",
          "snippet": "static inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "hrtimer_callback_running(timer)"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_callback_running",
          "args": [
            "timer"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structhrtimer",
            "node"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&old_base->active"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void migrate_hrtimer_list(struct hrtimer_clock_base *old_base,\n\t\t\t\tstruct hrtimer_clock_base *new_base)\n{\n\tstruct hrtimer *timer;\n\tstruct timerqueue_node *node;\n\n\twhile ((node = timerqueue_getnext(&old_base->active))) {\n\t\ttimer = container_of(node, struct hrtimer, node);\n\t\tBUG_ON(hrtimer_callback_running(timer));\n\t\tdebug_deactivate(timer);\n\n\t\t/*\n\t\t * Mark it as ENQUEUED not INACTIVE otherwise the\n\t\t * timer could be seen as !active and just vanish away\n\t\t * under us on another CPU\n\t\t */\n\t\t__remove_hrtimer(timer, old_base, HRTIMER_STATE_ENQUEUED, 0);\n\t\ttimer->base = new_base;\n\t\t/*\n\t\t * Enqueue the timers on the new cpu. This does not\n\t\t * reprogram the event device in case the timer\n\t\t * expires before the earliest on this CPU, but we run\n\t\t * hrtimer_interrupt after we migrated everything to\n\t\t * sort out already expired timers and reprogram the\n\t\t * event device.\n\t\t */\n\t\tenqueue_hrtimer(timer, new_base, HRTIMER_MODE_ABS);\n\t}\n}"
  },
  {
    "function_name": "hrtimers_prepare_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1803-1822",
    "snippet": "int hrtimers_prepare_cpu(unsigned int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tcpu_base->clock_base[i].cpu_base = cpu_base;\n\t\ttimerqueue_init_head(&cpu_base->clock_base[i].active);\n\t}\n\n\tcpu_base->cpu = cpu;\n\tcpu_base->active_bases = 0;\n\tcpu_base->hres_active = 0;\n\tcpu_base->hang_detected = 0;\n\tcpu_base->next_timer = NULL;\n\tcpu_base->softirq_next_timer = NULL;\n\tcpu_base->expires_next = KTIME_MAX;\n\tcpu_base->softirq_expires_next = KTIME_MAX;\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_init_head",
          "args": [
            "&cpu_base->clock_base[i].active"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hrtimer_bases",
            "cpu"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nint hrtimers_prepare_cpu(unsigned int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tcpu_base->clock_base[i].cpu_base = cpu_base;\n\t\ttimerqueue_init_head(&cpu_base->clock_base[i].active);\n\t}\n\n\tcpu_base->cpu = cpu;\n\tcpu_base->active_bases = 0;\n\tcpu_base->hres_active = 0;\n\tcpu_base->hang_detected = 0;\n\tcpu_base->next_timer = NULL;\n\tcpu_base->softirq_next_timer = NULL;\n\tcpu_base->expires_next = KTIME_MAX;\n\tcpu_base->softirq_expires_next = KTIME_MAX;\n\treturn 0;\n}"
  },
  {
    "function_name": "hrtimer_nanosleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1728-1759",
    "snippet": "long hrtimer_nanosleep(const struct timespec64 *rqtp,\n\t\t       const enum hrtimer_mode mode, const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tu64 slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_on_stack(&t.timer, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, timespec64_to_ktime(*rqtp), slack);\n\tret = do_nanosleep(&t, mode);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\tgoto out;\n\n\t/* Absolute timers do not update the rmtp value and restart: */\n\tif (mode == HRTIMER_MODE_ABS) {\n\t\tret = -ERESTARTNOHAND;\n\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->fn = hrtimer_nanosleep_restart;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&t.timer"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "440-443",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires_tv64",
          "args": [
            "&t.timer"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_nanosleep",
          "args": [
            "&t",
            "mode"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "do_nanosleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1677-1712",
          "snippet": "static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\thrtimer_init_sleeper(t, current);\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_start_expires(&t->timer, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\thrtimer_init_sleeper(t, current);\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_start_expires(&t->timer, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires_range_ns",
          "args": [
            "&t.timer",
            "timespec64_to_ktime(*rqtp)",
            "slack"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*rqtp"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_on_stack",
          "args": [
            "&t.timer",
            "clockid",
            "mode"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "432-437",
          "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "current"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "tg_has_rt_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2416-2432",
          "snippet": "static inline int tg_has_rt_tasks(struct task_group *tg)\n{\n\tstruct task_struct *g, *p;\n\n\t/*\n\t * Autogroups do not have RT tasks; see autogroup_create().\n\t */\n\tif (task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\tfor_each_process_thread(g, p) {\n\t\tif (rt_task(p) && task_group(p) == tg)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int tg_has_rt_tasks(struct task_group *tg)\n{\n\tstruct task_struct *g, *p;\n\n\t/*\n\t * Autogroups do not have RT tasks; see autogroup_create().\n\t */\n\tif (task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\tfor_each_process_thread(g, p) {\n\t\tif (rt_task(p) && task_group(p) == tg)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "current"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nlong hrtimer_nanosleep(const struct timespec64 *rqtp,\n\t\t       const enum hrtimer_mode mode, const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tu64 slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_on_stack(&t.timer, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, timespec64_to_ktime(*rqtp), slack);\n\tret = do_nanosleep(&t, mode);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\tgoto out;\n\n\t/* Absolute timers do not update the rmtp value and restart: */\n\tif (mode == HRTIMER_MODE_ABS) {\n\t\tret = -ERESTARTNOHAND;\n\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->fn = hrtimer_nanosleep_restart;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}"
  },
  {
    "function_name": "hrtimer_nanosleep_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1714-1726",
    "snippet": "static long __sched hrtimer_nanosleep_restart(struct restart_block *restart)\n{\n\tstruct hrtimer_sleeper t;\n\tint ret;\n\n\thrtimer_init_on_stack(&t.timer, restart->nanosleep.clockid,\n\t\t\t\tHRTIMER_MODE_ABS);\n\thrtimer_set_expires_tv64(&t.timer, restart->nanosleep.expires);\n\n\tret = do_nanosleep(&t, HRTIMER_MODE_ABS);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&t.timer"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "440-443",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_nanosleep",
          "args": [
            "&t",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "do_nanosleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1677-1712",
          "snippet": "static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\thrtimer_init_sleeper(t, current);\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_start_expires(&t->timer, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\thrtimer_init_sleeper(t, current);\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_start_expires(&t->timer, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires_tv64",
          "args": [
            "&t.timer",
            "restart->nanosleep.expires"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_on_stack",
          "args": [
            "&t.timer",
            "restart->nanosleep.clockid",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "432-437",
          "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic long __sched hrtimer_nanosleep_restart(struct restart_block *restart)\n{\n\tstruct hrtimer_sleeper t;\n\tint ret;\n\n\thrtimer_init_on_stack(&t.timer, restart->nanosleep.clockid,\n\t\t\t\tHRTIMER_MODE_ABS);\n\thrtimer_set_expires_tv64(&t.timer, restart->nanosleep.expires);\n\n\tret = do_nanosleep(&t, HRTIMER_MODE_ABS);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_nanosleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1677-1712",
    "snippet": "static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\thrtimer_init_sleeper(t, current);\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_start_expires(&t->timer, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nanosleep_copyout",
          "args": [
            "restart",
            "&rmt"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "nanosleep_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1658-1675",
          "snippet": "int nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "rem"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_expires_remaining",
          "args": [
            "&t->timer"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&t->timer"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "t->task"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "&t->timer",
            "mode"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_sleeper",
          "args": [
            "t",
            "current"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1651-1655",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\thrtimer_init_sleeper(t, current);\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_start_expires(&t->timer, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
  },
  {
    "function_name": "nanosleep_copyout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1658-1675",
    "snippet": "int nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_timespec64",
          "args": [
            "ts",
            "restart->nanosleep.rmtp"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "put_timespec64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "854-863",
          "snippet": "int put_timespec64(const struct timespec64 *ts,\n\t\t   struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts = {\n\t\t.tv_sec = ts->tv_sec,\n\t\t.tv_nsec = ts->tv_nsec\n\t};\n\n\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint put_timespec64(const struct timespec64 *ts,\n\t\t   struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts = {\n\t\t.tv_sec = ts->tv_sec,\n\t\t.tv_nsec = ts->tv_nsec\n\t};\n\n\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_old_timespec32",
          "args": [
            "ts",
            "restart->nanosleep.compat_rmtp"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "put_old_timespec32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "901-907",
          "snippet": "int put_old_timespec32(const struct timespec64 *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __put_old_timespec32(ts, uts);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint put_old_timespec32(const struct timespec64 *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __put_old_timespec32(ts, uts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
  },
  {
    "function_name": "hrtimer_init_sleeper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1651-1655",
    "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}"
  },
  {
    "function_name": "hrtimer_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1638-1649",
    "snippet": "static enum hrtimer_restart hrtimer_wakeup(struct hrtimer *timer)\n{\n\tstruct hrtimer_sleeper *t =\n\t\tcontainer_of(timer, struct hrtimer_sleeper, timer);\n\tstruct task_struct *task = t->task;\n\n\tt->task = NULL;\n\tif (task)\n\t\twake_up_process(task);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structhrtimer_sleeper",
            "timer"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic enum hrtimer_restart hrtimer_wakeup(struct hrtimer *timer)\n{\n\tstruct hrtimer_sleeper *t =\n\t\tcontainer_of(timer, struct hrtimer_sleeper, timer);\n\tstruct task_struct *task = t->task;\n\n\tt->task = NULL;\n\tif (task)\n\t\twake_up_process(task);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "hrtimer_run_queues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1601-1633",
    "snippet": "void hrtimer_run_queues(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tunsigned long flags;\n\tktime_t now;\n\n\tif (__hrtimer_hres_active(cpu_base))\n\t\treturn;\n\n\t/*\n\t * This _is_ ugly: We have to check periodically, whether we\n\t * can switch to highres and / or nohz mode. The clocksource\n\t * switch happens with xtime_lock held. Notification from\n\t * there only sets the check bit in the tick_oneshot code,\n\t * otherwise we might deadlock vs. xtime_lock.\n\t */\n\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) {\n\t\thrtimer_switch_to_hres();\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_run_queues",
          "args": [
            "cpu_base",
            "now",
            "flags",
            "HRTIMER_ACTIVE_HARD"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_run_queues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1428-1463",
          "snippet": "static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing querry for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing querry for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raise_softirq_irqoff",
          "args": [
            "HRTIMER_SOFTIRQ"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "449-453",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "now",
            "cpu_base->softirq_expires_next"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_update_base",
          "args": [
            "cpu_base"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "581-595",
          "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_switch_to_hres",
          "args": [],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_switch_to_hres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "752-752",
          "snippet": "static inline void hrtimer_switch_to_hres(void) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void hrtimer_switch_to_hres(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_oneshot_change",
          "args": [
            "!hrtimer_is_hres_enabled()"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_oneshot_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1371-1389",
          "snippet": "int tick_check_oneshot_change(int allow_nohz)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (!test_and_clear_bit(0, &ts->check_clocks))\n\t\treturn 0;\n\n\tif (ts->nohz_mode != NOHZ_MODE_INACTIVE)\n\t\treturn 0;\n\n\tif (!timekeeping_valid_for_hres() || !tick_is_oneshot_available())\n\t\treturn 0;\n\n\tif (!allow_nohz)\n\t\treturn 1;\n\n\ttick_nohz_switch_to_nohz();\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nint tick_check_oneshot_change(int allow_nohz)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (!test_and_clear_bit(0, &ts->check_clocks))\n\t\treturn 0;\n\n\tif (ts->nohz_mode != NOHZ_MODE_INACTIVE)\n\t\treturn 0;\n\n\tif (!timekeeping_valid_for_hres() || !tick_is_oneshot_available())\n\t\treturn 0;\n\n\tif (!allow_nohz)\n\t\treturn 1;\n\n\ttick_nohz_switch_to_nohz();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_is_hres_enabled",
          "args": [],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_is_hres_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "751-751",
          "snippet": "static inline int hrtimer_is_hres_enabled(void) { return 0; }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int hrtimer_is_hres_enabled(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "cpu_base"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "600-604",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nvoid hrtimer_run_queues(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tunsigned long flags;\n\tktime_t now;\n\n\tif (__hrtimer_hres_active(cpu_base))\n\t\treturn;\n\n\t/*\n\t * This _is_ ugly: We have to check periodically, whether we\n\t * can switch to highres and / or nohz mode. The clocksource\n\t * switch happens with xtime_lock held. Notification from\n\t * there only sets the check bit in the tick_oneshot code,\n\t * otherwise we might deadlock vs. xtime_lock.\n\t */\n\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) {\n\t\thrtimer_switch_to_hres();\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n}"
  },
  {
    "function_name": "__hrtimer_peek_ahead_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1594-1594",
    "snippet": "static inline void __hrtimer_peek_ahead_timers(void) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void __hrtimer_peek_ahead_timers(void) { }"
  },
  {
    "function_name": "__hrtimer_peek_ahead_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1580-1590",
    "snippet": "static inline void __hrtimer_peek_ahead_timers(void)\n{\n\tstruct tick_device *td;\n\n\tif (!hrtimer_hres_active())\n\t\treturn;\n\n\ttd = this_cpu_ptr(&tick_cpu_device);\n\tif (td && td->evtdev)\n\t\thrtimer_interrupt(td->evtdev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_interrupt",
          "args": [
            "td->evtdev"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1488-1577",
          "snippet": "void hrtimer_interrupt(struct clock_event_device *dev)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires_next, now, entry_time, delta;\n\tunsigned long flags;\n\tint retries = 0;\n\n\tBUG_ON(!cpu_base->hres_active);\n\tcpu_base->nr_events++;\n\tdev->next_event = KTIME_MAX;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tentry_time = now = hrtimer_update_base(cpu_base);\nretry:\n\tcpu_base->in_hrtirq = 1;\n\t/*\n\t * We set expires_next to KTIME_MAX here with cpu_base->lock\n\t * held to prevent that a timer is enqueued in our queue via\n\t * the migration code. This does not affect enqueueing of\n\t * timers which run their callback and need to be requeued on\n\t * this CPU.\n\t */\n\tcpu_base->expires_next = KTIME_MAX;\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\n\t/* Reevaluate the clock bases for the next expiry */\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\t/*\n\t * Store the new expiry value so the migration code can verify\n\t * against it.\n\t */\n\tcpu_base->expires_next = expires_next;\n\tcpu_base->in_hrtirq = 0;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\t/* Reprogramming necessary ? */\n\tif (!tick_program_event(expires_next, 0)) {\n\t\tcpu_base->hang_detected = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * The next timer was already expired due to:\n\t * - tracing\n\t * - long lasting callbacks\n\t * - being scheduled away when running in a VM\n\t *\n\t * We need to prevent that we loop forever in the hrtimer\n\t * interrupt routine. We give it 3 attempts to avoid\n\t * overreacting on some spurious event.\n\t *\n\t * Acquire base lock for updating the offsets and retrieving\n\t * the current time.\n\t */\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\tcpu_base->nr_retries++;\n\tif (++retries < 3)\n\t\tgoto retry;\n\t/*\n\t * Give the system a chance to do something else than looping\n\t * here. We stored the entry time, so we know exactly how long\n\t * we spent here. We schedule the next event this amount of\n\t * time away.\n\t */\n\tcpu_base->nr_hangs++;\n\tcpu_base->hang_detected = 1;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\tdelta = ktime_sub(now, entry_time);\n\tif ((unsigned int)delta > cpu_base->max_hang_time)\n\t\tcpu_base->max_hang_time = (unsigned int) delta;\n\t/*\n\t * Limit it to a sensible value as we enforce a longer\n\t * delay. Give the CPU at least 100ms to catch up.\n\t */\n\tif (delta > 100 * NSEC_PER_MSEC)\n\t\texpires_next = ktime_add_ns(now, 100 * NSEC_PER_MSEC);\n\telse\n\t\texpires_next = ktime_add(now, delta);\n\ttick_program_event(expires_next, 1);\n\tpr_warn_once(\"hrtimer: interrupt took %llu ns\\n\", ktime_to_ns(delta));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nvoid hrtimer_interrupt(struct clock_event_device *dev)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires_next, now, entry_time, delta;\n\tunsigned long flags;\n\tint retries = 0;\n\n\tBUG_ON(!cpu_base->hres_active);\n\tcpu_base->nr_events++;\n\tdev->next_event = KTIME_MAX;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tentry_time = now = hrtimer_update_base(cpu_base);\nretry:\n\tcpu_base->in_hrtirq = 1;\n\t/*\n\t * We set expires_next to KTIME_MAX here with cpu_base->lock\n\t * held to prevent that a timer is enqueued in our queue via\n\t * the migration code. This does not affect enqueueing of\n\t * timers which run their callback and need to be requeued on\n\t * this CPU.\n\t */\n\tcpu_base->expires_next = KTIME_MAX;\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\n\t/* Reevaluate the clock bases for the next expiry */\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\t/*\n\t * Store the new expiry value so the migration code can verify\n\t * against it.\n\t */\n\tcpu_base->expires_next = expires_next;\n\tcpu_base->in_hrtirq = 0;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\t/* Reprogramming necessary ? */\n\tif (!tick_program_event(expires_next, 0)) {\n\t\tcpu_base->hang_detected = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * The next timer was already expired due to:\n\t * - tracing\n\t * - long lasting callbacks\n\t * - being scheduled away when running in a VM\n\t *\n\t * We need to prevent that we loop forever in the hrtimer\n\t * interrupt routine. We give it 3 attempts to avoid\n\t * overreacting on some spurious event.\n\t *\n\t * Acquire base lock for updating the offsets and retrieving\n\t * the current time.\n\t */\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\tcpu_base->nr_retries++;\n\tif (++retries < 3)\n\t\tgoto retry;\n\t/*\n\t * Give the system a chance to do something else than looping\n\t * here. We stored the entry time, so we know exactly how long\n\t * we spent here. We schedule the next event this amount of\n\t * time away.\n\t */\n\tcpu_base->nr_hangs++;\n\tcpu_base->hang_detected = 1;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\tdelta = ktime_sub(now, entry_time);\n\tif ((unsigned int)delta > cpu_base->max_hang_time)\n\t\tcpu_base->max_hang_time = (unsigned int) delta;\n\t/*\n\t * Limit it to a sensible value as we enforce a longer\n\t * delay. Give the CPU at least 100ms to catch up.\n\t */\n\tif (delta > 100 * NSEC_PER_MSEC)\n\t\texpires_next = ktime_add_ns(now, 100 * NSEC_PER_MSEC);\n\telse\n\t\texpires_next = ktime_add(now, delta);\n\ttick_program_event(expires_next, 1);\n\tpr_warn_once(\"hrtimer: interrupt took %llu ns\\n\", ktime_to_ns(delta));\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_hres_active",
          "args": [],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_hres_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "606-609",
          "snippet": "static inline int hrtimer_hres_active(void)\n{\n\treturn __hrtimer_hres_active(this_cpu_ptr(&hrtimer_bases));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline int hrtimer_hres_active(void)\n{\n\treturn __hrtimer_hres_active(this_cpu_ptr(&hrtimer_bases));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void __hrtimer_peek_ahead_timers(void)\n{\n\tstruct tick_device *td;\n\n\tif (!hrtimer_hres_active())\n\t\treturn;\n\n\ttd = this_cpu_ptr(&tick_cpu_device);\n\tif (td && td->evtdev)\n\t\thrtimer_interrupt(td->evtdev);\n}"
  },
  {
    "function_name": "hrtimer_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1488-1577",
    "snippet": "void hrtimer_interrupt(struct clock_event_device *dev)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires_next, now, entry_time, delta;\n\tunsigned long flags;\n\tint retries = 0;\n\n\tBUG_ON(!cpu_base->hres_active);\n\tcpu_base->nr_events++;\n\tdev->next_event = KTIME_MAX;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tentry_time = now = hrtimer_update_base(cpu_base);\nretry:\n\tcpu_base->in_hrtirq = 1;\n\t/*\n\t * We set expires_next to KTIME_MAX here with cpu_base->lock\n\t * held to prevent that a timer is enqueued in our queue via\n\t * the migration code. This does not affect enqueueing of\n\t * timers which run their callback and need to be requeued on\n\t * this CPU.\n\t */\n\tcpu_base->expires_next = KTIME_MAX;\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\n\t/* Reevaluate the clock bases for the next expiry */\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\t/*\n\t * Store the new expiry value so the migration code can verify\n\t * against it.\n\t */\n\tcpu_base->expires_next = expires_next;\n\tcpu_base->in_hrtirq = 0;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\t/* Reprogramming necessary ? */\n\tif (!tick_program_event(expires_next, 0)) {\n\t\tcpu_base->hang_detected = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * The next timer was already expired due to:\n\t * - tracing\n\t * - long lasting callbacks\n\t * - being scheduled away when running in a VM\n\t *\n\t * We need to prevent that we loop forever in the hrtimer\n\t * interrupt routine. We give it 3 attempts to avoid\n\t * overreacting on some spurious event.\n\t *\n\t * Acquire base lock for updating the offsets and retrieving\n\t * the current time.\n\t */\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\tcpu_base->nr_retries++;\n\tif (++retries < 3)\n\t\tgoto retry;\n\t/*\n\t * Give the system a chance to do something else than looping\n\t * here. We stored the entry time, so we know exactly how long\n\t * we spent here. We schedule the next event this amount of\n\t * time away.\n\t */\n\tcpu_base->nr_hangs++;\n\tcpu_base->hang_detected = 1;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\tdelta = ktime_sub(now, entry_time);\n\tif ((unsigned int)delta > cpu_base->max_hang_time)\n\t\tcpu_base->max_hang_time = (unsigned int) delta;\n\t/*\n\t * Limit it to a sensible value as we enforce a longer\n\t * delay. Give the CPU at least 100ms to catch up.\n\t */\n\tif (delta > 100 * NSEC_PER_MSEC)\n\t\texpires_next = ktime_add_ns(now, 100 * NSEC_PER_MSEC);\n\telse\n\t\texpires_next = ktime_add(now, delta);\n\ttick_program_event(expires_next, 1);\n\tpr_warn_once(\"hrtimer: interrupt took %llu ns\\n\", ktime_to_ns(delta));\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)",
      "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"hrtimer: interrupt took %llu ns\\n\"",
            "ktime_to_ns(delta)"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "delta"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "expires_next",
            "1"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "27-49",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "now",
            "delta"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "now",
            "100 * NSEC_PER_MSEC"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "entry_time"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_base",
          "args": [
            "cpu_base"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "581-595",
          "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_get_next_event",
          "args": [
            "cpu_base",
            "HRTIMER_ACTIVE_ALL"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_get_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "555-579",
          "snippet": "static ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_run_queues",
          "args": [
            "cpu_base",
            "now",
            "flags",
            "HRTIMER_ACTIVE_HARD"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_run_queues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1428-1463",
          "snippet": "static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing querry for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing querry for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raise_softirq_irqoff",
          "args": [
            "HRTIMER_SOFTIRQ"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "449-453",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "now",
            "cpu_base->softirq_expires_next"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cpu_base->hres_active"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nvoid hrtimer_interrupt(struct clock_event_device *dev)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires_next, now, entry_time, delta;\n\tunsigned long flags;\n\tint retries = 0;\n\n\tBUG_ON(!cpu_base->hres_active);\n\tcpu_base->nr_events++;\n\tdev->next_event = KTIME_MAX;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tentry_time = now = hrtimer_update_base(cpu_base);\nretry:\n\tcpu_base->in_hrtirq = 1;\n\t/*\n\t * We set expires_next to KTIME_MAX here with cpu_base->lock\n\t * held to prevent that a timer is enqueued in our queue via\n\t * the migration code. This does not affect enqueueing of\n\t * timers which run their callback and need to be requeued on\n\t * this CPU.\n\t */\n\tcpu_base->expires_next = KTIME_MAX;\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\n\t/* Reevaluate the clock bases for the next expiry */\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\t/*\n\t * Store the new expiry value so the migration code can verify\n\t * against it.\n\t */\n\tcpu_base->expires_next = expires_next;\n\tcpu_base->in_hrtirq = 0;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\t/* Reprogramming necessary ? */\n\tif (!tick_program_event(expires_next, 0)) {\n\t\tcpu_base->hang_detected = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * The next timer was already expired due to:\n\t * - tracing\n\t * - long lasting callbacks\n\t * - being scheduled away when running in a VM\n\t *\n\t * We need to prevent that we loop forever in the hrtimer\n\t * interrupt routine. We give it 3 attempts to avoid\n\t * overreacting on some spurious event.\n\t *\n\t * Acquire base lock for updating the offsets and retrieving\n\t * the current time.\n\t */\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\tcpu_base->nr_retries++;\n\tif (++retries < 3)\n\t\tgoto retry;\n\t/*\n\t * Give the system a chance to do something else than looping\n\t * here. We stored the entry time, so we know exactly how long\n\t * we spent here. We schedule the next event this amount of\n\t * time away.\n\t */\n\tcpu_base->nr_hangs++;\n\tcpu_base->hang_detected = 1;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\tdelta = ktime_sub(now, entry_time);\n\tif ((unsigned int)delta > cpu_base->max_hang_time)\n\t\tcpu_base->max_hang_time = (unsigned int) delta;\n\t/*\n\t * Limit it to a sensible value as we enforce a longer\n\t * delay. Give the CPU at least 100ms to catch up.\n\t */\n\tif (delta > 100 * NSEC_PER_MSEC)\n\t\texpires_next = ktime_add_ns(now, 100 * NSEC_PER_MSEC);\n\telse\n\t\texpires_next = ktime_add(now, delta);\n\ttick_program_event(expires_next, 1);\n\tpr_warn_once(\"hrtimer: interrupt took %llu ns\\n\", ktime_to_ns(delta));\n}"
  },
  {
    "function_name": "hrtimer_run_softirq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1465-1480",
    "snippet": "static __latent_entropy void hrtimer_run_softirq(struct softirq_action *h)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tunsigned long flags;\n\tktime_t now;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tnow = hrtimer_update_base(cpu_base);\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_SOFT);\n\n\tcpu_base->softirq_activated = 0;\n\thrtimer_update_softirq_timer(cpu_base, true);\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_softirq_timer",
          "args": [
            "cpu_base",
            "true"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_softirq_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1045-1068",
          "snippet": "static void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nstatic void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_run_queues",
          "args": [
            "cpu_base",
            "now",
            "flags",
            "HRTIMER_ACTIVE_SOFT"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_run_queues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1428-1463",
          "snippet": "static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing querry for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing querry for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_base",
          "args": [
            "cpu_base"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "581-595",
          "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic __latent_entropy void hrtimer_run_softirq(struct softirq_action *h)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tunsigned long flags;\n\tktime_t now;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tnow = hrtimer_update_base(cpu_base);\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_SOFT);\n\n\tcpu_base->softirq_activated = 0;\n\thrtimer_update_softirq_timer(cpu_base, true);\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n}"
  },
  {
    "function_name": "__hrtimer_run_queues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1428-1463",
    "snippet": "static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing querry for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__run_hrtimer",
          "args": [
            "cpu_base",
            "base",
            "timer",
            "&basenow",
            "flags"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "__run_hrtimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1358-1426",
          "snippet": "static void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,\n\t\t\t  struct hrtimer_clock_base *base,\n\t\t\t  struct hrtimer *timer, ktime_t *now,\n\t\t\t  unsigned long flags)\n{\n\tenum hrtimer_restart (*fn)(struct hrtimer *);\n\tint restart;\n\n\tlockdep_assert_held(&cpu_base->lock);\n\n\tdebug_deactivate(timer);\n\tbase->running = timer;\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\t__remove_hrtimer(timer, base, HRTIMER_STATE_INACTIVE, 0);\n\tfn = timer->function;\n\n\t/*\n\t * Clear the 'is relative' flag for the TIME_LOW_RES case. If the\n\t * timer is restarted with a period then it becomes an absolute\n\t * timer. If its not restarted it does not matter.\n\t */\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES))\n\t\ttimer->is_rel = false;\n\n\t/*\n\t * The timer is marked as running in the CPU base, so it is\n\t * protected against migration to a different CPU even if the lock\n\t * is dropped.\n\t */\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\ttrace_hrtimer_expire_entry(timer, now);\n\trestart = fn(timer);\n\ttrace_hrtimer_expire_exit(timer);\n\traw_spin_lock_irq(&cpu_base->lock);\n\n\t/*\n\t * Note: We clear the running state after enqueue_hrtimer and\n\t * we do not reprogram the event hardware. Happens either in\n\t * hrtimer_start_range_ns() or in hrtimer_interrupt()\n\t *\n\t * Note: Because we dropped the cpu_base->lock above,\n\t * hrtimer_start_range_ns() can have popped in and enqueued the timer\n\t * for us already.\n\t */\n\tif (restart != HRTIMER_NORESTART &&\n\t    !(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\tenqueue_hrtimer(timer, base, HRTIMER_MODE_ABS);\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running.timer == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\tWARN_ON_ONCE(base->running != timer);\n\tbase->running = NULL;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,\n\t\t\t  struct hrtimer_clock_base *base,\n\t\t\t  struct hrtimer *timer, ktime_t *now,\n\t\t\t  unsigned long flags)\n{\n\tenum hrtimer_restart (*fn)(struct hrtimer *);\n\tint restart;\n\n\tlockdep_assert_held(&cpu_base->lock);\n\n\tdebug_deactivate(timer);\n\tbase->running = timer;\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\t__remove_hrtimer(timer, base, HRTIMER_STATE_INACTIVE, 0);\n\tfn = timer->function;\n\n\t/*\n\t * Clear the 'is relative' flag for the TIME_LOW_RES case. If the\n\t * timer is restarted with a period then it becomes an absolute\n\t * timer. If its not restarted it does not matter.\n\t */\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES))\n\t\ttimer->is_rel = false;\n\n\t/*\n\t * The timer is marked as running in the CPU base, so it is\n\t * protected against migration to a different CPU even if the lock\n\t * is dropped.\n\t */\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\ttrace_hrtimer_expire_entry(timer, now);\n\trestart = fn(timer);\n\ttrace_hrtimer_expire_exit(timer);\n\traw_spin_lock_irq(&cpu_base->lock);\n\n\t/*\n\t * Note: We clear the running state after enqueue_hrtimer and\n\t * we do not reprogram the event hardware. Happens either in\n\t * hrtimer_start_range_ns() or in hrtimer_interrupt()\n\t *\n\t * Note: Because we dropped the cpu_base->lock above,\n\t * hrtimer_start_range_ns() can have popped in and enqueued the timer\n\t * for us already.\n\t */\n\tif (restart != HRTIMER_NORESTART &&\n\t    !(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\tenqueue_hrtimer(timer, base, HRTIMER_MODE_ABS);\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running.timer == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\tWARN_ON_ONCE(base->running != timer);\n\tbase->running = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_get_softexpires_tv64",
          "args": [
            "timer"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structhrtimer",
            "node"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&base->active"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "now",
            "base->offset"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_active_base",
          "args": [
            "base",
            "cpu_base",
            "active"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing querry for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__run_hrtimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1358-1426",
    "snippet": "static void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,\n\t\t\t  struct hrtimer_clock_base *base,\n\t\t\t  struct hrtimer *timer, ktime_t *now,\n\t\t\t  unsigned long flags)\n{\n\tenum hrtimer_restart (*fn)(struct hrtimer *);\n\tint restart;\n\n\tlockdep_assert_held(&cpu_base->lock);\n\n\tdebug_deactivate(timer);\n\tbase->running = timer;\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\t__remove_hrtimer(timer, base, HRTIMER_STATE_INACTIVE, 0);\n\tfn = timer->function;\n\n\t/*\n\t * Clear the 'is relative' flag for the TIME_LOW_RES case. If the\n\t * timer is restarted with a period then it becomes an absolute\n\t * timer. If its not restarted it does not matter.\n\t */\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES))\n\t\ttimer->is_rel = false;\n\n\t/*\n\t * The timer is marked as running in the CPU base, so it is\n\t * protected against migration to a different CPU even if the lock\n\t * is dropped.\n\t */\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\ttrace_hrtimer_expire_entry(timer, now);\n\trestart = fn(timer);\n\ttrace_hrtimer_expire_exit(timer);\n\traw_spin_lock_irq(&cpu_base->lock);\n\n\t/*\n\t * Note: We clear the running state after enqueue_hrtimer and\n\t * we do not reprogram the event hardware. Happens either in\n\t * hrtimer_start_range_ns() or in hrtimer_interrupt()\n\t *\n\t * Note: Because we dropped the cpu_base->lock above,\n\t * hrtimer_start_range_ns() can have popped in and enqueued the timer\n\t * for us already.\n\t */\n\tif (restart != HRTIMER_NORESTART &&\n\t    !(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\tenqueue_hrtimer(timer, base, HRTIMER_MODE_ABS);\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running.timer == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\tWARN_ON_ONCE(base->running != timer);\n\tbase->running = NULL;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "base->running != timer"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_barrier",
          "args": [
            "&base->seq"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enqueue_hrtimer",
          "args": [
            "timer",
            "base",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_hrtimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "950-961",
          "snippet": "static int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\ttimer->state = HRTIMER_STATE_ENQUEUED;\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\ttimer->state = HRTIMER_STATE_ENQUEUED;\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&cpu_base->lock"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_hrtimer_expire_exit",
          "args": [
            "timer"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "timer"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "364-427",
          "snippet": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\t/*\n\t\t * signal was not sent because of sig_ignor\n\t\t * we will not get a call back to restart it AND\n\t\t * it should be restarted.\n\t\t */\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n\t\t\t/*\n\t\t\t * FIXME: What we really want, is to stop this\n\t\t\t * timer completely and restart it in case the\n\t\t\t * SIG_IGN is removed. This is a non trivial\n\t\t\t * change which involves sighand locking\n\t\t\t * (sigh !), which we don't want to do late in\n\t\t\t * the release cycle.\n\t\t\t *\n\t\t\t * For now we just let timers with an interval\n\t\t\t * less than a jiffie expire every jiffie to\n\t\t\t * avoid softirq starvation in case of SIG_IGN\n\t\t\t * and a very small interval, which would put\n\t\t\t * the timer right back on the softirq pending\n\t\t\t * list. By moving now ahead of time we trick\n\t\t\t * hrtimer_forward() to expire the timer\n\t\t\t * later, while we still maintain the overrun\n\t\t\t * accuracy, but have some inconsistency in\n\t\t\t * the timer_gettime() case. This is at least\n\t\t\t * better than a starved softirq. A more\n\t\t\t * complex fix which solves also another related\n\t\t\t * inconsistency is already in the pipeline.\n\t\t\t */\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\t/*\n\t\t * signal was not sent because of sig_ignor\n\t\t * we will not get a call back to restart it AND\n\t\t * it should be restarted.\n\t\t */\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n\t\t\t/*\n\t\t\t * FIXME: What we really want, is to stop this\n\t\t\t * timer completely and restart it in case the\n\t\t\t * SIG_IGN is removed. This is a non trivial\n\t\t\t * change which involves sighand locking\n\t\t\t * (sigh !), which we don't want to do late in\n\t\t\t * the release cycle.\n\t\t\t *\n\t\t\t * For now we just let timers with an interval\n\t\t\t * less than a jiffie expire every jiffie to\n\t\t\t * avoid softirq starvation in case of SIG_IGN\n\t\t\t * and a very small interval, which would put\n\t\t\t * the timer right back on the softirq pending\n\t\t\t * list. By moving now ahead of time we trick\n\t\t\t * hrtimer_forward() to expire the timer\n\t\t\t * later, while we still maintain the overrun\n\t\t\t * accuracy, but have some inconsistency in\n\t\t\t * the timer_gettime() case. This is at least\n\t\t\t * better than a starved softirq. A more\n\t\t\t * complex fix which solves also another related\n\t\t\t * inconsistency is already in the pipeline.\n\t\t\t */\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_hrtimer_expire_entry",
          "args": [
            "timer",
            "now"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TIME_LOW_RES"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_hrtimer",
          "args": [
            "timer",
            "base",
            "HRTIMER_STATE_INACTIVE",
            "0"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_hrtimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "973-997",
          "snippet": "static void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\ttimer->state = newstate;\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superflous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\ttimer->state = newstate;\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superflous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_barrier",
          "args": [
            "&base->seq"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_deactivate",
          "args": [
            "timer"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "debug_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "469-473",
          "snippet": "static inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cpu_base->lock"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,\n\t\t\t  struct hrtimer_clock_base *base,\n\t\t\t  struct hrtimer *timer, ktime_t *now,\n\t\t\t  unsigned long flags)\n{\n\tenum hrtimer_restart (*fn)(struct hrtimer *);\n\tint restart;\n\n\tlockdep_assert_held(&cpu_base->lock);\n\n\tdebug_deactivate(timer);\n\tbase->running = timer;\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\t__remove_hrtimer(timer, base, HRTIMER_STATE_INACTIVE, 0);\n\tfn = timer->function;\n\n\t/*\n\t * Clear the 'is relative' flag for the TIME_LOW_RES case. If the\n\t * timer is restarted with a period then it becomes an absolute\n\t * timer. If its not restarted it does not matter.\n\t */\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES))\n\t\ttimer->is_rel = false;\n\n\t/*\n\t * The timer is marked as running in the CPU base, so it is\n\t * protected against migration to a different CPU even if the lock\n\t * is dropped.\n\t */\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\ttrace_hrtimer_expire_entry(timer, now);\n\trestart = fn(timer);\n\ttrace_hrtimer_expire_exit(timer);\n\traw_spin_lock_irq(&cpu_base->lock);\n\n\t/*\n\t * Note: We clear the running state after enqueue_hrtimer and\n\t * we do not reprogram the event hardware. Happens either in\n\t * hrtimer_start_range_ns() or in hrtimer_interrupt()\n\t *\n\t * Note: Because we dropped the cpu_base->lock above,\n\t * hrtimer_start_range_ns() can have popped in and enqueued the timer\n\t * for us already.\n\t */\n\tif (restart != HRTIMER_NORESTART &&\n\t    !(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\tenqueue_hrtimer(timer, base, HRTIMER_MODE_ABS);\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running.timer == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\tWARN_ON_ONCE(base->running != timer);\n\tbase->running = NULL;\n}"
  },
  {
    "function_name": "hrtimer_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1320-1337",
    "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "timer->base"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&base->seq",
            "seq"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_read_seqcount_begin",
          "args": [
            "&base->seq"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "timer->base"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
  },
  {
    "function_name": "hrtimer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1305-1310",
    "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_init",
          "args": [
            "timer",
            "clock_id",
            "mode"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1268-1291",
          "snippet": "static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tbool softtimer = !!(mode & HRTIMER_MODE_SOFT);\n\tint base = softtimer ? HRTIMER_MAX_CLOCK_BASES / 2 : 0;\n\tstruct hrtimer_cpu_base *cpu_base;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * POSIX magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they needs to become CLOCK_MONOTONIC to\n\t * ensure POSIX compliance.\n\t */\n\tif (clock_id == CLOCK_REALTIME && mode & HRTIMER_MODE_REL)\n\t\tclock_id = CLOCK_MONOTONIC;\n\n\tbase += hrtimer_clockid_to_base(clock_id);\n\ttimer->is_soft = softtimer;\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tbool softtimer = !!(mode & HRTIMER_MODE_SOFT);\n\tint base = softtimer ? HRTIMER_MAX_CLOCK_BASES / 2 : 0;\n\tstruct hrtimer_cpu_base *cpu_base;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * POSIX magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they needs to become CLOCK_MONOTONIC to\n\t * ensure POSIX compliance.\n\t */\n\tif (clock_id == CLOCK_REALTIME && mode & HRTIMER_MODE_REL)\n\t\tclock_id = CLOCK_MONOTONIC;\n\n\tbase += hrtimer_clockid_to_base(clock_id);\n\ttimer->is_soft = softtimer;\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_init",
          "args": [
            "timer",
            "clock_id",
            "mode"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "debug_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "454-460",
          "snippet": "static inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
  },
  {
    "function_name": "__hrtimer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1268-1291",
    "snippet": "static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tbool softtimer = !!(mode & HRTIMER_MODE_SOFT);\n\tint base = softtimer ? HRTIMER_MAX_CLOCK_BASES / 2 : 0;\n\tstruct hrtimer_cpu_base *cpu_base;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * POSIX magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they needs to become CLOCK_MONOTONIC to\n\t * ensure POSIX compliance.\n\t */\n\tif (clock_id == CLOCK_REALTIME && mode & HRTIMER_MODE_REL)\n\t\tclock_id = CLOCK_MONOTONIC;\n\n\tbase += hrtimer_clockid_to_base(clock_id);\n\ttimer->is_soft = softtimer;\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_init",
          "args": [
            "&timer->node"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_clockid_to_base",
          "args": [
            "clock_id"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_clockid_to_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1256-1266",
          "snippet": "static inline int hrtimer_clockid_to_base(clockid_t clock_id)\n{\n\tif (likely(clock_id < MAX_CLOCKS)) {\n\t\tint base = hrtimer_clock_to_base_table[clock_id];\n\n\t\tif (likely(base != HRTIMER_MAX_CLOCK_BASES))\n\t\t\treturn base;\n\t}\n\tWARN(1, \"Invalid clockid %d. Using MONOTONIC\\n\", clock_id);\n\treturn HRTIMER_BASE_MONOTONIC;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {\n\t/* Make sure we catch unsupported clockids */\n\t[0 ... MAX_CLOCKS - 1]\t= HRTIMER_MAX_CLOCK_BASES,\n\n\t[CLOCK_REALTIME]\t= HRTIMER_BASE_REALTIME,\n\t[CLOCK_MONOTONIC]\t= HRTIMER_BASE_MONOTONIC,\n\t[CLOCK_BOOTTIME]\t= HRTIMER_BASE_BOOTTIME,\n\t[CLOCK_TAI]\t\t= HRTIMER_BASE_TAI,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {\n\t/* Make sure we catch unsupported clockids */\n\t[0 ... MAX_CLOCKS - 1]\t= HRTIMER_MAX_CLOCK_BASES,\n\n\t[CLOCK_REALTIME]\t= HRTIMER_BASE_REALTIME,\n\t[CLOCK_MONOTONIC]\t= HRTIMER_BASE_MONOTONIC,\n\t[CLOCK_BOOTTIME]\t= HRTIMER_BASE_BOOTTIME,\n\t[CLOCK_TAI]\t\t= HRTIMER_BASE_TAI,\n};\n\nstatic inline int hrtimer_clockid_to_base(clockid_t clock_id)\n{\n\tif (likely(clock_id < MAX_CLOCKS)) {\n\t\tint base = hrtimer_clock_to_base_table[clock_id];\n\n\t\tif (likely(base != HRTIMER_MAX_CLOCK_BASES))\n\t\t\treturn base;\n\t}\n\tWARN(1, \"Invalid clockid %d. Using MONOTONIC\\n\", clock_id);\n\treturn HRTIMER_BASE_MONOTONIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "timer",
            "0",
            "sizeof(struct hrtimer)"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tbool softtimer = !!(mode & HRTIMER_MODE_SOFT);\n\tint base = softtimer ? HRTIMER_MAX_CLOCK_BASES / 2 : 0;\n\tstruct hrtimer_cpu_base *cpu_base;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * POSIX magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they needs to become CLOCK_MONOTONIC to\n\t * ensure POSIX compliance.\n\t */\n\tif (clock_id == CLOCK_REALTIME && mode & HRTIMER_MODE_REL)\n\t\tclock_id = CLOCK_MONOTONIC;\n\n\tbase += hrtimer_clockid_to_base(clock_id);\n\ttimer->is_soft = softtimer;\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n}"
  },
  {
    "function_name": "hrtimer_clockid_to_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1256-1266",
    "snippet": "static inline int hrtimer_clockid_to_base(clockid_t clock_id)\n{\n\tif (likely(clock_id < MAX_CLOCKS)) {\n\t\tint base = hrtimer_clock_to_base_table[clock_id];\n\n\t\tif (likely(base != HRTIMER_MAX_CLOCK_BASES))\n\t\t\treturn base;\n\t}\n\tWARN(1, \"Invalid clockid %d. Using MONOTONIC\\n\", clock_id);\n\treturn HRTIMER_BASE_MONOTONIC;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {\n\t/* Make sure we catch unsupported clockids */\n\t[0 ... MAX_CLOCKS - 1]\t= HRTIMER_MAX_CLOCK_BASES,\n\n\t[CLOCK_REALTIME]\t= HRTIMER_BASE_REALTIME,\n\t[CLOCK_MONOTONIC]\t= HRTIMER_BASE_MONOTONIC,\n\t[CLOCK_BOOTTIME]\t= HRTIMER_BASE_BOOTTIME,\n\t[CLOCK_TAI]\t\t= HRTIMER_BASE_TAI,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Invalid clockid %d. Using MONOTONIC\\n\"",
            "clock_id"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "base != HRTIMER_MAX_CLOCK_BASES"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "clock_id < MAX_CLOCKS"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {\n\t/* Make sure we catch unsupported clockids */\n\t[0 ... MAX_CLOCKS - 1]\t= HRTIMER_MAX_CLOCK_BASES,\n\n\t[CLOCK_REALTIME]\t= HRTIMER_BASE_REALTIME,\n\t[CLOCK_MONOTONIC]\t= HRTIMER_BASE_MONOTONIC,\n\t[CLOCK_BOOTTIME]\t= HRTIMER_BASE_BOOTTIME,\n\t[CLOCK_TAI]\t\t= HRTIMER_BASE_TAI,\n};\n\nstatic inline int hrtimer_clockid_to_base(clockid_t clock_id)\n{\n\tif (likely(clock_id < MAX_CLOCKS)) {\n\t\tint base = hrtimer_clock_to_base_table[clock_id];\n\n\t\tif (likely(base != HRTIMER_MAX_CLOCK_BASES))\n\t\t\treturn base;\n\t}\n\tWARN(1, \"Invalid clockid %d. Using MONOTONIC\\n\", clock_id);\n\treturn HRTIMER_BASE_MONOTONIC;\n}"
  },
  {
    "function_name": "hrtimer_next_event_without",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1229-1253",
    "snippet": "u64 hrtimer_next_event_without(const struct hrtimer *exclude)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (__hrtimer_hres_active(cpu_base)) {\n\t\tunsigned int active;\n\n\t\tif (!cpu_base->softirq_activated) {\n\t\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\t\texpires = __hrtimer_next_event_base(cpu_base, exclude,\n\t\t\t\t\t\t\t    active, KTIME_MAX);\n\t\t}\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\texpires = __hrtimer_next_event_base(cpu_base, exclude, active,\n\t\t\t\t\t\t    expires);\n\t}\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
      "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_next_event_base",
          "args": [
            "cpu_base",
            "exclude",
            "active",
            "expires"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_next_event_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "492-536",
          "snippet": "static ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "cpu_base"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "600-604",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nu64 hrtimer_next_event_without(const struct hrtimer *exclude)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (__hrtimer_hres_active(cpu_base)) {\n\t\tunsigned int active;\n\n\t\tif (!cpu_base->softirq_activated) {\n\t\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\t\texpires = __hrtimer_next_event_base(cpu_base, exclude,\n\t\t\t\t\t\t\t    active, KTIME_MAX);\n\t\t}\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\texpires = __hrtimer_next_event_base(cpu_base, exclude, active,\n\t\t\t\t\t\t    expires);\n\t}\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}"
  },
  {
    "function_name": "hrtimer_get_next_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1206-1220",
    "snippet": "u64 hrtimer_get_next_event(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (!__hrtimer_hres_active(cpu_base))\n\t\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_get_next_event",
          "args": [
            "cpu_base",
            "HRTIMER_ACTIVE_ALL"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_get_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "555-579",
          "snippet": "static ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "cpu_base"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "600-604",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nu64 hrtimer_get_next_event(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (!__hrtimer_hres_active(cpu_base))\n\t\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}"
  },
  {
    "function_name": "__hrtimer_get_remaining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1184-1197",
    "snippet": "ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust)\n{\n\tunsigned long flags;\n\tktime_t rem;\n\n\tlock_hrtimer_base(timer, &flags);\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES) && adjust)\n\t\trem = hrtimer_expires_remaining_adjusted(timer);\n\telse\n\t\trem = hrtimer_expires_remaining(timer);\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn rem;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_hrtimer_base",
          "args": [
            "timer",
            "&flags"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_hrtimer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "884-888",
          "snippet": "static inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_expires_remaining",
          "args": [
            "timer"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_expires_remaining_adjusted",
          "args": [
            "timer"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TIME_LOW_RES"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust)\n{\n\tunsigned long flags;\n\tktime_t rem;\n\n\tlock_hrtimer_base(timer, &flags);\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES) && adjust)\n\t\trem = hrtimer_expires_remaining_adjusted(timer);\n\telse\n\t\trem = hrtimer_expires_remaining(timer);\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn rem;\n}"
  },
  {
    "function_name": "hrtimer_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1167-1176",
    "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "timer"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1132-1156",
          "snippet": "int hrtimer_try_to_cancel(struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\t/*\n\t * Check lockless first. If the timer is not active (neither\n\t * enqueued nor running the callback, nothing to do here.  The\n\t * base lock does not serialize against a concurrent enqueue,\n\t * so we can avoid taking it.\n\t */\n\tif (!hrtimer_active(timer))\n\t\treturn 0;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (!hrtimer_callback_running(timer))\n\t\tret = remove_hrtimer(timer, base, false);\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_try_to_cancel(struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\t/*\n\t * Check lockless first. If the timer is not active (neither\n\t * enqueued nor running the callback, nothing to do here.  The\n\t * base lock does not serialize against a concurrent enqueue,\n\t * so we can avoid taking it.\n\t */\n\tif (!hrtimer_active(timer))\n\t\treturn 0;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (!hrtimer_callback_running(timer))\n\t\tret = remove_hrtimer(timer, base, false);\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "hrtimer_try_to_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1132-1156",
    "snippet": "int hrtimer_try_to_cancel(struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\t/*\n\t * Check lockless first. If the timer is not active (neither\n\t * enqueued nor running the callback, nothing to do here.  The\n\t * base lock does not serialize against a concurrent enqueue,\n\t * so we can avoid taking it.\n\t */\n\tif (!hrtimer_active(timer))\n\t\treturn 0;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (!hrtimer_callback_running(timer))\n\t\tret = remove_hrtimer(timer, base, false);\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_hrtimer_base",
          "args": [
            "timer",
            "&flags"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_hrtimer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "884-888",
          "snippet": "static inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hrtimer",
          "args": [
            "timer",
            "base",
            "false"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hrtimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1002-1027",
          "snippet": "static inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool restart)\n{\n\tif (hrtimer_is_queued(timer)) {\n\t\tu8 state = timer->state;\n\t\tint reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool restart)\n{\n\tif (hrtimer_is_queued(timer)) {\n\t\tu8 state = timer->state;\n\t\tint reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_callback_running",
          "args": [
            "timer"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "timer"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1320-1337",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_try_to_cancel(struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\t/*\n\t * Check lockless first. If the timer is not active (neither\n\t * enqueued nor running the callback, nothing to do here.  The\n\t * base lock does not serialize against a concurrent enqueue,\n\t * so we can avoid taking it.\n\t */\n\tif (!hrtimer_active(timer))\n\t\treturn 0;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (!hrtimer_callback_running(timer))\n\t\tret = remove_hrtimer(timer, base, false);\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n\n}"
  },
  {
    "function_name": "hrtimer_start_range_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1101-1119",
    "snippet": "void hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t    u64 delta_ns, const enum hrtimer_mode mode)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\n\t/*\n\t * Check whether the HRTIMER_MODE_SOFT bit and hrtimer.is_soft\n\t * match.\n\t */\n\tWARN_ON_ONCE(!(mode & HRTIMER_MODE_SOFT) ^ !timer->is_soft);\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (__hrtimer_start_range_ns(timer, tim, delta_ns, mode, base))\n\t\thrtimer_reprogram(timer, true);\n\n\tunlock_hrtimer_base(timer, &flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_hrtimer_base",
          "args": [
            "timer",
            "&flags"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_hrtimer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "884-888",
          "snippet": "static inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_reprogram",
          "args": [
            "timer",
            "true"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_reprogram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "764-844",
          "snippet": "static void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will\n\t * reevaluate the clock bases and reprogram the clock event\n\t * device. The callbacks are always executed in hard interrupt\n\t * context so we don't need an extra check for a running\n\t * callback.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/* Update the pointer to the next expiring timer */\n\tcpu_base->next_timer = timer;\n\tcpu_base->expires_next = expires;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * programmed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * do not schedule a timer which is earlier than the expiry\n\t * which we enforced in the hang detection. We want the system\n\t * to make progress.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\t/*\n\t * Program the timer hardware. We enforce the expiry for\n\t * events which are already in the past.\n\t */\n\ttick_program_event(expires, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will\n\t * reevaluate the clock bases and reprogram the clock event\n\t * device. The callbacks are always executed in hard interrupt\n\t * context so we don't need an extra check for a running\n\t * callback.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/* Update the pointer to the next expiring timer */\n\tcpu_base->next_timer = timer;\n\tcpu_base->expires_next = expires;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * programmed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * do not schedule a timer which is earlier than the expiry\n\t * which we enforced in the hang detection. We want the system\n\t * to make progress.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\t/*\n\t * Program the timer hardware. We enforce the expiry for\n\t * events which are already in the past.\n\t */\n\ttick_program_event(expires, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_start_range_ns",
          "args": [
            "timer",
            "tim",
            "delta_ns",
            "mode",
            "base"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_start_range_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1070-1090",
          "snippet": "static int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t    u64 delta_ns, const enum hrtimer_mode mode,\n\t\t\t\t    struct hrtimer_clock_base *base)\n{\n\tstruct hrtimer_clock_base *new_base;\n\n\t/* Remove an active timer from the queue: */\n\tremove_hrtimer(timer, base, true);\n\n\tif (mode & HRTIMER_MODE_REL)\n\t\ttim = ktime_add_safe(tim, base->get_time());\n\n\ttim = hrtimer_update_lowres(timer, tim, mode);\n\n\thrtimer_set_expires_range_ns(timer, tim, delta_ns);\n\n\t/* Switch the timer base, if necessary: */\n\tnew_base = switch_hrtimer_base(timer, base, mode & HRTIMER_MODE_PINNED);\n\n\treturn enqueue_hrtimer(timer, new_base, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t    u64 delta_ns, const enum hrtimer_mode mode,\n\t\t\t\t    struct hrtimer_clock_base *base)\n{\n\tstruct hrtimer_clock_base *new_base;\n\n\t/* Remove an active timer from the queue: */\n\tremove_hrtimer(timer, base, true);\n\n\tif (mode & HRTIMER_MODE_REL)\n\t\ttim = ktime_add_safe(tim, base->get_time());\n\n\ttim = hrtimer_update_lowres(timer, tim, mode);\n\n\thrtimer_set_expires_range_ns(timer, tim, delta_ns);\n\n\t/* Switch the timer base, if necessary: */\n\tnew_base = switch_hrtimer_base(timer, base, mode & HRTIMER_MODE_PINNED);\n\n\treturn enqueue_hrtimer(timer, new_base, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(mode & HRTIMER_MODE_SOFT) ^ !timer->is_soft"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t    u64 delta_ns, const enum hrtimer_mode mode)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\n\t/*\n\t * Check whether the HRTIMER_MODE_SOFT bit and hrtimer.is_soft\n\t * match.\n\t */\n\tWARN_ON_ONCE(!(mode & HRTIMER_MODE_SOFT) ^ !timer->is_soft);\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (__hrtimer_start_range_ns(timer, tim, delta_ns, mode, base))\n\t\thrtimer_reprogram(timer, true);\n\n\tunlock_hrtimer_base(timer, &flags);\n}"
  },
  {
    "function_name": "__hrtimer_start_range_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1070-1090",
    "snippet": "static int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t    u64 delta_ns, const enum hrtimer_mode mode,\n\t\t\t\t    struct hrtimer_clock_base *base)\n{\n\tstruct hrtimer_clock_base *new_base;\n\n\t/* Remove an active timer from the queue: */\n\tremove_hrtimer(timer, base, true);\n\n\tif (mode & HRTIMER_MODE_REL)\n\t\ttim = ktime_add_safe(tim, base->get_time());\n\n\ttim = hrtimer_update_lowres(timer, tim, mode);\n\n\thrtimer_set_expires_range_ns(timer, tim, delta_ns);\n\n\t/* Switch the timer base, if necessary: */\n\tnew_base = switch_hrtimer_base(timer, base, mode & HRTIMER_MODE_PINNED);\n\n\treturn enqueue_hrtimer(timer, new_base, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enqueue_hrtimer",
          "args": [
            "timer",
            "new_base",
            "mode"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_hrtimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "950-961",
          "snippet": "static int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\ttimer->state = HRTIMER_STATE_ENQUEUED;\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\ttimer->state = HRTIMER_STATE_ENQUEUED;\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "switch_hrtimer_base",
          "args": [
            "timer",
            "base",
            "mode & HRTIMER_MODE_PINNED"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "switch_hrtimer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "225-273",
          "snippet": "static inline struct hrtimer_clock_base *\nswitch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t\t    int pinned)\n{\n\tstruct hrtimer_cpu_base *new_cpu_base, *this_cpu_base;\n\tstruct hrtimer_clock_base *new_base;\n\tint basenum = base->index;\n\n\tthis_cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tnew_cpu_base = get_target_base(this_cpu_base, pinned);\nagain:\n\tnew_base = &new_cpu_base->clock_base[basenum];\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to move timer to new_base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * so we keep it on the same CPU. No hassle vs. reprogramming\n\t\t * the event source in the high resolution case. The softirq\n\t\t * code will take care of this when the timer function has\n\t\t * completed. There is no conflict as we hold the lock until\n\t\t * the timer is enqueued.\n\t\t */\n\t\tif (unlikely(hrtimer_callback_running(timer)))\n\t\t\treturn base;\n\n\t\t/* See the comment in lock_hrtimer_base() */\n\t\ttimer->base = &migration_base;\n\t\traw_spin_unlock(&base->cpu_base->lock);\n\t\traw_spin_lock(&new_base->cpu_base->lock);\n\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traw_spin_lock(&base->cpu_base->lock);\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\ttimer->base = base;\n\t\t\tgoto again;\n\t\t}\n\t\ttimer->base = new_base;\n\t} else {\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn new_base;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define migration_base\tmigration_cpu_base.clock_base[0]"
          ],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define migration_base\tmigration_cpu_base.clock_base[0]\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline struct hrtimer_clock_base *\nswitch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t\t    int pinned)\n{\n\tstruct hrtimer_cpu_base *new_cpu_base, *this_cpu_base;\n\tstruct hrtimer_clock_base *new_base;\n\tint basenum = base->index;\n\n\tthis_cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tnew_cpu_base = get_target_base(this_cpu_base, pinned);\nagain:\n\tnew_base = &new_cpu_base->clock_base[basenum];\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to move timer to new_base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * so we keep it on the same CPU. No hassle vs. reprogramming\n\t\t * the event source in the high resolution case. The softirq\n\t\t * code will take care of this when the timer function has\n\t\t * completed. There is no conflict as we hold the lock until\n\t\t * the timer is enqueued.\n\t\t */\n\t\tif (unlikely(hrtimer_callback_running(timer)))\n\t\t\treturn base;\n\n\t\t/* See the comment in lock_hrtimer_base() */\n\t\ttimer->base = &migration_base;\n\t\traw_spin_unlock(&base->cpu_base->lock);\n\t\traw_spin_lock(&new_base->cpu_base->lock);\n\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traw_spin_lock(&base->cpu_base->lock);\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\ttimer->base = base;\n\t\t\tgoto again;\n\t\t}\n\t\ttimer->base = new_base;\n\t} else {\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn new_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires_range_ns",
          "args": [
            "timer",
            "tim",
            "delta_ns"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_update_lowres",
          "args": [
            "timer",
            "tim",
            "mode"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_lowres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1029-1043",
          "snippet": "static inline ktime_t hrtimer_update_lowres(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t\t    const enum hrtimer_mode mode)\n{\n#ifdef CONFIG_TIME_LOW_RES\n\t/*\n\t * CONFIG_TIME_LOW_RES indicates that the system has no way to return\n\t * granular time values. For relative timers we add hrtimer_resolution\n\t * (i.e. one jiffie) to prevent short timeouts.\n\t */\n\ttimer->is_rel = mode & HRTIMER_MODE_REL;\n\tif (timer->is_rel)\n\t\ttim = ktime_add_safe(tim, hrtimer_resolution);\n#endif\n\treturn tim;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_lowres(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t\t    const enum hrtimer_mode mode)\n{\n#ifdef CONFIG_TIME_LOW_RES\n\t/*\n\t * CONFIG_TIME_LOW_RES indicates that the system has no way to return\n\t * granular time values. For relative timers we add hrtimer_resolution\n\t * (i.e. one jiffie) to prevent short timeouts.\n\t */\n\ttimer->is_rel = mode & HRTIMER_MODE_REL;\n\tif (timer->is_rel)\n\t\ttim = ktime_add_safe(tim, hrtimer_resolution);\n#endif\n\treturn tim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "tim",
            "base->get_time()"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->get_time",
          "args": [],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_hrtimer",
          "args": [
            "timer",
            "base",
            "true"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hrtimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1002-1027",
          "snippet": "static inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool restart)\n{\n\tif (hrtimer_is_queued(timer)) {\n\t\tu8 state = timer->state;\n\t\tint reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool restart)\n{\n\tif (hrtimer_is_queued(timer)) {\n\t\tu8 state = timer->state;\n\t\tint reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t    u64 delta_ns, const enum hrtimer_mode mode,\n\t\t\t\t    struct hrtimer_clock_base *base)\n{\n\tstruct hrtimer_clock_base *new_base;\n\n\t/* Remove an active timer from the queue: */\n\tremove_hrtimer(timer, base, true);\n\n\tif (mode & HRTIMER_MODE_REL)\n\t\ttim = ktime_add_safe(tim, base->get_time());\n\n\ttim = hrtimer_update_lowres(timer, tim, mode);\n\n\thrtimer_set_expires_range_ns(timer, tim, delta_ns);\n\n\t/* Switch the timer base, if necessary: */\n\tnew_base = switch_hrtimer_base(timer, base, mode & HRTIMER_MODE_PINNED);\n\n\treturn enqueue_hrtimer(timer, new_base, mode);\n}"
  },
  {
    "function_name": "hrtimer_update_softirq_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1045-1068",
    "snippet": "static void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_reprogram",
          "args": [
            "cpu_base->softirq_next_timer",
            "reprogram"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_reprogram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "764-844",
          "snippet": "static void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will\n\t * reevaluate the clock bases and reprogram the clock event\n\t * device. The callbacks are always executed in hard interrupt\n\t * context so we don't need an extra check for a running\n\t * callback.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/* Update the pointer to the next expiring timer */\n\tcpu_base->next_timer = timer;\n\tcpu_base->expires_next = expires;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * programmed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * do not schedule a timer which is earlier than the expiry\n\t * which we enforced in the hang detection. We want the system\n\t * to make progress.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\t/*\n\t * Program the timer hardware. We enforce the expiry for\n\t * events which are already in the past.\n\t */\n\ttick_program_event(expires, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will\n\t * reevaluate the clock bases and reprogram the clock event\n\t * device. The callbacks are always executed in hard interrupt\n\t * context so we don't need an extra check for a running\n\t * callback.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/* Update the pointer to the next expiring timer */\n\tcpu_base->next_timer = timer;\n\tcpu_base->expires_next = expires;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * programmed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * do not schedule a timer which is earlier than the expiry\n\t * which we enforced in the hang detection. We want the system\n\t * to make progress.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\t/*\n\t * Program the timer hardware. We enforce the expiry for\n\t * events which are already in the past.\n\t */\n\ttick_program_event(expires, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_get_next_event",
          "args": [
            "cpu_base",
            "HRTIMER_ACTIVE_SOFT"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_get_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "555-579",
          "snippet": "static ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nstatic void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}"
  },
  {
    "function_name": "hrtimer_update_lowres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1029-1043",
    "snippet": "static inline ktime_t hrtimer_update_lowres(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t\t    const enum hrtimer_mode mode)\n{\n#ifdef CONFIG_TIME_LOW_RES\n\t/*\n\t * CONFIG_TIME_LOW_RES indicates that the system has no way to return\n\t * granular time values. For relative timers we add hrtimer_resolution\n\t * (i.e. one jiffie) to prevent short timeouts.\n\t */\n\ttimer->is_rel = mode & HRTIMER_MODE_REL;\n\tif (timer->is_rel)\n\t\ttim = ktime_add_safe(tim, hrtimer_resolution);\n#endif\n\treturn tim;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "tim",
            "hrtimer_resolution"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_lowres(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t\t    const enum hrtimer_mode mode)\n{\n#ifdef CONFIG_TIME_LOW_RES\n\t/*\n\t * CONFIG_TIME_LOW_RES indicates that the system has no way to return\n\t * granular time values. For relative timers we add hrtimer_resolution\n\t * (i.e. one jiffie) to prevent short timeouts.\n\t */\n\ttimer->is_rel = mode & HRTIMER_MODE_REL;\n\tif (timer->is_rel)\n\t\ttim = ktime_add_safe(tim, hrtimer_resolution);\n#endif\n\treturn tim;\n}"
  },
  {
    "function_name": "remove_hrtimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1002-1027",
    "snippet": "static inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool restart)\n{\n\tif (hrtimer_is_queued(timer)) {\n\t\tu8 state = timer->state;\n\t\tint reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__remove_hrtimer",
          "args": [
            "timer",
            "base",
            "state",
            "reprogram"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_hrtimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "973-997",
          "snippet": "static void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\ttimer->state = newstate;\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superflous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\ttimer->state = newstate;\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superflous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_deactivate",
          "args": [
            "timer"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "debug_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "469-473",
          "snippet": "static inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_is_queued",
          "args": [
            "timer"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool restart)\n{\n\tif (hrtimer_is_queued(timer)) {\n\t\tu8 state = timer->state;\n\t\tint reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__remove_hrtimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "973-997",
    "snippet": "static void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\ttimer->state = newstate;\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superflous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_force_reprogram",
          "args": [
            "cpu_base",
            "1"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_force_reprogram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "616-665",
          "snippet": "static void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\t/*\n\t * Find the current next expiration time.\n\t */\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\tif (cpu_base->next_timer && cpu_base->next_timer->is_soft) {\n\t\t/*\n\t\t * When the softirq is activated, hrtimer has to be\n\t\t * programmed with the first hard hrtimer because soft\n\t\t * timer interrupt could occur too late.\n\t\t */\n\t\tif (cpu_base->softirq_activated)\n\t\t\texpires_next = __hrtimer_get_next_event(cpu_base,\n\t\t\t\t\t\t\t\tHRTIMER_ACTIVE_HARD);\n\t\telse\n\t\t\tcpu_base->softirq_expires_next = expires_next;\n\t}\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectivly block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(cpu_base->expires_next, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\t/*\n\t * Find the current next expiration time.\n\t */\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\tif (cpu_base->next_timer && cpu_base->next_timer->is_soft) {\n\t\t/*\n\t\t * When the softirq is activated, hrtimer has to be\n\t\t * programmed with the first hard hrtimer because soft\n\t\t * timer interrupt could occur too late.\n\t\t */\n\t\tif (cpu_base->softirq_activated)\n\t\t\texpires_next = __hrtimer_get_next_event(cpu_base,\n\t\t\t\t\t\t\t\tHRTIMER_ACTIVE_HARD);\n\t\telse\n\t\t\tcpu_base->softirq_expires_next = expires_next;\n\t}\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectivly block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(cpu_base->expires_next, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timerqueue_del",
          "args": [
            "&base->active",
            "&timer->node"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\ttimer->state = newstate;\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superflous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}"
  },
  {
    "function_name": "enqueue_hrtimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "950-961",
    "snippet": "static int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\ttimer->state = HRTIMER_STATE_ENQUEUED;\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_add",
          "args": [
            "&base->active",
            "&timer->node"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_activate",
          "args": [
            "timer",
            "mode"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "debug_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "462-467",
          "snippet": "static inline void debug_activate(struct hrtimer *timer,\n\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_activate(timer, mode);\n\ttrace_hrtimer_start(timer, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_activate(struct hrtimer *timer,\n\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_activate(timer, mode);\n\ttrace_hrtimer_start(timer, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\ttimer->state = HRTIMER_STATE_ENQUEUED;\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}"
  },
  {
    "function_name": "hrtimer_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "907-939",
    "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_add_expires",
          "args": [
            "timer",
            "interval"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires_tv64",
          "args": [
            "timer"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_add_expires_ns",
          "args": [
            "timer",
            "incr * orun"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_divns",
          "args": [
            "delta",
            "incr"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_divns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "299-316",
          "snippet": "s64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (unsigned long) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\ns64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (unsigned long) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "interval"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta >= interval"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timer->state & HRTIMER_STATE_ENQUEUED"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "hrtimer_get_expires(timer)"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
  },
  {
    "function_name": "unlock_hrtimer_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "884-888",
    "snippet": "static inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timer->base->cpu_base->lock",
            "*flags"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}"
  },
  {
    "function_name": "hrtimers_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "872-879",
    "snippet": "void hrtimers_resume(void)\n{\n\tlockdep_assert_irqs_disabled();\n\t/* Retrigger on the local CPU */\n\tretrigger_next_event(NULL);\n\t/* And schedule a retrigger for all others */\n\tclock_was_set_delayed();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock_was_set_delayed",
          "args": [],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "744-747",
          "snippet": "void clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrigger_next_event",
          "args": [
            "NULL"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "retrigger_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "753-753",
          "snippet": "static inline void retrigger_next_event(void *arg) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void retrigger_next_event(void *arg) { }"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimers_resume(void)\n{\n\tlockdep_assert_irqs_disabled();\n\t/* Retrigger on the local CPU */\n\tretrigger_next_event(NULL);\n\t/* And schedule a retrigger for all others */\n\tclock_was_set_delayed();\n}"
  },
  {
    "function_name": "clock_was_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "857-864",
    "snippet": "void clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerfd_clock_was_set",
          "args": [],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "retrigger_next_event",
            "NULL",
            "1"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "on_each_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "37-45",
          "snippet": "int on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}"
  },
  {
    "function_name": "hrtimer_reprogram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "764-844",
    "snippet": "static void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will\n\t * reevaluate the clock bases and reprogram the clock event\n\t * device. The callbacks are always executed in hard interrupt\n\t * context so we don't need an extra check for a running\n\t * callback.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/* Update the pointer to the next expiring timer */\n\tcpu_base->next_timer = timer;\n\tcpu_base->expires_next = expires;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * programmed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * do not schedule a timer which is earlier than the expiry\n\t * which we enforced in the hang detection. We want the system\n\t * to make progress.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\t/*\n\t * Program the timer hardware. We enforce the expiry for\n\t * events which are already in the past.\n\t */\n\ttick_program_event(expires, 1);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "expires",
            "1"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "27-49",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "cpu_base"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "600-604",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "expires",
            "timer_cpu_base->expires_next"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "expires",
            "timer_cpu_base->softirq_expires_next"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "hrtimer_get_expires_tv64(timer) < 0"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires_tv64",
          "args": [
            "timer"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "hrtimer_get_expires(timer)",
            "base->offset"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will\n\t * reevaluate the clock bases and reprogram the clock event\n\t * device. The callbacks are always executed in hard interrupt\n\t * context so we don't need an extra check for a running\n\t * callback.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/* Update the pointer to the next expiring timer */\n\tcpu_base->next_timer = timer;\n\tcpu_base->expires_next = expires;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * programmed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * do not schedule a timer which is earlier than the expiry\n\t * which we enforced in the hang detection. We want the system\n\t * to make progress.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\t/*\n\t * Program the timer hardware. We enforce the expiry for\n\t * events which are already in the past.\n\t */\n\ttick_program_event(expires, 1);\n}"
  },
  {
    "function_name": "retrigger_next_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "753-753",
    "snippet": "static inline void retrigger_next_event(void *arg) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void retrigger_next_event(void *arg) { }"
  },
  {
    "function_name": "hrtimer_switch_to_hres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "752-752",
    "snippet": "static inline void hrtimer_switch_to_hres(void) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void hrtimer_switch_to_hres(void) { }"
  },
  {
    "function_name": "hrtimer_is_hres_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "751-751",
    "snippet": "static inline int hrtimer_is_hres_enabled(void) { return 0; }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int hrtimer_is_hres_enabled(void) { return 0; }"
  },
  {
    "function_name": "clock_was_set_delayed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "744-747",
    "snippet": "void clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&hrtimer_work"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}"
  },
  {
    "function_name": "clock_was_set_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "733-736",
    "snippet": "static void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock_was_set",
          "args": [],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "857-864",
          "snippet": "void clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set();\n}"
  },
  {
    "function_name": "hrtimer_switch_to_hres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "716-731",
    "snippet": "static void hrtimer_switch_to_hres(void)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\tif (tick_init_highres()) {\n\t\tpr_warn(\"Could not switch to high resolution mode on CPU %u\\n\",\n\t\t\tbase->cpu);\n\t\treturn;\n\t}\n\tbase->hres_active = 1;\n\thrtimer_resolution = HIGH_RES_NSEC;\n\n\ttick_setup_sched_timer();\n\t/* \"Retrigger\" the interrupt to get things going */\n\tretrigger_next_event(NULL);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "retrigger_next_event",
          "args": [
            "NULL"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "retrigger_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "753-753",
          "snippet": "static inline void retrigger_next_event(void *arg) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void retrigger_next_event(void *arg) { }"
        }
      },
      {
        "call_info": {
          "callee": "tick_setup_sched_timer",
          "args": [],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_sched_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1300-1325",
          "snippet": "void tick_setup_sched_timer(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now = ktime_get();\n\n\t/*\n\t * Emulate tick processing via per-CPU hrtimers:\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tts->sched_timer.function = tick_sched_timer;\n\n\t/* Get the next period (per-CPU) */\n\thrtimer_set_expires(&ts->sched_timer, tick_init_jiffy_update());\n\n\t/* Offset the tick to avert jiffies_lock contention. */\n\tif (sched_skew_tick) {\n\t\tu64 offset = ktime_to_ns(tick_period) >> 1;\n\t\tdo_div(offset, num_possible_cpus());\n\t\toffset *= smp_processor_id();\n\t\thrtimer_add_expires_ns(&ts->sched_timer, offset);\n\t}\n\n\thrtimer_forward(&ts->sched_timer, now, tick_period);\n\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED);\n\ttick_nohz_activate(ts, NOHZ_MODE_HIGHRES);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_setup_sched_timer(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now = ktime_get();\n\n\t/*\n\t * Emulate tick processing via per-CPU hrtimers:\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tts->sched_timer.function = tick_sched_timer;\n\n\t/* Get the next period (per-CPU) */\n\thrtimer_set_expires(&ts->sched_timer, tick_init_jiffy_update());\n\n\t/* Offset the tick to avert jiffies_lock contention. */\n\tif (sched_skew_tick) {\n\t\tu64 offset = ktime_to_ns(tick_period) >> 1;\n\t\tdo_div(offset, num_possible_cpus());\n\t\toffset *= smp_processor_id();\n\t\thrtimer_add_expires_ns(&ts->sched_timer, offset);\n\t}\n\n\thrtimer_forward(&ts->sched_timer, now, tick_period);\n\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED);\n\ttick_nohz_activate(ts, NOHZ_MODE_HIGHRES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not switch to high resolution mode on CPU %u\\n\"",
            "base->cpu"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_init_highres",
          "args": [],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "tick_init_highres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "128-131",
          "snippet": "int tick_init_highres(void)\n{\n\treturn tick_switch_to_oneshot(hrtimer_interrupt);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_init_highres(void)\n{\n\treturn tick_switch_to_oneshot(hrtimer_interrupt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void hrtimer_switch_to_hres(void)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\tif (tick_init_highres()) {\n\t\tpr_warn(\"Could not switch to high resolution mode on CPU %u\\n\",\n\t\t\tbase->cpu);\n\t\treturn;\n\t}\n\tbase->hres_active = 1;\n\thrtimer_resolution = HIGH_RES_NSEC;\n\n\ttick_setup_sched_timer();\n\t/* \"Retrigger\" the interrupt to get things going */\n\tretrigger_next_event(NULL);\n}"
  },
  {
    "function_name": "retrigger_next_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "700-711",
    "snippet": "static void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\tif (!__hrtimer_hres_active(base))\n\t\treturn;\n\n\traw_spin_lock(&base->lock);\n\thrtimer_update_base(base);\n\thrtimer_force_reprogram(base, 0);\n\traw_spin_unlock(&base->lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&base->lock"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_force_reprogram",
          "args": [
            "base",
            "0"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_force_reprogram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "616-665",
          "snippet": "static void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\t/*\n\t * Find the current next expiration time.\n\t */\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\tif (cpu_base->next_timer && cpu_base->next_timer->is_soft) {\n\t\t/*\n\t\t * When the softirq is activated, hrtimer has to be\n\t\t * programmed with the first hard hrtimer because soft\n\t\t * timer interrupt could occur too late.\n\t\t */\n\t\tif (cpu_base->softirq_activated)\n\t\t\texpires_next = __hrtimer_get_next_event(cpu_base,\n\t\t\t\t\t\t\t\tHRTIMER_ACTIVE_HARD);\n\t\telse\n\t\t\tcpu_base->softirq_expires_next = expires_next;\n\t}\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectivly block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(cpu_base->expires_next, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\t/*\n\t * Find the current next expiration time.\n\t */\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\tif (cpu_base->next_timer && cpu_base->next_timer->is_soft) {\n\t\t/*\n\t\t * When the softirq is activated, hrtimer has to be\n\t\t * programmed with the first hard hrtimer because soft\n\t\t * timer interrupt could occur too late.\n\t\t */\n\t\tif (cpu_base->softirq_activated)\n\t\t\texpires_next = __hrtimer_get_next_event(cpu_base,\n\t\t\t\t\t\t\t\tHRTIMER_ACTIVE_HARD);\n\t\telse\n\t\t\tcpu_base->softirq_expires_next = expires_next;\n\t}\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectivly block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(cpu_base->expires_next, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_base",
          "args": [
            "base"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "581-595",
          "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&base->lock"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "base"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "600-604",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\tif (!__hrtimer_hres_active(base))\n\t\treturn;\n\n\traw_spin_lock(&base->lock);\n\thrtimer_update_base(base);\n\thrtimer_force_reprogram(base, 0);\n\traw_spin_unlock(&base->lock);\n}"
  },
  {
    "function_name": "hrtimer_is_hres_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "690-693",
    "snippet": "static inline int hrtimer_is_hres_enabled(void)\n{\n\treturn hrtimer_hres_enabled;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int hrtimer_is_hres_enabled(void)\n{\n\treturn hrtimer_hres_enabled;\n}"
  },
  {
    "function_name": "setup_hrtimer_hres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "680-683",
    "snippet": "static int __init setup_hrtimer_hres(char *str)\n{\n\treturn (kstrtobool(str, &hrtimer_hres_enabled) == 0);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "str",
            "&hrtimer_hres_enabled"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int __init setup_hrtimer_hres(char *str)\n{\n\treturn (kstrtobool(str, &hrtimer_hres_enabled) == 0);\n}"
  },
  {
    "function_name": "hrtimer_force_reprogram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "616-665",
    "snippet": "static void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\t/*\n\t * Find the current next expiration time.\n\t */\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\tif (cpu_base->next_timer && cpu_base->next_timer->is_soft) {\n\t\t/*\n\t\t * When the softirq is activated, hrtimer has to be\n\t\t * programmed with the first hard hrtimer because soft\n\t\t * timer interrupt could occur too late.\n\t\t */\n\t\tif (cpu_base->softirq_activated)\n\t\t\texpires_next = __hrtimer_get_next_event(cpu_base,\n\t\t\t\t\t\t\t\tHRTIMER_ACTIVE_HARD);\n\t\telse\n\t\t\tcpu_base->softirq_expires_next = expires_next;\n\t}\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectivly block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(cpu_base->expires_next, 1);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)",
      "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "cpu_base->expires_next",
            "1"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "27-49",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "cpu_base"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "600-604",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_get_next_event",
          "args": [
            "cpu_base",
            "HRTIMER_ACTIVE_HARD"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_get_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "555-579",
          "snippet": "static ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\t/*\n\t * Find the current next expiration time.\n\t */\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\tif (cpu_base->next_timer && cpu_base->next_timer->is_soft) {\n\t\t/*\n\t\t * When the softirq is activated, hrtimer has to be\n\t\t * programmed with the first hard hrtimer because soft\n\t\t * timer interrupt could occur too late.\n\t\t */\n\t\tif (cpu_base->softirq_activated)\n\t\t\texpires_next = __hrtimer_get_next_event(cpu_base,\n\t\t\t\t\t\t\t\tHRTIMER_ACTIVE_HARD);\n\t\telse\n\t\t\tcpu_base->softirq_expires_next = expires_next;\n\t}\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectivly block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(cpu_base->expires_next, 1);\n}"
  },
  {
    "function_name": "hrtimer_hres_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "606-609",
    "snippet": "static inline int hrtimer_hres_active(void)\n{\n\treturn __hrtimer_hres_active(this_cpu_ptr(&hrtimer_bases));\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "this_cpu_ptr(&hrtimer_bases)"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "600-604",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline int hrtimer_hres_active(void)\n{\n\treturn __hrtimer_hres_active(this_cpu_ptr(&hrtimer_bases));\n}"
  },
  {
    "function_name": "__hrtimer_hres_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "600-604",
    "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HIGH_RES_TIMERS"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
  },
  {
    "function_name": "hrtimer_update_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "581-595",
    "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_update_offsets_now",
          "args": [
            "&base->clock_was_set_seq",
            "offs_real",
            "offs_boot",
            "offs_tai"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_update_offsets_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2214-2243",
          "snippet": "ktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,\n\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\t\tbase = ktime_add_ns(base, nsecs);\n\n\t\tif (*cwsseq != tk->clock_was_set_seq) {\n\t\t\t*cwsseq = tk->clock_was_set_seq;\n\t\t\t*offs_real = tk->offs_real;\n\t\t\t*offs_boot = tk->offs_boot;\n\t\t\t*offs_tai = tk->offs_tai;\n\t\t}\n\n\t\t/* Handle leapsecond insertion adjustments */\n\t\tif (unlikely(base >= tk->next_leap_ktime))\n\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn base;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,\n\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\t\tbase = ktime_add_ns(base, nsecs);\n\n\t\tif (*cwsseq != tk->clock_was_set_seq) {\n\t\t\t*cwsseq = tk->clock_was_set_seq;\n\t\t\t*offs_real = tk->offs_real;\n\t\t\t*offs_boot = tk->offs_boot;\n\t\t\t*offs_tai = tk->offs_tai;\n\t\t}\n\n\t\t/* Handle leapsecond insertion adjustments */\n\t\tif (unlikely(base >= tk->next_leap_ktime))\n\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
  },
  {
    "function_name": "__hrtimer_get_next_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "555-579",
    "snippet": "static ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
      "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_next_event_base",
          "args": [
            "cpu_base",
            "NULL",
            "active",
            "expires_next"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_next_event_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "492-536",
          "snippet": "static ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}"
  },
  {
    "function_name": "__hrtimer_next_event_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "492-536",
    "snippet": "static ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "hrtimer_get_expires(timer)",
            "base->offset"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "next",
            "structhrtimer",
            "node"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_iterate_next",
          "args": [
            "next"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "next",
            "structhrtimer",
            "node"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&base->active"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_active_base",
          "args": [
            "base",
            "cpu_base",
            "active"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}"
  },
  {
    "function_name": "__next_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "475-487",
    "snippet": "static struct hrtimer_clock_base *\n__next_base(struct hrtimer_cpu_base *cpu_base, unsigned int *active)\n{\n\tunsigned int idx;\n\n\tif (!*active)\n\t\treturn NULL;\n\n\tidx = __ffs(*active);\n\t*active &= ~(1U << idx);\n\n\treturn &cpu_base->clock_base[idx];\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "*active"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic struct hrtimer_clock_base *\n__next_base(struct hrtimer_cpu_base *cpu_base, unsigned int *active)\n{\n\tunsigned int idx;\n\n\tif (!*active)\n\t\treturn NULL;\n\n\tidx = __ffs(*active);\n\t*active &= ~(1U << idx);\n\n\treturn &cpu_base->clock_base[idx];\n}"
  },
  {
    "function_name": "debug_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "469-473",
    "snippet": "static inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_hrtimer_cancel",
          "args": [
            "timer"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_hrtimer_deactivate",
          "args": [
            "timer"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "debug_hrtimer_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "451-451",
          "snippet": "static inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}"
  },
  {
    "function_name": "debug_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "462-467",
    "snippet": "static inline void debug_activate(struct hrtimer *timer,\n\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_activate(timer, mode);\n\ttrace_hrtimer_start(timer, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_hrtimer_start",
          "args": [
            "timer",
            "mode"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_hrtimer_activate",
          "args": [
            "timer",
            "mode"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "debug_hrtimer_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "449-450",
          "snippet": "static inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_activate(struct hrtimer *timer,\n\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_activate(timer, mode);\n\ttrace_hrtimer_start(timer, mode);\n}"
  },
  {
    "function_name": "debug_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "454-460",
    "snippet": "static inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_hrtimer_init",
          "args": [
            "timer",
            "clockid",
            "mode"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_hrtimer_init",
          "args": [
            "timer"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "debug_hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "448-448",
          "snippet": "static inline void debug_hrtimer_init(struct hrtimer *timer) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_init(struct hrtimer *timer) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}"
  },
  {
    "function_name": "debug_hrtimer_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "451-451",
    "snippet": "static inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }"
  },
  {
    "function_name": "debug_hrtimer_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "449-450",
    "snippet": "static inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode) { }"
  },
  {
    "function_name": "debug_hrtimer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "448-448",
    "snippet": "static inline void debug_hrtimer_init(struct hrtimer *timer) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_init(struct hrtimer *timer) { }"
  },
  {
    "function_name": "destroy_hrtimer_on_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "440-443",
    "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
  },
  {
    "function_name": "hrtimer_init_on_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "432-437",
    "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_init",
          "args": [
            "timer",
            "clock_id",
            "mode"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1268-1291",
          "snippet": "static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tbool softtimer = !!(mode & HRTIMER_MODE_SOFT);\n\tint base = softtimer ? HRTIMER_MAX_CLOCK_BASES / 2 : 0;\n\tstruct hrtimer_cpu_base *cpu_base;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * POSIX magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they needs to become CLOCK_MONOTONIC to\n\t * ensure POSIX compliance.\n\t */\n\tif (clock_id == CLOCK_REALTIME && mode & HRTIMER_MODE_REL)\n\t\tclock_id = CLOCK_MONOTONIC;\n\n\tbase += hrtimer_clockid_to_base(clock_id);\n\ttimer->is_soft = softtimer;\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tbool softtimer = !!(mode & HRTIMER_MODE_SOFT);\n\tint base = softtimer ? HRTIMER_MAX_CLOCK_BASES / 2 : 0;\n\tstruct hrtimer_cpu_base *cpu_base;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * POSIX magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they needs to become CLOCK_MONOTONIC to\n\t * ensure POSIX compliance.\n\t */\n\tif (clock_id == CLOCK_REALTIME && mode & HRTIMER_MODE_REL)\n\t\tclock_id = CLOCK_MONOTONIC;\n\n\tbase += hrtimer_clockid_to_base(clock_id);\n\ttimer->is_soft = softtimer;\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_object_init_on_stack",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
  },
  {
    "function_name": "debug_hrtimer_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "424-427",
    "snippet": "static inline void debug_hrtimer_free(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_free(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
  },
  {
    "function_name": "debug_hrtimer_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "419-422",
    "snippet": "static inline void debug_hrtimer_deactivate(struct hrtimer *timer)\n{\n\tdebug_object_deactivate(timer, &hrtimer_debug_descr);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_deactivate",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_deactivate(struct hrtimer *timer)\n{\n\tdebug_object_deactivate(timer, &hrtimer_debug_descr);\n}"
  },
  {
    "function_name": "debug_hrtimer_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "413-417",
    "snippet": "static inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_object_activate(timer, &hrtimer_debug_descr);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_activate",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_object_activate(timer, &hrtimer_debug_descr);\n}"
  },
  {
    "function_name": "debug_hrtimer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "408-411",
    "snippet": "static inline void debug_hrtimer_init(struct hrtimer *timer)\n{\n\tdebug_object_init(timer, &hrtimer_debug_descr);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_init",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_init(struct hrtimer *timer)\n{\n\tdebug_object_init(timer, &hrtimer_debug_descr);\n}"
  },
  {
    "function_name": "hrtimer_fixup_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "386-398",
    "snippet": "static bool hrtimer_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_free(timer, &hrtimer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "timer"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic bool hrtimer_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_free(timer, &hrtimer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "hrtimer_fixup_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "371-380",
    "snippet": "static bool hrtimer_fixup_activate(void *addr, enum debug_obj_state state)\n{\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tWARN_ON(1);\n\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic bool hrtimer_fixup_activate(void *addr, enum debug_obj_state state)\n{\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tWARN_ON(1);\n\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "hrtimer_fixup_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "352-364",
    "snippet": "static bool hrtimer_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_init(timer, &hrtimer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_init",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "timer"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic bool hrtimer_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_init(timer, &hrtimer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "hrtimer_debug_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "343-346",
    "snippet": "static void *hrtimer_debug_hint(void *addr)\n{\n\treturn ((struct hrtimer *) addr)->function;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void *hrtimer_debug_hint(void *addr)\n{\n\treturn ((struct hrtimer *) addr)->function;\n}"
  },
  {
    "function_name": "ktime_add_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "323-335",
    "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "KTIME_SEC_MAX",
            "0"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_unsafe",
          "args": [
            "lhs",
            "rhs"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
  },
  {
    "function_name": "__ktime_divns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "299-316",
    "snippet": "s64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (unsigned long) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "(unsigned long) div"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "kt"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\ns64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (unsigned long) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}"
  },
  {
    "function_name": "lock_hrtimer_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "277-285",
    "snippet": "static inline struct hrtimer_clock_base *\nlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base = timer->base;\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\n\treturn base;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&base->cpu_base->lock",
            "*flags"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline struct hrtimer_clock_base *\nlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base = timer->base;\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\n\treturn base;\n}"
  },
  {
    "function_name": "switch_hrtimer_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "225-273",
    "snippet": "static inline struct hrtimer_clock_base *\nswitch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t\t    int pinned)\n{\n\tstruct hrtimer_cpu_base *new_cpu_base, *this_cpu_base;\n\tstruct hrtimer_clock_base *new_base;\n\tint basenum = base->index;\n\n\tthis_cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tnew_cpu_base = get_target_base(this_cpu_base, pinned);\nagain:\n\tnew_base = &new_cpu_base->clock_base[basenum];\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to move timer to new_base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * so we keep it on the same CPU. No hassle vs. reprogramming\n\t\t * the event source in the high resolution case. The softirq\n\t\t * code will take care of this when the timer function has\n\t\t * completed. There is no conflict as we hold the lock until\n\t\t * the timer is enqueued.\n\t\t */\n\t\tif (unlikely(hrtimer_callback_running(timer)))\n\t\t\treturn base;\n\n\t\t/* See the comment in lock_hrtimer_base() */\n\t\ttimer->base = &migration_base;\n\t\traw_spin_unlock(&base->cpu_base->lock);\n\t\traw_spin_lock(&new_base->cpu_base->lock);\n\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traw_spin_lock(&base->cpu_base->lock);\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\ttimer->base = base;\n\t\t\tgoto again;\n\t\t}\n\t\ttimer->base = new_base;\n\t} else {\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn new_base;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define migration_base\tmigration_cpu_base.clock_base[0]"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_check_target",
          "args": [
            "timer",
            "new_base"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_check_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "193-200",
          "snippet": "static int\nhrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)\n{\n\tktime_t expires;\n\n\texpires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);\n\treturn expires < new_base->cpu_base->expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int\nhrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)\n{\n\tktime_t expires;\n\n\texpires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);\n\treturn expires < new_base->cpu_base->expires_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&base->cpu_base->lock"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&new_base->cpu_base->lock"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "hrtimer_callback_running(timer)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_callback_running",
          "args": [
            "timer"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_target_base",
          "args": [
            "this_cpu_base",
            "pinned"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "get_target_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "202-211",
          "snippet": "static inline\nstruct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base,\n\t\t\t\t\t int pinned)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) && !pinned)\n\t\treturn &per_cpu(hrtimer_bases, get_nohz_timer_target());\n#endif\n\treturn base;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline\nstruct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base,\n\t\t\t\t\t int pinned)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) && !pinned)\n\t\treturn &per_cpu(hrtimer_bases, get_nohz_timer_target());\n#endif\n\treturn base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define migration_base\tmigration_cpu_base.clock_base[0]\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline struct hrtimer_clock_base *\nswitch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t\t    int pinned)\n{\n\tstruct hrtimer_cpu_base *new_cpu_base, *this_cpu_base;\n\tstruct hrtimer_clock_base *new_base;\n\tint basenum = base->index;\n\n\tthis_cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tnew_cpu_base = get_target_base(this_cpu_base, pinned);\nagain:\n\tnew_base = &new_cpu_base->clock_base[basenum];\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to move timer to new_base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * so we keep it on the same CPU. No hassle vs. reprogramming\n\t\t * the event source in the high resolution case. The softirq\n\t\t * code will take care of this when the timer function has\n\t\t * completed. There is no conflict as we hold the lock until\n\t\t * the timer is enqueued.\n\t\t */\n\t\tif (unlikely(hrtimer_callback_running(timer)))\n\t\t\treturn base;\n\n\t\t/* See the comment in lock_hrtimer_base() */\n\t\ttimer->base = &migration_base;\n\t\traw_spin_unlock(&base->cpu_base->lock);\n\t\traw_spin_lock(&new_base->cpu_base->lock);\n\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traw_spin_lock(&base->cpu_base->lock);\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\ttimer->base = base;\n\t\t\tgoto again;\n\t\t}\n\t\ttimer->base = new_base;\n\t} else {\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn new_base;\n}"
  },
  {
    "function_name": "get_target_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "202-211",
    "snippet": "static inline\nstruct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base,\n\t\t\t\t\t int pinned)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) && !pinned)\n\t\treturn &per_cpu(hrtimer_bases, get_nohz_timer_target());\n#endif\n\treturn base;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hrtimer_bases",
            "get_nohz_timer_target()"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nohz_timer_target",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "get_nohz_timer_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "497-523",
          "snippet": "int get_nohz_timer_target(void)\n{\n\tint i, cpu = smp_processor_id();\n\tstruct sched_domain *sd;\n\n\tif (!idle_cpu(cpu) && housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\treturn cpu;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tfor_each_cpu(i, sched_domain_span(sd)) {\n\t\t\tif (cpu == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (!idle_cpu(i) && housekeeping_cpu(i, HK_FLAG_TIMER)) {\n\t\t\t\tcpu = i;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\tcpu = housekeeping_any_cpu(HK_FLAG_TIMER);\nunlock:\n\trcu_read_unlock();\n\treturn cpu;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint get_nohz_timer_target(void)\n{\n\tint i, cpu = smp_processor_id();\n\tstruct sched_domain *sd;\n\n\tif (!idle_cpu(cpu) && housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\treturn cpu;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tfor_each_cpu(i, sched_domain_span(sd)) {\n\t\t\tif (cpu == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (!idle_cpu(i) && housekeeping_cpu(i, HK_FLAG_TIMER)) {\n\t\t\t\tcpu = i;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\tcpu = housekeeping_any_cpu(HK_FLAG_TIMER);\nunlock:\n\trcu_read_unlock();\n\treturn cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&timers_migration_enabled"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline\nstruct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base,\n\t\t\t\t\t int pinned)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) && !pinned)\n\t\treturn &per_cpu(hrtimer_bases, get_nohz_timer_target());\n#endif\n\treturn base;\n}"
  },
  {
    "function_name": "hrtimer_check_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "193-200",
    "snippet": "static int\nhrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)\n{\n\tktime_t expires;\n\n\texpires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);\n\treturn expires < new_base->cpu_base->expires_next;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "hrtimer_get_expires(timer)",
            "new_base->offset"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int\nhrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)\n{\n\tktime_t expires;\n\n\texpires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);\n\treturn expires < new_base->cpu_base->expires_next;\n}"
  },
  {
    "function_name": "lock_hrtimer_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "165-182",
    "snippet": "static\nstruct hrtimer_clock_base *lock_hrtimer_base(const struct hrtimer *timer,\n\t\t\t\t\t     unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base;\n\n\tfor (;;) {\n\t\tbase = timer->base;\n\t\tif (likely(base != &migration_base)) {\n\t\t\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\t\t\tif (likely(base == timer->base))\n\t\t\t\treturn base;\n\t\t\t/* The timer has migrated to another CPU: */\n\t\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define migration_base\tmigration_cpu_base.clock_base[0]"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&base->cpu_base->lock",
            "*flags"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "base == timer->base"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&base->cpu_base->lock",
            "*flags"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "base != &migration_base"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define migration_base\tmigration_cpu_base.clock_base[0]\n\nstatic\nstruct hrtimer_clock_base *lock_hrtimer_base(const struct hrtimer *timer,\n\t\t\t\t\t     unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base;\n\n\tfor (;;) {\n\t\tbase = timer->base;\n\t\tif (likely(base != &migration_base)) {\n\t\t\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\t\t\tif (likely(base == timer->base))\n\t\t\t\treturn base;\n\t\t\t/* The timer has migrated to another CPU: */\n\t\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "nanosleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1763-1777",
    "snippet": "SYSCALL_DEFINE2(nanosleep, struct __kernel_timespec __user *, rqtp,\n\t\tstruct __kernel_timespec __user *, rmtp)\n{\n\tstruct timespec64 tu;\n\n\tif (get_timespec64(&tu, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&tu))\n\t\treturn -EINVAL;\n\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;\n\tcurrent->restart_block.nanosleep.rmtp = rmtp;\n\treturn hrtimer_nanosleep(&tu, HRTIMER_MODE_REL, CLOCK_MONOTONIC);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nSYSCALL_DEFINE2(nanosleep, struct __kernel_timespec __user *, rqtp,\n\t\tstruct __kernel_timespec __user *, rmtp)\n{\n\tstruct timespec64 tu;\n\n\tif (get_timespec64(&tu, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&tu))\n\t\treturn -EINVAL;\n\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;\n\tcurrent->restart_block.nanosleep.rmtp = rmtp;\n\treturn hrtimer_nanosleep(&tu, HRTIMER_MODE_REL, CLOCK_MONOTONIC);\n}"
  },
  {
    "function_name": "nanosleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
    "lines": "1783-1797",
    "snippet": "SYSCALL_DEFINE2(nanosleep, struct old_timespec32 __user *, rqtp,\n\t\t       struct old_timespec32 __user *, rmtp)\n{\n\tstruct timespec64 tu;\n\n\tif (get_old_timespec32(&tu, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&tu))\n\t\treturn -EINVAL;\n\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;\n\tcurrent->restart_block.nanosleep.compat_rmtp = rmtp;\n\treturn hrtimer_nanosleep(&tu, HRTIMER_MODE_REL, CLOCK_MONOTONIC);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nSYSCALL_DEFINE2(nanosleep, struct old_timespec32 __user *, rqtp,\n\t\t       struct old_timespec32 __user *, rmtp)\n{\n\tstruct timespec64 tu;\n\n\tif (get_old_timespec32(&tu, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&tu))\n\t\treturn -EINVAL;\n\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;\n\tcurrent->restart_block.nanosleep.compat_rmtp = rmtp;\n\treturn hrtimer_nanosleep(&tu, HRTIMER_MODE_REL, CLOCK_MONOTONIC);\n}"
  }
]