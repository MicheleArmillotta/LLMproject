[
  {
    "function_name": "futex_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3612-3639",
    "snippet": "static int __init futex_init(void)\n{\n\tunsigned int futex_shift;\n\tunsigned long i;\n\n#if CONFIG_BASE_SMALL\n\tfutex_hashsize = 16;\n#else\n\tfutex_hashsize = roundup_pow_of_two(256 * num_possible_cpus());\n#endif\n\n\tfutex_queues = alloc_large_system_hash(\"futex\", sizeof(*futex_queues),\n\t\t\t\t\t       futex_hashsize, 0,\n\t\t\t\t\t       futex_hashsize < 256 ? HASH_SMALL : 0,\n\t\t\t\t\t       &futex_shift, NULL,\n\t\t\t\t\t       futex_hashsize, futex_hashsize);\n\tfutex_hashsize = 1UL << futex_shift;\n\n\tfutex_detect_cmpxchg();\n\n\tfor (i = 0; i < futex_hashsize; i++) {\n\t\tatomic_set(&futex_queues[i].waiters, 0);\n\t\tplist_head_init(&futex_queues[i].chain);\n\t\tspin_lock_init(&futex_queues[i].lock);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define futex_hashsize (__futex_data.hashsize)",
      "#define futex_queues   (__futex_data.queues)"
    ],
    "globals_used": [
      "__read_mostly __aligned(2*sizeof(long));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&futex_queues[i].lock"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_head_init",
          "args": [
            "&futex_queues[i].chain"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&futex_queues[i].waiters",
            "0"
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "futex_detect_cmpxchg",
          "args": [],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "futex_detect_cmpxchg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "3592-3610",
          "snippet": "static void __init futex_detect_cmpxchg(void)\n{\n#ifndef CONFIG_HAVE_FUTEX_CMPXCHG\n\tu32 curval;\n\n\t/*\n\t * This will fail and we want it. Some arch implementations do\n\t * runtime detection of the futex_atomic_cmpxchg_inatomic()\n\t * functionality. We want to know that before we call in any\n\t * of the complex code paths. Also we want to prevent\n\t * registration of robust lists in that case. NULL is\n\t * guaranteed to fault and we get -EFAULT on functional\n\t * implementation, the non-functional ones will return\n\t * -ENOSYS.\n\t */\n\tif (cmpxchg_futex_value_locked(&curval, NULL, 0, 0) == -EFAULT)\n\t\tfutex_cmpxchg_enabled = 1;\n#endif\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void __init futex_detect_cmpxchg(void)\n{\n#ifndef CONFIG_HAVE_FUTEX_CMPXCHG\n\tu32 curval;\n\n\t/*\n\t * This will fail and we want it. Some arch implementations do\n\t * runtime detection of the futex_atomic_cmpxchg_inatomic()\n\t * functionality. We want to know that before we call in any\n\t * of the complex code paths. Also we want to prevent\n\t * registration of robust lists in that case. NULL is\n\t * guaranteed to fault and we get -EFAULT on functional\n\t * implementation, the non-functional ones will return\n\t * -ENOSYS.\n\t */\n\tif (cmpxchg_futex_value_locked(&curval, NULL, 0, 0) == -EFAULT)\n\t\tfutex_cmpxchg_enabled = 1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_large_system_hash",
          "args": [
            "\"futex\"",
            "sizeof(*futex_queues)",
            "futex_hashsize",
            "0",
            "futex_hashsize < 256 ? HASH_SMALL : 0",
            "&futex_shift",
            "NULL",
            "futex_hashsize",
            "futex_hashsize"
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "256 * num_possible_cpus()"
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define futex_hashsize (__futex_data.hashsize)\n#define futex_queues   (__futex_data.queues)\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int __init futex_init(void)\n{\n\tunsigned int futex_shift;\n\tunsigned long i;\n\n#if CONFIG_BASE_SMALL\n\tfutex_hashsize = 16;\n#else\n\tfutex_hashsize = roundup_pow_of_two(256 * num_possible_cpus());\n#endif\n\n\tfutex_queues = alloc_large_system_hash(\"futex\", sizeof(*futex_queues),\n\t\t\t\t\t       futex_hashsize, 0,\n\t\t\t\t\t       futex_hashsize < 256 ? HASH_SMALL : 0,\n\t\t\t\t\t       &futex_shift, NULL,\n\t\t\t\t\t       futex_hashsize, futex_hashsize);\n\tfutex_hashsize = 1UL << futex_shift;\n\n\tfutex_detect_cmpxchg();\n\n\tfor (i = 0; i < futex_hashsize; i++) {\n\t\tatomic_set(&futex_queues[i].waiters, 0);\n\t\tplist_head_init(&futex_queues[i].chain);\n\t\tspin_lock_init(&futex_queues[i].lock);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "futex_detect_cmpxchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3592-3610",
    "snippet": "static void __init futex_detect_cmpxchg(void)\n{\n#ifndef CONFIG_HAVE_FUTEX_CMPXCHG\n\tu32 curval;\n\n\t/*\n\t * This will fail and we want it. Some arch implementations do\n\t * runtime detection of the futex_atomic_cmpxchg_inatomic()\n\t * functionality. We want to know that before we call in any\n\t * of the complex code paths. Also we want to prevent\n\t * registration of robust lists in that case. NULL is\n\t * guaranteed to fault and we get -EFAULT on functional\n\t * implementation, the non-functional ones will return\n\t * -ENOSYS.\n\t */\n\tif (cmpxchg_futex_value_locked(&curval, NULL, 0, 0) == -EFAULT)\n\t\tfutex_cmpxchg_enabled = 1;\n#endif\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg_futex_value_locked",
          "args": [
            "&curval",
            "NULL",
            "0",
            "0"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "cmpxchg_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "756-766",
          "snippet": "static int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void __init futex_detect_cmpxchg(void)\n{\n#ifndef CONFIG_HAVE_FUTEX_CMPXCHG\n\tu32 curval;\n\n\t/*\n\t * This will fail and we want it. Some arch implementations do\n\t * runtime detection of the futex_atomic_cmpxchg_inatomic()\n\t * functionality. We want to know that before we call in any\n\t * of the complex code paths. Also we want to prevent\n\t * registration of robust lists in that case. NULL is\n\t * guaranteed to fault and we get -EFAULT on functional\n\t * implementation, the non-functional ones will return\n\t * -ENOSYS.\n\t */\n\tif (cmpxchg_futex_value_locked(&curval, NULL, 0, 0) == -EFAULT)\n\t\tfutex_cmpxchg_enabled = 1;\n#endif\n}"
  },
  {
    "function_name": "do_futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3497-3554",
    "snippet": "long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,\n\t\tu32 __user *uaddr2, u32 val2, u32 val3)\n{\n\tint cmd = op & FUTEX_CMD_MASK;\n\tunsigned int flags = 0;\n\n\tif (!(op & FUTEX_PRIVATE_FLAG))\n\t\tflags |= FLAGS_SHARED;\n\n\tif (op & FUTEX_CLOCK_REALTIME) {\n\t\tflags |= FLAGS_CLOCKRT;\n\t\tif (cmd != FUTEX_WAIT && cmd != FUTEX_WAIT_BITSET && \\\n\t\t    cmd != FUTEX_WAIT_REQUEUE_PI)\n\t\t\treturn -ENOSYS;\n\t}\n\n\tswitch (cmd) {\n\tcase FUTEX_LOCK_PI:\n\tcase FUTEX_UNLOCK_PI:\n\tcase FUTEX_TRYLOCK_PI:\n\tcase FUTEX_WAIT_REQUEUE_PI:\n\tcase FUTEX_CMP_REQUEUE_PI:\n\t\tif (!futex_cmpxchg_enabled)\n\t\t\treturn -ENOSYS;\n\t}\n\n\tswitch (cmd) {\n\tcase FUTEX_WAIT:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\t/* fall through */\n\tcase FUTEX_WAIT_BITSET:\n\t\treturn futex_wait(uaddr, flags, val, timeout, val3);\n\tcase FUTEX_WAKE:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\t/* fall through */\n\tcase FUTEX_WAKE_BITSET:\n\t\treturn futex_wake(uaddr, flags, val, val3);\n\tcase FUTEX_REQUEUE:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, NULL, 0);\n\tcase FUTEX_CMP_REQUEUE:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 0);\n\tcase FUTEX_WAKE_OP:\n\t\treturn futex_wake_op(uaddr, flags, uaddr2, val, val2, val3);\n\tcase FUTEX_LOCK_PI:\n\t\treturn futex_lock_pi(uaddr, flags, timeout, 0);\n\tcase FUTEX_UNLOCK_PI:\n\t\treturn futex_unlock_pi(uaddr, flags);\n\tcase FUTEX_TRYLOCK_PI:\n\t\treturn futex_lock_pi(uaddr, flags, NULL, 1);\n\tcase FUTEX_WAIT_REQUEUE_PI:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\treturn futex_wait_requeue_pi(uaddr, flags, val, timeout, val3,\n\t\t\t\t\t     uaddr2);\n\tcase FUTEX_CMP_REQUEUE_PI:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 1);\n\t}\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define FLAGS_CLOCKRT\t\t0x02"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "futex_requeue",
          "args": [
            "uaddr",
            "flags",
            "uaddr2",
            "val",
            "val2",
            "&val3",
            "1"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "futex_requeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1852-2138",
          "snippet": "static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (nr_wake < 0 || nr_requeue < 0)\n\t\treturn -EINVAL;\n\n\t/*\n\t * When PI not supported: return -ENOSYS if requeue_pi is true,\n\t * consequently the compiler knows requeue_pi is always false past\n\t * this point which will optimize away all the conditional code\n\t * further down.\n\t */\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI) && requeue_pi)\n\t\treturn -ENOSYS;\n\n\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;\n\n\t\t\t/* If the above failed, then pi_state is NULL */\n\t\tcase -EFAULT:\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Owner is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always\n\t\t * be paired with each other and no other futex ops.\n\t\t *\n\t\t * We should never be requeueing a futex_q with a pi_state,\n\t\t * which is awaiting a futex_unlock_pi().\n\t\t */\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\n\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);\n\n\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret ? ret : task_count;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (nr_wake < 0 || nr_requeue < 0)\n\t\treturn -EINVAL;\n\n\t/*\n\t * When PI not supported: return -ENOSYS if requeue_pi is true,\n\t * consequently the compiler knows requeue_pi is always false past\n\t * this point which will optimize away all the conditional code\n\t * further down.\n\t */\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI) && requeue_pi)\n\t\treturn -ENOSYS;\n\n\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;\n\n\t\t\t/* If the above failed, then pi_state is NULL */\n\t\tcase -EFAULT:\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Owner is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always\n\t\t * be paired with each other and no other futex ops.\n\t\t *\n\t\t * We should never be requeueing a futex_q with a pi_state,\n\t\t * which is awaiting a futex_unlock_pi().\n\t\t */\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\n\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);\n\n\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret ? ret : task_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_wait_requeue_pi",
          "args": [
            "uaddr",
            "flags",
            "val",
            "timeout",
            "val3",
            "uaddr2"
          ],
          "line": 3548
        },
        "resolved": true,
        "details": {
          "function_name": "futex_wait_requeue_pi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "3105-3276",
          "snippet": "static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = FUTEX_KEY_INIT;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (uaddr == uaddr2)\n\t\treturn -EINVAL;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\trt_mutex_init_waiter(&rt_waiter);\n\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (match_futex(&q.key, &key2)) {\n\t\tqueue_unlock(hb);\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current);\n\t\t\tif (ret && rt_mutex_owner(&q.pi_state->pi_mutex) == current) {\n\t\t\t\tpi_state = q.pi_state;\n\t\t\t\tget_pi_state(pi_state);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Drop the reference to the pi state which\n\t\t\t * the requeue_pi() code acquired for us.\n\t\t\t */\n\t\t\tput_pi_state(q.pi_state);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\tstruct rt_mutex *pi_mutex;\n\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_wait_proxy_lock(pi_mutex, to, &rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\tif (ret && !rt_mutex_cleanup_proxy_lock(pi_mutex, &rt_waiter))\n\t\t\tret = 0;\n\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/*\n\t\t * If fixup_pi_state_owner() faulted and was unable to handle\n\t\t * the fault, unlock the rt_mutex and return the fault to\n\t\t * userspace.\n\t\t */\n\t\tif (ret && rt_mutex_owner(&q.pi_state->pi_mutex) == current) {\n\t\t\tpi_state = q.pi_state;\n\t\t\tget_pi_state(pi_state);\n\t\t}\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\tif (pi_state) {\n\t\trt_mutex_futex_unlock(&pi_state->pi_mutex);\n\t\tput_pi_state(pi_state);\n\t}\n\n\tif (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(&q.key);\nout_key2:\n\tput_futex_key(&key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define FLAGS_CLOCKRT\t\t0x02"
          ],
          "globals_used": [
            "static const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};",
            "static long futex_wait_restart(struct restart_block *restart);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define FLAGS_CLOCKRT\t\t0x02\n\nstatic const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};\nstatic long futex_wait_restart(struct restart_block *restart);\n\nstatic int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = FUTEX_KEY_INIT;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (uaddr == uaddr2)\n\t\treturn -EINVAL;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\trt_mutex_init_waiter(&rt_waiter);\n\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (match_futex(&q.key, &key2)) {\n\t\tqueue_unlock(hb);\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current);\n\t\t\tif (ret && rt_mutex_owner(&q.pi_state->pi_mutex) == current) {\n\t\t\t\tpi_state = q.pi_state;\n\t\t\t\tget_pi_state(pi_state);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Drop the reference to the pi state which\n\t\t\t * the requeue_pi() code acquired for us.\n\t\t\t */\n\t\t\tput_pi_state(q.pi_state);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\tstruct rt_mutex *pi_mutex;\n\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_wait_proxy_lock(pi_mutex, to, &rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\tif (ret && !rt_mutex_cleanup_proxy_lock(pi_mutex, &rt_waiter))\n\t\t\tret = 0;\n\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/*\n\t\t * If fixup_pi_state_owner() faulted and was unable to handle\n\t\t * the fault, unlock the rt_mutex and return the fault to\n\t\t * userspace.\n\t\t */\n\t\tif (ret && rt_mutex_owner(&q.pi_state->pi_mutex) == current) {\n\t\t\tpi_state = q.pi_state;\n\t\t\tget_pi_state(pi_state);\n\t\t}\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\tif (pi_state) {\n\t\trt_mutex_futex_unlock(&pi_state->pi_mutex);\n\t\tput_pi_state(pi_state);\n\t}\n\n\tif (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(&q.key);\nout_key2:\n\tput_futex_key(&key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_lock_pi",
          "args": [
            "uaddr",
            "flags",
            "NULL",
            "1"
          ],
          "line": 3545
        },
        "resolved": true,
        "details": {
          "function_name": "futex_lock_pi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2711-2888",
          "snippet": "static int futex_lock_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t ktime_t *time, int trylock)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (refill_pi_state_cache())\n\t\treturn -ENOMEM;\n\n\tif (time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, CLOCK_REALTIME,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires(&to->timer, *time);\n\t}\n\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q.key, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = queue_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current, 0);\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * Atomic work succeeded and we got the lock,\n\t\t * or failed. Either way, we do _not_ block.\n\t\t */\n\t\tswitch (ret) {\n\t\tcase 1:\n\t\t\t/* We got the lock. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_put_key;\n\t\tcase -EFAULT:\n\t\t\tgoto uaddr_faulted;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Task is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tqueue_unlock(hb);\n\t\t\tput_futex_key(&q.key);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock_put_key;\n\t\t}\n\t}\n\n\tWARN_ON(!q.pi_state);\n\n\t/*\n\t * Only actually queue now that the atomic ops are done:\n\t */\n\t__queue_me(&q, hb);\n\n\tif (trylock) {\n\t\tret = rt_mutex_futex_trylock(&q.pi_state->pi_mutex);\n\t\t/* Fixup the trylock return value: */\n\t\tret = ret ? 0 : -EWOULDBLOCK;\n\t\tgoto no_block;\n\t}\n\n\trt_mutex_init_waiter(&rt_waiter);\n\n\t/*\n\t * On PREEMPT_RT_FULL, when hb->lock becomes an rt_mutex, we must not\n\t * hold it while doing rt_mutex_start_proxy(), because then it will\n\t * include hb->lock in the blocking chain, even through we'll not in\n\t * fact hold it while blocking. This will lead it to report -EDEADLK\n\t * and BUG when futex_unlock_pi() interleaves with this.\n\t *\n\t * Therefore acquire wait_lock while holding hb->lock, but drop the\n\t * latter before calling rt_mutex_start_proxy_lock(). This still fully\n\t * serializes against futex_unlock_pi() as that does the exact same\n\t * lock handoff sequence.\n\t */\n\traw_spin_lock_irq(&q.pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q.lock_ptr);\n\tret = __rt_mutex_start_proxy_lock(&q.pi_state->pi_mutex, &rt_waiter, current);\n\traw_spin_unlock_irq(&q.pi_state->pi_mutex.wait_lock);\n\n\tif (ret) {\n\t\tif (ret == 1)\n\t\t\tret = 0;\n\n\t\tspin_lock(q.lock_ptr);\n\t\tgoto no_block;\n\t}\n\n\n\tif (unlikely(to))\n\t\thrtimer_start_expires(&to->timer, HRTIMER_MODE_ABS);\n\n\tret = rt_mutex_wait_proxy_lock(&q.pi_state->pi_mutex, to, &rt_waiter);\n\n\tspin_lock(q.lock_ptr);\n\t/*\n\t * If we failed to acquire the lock (signal/timeout), we must\n\t * first acquire the hb->lock before removing the lock from the\n\t * rt_mutex waitqueue, such that we can keep the hb and rt_mutex\n\t * wait lists consistent.\n\t *\n\t * In particular; it is important that futex_unlock_pi() can not\n\t * observe this inconsistency.\n\t */\n\tif (ret && !rt_mutex_cleanup_proxy_lock(&q.pi_state->pi_mutex, &rt_waiter))\n\t\tret = 0;\n\nno_block:\n\t/*\n\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t * haven't already.\n\t */\n\tres = fixup_owner(uaddr, &q, !ret);\n\t/*\n\t * If fixup_owner() returned an error, proprogate that.  If it acquired\n\t * the lock, clear our -ETIMEDOUT or -EINTR.\n\t */\n\tif (res)\n\t\tret = (res < 0) ? res : 0;\n\n\t/*\n\t * If fixup_owner() faulted and was unable to handle the fault, unlock\n\t * it and return the fault to userspace.\n\t */\n\tif (ret && (rt_mutex_owner(&q.pi_state->pi_mutex) == current)) {\n\t\tpi_state = q.pi_state;\n\t\tget_pi_state(pi_state);\n\t}\n\n\t/* Unqueue and drop the lock */\n\tunqueue_me_pi(&q);\n\n\tif (pi_state) {\n\t\trt_mutex_futex_unlock(&pi_state->pi_mutex);\n\t\tput_pi_state(pi_state);\n\t}\n\n\tgoto out_put_key;\n\nout_unlock_put_key:\n\tqueue_unlock(hb);\n\nout_put_key:\n\tput_futex_key(&q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret != -EINTR ? ret : -ERESTARTNOINTR;\n\nuaddr_faulted:\n\tqueue_unlock(hb);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (ret)\n\t\tgoto out_put_key;\n\n\tif (!(flags & FLAGS_SHARED))\n\t\tgoto retry_private;\n\n\tput_futex_key(&q.key);\n\tgoto retry;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};\n\nstatic int futex_lock_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t ktime_t *time, int trylock)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (refill_pi_state_cache())\n\t\treturn -ENOMEM;\n\n\tif (time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, CLOCK_REALTIME,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires(&to->timer, *time);\n\t}\n\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q.key, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = queue_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current, 0);\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * Atomic work succeeded and we got the lock,\n\t\t * or failed. Either way, we do _not_ block.\n\t\t */\n\t\tswitch (ret) {\n\t\tcase 1:\n\t\t\t/* We got the lock. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_put_key;\n\t\tcase -EFAULT:\n\t\t\tgoto uaddr_faulted;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Task is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tqueue_unlock(hb);\n\t\t\tput_futex_key(&q.key);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock_put_key;\n\t\t}\n\t}\n\n\tWARN_ON(!q.pi_state);\n\n\t/*\n\t * Only actually queue now that the atomic ops are done:\n\t */\n\t__queue_me(&q, hb);\n\n\tif (trylock) {\n\t\tret = rt_mutex_futex_trylock(&q.pi_state->pi_mutex);\n\t\t/* Fixup the trylock return value: */\n\t\tret = ret ? 0 : -EWOULDBLOCK;\n\t\tgoto no_block;\n\t}\n\n\trt_mutex_init_waiter(&rt_waiter);\n\n\t/*\n\t * On PREEMPT_RT_FULL, when hb->lock becomes an rt_mutex, we must not\n\t * hold it while doing rt_mutex_start_proxy(), because then it will\n\t * include hb->lock in the blocking chain, even through we'll not in\n\t * fact hold it while blocking. This will lead it to report -EDEADLK\n\t * and BUG when futex_unlock_pi() interleaves with this.\n\t *\n\t * Therefore acquire wait_lock while holding hb->lock, but drop the\n\t * latter before calling rt_mutex_start_proxy_lock(). This still fully\n\t * serializes against futex_unlock_pi() as that does the exact same\n\t * lock handoff sequence.\n\t */\n\traw_spin_lock_irq(&q.pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q.lock_ptr);\n\tret = __rt_mutex_start_proxy_lock(&q.pi_state->pi_mutex, &rt_waiter, current);\n\traw_spin_unlock_irq(&q.pi_state->pi_mutex.wait_lock);\n\n\tif (ret) {\n\t\tif (ret == 1)\n\t\t\tret = 0;\n\n\t\tspin_lock(q.lock_ptr);\n\t\tgoto no_block;\n\t}\n\n\n\tif (unlikely(to))\n\t\thrtimer_start_expires(&to->timer, HRTIMER_MODE_ABS);\n\n\tret = rt_mutex_wait_proxy_lock(&q.pi_state->pi_mutex, to, &rt_waiter);\n\n\tspin_lock(q.lock_ptr);\n\t/*\n\t * If we failed to acquire the lock (signal/timeout), we must\n\t * first acquire the hb->lock before removing the lock from the\n\t * rt_mutex waitqueue, such that we can keep the hb and rt_mutex\n\t * wait lists consistent.\n\t *\n\t * In particular; it is important that futex_unlock_pi() can not\n\t * observe this inconsistency.\n\t */\n\tif (ret && !rt_mutex_cleanup_proxy_lock(&q.pi_state->pi_mutex, &rt_waiter))\n\t\tret = 0;\n\nno_block:\n\t/*\n\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t * haven't already.\n\t */\n\tres = fixup_owner(uaddr, &q, !ret);\n\t/*\n\t * If fixup_owner() returned an error, proprogate that.  If it acquired\n\t * the lock, clear our -ETIMEDOUT or -EINTR.\n\t */\n\tif (res)\n\t\tret = (res < 0) ? res : 0;\n\n\t/*\n\t * If fixup_owner() faulted and was unable to handle the fault, unlock\n\t * it and return the fault to userspace.\n\t */\n\tif (ret && (rt_mutex_owner(&q.pi_state->pi_mutex) == current)) {\n\t\tpi_state = q.pi_state;\n\t\tget_pi_state(pi_state);\n\t}\n\n\t/* Unqueue and drop the lock */\n\tunqueue_me_pi(&q);\n\n\tif (pi_state) {\n\t\trt_mutex_futex_unlock(&pi_state->pi_mutex);\n\t\tput_pi_state(pi_state);\n\t}\n\n\tgoto out_put_key;\n\nout_unlock_put_key:\n\tqueue_unlock(hb);\n\nout_put_key:\n\tput_futex_key(&q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret != -EINTR ? ret : -ERESTARTNOINTR;\n\nuaddr_faulted:\n\tqueue_unlock(hb);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (ret)\n\t\tgoto out_put_key;\n\n\tif (!(flags & FLAGS_SHARED))\n\t\tgoto retry_private;\n\n\tput_futex_key(&q.key);\n\tgoto retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_unlock_pi",
          "args": [
            "uaddr",
            "flags"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "futex_unlock_pi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2895-3014",
          "snippet": "static int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)\n{\n\tu32 uninitialized_var(curval), uval, vpid = task_pid_vnr(current);\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -EFAULT;\n\t/*\n\t * We release only a lock we actually own:\n\t */\n\tif ((uval & FUTEX_TID_MASK) != vpid)\n\t\treturn -EPERM;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\thb = hash_futex(&key);\n\tspin_lock(&hb->lock);\n\n\t/*\n\t * Check waiters first. We do not trust user space values at\n\t * all and we at least want to know if user space fiddled\n\t * with the futex value instead of blindly unlocking.\n\t */\n\ttop_waiter = futex_top_waiter(hb, &key);\n\tif (top_waiter) {\n\t\tstruct futex_pi_state *pi_state = top_waiter->pi_state;\n\n\t\tret = -EINVAL;\n\t\tif (!pi_state)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * If current does not own the pi_state then the futex is\n\t\t * inconsistent and user space fiddled with the futex value.\n\t\t */\n\t\tif (pi_state->owner != current)\n\t\t\tgoto out_unlock;\n\n\t\tget_pi_state(pi_state);\n\t\t/*\n\t\t * By taking wait_lock while still holding hb->lock, we ensure\n\t\t * there is no point where we hold neither; and therefore\n\t\t * wake_futex_pi() must observe a state consistent with what we\n\t\t * observed.\n\t\t */\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\tspin_unlock(&hb->lock);\n\n\t\t/* drops pi_state->pi_mutex.wait_lock */\n\t\tret = wake_futex_pi(uaddr, uval, pi_state);\n\n\t\tput_pi_state(pi_state);\n\n\t\t/*\n\t\t * Success, we're done! No tricky corner cases.\n\t\t */\n\t\tif (!ret)\n\t\t\tgoto out_putkey;\n\t\t/*\n\t\t * The atomic access to the futex value generated a\n\t\t * pagefault, so retry the user-access and the wakeup:\n\t\t */\n\t\tif (ret == -EFAULT)\n\t\t\tgoto pi_faulted;\n\t\t/*\n\t\t * A unconditional UNLOCK_PI op raced against a waiter\n\t\t * setting the FUTEX_WAITERS bit. Try again.\n\t\t */\n\t\tif (ret == -EAGAIN) {\n\t\t\tput_futex_key(&key);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * wake_futex_pi has detected invalid state. Tell user\n\t\t * space.\n\t\t */\n\t\tgoto out_putkey;\n\t}\n\n\t/*\n\t * We have no kernel internal state, i.e. no waiters in the\n\t * kernel. Waiters which are about to queue themselves are stuck\n\t * on hb->lock. So we can safely ignore them. We do neither\n\t * preserve the WAITERS bit not the OWNER_DIED one. We are the\n\t * owner.\n\t */\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, 0)) {\n\t\tspin_unlock(&hb->lock);\n\t\tgoto pi_faulted;\n\t}\n\n\t/*\n\t * If uval has changed, let user space handle it.\n\t */\n\tret = (curval == uval) ? 0 : -EAGAIN;\n\nout_unlock:\n\tspin_unlock(&hb->lock);\nout_putkey:\n\tput_futex_key(&key);\n\treturn ret;\n\npi_faulted:\n\tput_futex_key(&key);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (!ret)\n\t\tgoto retry;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)\n{\n\tu32 uninitialized_var(curval), uval, vpid = task_pid_vnr(current);\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -EFAULT;\n\t/*\n\t * We release only a lock we actually own:\n\t */\n\tif ((uval & FUTEX_TID_MASK) != vpid)\n\t\treturn -EPERM;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\thb = hash_futex(&key);\n\tspin_lock(&hb->lock);\n\n\t/*\n\t * Check waiters first. We do not trust user space values at\n\t * all and we at least want to know if user space fiddled\n\t * with the futex value instead of blindly unlocking.\n\t */\n\ttop_waiter = futex_top_waiter(hb, &key);\n\tif (top_waiter) {\n\t\tstruct futex_pi_state *pi_state = top_waiter->pi_state;\n\n\t\tret = -EINVAL;\n\t\tif (!pi_state)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * If current does not own the pi_state then the futex is\n\t\t * inconsistent and user space fiddled with the futex value.\n\t\t */\n\t\tif (pi_state->owner != current)\n\t\t\tgoto out_unlock;\n\n\t\tget_pi_state(pi_state);\n\t\t/*\n\t\t * By taking wait_lock while still holding hb->lock, we ensure\n\t\t * there is no point where we hold neither; and therefore\n\t\t * wake_futex_pi() must observe a state consistent with what we\n\t\t * observed.\n\t\t */\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\tspin_unlock(&hb->lock);\n\n\t\t/* drops pi_state->pi_mutex.wait_lock */\n\t\tret = wake_futex_pi(uaddr, uval, pi_state);\n\n\t\tput_pi_state(pi_state);\n\n\t\t/*\n\t\t * Success, we're done! No tricky corner cases.\n\t\t */\n\t\tif (!ret)\n\t\t\tgoto out_putkey;\n\t\t/*\n\t\t * The atomic access to the futex value generated a\n\t\t * pagefault, so retry the user-access and the wakeup:\n\t\t */\n\t\tif (ret == -EFAULT)\n\t\t\tgoto pi_faulted;\n\t\t/*\n\t\t * A unconditional UNLOCK_PI op raced against a waiter\n\t\t * setting the FUTEX_WAITERS bit. Try again.\n\t\t */\n\t\tif (ret == -EAGAIN) {\n\t\t\tput_futex_key(&key);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * wake_futex_pi has detected invalid state. Tell user\n\t\t * space.\n\t\t */\n\t\tgoto out_putkey;\n\t}\n\n\t/*\n\t * We have no kernel internal state, i.e. no waiters in the\n\t * kernel. Waiters which are about to queue themselves are stuck\n\t * on hb->lock. So we can safely ignore them. We do neither\n\t * preserve the WAITERS bit not the OWNER_DIED one. We are the\n\t * owner.\n\t */\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, 0)) {\n\t\tspin_unlock(&hb->lock);\n\t\tgoto pi_faulted;\n\t}\n\n\t/*\n\t * If uval has changed, let user space handle it.\n\t */\n\tret = (curval == uval) ? 0 : -EAGAIN;\n\nout_unlock:\n\tspin_unlock(&hb->lock);\nout_putkey:\n\tput_futex_key(&key);\n\treturn ret;\n\npi_faulted:\n\tput_futex_key(&key);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (!ret)\n\t\tgoto retry;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_wake_op",
          "args": [
            "uaddr",
            "flags",
            "uaddr2",
            "val",
            "val2",
            "val3"
          ],
          "line": 3539
        },
        "resolved": true,
        "details": {
          "function_name": "futex_wake_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1614-1705",
          "snippet": "static int\nfutex_wake_op(u32 __user *uaddr1, unsigned int flags, u32 __user *uaddr2,\n\t      int nr_wake, int nr_wake2, int op)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tint ret, op_ret;\n\tDEFINE_WAKE_Q(wake_q);\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\tdouble_lock_hb(hb1, hb2);\n\top_ret = futex_atomic_op_inuser(op, uaddr2);\n\tif (unlikely(op_ret < 0)) {\n\n\t\tdouble_unlock_hb(hb1, hb2);\n\n#ifndef CONFIG_MMU\n\t\t/*\n\t\t * we don't get EFAULT from MMU faults if we don't have an MMU,\n\t\t * but we might get them from range checking\n\t\t */\n\t\tret = op_ret;\n\t\tgoto out_put_keys;\n#endif\n\n\t\tif (unlikely(op_ret != -EFAULT)) {\n\t\t\tret = op_ret;\n\t\t\tgoto out_put_keys;\n\t\t}\n\n\t\tret = fault_in_user_writeable(uaddr2);\n\t\tif (ret)\n\t\t\tgoto out_put_keys;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&key2);\n\t\tput_futex_key(&key1);\n\t\tgoto retry;\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (match_futex (&this->key, &key1)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (op_ret > 0) {\n\t\top_ret = 0;\n\t\tplist_for_each_entry_safe(this, next, &hb2->chain, list) {\n\t\t\tif (match_futex (&this->key, &key2)) {\n\t\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\t\tif (++op_ret >= nr_wake2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret += op_ret;\n\t}\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int\nfutex_wake_op(u32 __user *uaddr1, unsigned int flags, u32 __user *uaddr2,\n\t      int nr_wake, int nr_wake2, int op)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tint ret, op_ret;\n\tDEFINE_WAKE_Q(wake_q);\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\tdouble_lock_hb(hb1, hb2);\n\top_ret = futex_atomic_op_inuser(op, uaddr2);\n\tif (unlikely(op_ret < 0)) {\n\n\t\tdouble_unlock_hb(hb1, hb2);\n\n#ifndef CONFIG_MMU\n\t\t/*\n\t\t * we don't get EFAULT from MMU faults if we don't have an MMU,\n\t\t * but we might get them from range checking\n\t\t */\n\t\tret = op_ret;\n\t\tgoto out_put_keys;\n#endif\n\n\t\tif (unlikely(op_ret != -EFAULT)) {\n\t\t\tret = op_ret;\n\t\t\tgoto out_put_keys;\n\t\t}\n\n\t\tret = fault_in_user_writeable(uaddr2);\n\t\tif (ret)\n\t\t\tgoto out_put_keys;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&key2);\n\t\tput_futex_key(&key1);\n\t\tgoto retry;\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (match_futex (&this->key, &key1)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (op_ret > 0) {\n\t\top_ret = 0;\n\t\tplist_for_each_entry_safe(this, next, &hb2->chain, list) {\n\t\t\tif (match_futex (&this->key, &key2)) {\n\t\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\t\tif (++op_ret >= nr_wake2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret += op_ret;\n\t}\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_wake",
          "args": [
            "uaddr",
            "flags",
            "val",
            "val3"
          ],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "futex_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1514-1561",
          "snippet": "static int\nfutex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *this, *next;\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tint ret;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\thb = hash_futex(&key);\n\n\t/* Make sure we really have tasks to wakeup */\n\tif (!hb_waiters_pending(hb))\n\t\tgoto out_put_key;\n\n\tspin_lock(&hb->lock);\n\n\tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n\t\tif (match_futex (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check if one of the bits is set in both bitsets */\n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\n\twake_up_q(&wake_q);\nout_put_key:\n\tput_futex_key(&key);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int\nfutex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *this, *next;\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tint ret;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\thb = hash_futex(&key);\n\n\t/* Make sure we really have tasks to wakeup */\n\tif (!hb_waiters_pending(hb))\n\t\tgoto out_put_key;\n\n\tspin_lock(&hb->lock);\n\n\tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n\t\tif (match_futex (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check if one of the bits is set in both bitsets */\n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\n\twake_up_q(&wake_q);\nout_put_key:\n\tput_futex_key(&key);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_wait",
          "args": [
            "uaddr",
            "flags",
            "val",
            "timeout",
            "val3"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "futex_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2611-2683",
          "snippet": "static int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,\n\t\t      ktime_t *abs_time, u32 bitset)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.bitset = bitset;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t/*\n\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n\t * q.key refs.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\t/* unqueue_me() drops q.key ref */\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = *abs_time;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = flags | FLAGS_HAS_TIMEOUT;\n\n\tret = -ERESTART_RESTARTBLOCK;\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define FLAGS_HAS_TIMEOUT\t0x04",
            "#define FLAGS_CLOCKRT\t\t0x02"
          ],
          "globals_used": [
            "static const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};",
            "static long futex_wait_restart(struct restart_block *restart);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define FLAGS_HAS_TIMEOUT\t0x04\n#define FLAGS_CLOCKRT\t\t0x02\n\nstatic const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};\nstatic long futex_wait_restart(struct restart_block *restart);\n\nstatic int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,\n\t\t      ktime_t *abs_time, u32 bitset)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.bitset = bitset;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t/*\n\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n\t * q.key refs.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\t/* unqueue_me() drops q.key ref */\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = *abs_time;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = flags | FLAGS_HAS_TIMEOUT;\n\n\tret = -ERESTART_RESTARTBLOCK;\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define FLAGS_CLOCKRT\t\t0x02\n\nlong do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,\n\t\tu32 __user *uaddr2, u32 val2, u32 val3)\n{\n\tint cmd = op & FUTEX_CMD_MASK;\n\tunsigned int flags = 0;\n\n\tif (!(op & FUTEX_PRIVATE_FLAG))\n\t\tflags |= FLAGS_SHARED;\n\n\tif (op & FUTEX_CLOCK_REALTIME) {\n\t\tflags |= FLAGS_CLOCKRT;\n\t\tif (cmd != FUTEX_WAIT && cmd != FUTEX_WAIT_BITSET && \\\n\t\t    cmd != FUTEX_WAIT_REQUEUE_PI)\n\t\t\treturn -ENOSYS;\n\t}\n\n\tswitch (cmd) {\n\tcase FUTEX_LOCK_PI:\n\tcase FUTEX_UNLOCK_PI:\n\tcase FUTEX_TRYLOCK_PI:\n\tcase FUTEX_WAIT_REQUEUE_PI:\n\tcase FUTEX_CMP_REQUEUE_PI:\n\t\tif (!futex_cmpxchg_enabled)\n\t\t\treturn -ENOSYS;\n\t}\n\n\tswitch (cmd) {\n\tcase FUTEX_WAIT:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\t/* fall through */\n\tcase FUTEX_WAIT_BITSET:\n\t\treturn futex_wait(uaddr, flags, val, timeout, val3);\n\tcase FUTEX_WAKE:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\t/* fall through */\n\tcase FUTEX_WAKE_BITSET:\n\t\treturn futex_wake(uaddr, flags, val, val3);\n\tcase FUTEX_REQUEUE:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, NULL, 0);\n\tcase FUTEX_CMP_REQUEUE:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 0);\n\tcase FUTEX_WAKE_OP:\n\t\treturn futex_wake_op(uaddr, flags, uaddr2, val, val2, val3);\n\tcase FUTEX_LOCK_PI:\n\t\treturn futex_lock_pi(uaddr, flags, timeout, 0);\n\tcase FUTEX_UNLOCK_PI:\n\t\treturn futex_unlock_pi(uaddr, flags);\n\tcase FUTEX_TRYLOCK_PI:\n\t\treturn futex_lock_pi(uaddr, flags, NULL, 1);\n\tcase FUTEX_WAIT_REQUEUE_PI:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\treturn futex_wait_requeue_pi(uaddr, flags, val, timeout, val3,\n\t\t\t\t\t     uaddr2);\n\tcase FUTEX_CMP_REQUEUE_PI:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 1);\n\t}\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "exit_robust_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3434-3495",
    "snippet": "void exit_robust_list(struct task_struct *curr)\n{\n\tstruct robust_list_head __user *head = curr->robust_list;\n\tstruct robust_list __user *entry, *next_entry, *pending;\n\tunsigned int limit = ROBUST_LIST_LIMIT, pi, pip;\n\tunsigned int uninitialized_var(next_pi);\n\tunsigned long futex_offset;\n\tint rc;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\n\t/*\n\t * Fetch the list head (which was registered earlier, via\n\t * sys_set_robust_list()):\n\t */\n\tif (fetch_robust_entry(&entry, &head->list.next, &pi))\n\t\treturn;\n\t/*\n\t * Fetch the relative futex offset:\n\t */\n\tif (get_user(futex_offset, &head->futex_offset))\n\t\treturn;\n\t/*\n\t * Fetch any possibly pending lock-add first, and handle it\n\t * if it exists:\n\t */\n\tif (fetch_robust_entry(&pending, &head->list_op_pending, &pip))\n\t\treturn;\n\n\tnext_entry = NULL;\t/* avoid warning with gcc */\n\twhile (entry != &head->list) {\n\t\t/*\n\t\t * Fetch the next entry in the list before calling\n\t\t * handle_futex_death:\n\t\t */\n\t\trc = fetch_robust_entry(&next_entry, &entry->next, &next_pi);\n\t\t/*\n\t\t * A pending lock might already be on the list, so\n\t\t * don't process it twice:\n\t\t */\n\t\tif (entry != pending)\n\t\t\tif (handle_futex_death((void __user *)entry + futex_offset,\n\t\t\t\t\t\tcurr, pi))\n\t\t\t\treturn;\n\t\tif (rc)\n\t\t\treturn;\n\t\tentry = next_entry;\n\t\tpi = next_pi;\n\t\t/*\n\t\t * Avoid excessively long or circular lists:\n\t\t */\n\t\tif (!--limit)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (pending)\n\t\thandle_futex_death((void __user *)pending + futex_offset,\n\t\t\t\t   curr, pip);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_futex_death",
          "args": [
            "(void __user *)pending + futex_offset",
            "curr",
            "pip"
          ],
          "line": 3493
        },
        "resolved": true,
        "details": {
          "function_name": "handle_futex_death",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "3363-3408",
          "snippet": "int handle_futex_death(u32 __user *uaddr, struct task_struct *curr, int pi)\n{\n\tu32 uval, uninitialized_var(nval), mval;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -1;\n\n\tif ((uval & FUTEX_TID_MASK) == task_pid_vnr(curr)) {\n\t\t/*\n\t\t * Ok, this dying thread is truly holding a futex\n\t\t * of interest. Set the OWNER_DIED bit atomically\n\t\t * via cmpxchg, and if the value had FUTEX_WAITERS\n\t\t * set, wake up a waiter (if any). (We have to do a\n\t\t * futex_wake() even if OWNER_DIED is already set -\n\t\t * to handle the rare but possible case of recursive\n\t\t * thread-death.) The rest of the cleanup is done in\n\t\t * userspace.\n\t\t */\n\t\tmval = (uval & FUTEX_WAITERS) | FUTEX_OWNER_DIED;\n\t\t/*\n\t\t * We are not holding a lock here, but we want to have\n\t\t * the pagefault_disable/enable() protection because\n\t\t * we want to handle the fault gracefully. If the\n\t\t * access fails we try to fault in the futex with R/W\n\t\t * verification via get_user_pages. get_user() above\n\t\t * does not guarantee R/W access. If that fails we\n\t\t * give up and leave the futex locked.\n\t\t */\n\t\tif (cmpxchg_futex_value_locked(&nval, uaddr, uval, mval)) {\n\t\t\tif (fault_in_user_writeable(uaddr))\n\t\t\t\treturn -1;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (nval != uval)\n\t\t\tgoto retry;\n\n\t\t/*\n\t\t * Wake robust non-PI futexes here. The wakeup of\n\t\t * PI futexes happens in exit_pi_state():\n\t\t */\n\t\tif (!pi && (uval & FUTEX_WAITERS))\n\t\t\tfutex_wake(uaddr, 1, 1, FUTEX_BITSET_MATCH_ANY);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nint handle_futex_death(u32 __user *uaddr, struct task_struct *curr, int pi)\n{\n\tu32 uval, uninitialized_var(nval), mval;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -1;\n\n\tif ((uval & FUTEX_TID_MASK) == task_pid_vnr(curr)) {\n\t\t/*\n\t\t * Ok, this dying thread is truly holding a futex\n\t\t * of interest. Set the OWNER_DIED bit atomically\n\t\t * via cmpxchg, and if the value had FUTEX_WAITERS\n\t\t * set, wake up a waiter (if any). (We have to do a\n\t\t * futex_wake() even if OWNER_DIED is already set -\n\t\t * to handle the rare but possible case of recursive\n\t\t * thread-death.) The rest of the cleanup is done in\n\t\t * userspace.\n\t\t */\n\t\tmval = (uval & FUTEX_WAITERS) | FUTEX_OWNER_DIED;\n\t\t/*\n\t\t * We are not holding a lock here, but we want to have\n\t\t * the pagefault_disable/enable() protection because\n\t\t * we want to handle the fault gracefully. If the\n\t\t * access fails we try to fault in the futex with R/W\n\t\t * verification via get_user_pages. get_user() above\n\t\t * does not guarantee R/W access. If that fails we\n\t\t * give up and leave the futex locked.\n\t\t */\n\t\tif (cmpxchg_futex_value_locked(&nval, uaddr, uval, mval)) {\n\t\t\tif (fault_in_user_writeable(uaddr))\n\t\t\t\treturn -1;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (nval != uval)\n\t\t\tgoto retry;\n\n\t\t/*\n\t\t * Wake robust non-PI futexes here. The wakeup of\n\t\t * PI futexes happens in exit_pi_state():\n\t\t */\n\t\tif (!pi && (uval & FUTEX_WAITERS))\n\t\t\tfutex_wake(uaddr, 1, 1, FUTEX_BITSET_MATCH_ANY);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3489
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_robust_entry",
          "args": [
            "&next_entry",
            "&entry->next",
            "&next_pi"
          ],
          "line": 3470
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_robust_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "3413-3426",
          "snippet": "static inline int fetch_robust_entry(struct robust_list __user **entry,\n\t\t\t\t     struct robust_list __user * __user *head,\n\t\t\t\t     unsigned int *pi)\n{\n\tunsigned long uentry;\n\n\tif (get_user(uentry, (unsigned long __user *)head))\n\t\treturn -EFAULT;\n\n\t*entry = (void __user *)(uentry & ~1UL);\n\t*pi = uentry & 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int fetch_robust_entry(struct robust_list __user **entry,\n\t\t\t\t     struct robust_list __user * __user *head,\n\t\t\t\t     unsigned int *pi)\n{\n\tunsigned long uentry;\n\n\tif (get_user(uentry, (unsigned long __user *)head))\n\t\treturn -EFAULT;\n\n\t*entry = (void __user *)(uentry & ~1UL);\n\t*pi = uentry & 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "futex_offset",
            "&head->futex_offset"
          ],
          "line": 3455
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nvoid exit_robust_list(struct task_struct *curr)\n{\n\tstruct robust_list_head __user *head = curr->robust_list;\n\tstruct robust_list __user *entry, *next_entry, *pending;\n\tunsigned int limit = ROBUST_LIST_LIMIT, pi, pip;\n\tunsigned int uninitialized_var(next_pi);\n\tunsigned long futex_offset;\n\tint rc;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\n\t/*\n\t * Fetch the list head (which was registered earlier, via\n\t * sys_set_robust_list()):\n\t */\n\tif (fetch_robust_entry(&entry, &head->list.next, &pi))\n\t\treturn;\n\t/*\n\t * Fetch the relative futex offset:\n\t */\n\tif (get_user(futex_offset, &head->futex_offset))\n\t\treturn;\n\t/*\n\t * Fetch any possibly pending lock-add first, and handle it\n\t * if it exists:\n\t */\n\tif (fetch_robust_entry(&pending, &head->list_op_pending, &pip))\n\t\treturn;\n\n\tnext_entry = NULL;\t/* avoid warning with gcc */\n\twhile (entry != &head->list) {\n\t\t/*\n\t\t * Fetch the next entry in the list before calling\n\t\t * handle_futex_death:\n\t\t */\n\t\trc = fetch_robust_entry(&next_entry, &entry->next, &next_pi);\n\t\t/*\n\t\t * A pending lock might already be on the list, so\n\t\t * don't process it twice:\n\t\t */\n\t\tif (entry != pending)\n\t\t\tif (handle_futex_death((void __user *)entry + futex_offset,\n\t\t\t\t\t\tcurr, pi))\n\t\t\t\treturn;\n\t\tif (rc)\n\t\t\treturn;\n\t\tentry = next_entry;\n\t\tpi = next_pi;\n\t\t/*\n\t\t * Avoid excessively long or circular lists:\n\t\t */\n\t\tif (!--limit)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (pending)\n\t\thandle_futex_death((void __user *)pending + futex_offset,\n\t\t\t\t   curr, pip);\n}"
  },
  {
    "function_name": "fetch_robust_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3413-3426",
    "snippet": "static inline int fetch_robust_entry(struct robust_list __user **entry,\n\t\t\t\t     struct robust_list __user * __user *head,\n\t\t\t\t     unsigned int *pi)\n{\n\tunsigned long uentry;\n\n\tif (get_user(uentry, (unsigned long __user *)head))\n\t\treturn -EFAULT;\n\n\t*entry = (void __user *)(uentry & ~1UL);\n\t*pi = uentry & 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "uentry",
            "(unsigned long __user *)head"
          ],
          "line": 3419
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int fetch_robust_entry(struct robust_list __user **entry,\n\t\t\t\t     struct robust_list __user * __user *head,\n\t\t\t\t     unsigned int *pi)\n{\n\tunsigned long uentry;\n\n\tif (get_user(uentry, (unsigned long __user *)head))\n\t\treturn -EFAULT;\n\n\t*entry = (void __user *)(uentry & ~1UL);\n\t*pi = uentry & 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_futex_death",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3363-3408",
    "snippet": "int handle_futex_death(u32 __user *uaddr, struct task_struct *curr, int pi)\n{\n\tu32 uval, uninitialized_var(nval), mval;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -1;\n\n\tif ((uval & FUTEX_TID_MASK) == task_pid_vnr(curr)) {\n\t\t/*\n\t\t * Ok, this dying thread is truly holding a futex\n\t\t * of interest. Set the OWNER_DIED bit atomically\n\t\t * via cmpxchg, and if the value had FUTEX_WAITERS\n\t\t * set, wake up a waiter (if any). (We have to do a\n\t\t * futex_wake() even if OWNER_DIED is already set -\n\t\t * to handle the rare but possible case of recursive\n\t\t * thread-death.) The rest of the cleanup is done in\n\t\t * userspace.\n\t\t */\n\t\tmval = (uval & FUTEX_WAITERS) | FUTEX_OWNER_DIED;\n\t\t/*\n\t\t * We are not holding a lock here, but we want to have\n\t\t * the pagefault_disable/enable() protection because\n\t\t * we want to handle the fault gracefully. If the\n\t\t * access fails we try to fault in the futex with R/W\n\t\t * verification via get_user_pages. get_user() above\n\t\t * does not guarantee R/W access. If that fails we\n\t\t * give up and leave the futex locked.\n\t\t */\n\t\tif (cmpxchg_futex_value_locked(&nval, uaddr, uval, mval)) {\n\t\t\tif (fault_in_user_writeable(uaddr))\n\t\t\t\treturn -1;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (nval != uval)\n\t\t\tgoto retry;\n\n\t\t/*\n\t\t * Wake robust non-PI futexes here. The wakeup of\n\t\t * PI futexes happens in exit_pi_state():\n\t\t */\n\t\tif (!pi && (uval & FUTEX_WAITERS))\n\t\t\tfutex_wake(uaddr, 1, 1, FUTEX_BITSET_MATCH_ANY);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "futex_wake",
          "args": [
            "uaddr",
            "1",
            "1",
            "FUTEX_BITSET_MATCH_ANY"
          ],
          "line": 3405
        },
        "resolved": true,
        "details": {
          "function_name": "futex_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1514-1561",
          "snippet": "static int\nfutex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *this, *next;\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tint ret;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\thb = hash_futex(&key);\n\n\t/* Make sure we really have tasks to wakeup */\n\tif (!hb_waiters_pending(hb))\n\t\tgoto out_put_key;\n\n\tspin_lock(&hb->lock);\n\n\tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n\t\tif (match_futex (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check if one of the bits is set in both bitsets */\n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\n\twake_up_q(&wake_q);\nout_put_key:\n\tput_futex_key(&key);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int\nfutex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *this, *next;\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tint ret;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\thb = hash_futex(&key);\n\n\t/* Make sure we really have tasks to wakeup */\n\tif (!hb_waiters_pending(hb))\n\t\tgoto out_put_key;\n\n\tspin_lock(&hb->lock);\n\n\tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n\t\tif (match_futex (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check if one of the bits is set in both bitsets */\n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\n\twake_up_q(&wake_q);\nout_put_key:\n\tput_futex_key(&key);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fault_in_user_writeable",
          "args": [
            "uaddr"
          ],
          "line": 3393
        },
        "resolved": true,
        "details": {
          "function_name": "fault_in_user_writeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "724-735",
          "snippet": "static int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg_futex_value_locked",
          "args": [
            "&nval",
            "uaddr",
            "uval",
            "mval"
          ],
          "line": 3392
        },
        "resolved": true,
        "details": {
          "function_name": "cmpxchg_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "756-766",
          "snippet": "static int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "curr"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "uval",
            "uaddr"
          ],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nint handle_futex_death(u32 __user *uaddr, struct task_struct *curr, int pi)\n{\n\tu32 uval, uninitialized_var(nval), mval;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -1;\n\n\tif ((uval & FUTEX_TID_MASK) == task_pid_vnr(curr)) {\n\t\t/*\n\t\t * Ok, this dying thread is truly holding a futex\n\t\t * of interest. Set the OWNER_DIED bit atomically\n\t\t * via cmpxchg, and if the value had FUTEX_WAITERS\n\t\t * set, wake up a waiter (if any). (We have to do a\n\t\t * futex_wake() even if OWNER_DIED is already set -\n\t\t * to handle the rare but possible case of recursive\n\t\t * thread-death.) The rest of the cleanup is done in\n\t\t * userspace.\n\t\t */\n\t\tmval = (uval & FUTEX_WAITERS) | FUTEX_OWNER_DIED;\n\t\t/*\n\t\t * We are not holding a lock here, but we want to have\n\t\t * the pagefault_disable/enable() protection because\n\t\t * we want to handle the fault gracefully. If the\n\t\t * access fails we try to fault in the futex with R/W\n\t\t * verification via get_user_pages. get_user() above\n\t\t * does not guarantee R/W access. If that fails we\n\t\t * give up and leave the futex locked.\n\t\t */\n\t\tif (cmpxchg_futex_value_locked(&nval, uaddr, uval, mval)) {\n\t\t\tif (fault_in_user_writeable(uaddr))\n\t\t\t\treturn -1;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (nval != uval)\n\t\t\tgoto retry;\n\n\t\t/*\n\t\t * Wake robust non-PI futexes here. The wakeup of\n\t\t * PI futexes happens in exit_pi_state():\n\t\t */\n\t\tif (!pi && (uval & FUTEX_WAITERS))\n\t\t\tfutex_wake(uaddr, 1, 1, FUTEX_BITSET_MATCH_ANY);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "futex_wait_requeue_pi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3105-3276",
    "snippet": "static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = FUTEX_KEY_INIT;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (uaddr == uaddr2)\n\t\treturn -EINVAL;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\trt_mutex_init_waiter(&rt_waiter);\n\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (match_futex(&q.key, &key2)) {\n\t\tqueue_unlock(hb);\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current);\n\t\t\tif (ret && rt_mutex_owner(&q.pi_state->pi_mutex) == current) {\n\t\t\t\tpi_state = q.pi_state;\n\t\t\t\tget_pi_state(pi_state);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Drop the reference to the pi state which\n\t\t\t * the requeue_pi() code acquired for us.\n\t\t\t */\n\t\t\tput_pi_state(q.pi_state);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\tstruct rt_mutex *pi_mutex;\n\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_wait_proxy_lock(pi_mutex, to, &rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\tif (ret && !rt_mutex_cleanup_proxy_lock(pi_mutex, &rt_waiter))\n\t\t\tret = 0;\n\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/*\n\t\t * If fixup_pi_state_owner() faulted and was unable to handle\n\t\t * the fault, unlock the rt_mutex and return the fault to\n\t\t * userspace.\n\t\t */\n\t\tif (ret && rt_mutex_owner(&q.pi_state->pi_mutex) == current) {\n\t\t\tpi_state = q.pi_state;\n\t\t\tget_pi_state(pi_state);\n\t\t}\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\tif (pi_state) {\n\t\trt_mutex_futex_unlock(&pi_state->pi_mutex);\n\t\tput_pi_state(pi_state);\n\t}\n\n\tif (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(&q.key);\nout_key2:\n\tput_futex_key(&key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define FLAGS_CLOCKRT\t\t0x02"
    ],
    "globals_used": [
      "static const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};",
      "static long futex_wait_restart(struct restart_block *restart);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&to->timer"
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "440-443",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&to->timer"
          ],
          "line": 3272
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_futex_key",
          "args": [
            "&key2"
          ],
          "line": 3268
        },
        "resolved": true,
        "details": {
          "function_name": "put_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "707-710",
          "snippet": "static inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pi_state",
          "args": [
            "pi_state"
          ],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "put_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "825-863",
          "snippet": "static void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_futex_unlock",
          "args": [
            "&pi_state->pi_mutex"
          ],
          "line": 3250
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_futex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1636-1648",
          "snippet": "void __sched rt_mutex_futex_unlock(struct rt_mutex *lock)\n{\n\tDEFINE_WAKE_Q(wake_q);\n\tunsigned long flags;\n\tbool postunlock;\n\n\traw_spin_lock_irqsave(&lock->wait_lock, flags);\n\tpostunlock = __rt_mutex_futex_unlock(lock, &wake_q);\n\traw_spin_unlock_irqrestore(&lock->wait_lock, flags);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_futex_unlock(struct rt_mutex *lock)\n{\n\tDEFINE_WAKE_Q(wake_q);\n\tunsigned long flags;\n\tbool postunlock;\n\n\traw_spin_lock_irqsave(&lock->wait_lock, flags);\n\tpostunlock = __rt_mutex_futex_unlock(lock, &wake_q);\n\traw_spin_unlock_irqrestore(&lock->wait_lock, flags);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unqueue_me_pi",
          "args": [
            "&q"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "unqueue_me_pi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2270-2280",
          "snippet": "static void unqueue_me_pi(struct futex_q *q)\n\t__releases(q->lock_ptr)\n{\n\t__unqueue_futex(q);\n\n\tBUG_ON(!q->pi_state);\n\tput_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void unqueue_me_pi(struct futex_q *q)\n\t__releases(q->lock_ptr)\n{\n\t__unqueue_futex(q);\n\n\tBUG_ON(!q->pi_state);\n\tput_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pi_state",
          "args": [
            "pi_state"
          ],
          "line": 3242
        },
        "resolved": true,
        "details": {
          "function_name": "get_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "816-819",
          "snippet": "static void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_owner",
          "args": [
            "&q.pi_state->pi_mutex"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex_common.h",
          "lines": "108-113",
          "snippet": "static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}",
          "includes": [
            "# include \"rtmutex.h\"",
            "# include \"rtmutex-debug.h\"",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>"
          ],
          "macros_used": [
            "#define RT_MUTEX_HAS_WAITERS\t1UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"rtmutex.h\"\n# include \"rtmutex-debug.h\"\n#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n\n#define RT_MUTEX_HAS_WAITERS\t1UL\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_owner",
          "args": [
            "uaddr2",
            "&q",
            "!ret"
          ],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2451-2495",
          "snippet": "static int fixup_owner(u32 __user *uaddr, struct futex_q *q, int locked)\n{\n\tint ret = 0;\n\n\tif (locked) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case:\n\t\t *\n\t\t * Speculative pi_state->owner read (we don't hold wait_lock);\n\t\t * since we own the lock pi_state->owner == current is the\n\t\t * stable state, anything else needs more attention.\n\t\t */\n\t\tif (q->pi_state->owner != current)\n\t\t\tret = fixup_pi_state_owner(uaddr, q, current);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we didn't get the lock; check if anybody stole it from us. In\n\t * that case, we need to fix up the uval to point to them instead of\n\t * us, otherwise bad things happen. [10]\n\t *\n\t * Another speculative read; pi_state->owner == current is unstable\n\t * but needs our attention.\n\t */\n\tif (q->pi_state->owner == current) {\n\t\tret = fixup_pi_state_owner(uaddr, q, NULL);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Paranoia check. If we did not take the lock, then we should not be\n\t * the owner of the rt_mutex.\n\t */\n\tif (rt_mutex_owner(&q->pi_state->pi_mutex) == current) {\n\t\tprintk(KERN_ERR \"fixup_owner: ret = %d pi-mutex: %p \"\n\t\t\t\t\"pi-state %p\\n\", ret,\n\t\t\t\tq->pi_state->pi_mutex.owner,\n\t\t\t\tq->pi_state->owner);\n\t}\n\nout:\n\treturn ret ? ret : locked;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fixup_owner(u32 __user *uaddr, struct futex_q *q, int locked)\n{\n\tint ret = 0;\n\n\tif (locked) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case:\n\t\t *\n\t\t * Speculative pi_state->owner read (we don't hold wait_lock);\n\t\t * since we own the lock pi_state->owner == current is the\n\t\t * stable state, anything else needs more attention.\n\t\t */\n\t\tif (q->pi_state->owner != current)\n\t\t\tret = fixup_pi_state_owner(uaddr, q, current);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we didn't get the lock; check if anybody stole it from us. In\n\t * that case, we need to fix up the uval to point to them instead of\n\t * us, otherwise bad things happen. [10]\n\t *\n\t * Another speculative read; pi_state->owner == current is unstable\n\t * but needs our attention.\n\t */\n\tif (q->pi_state->owner == current) {\n\t\tret = fixup_pi_state_owner(uaddr, q, NULL);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Paranoia check. If we did not take the lock, then we should not be\n\t * the owner of the rt_mutex.\n\t */\n\tif (rt_mutex_owner(&q->pi_state->pi_mutex) == current) {\n\t\tprintk(KERN_ERR \"fixup_owner: ret = %d pi-mutex: %p \"\n\t\t\t\t\"pi-state %p\\n\", ret,\n\t\t\t\tq->pi_state->pi_mutex.owner,\n\t\t\t\tq->pi_state->owner);\n\t}\n\nout:\n\treturn ret ? ret : locked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_rt_mutex_free_waiter",
          "args": [
            "&rt_waiter"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rt_mutex_free_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "164-168",
          "snippet": "void debug_rt_mutex_free_waiter(struct rt_mutex_waiter *waiter)\n{\n\tput_pid(waiter->deadlock_task_pid);\n\tmemset(waiter, 0x22, sizeof(*waiter));\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid debug_rt_mutex_free_waiter(struct rt_mutex_waiter *waiter)\n{\n\tput_pid(waiter->deadlock_task_pid);\n\tmemset(waiter, 0x22, sizeof(*waiter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_cleanup_proxy_lock",
          "args": [
            "pi_mutex",
            "&rt_waiter"
          ],
          "line": 3219
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_cleanup_proxy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1862-1897",
          "snippet": "bool rt_mutex_cleanup_proxy_lock(struct rt_mutex *lock,\n\t\t\t\t struct rt_mutex_waiter *waiter)\n{\n\tbool cleanup = false;\n\n\traw_spin_lock_irq(&lock->wait_lock);\n\t/*\n\t * Do an unconditional try-lock, this deals with the lock stealing\n\t * state where __rt_mutex_futex_unlock() -> mark_wakeup_next_waiter()\n\t * sets a NULL owner.\n\t *\n\t * We're not interested in the return value, because the subsequent\n\t * test on rt_mutex_owner() will infer that. If the trylock succeeded,\n\t * we will own the lock and it will have removed the waiter. If we\n\t * failed the trylock, we're still not owner and we need to remove\n\t * ourselves.\n\t */\n\ttry_to_take_rt_mutex(lock, current, waiter);\n\t/*\n\t * Unless we're the owner; we're still enqueued on the wait_list.\n\t * So check if we became owner, if not, take us off the wait_list.\n\t */\n\tif (rt_mutex_owner(lock) != current) {\n\t\tremove_waiter(lock, waiter);\n\t\tcleanup = true;\n\t}\n\t/*\n\t * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might\n\t * have to fix that up.\n\t */\n\tfixup_rt_mutex_waiters(lock);\n\n\traw_spin_unlock_irq(&lock->wait_lock);\n\n\treturn cleanup;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nbool rt_mutex_cleanup_proxy_lock(struct rt_mutex *lock,\n\t\t\t\t struct rt_mutex_waiter *waiter)\n{\n\tbool cleanup = false;\n\n\traw_spin_lock_irq(&lock->wait_lock);\n\t/*\n\t * Do an unconditional try-lock, this deals with the lock stealing\n\t * state where __rt_mutex_futex_unlock() -> mark_wakeup_next_waiter()\n\t * sets a NULL owner.\n\t *\n\t * We're not interested in the return value, because the subsequent\n\t * test on rt_mutex_owner() will infer that. If the trylock succeeded,\n\t * we will own the lock and it will have removed the waiter. If we\n\t * failed the trylock, we're still not owner and we need to remove\n\t * ourselves.\n\t */\n\ttry_to_take_rt_mutex(lock, current, waiter);\n\t/*\n\t * Unless we're the owner; we're still enqueued on the wait_list.\n\t * So check if we became owner, if not, take us off the wait_list.\n\t */\n\tif (rt_mutex_owner(lock) != current) {\n\t\tremove_waiter(lock, waiter);\n\t\tcleanup = true;\n\t}\n\t/*\n\t * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might\n\t * have to fix that up.\n\t */\n\tfixup_rt_mutex_waiters(lock);\n\n\traw_spin_unlock_irq(&lock->wait_lock);\n\n\treturn cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "q.lock_ptr"
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_wait_proxy_lock",
          "args": [
            "pi_mutex",
            "to",
            "&rt_waiter"
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_wait_proxy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1823-1841",
          "snippet": "int rt_mutex_wait_proxy_lock(struct rt_mutex *lock,\n\t\t\t       struct hrtimer_sleeper *to,\n\t\t\t       struct rt_mutex_waiter *waiter)\n{\n\tint ret;\n\n\traw_spin_lock_irq(&lock->wait_lock);\n\t/* sleep on the mutex */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tret = __rt_mutex_slowlock(lock, TASK_INTERRUPTIBLE, to, waiter);\n\t/*\n\t * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might\n\t * have to fix that up.\n\t */\n\tfixup_rt_mutex_waiters(lock);\n\traw_spin_unlock_irq(&lock->wait_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint rt_mutex_wait_proxy_lock(struct rt_mutex *lock,\n\t\t\t       struct hrtimer_sleeper *to,\n\t\t\t       struct rt_mutex_waiter *waiter)\n{\n\tint ret;\n\n\traw_spin_lock_irq(&lock->wait_lock);\n\t/* sleep on the mutex */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tret = __rt_mutex_slowlock(lock, TASK_INTERRUPTIBLE, to, waiter);\n\t/*\n\t * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might\n\t * have to fix that up.\n\t */\n\tfixup_rt_mutex_waiters(lock);\n\traw_spin_unlock_irq(&lock->wait_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!q.pi_state"
          ],
          "line": 3214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "q.lock_ptr"
          ],
          "line": 3204
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_pi_state_owner",
          "args": [
            "uaddr2",
            "&q",
            "current"
          ],
          "line": 3194
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_pi_state_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2282-2432",
          "snippet": "static int fixup_pi_state_owner(u32 __user *uaddr, struct futex_q *q,\n\t\t\t\tstruct task_struct *argowner)\n{\n\tstruct futex_pi_state *pi_state = q->pi_state;\n\tu32 uval, uninitialized_var(curval), newval;\n\tstruct task_struct *oldowner, *newowner;\n\tu32 newtid;\n\tint ret;\n\n\tlockdep_assert_held(q->lock_ptr);\n\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\toldowner = pi_state->owner;\n\n\t/*\n\t * We are here because either:\n\t *\n\t *  - we stole the lock and pi_state->owner needs updating to reflect\n\t *    that (@argowner == current),\n\t *\n\t * or:\n\t *\n\t *  - someone stole our lock and we need to fix things to point to the\n\t *    new owner (@argowner == NULL).\n\t *\n\t * Either way, we have to replace the TID in the user space variable.\n\t * This must be atomic as we have to preserve the owner died bit here.\n\t *\n\t * Note: We write the user space value _before_ changing the pi_state\n\t * because we can fault here. Imagine swapped out pages or a fork\n\t * that marked all the anonymous memory readonly for cow.\n\t *\n\t * Modifying pi_state _before_ the user space value would leave the\n\t * pi_state in an inconsistent state when we fault here, because we\n\t * need to drop the locks to handle the fault. This might be observed\n\t * in the PID check in lookup_pi_state.\n\t */\nretry:\n\tif (!argowner) {\n\t\tif (oldowner != current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (__rt_mutex_futex_trylock(&pi_state->pi_mutex)) {\n\t\t\t/* We got the lock after all, nothing to fix. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Since we just failed the trylock; there must be an owner.\n\t\t */\n\t\tnewowner = rt_mutex_owner(&pi_state->pi_mutex);\n\t\tBUG_ON(!newowner);\n\t} else {\n\t\tWARN_ON_ONCE(argowner != current);\n\t\tif (oldowner == current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tnewowner = argowner;\n\t}\n\n\tnewtid = task_pid_vnr(newowner) | FUTEX_WAITERS;\n\t/* Owner died? */\n\tif (!pi_state->owner)\n\t\tnewtid |= FUTEX_OWNER_DIED;\n\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\tgoto handle_fault;\n\n\tfor (;;) {\n\t\tnewval = (uval & FUTEX_OWNER_DIED) | newtid;\n\n\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\t\tgoto handle_fault;\n\t\tif (curval == uval)\n\t\t\tbreak;\n\t\tuval = curval;\n\t}\n\n\t/*\n\t * We fixed up user space. Now we need to fix the pi_state\n\t * itself.\n\t */\n\tif (pi_state->owner != NULL) {\n\t\traw_spin_lock(&pi_state->owner->pi_lock);\n\t\tWARN_ON(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock(&pi_state->owner->pi_lock);\n\t}\n\n\tpi_state->owner = newowner;\n\n\traw_spin_lock(&newowner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &newowner->pi_state_list);\n\traw_spin_unlock(&newowner->pi_lock);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\treturn 0;\n\n\t/*\n\t * To handle the page fault we need to drop the locks here. That gives\n\t * the other task (either the highest priority waiter itself or the\n\t * task which stole the rtmutex) the chance to try the fixup of the\n\t * pi_state. So once we are back from handling the fault we need to\n\t * check the pi_state after reacquiring the locks and before trying to\n\t * do another fixup. When the fixup has been done already we simply\n\t * return.\n\t *\n\t * Note: we hold both hb->lock and pi_mutex->wait_lock. We can safely\n\t * drop hb->lock since the caller owns the hb -> futex_q relation.\n\t * Dropping the pi_mutex->wait_lock requires the state revalidate.\n\t */\nhandle_fault:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q->lock_ptr);\n\n\tret = fault_in_user_writeable(uaddr);\n\n\tspin_lock(q->lock_ptr);\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Check if someone else fixed it for us:\n\t */\n\tif (pi_state->owner != oldowner) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tgoto retry;\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fixup_pi_state_owner(u32 __user *uaddr, struct futex_q *q,\n\t\t\t\tstruct task_struct *argowner)\n{\n\tstruct futex_pi_state *pi_state = q->pi_state;\n\tu32 uval, uninitialized_var(curval), newval;\n\tstruct task_struct *oldowner, *newowner;\n\tu32 newtid;\n\tint ret;\n\n\tlockdep_assert_held(q->lock_ptr);\n\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\toldowner = pi_state->owner;\n\n\t/*\n\t * We are here because either:\n\t *\n\t *  - we stole the lock and pi_state->owner needs updating to reflect\n\t *    that (@argowner == current),\n\t *\n\t * or:\n\t *\n\t *  - someone stole our lock and we need to fix things to point to the\n\t *    new owner (@argowner == NULL).\n\t *\n\t * Either way, we have to replace the TID in the user space variable.\n\t * This must be atomic as we have to preserve the owner died bit here.\n\t *\n\t * Note: We write the user space value _before_ changing the pi_state\n\t * because we can fault here. Imagine swapped out pages or a fork\n\t * that marked all the anonymous memory readonly for cow.\n\t *\n\t * Modifying pi_state _before_ the user space value would leave the\n\t * pi_state in an inconsistent state when we fault here, because we\n\t * need to drop the locks to handle the fault. This might be observed\n\t * in the PID check in lookup_pi_state.\n\t */\nretry:\n\tif (!argowner) {\n\t\tif (oldowner != current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (__rt_mutex_futex_trylock(&pi_state->pi_mutex)) {\n\t\t\t/* We got the lock after all, nothing to fix. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Since we just failed the trylock; there must be an owner.\n\t\t */\n\t\tnewowner = rt_mutex_owner(&pi_state->pi_mutex);\n\t\tBUG_ON(!newowner);\n\t} else {\n\t\tWARN_ON_ONCE(argowner != current);\n\t\tif (oldowner == current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tnewowner = argowner;\n\t}\n\n\tnewtid = task_pid_vnr(newowner) | FUTEX_WAITERS;\n\t/* Owner died? */\n\tif (!pi_state->owner)\n\t\tnewtid |= FUTEX_OWNER_DIED;\n\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\tgoto handle_fault;\n\n\tfor (;;) {\n\t\tnewval = (uval & FUTEX_OWNER_DIED) | newtid;\n\n\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\t\tgoto handle_fault;\n\t\tif (curval == uval)\n\t\t\tbreak;\n\t\tuval = curval;\n\t}\n\n\t/*\n\t * We fixed up user space. Now we need to fix the pi_state\n\t * itself.\n\t */\n\tif (pi_state->owner != NULL) {\n\t\traw_spin_lock(&pi_state->owner->pi_lock);\n\t\tWARN_ON(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock(&pi_state->owner->pi_lock);\n\t}\n\n\tpi_state->owner = newowner;\n\n\traw_spin_lock(&newowner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &newowner->pi_state_list);\n\traw_spin_unlock(&newowner->pi_lock);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\treturn 0;\n\n\t/*\n\t * To handle the page fault we need to drop the locks here. That gives\n\t * the other task (either the highest priority waiter itself or the\n\t * task which stole the rtmutex) the chance to try the fixup of the\n\t * pi_state. So once we are back from handling the fault we need to\n\t * check the pi_state after reacquiring the locks and before trying to\n\t * do another fixup. When the fixup has been done already we simply\n\t * return.\n\t *\n\t * Note: we hold both hb->lock and pi_mutex->wait_lock. We can safely\n\t * drop hb->lock since the caller owns the hb -> futex_q relation.\n\t * Dropping the pi_mutex->wait_lock requires the state revalidate.\n\t */\nhandle_fault:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q->lock_ptr);\n\n\tret = fault_in_user_writeable(uaddr);\n\n\tspin_lock(q->lock_ptr);\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Check if someone else fixed it for us:\n\t */\n\tif (pi_state->owner != oldowner) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tgoto retry;\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_early_requeue_pi_wakeup",
          "args": [
            "hb",
            "&q",
            "&key2",
            "to"
          ],
          "line": 3172
        },
        "resolved": true,
        "details": {
          "function_name": "handle_early_requeue_pi_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "3032-3063",
          "snippet": "static inline\nint handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,\n\t\t\t\t   struct futex_q *q, union futex_key *key2,\n\t\t\t\t   struct hrtimer_sleeper *timeout)\n{\n\tint ret = 0;\n\n\t/*\n\t * With the hb lock held, we avoid races while we process the wakeup.\n\t * We only need to hold hb (and not hb2) to ensure atomicity as the\n\t * wakeup code can't change q.key from uaddr to uaddr2 if we hold hb.\n\t * It can't be requeued from uaddr2 to something else since we don't\n\t * support a PI aware source futex for requeue.\n\t */\n\tif (!match_futex(&q->key, key2)) {\n\t\tWARN_ON(q->lock_ptr && (&hb->lock != q->lock_ptr));\n\t\t/*\n\t\t * We were woken prior to requeue by a timeout or a signal.\n\t\t * Unqueue the futex_q and determine which it was.\n\t\t */\n\t\tplist_del(&q->list, &hb->chain);\n\t\thb_waiters_dec(hb);\n\n\t\t/* Handle spurious wakeups gracefully */\n\t\tret = -EWOULDBLOCK;\n\t\tif (timeout && !timeout->task)\n\t\t\tret = -ETIMEDOUT;\n\t\telse if (signal_pending(current))\n\t\t\tret = -ERESTARTNOINTR;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline\nint handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,\n\t\t\t\t   struct futex_q *q, union futex_key *key2,\n\t\t\t\t   struct hrtimer_sleeper *timeout)\n{\n\tint ret = 0;\n\n\t/*\n\t * With the hb lock held, we avoid races while we process the wakeup.\n\t * We only need to hold hb (and not hb2) to ensure atomicity as the\n\t * wakeup code can't change q.key from uaddr to uaddr2 if we hold hb.\n\t * It can't be requeued from uaddr2 to something else since we don't\n\t * support a PI aware source futex for requeue.\n\t */\n\tif (!match_futex(&q->key, key2)) {\n\t\tWARN_ON(q->lock_ptr && (&hb->lock != q->lock_ptr));\n\t\t/*\n\t\t * We were woken prior to requeue by a timeout or a signal.\n\t\t * Unqueue the futex_q and determine which it was.\n\t\t */\n\t\tplist_del(&q->list, &hb->chain);\n\t\thb_waiters_dec(hb);\n\n\t\t/* Handle spurious wakeups gracefully */\n\t\tret = -EWOULDBLOCK;\n\t\tif (timeout && !timeout->task)\n\t\t\tret = -ETIMEDOUT;\n\t\telse if (signal_pending(current))\n\t\t\tret = -ERESTARTNOINTR;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_wait_queue_me",
          "args": [
            "hb",
            "&q",
            "to"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "futex_wait_queue_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2503-2533",
          "snippet": "static void futex_wait_queue_me(struct futex_hash_bucket *hb, struct futex_q *q,\n\t\t\t\tstruct hrtimer_sleeper *timeout)\n{\n\t/*\n\t * The task state is guaranteed to be set before another task can\n\t * wake it. set_current_state() is implemented using smp_store_mb() and\n\t * queue_me() calls spin_unlock() upon completion, both serializing\n\t * access to the hash list and forcing another memory barrier.\n\t */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tqueue_me(q, hb);\n\n\t/* Arm the timer */\n\tif (timeout)\n\t\thrtimer_start_expires(&timeout->timer, HRTIMER_MODE_ABS);\n\n\t/*\n\t * If we have been removed from the hash list, then another task\n\t * has tried to wake us, and we can skip the call to schedule().\n\t */\n\tif (likely(!plist_node_empty(&q->list))) {\n\t\t/*\n\t\t * If the timer has already expired, current will already be\n\t\t * flagged for rescheduling. Only call schedule if there\n\t\t * is no timeout, or if it has yet to expire.\n\t\t */\n\t\tif (!timeout || timeout->task)\n\t\t\tfreezable_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void futex_wait_queue_me(struct futex_hash_bucket *hb, struct futex_q *q,\n\t\t\t\tstruct hrtimer_sleeper *timeout)\n{\n\t/*\n\t * The task state is guaranteed to be set before another task can\n\t * wake it. set_current_state() is implemented using smp_store_mb() and\n\t * queue_me() calls spin_unlock() upon completion, both serializing\n\t * access to the hash list and forcing another memory barrier.\n\t */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tqueue_me(q, hb);\n\n\t/* Arm the timer */\n\tif (timeout)\n\t\thrtimer_start_expires(&timeout->timer, HRTIMER_MODE_ABS);\n\n\t/*\n\t * If we have been removed from the hash list, then another task\n\t * has tried to wake us, and we can skip the call to schedule().\n\t */\n\tif (likely(!plist_node_empty(&q->list))) {\n\t\t/*\n\t\t * If the timer has already expired, current will already be\n\t\t * flagged for rescheduling. Only call schedule if there\n\t\t * is no timeout, or if it has yet to expire.\n\t\t */\n\t\tif (!timeout || timeout->task)\n\t\t\tfreezable_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_unlock",
          "args": [
            "hb"
          ],
          "line": 3163
        },
        "resolved": true,
        "details": {
          "function_name": "queue_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2164-2170",
          "snippet": "static inline void\nqueue_unlock(struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tspin_unlock(&hb->lock);\n\thb_waiters_dec(hb);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void\nqueue_unlock(struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tspin_unlock(&hb->lock);\n\thb_waiters_dec(hb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_futex",
          "args": [
            "&q.key",
            "&key2"
          ],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "match_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "409-415",
          "snippet": "static inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_wait_setup",
          "args": [
            "uaddr",
            "val",
            "flags",
            "&q",
            "&hb"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "futex_wait_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2552-2609",
          "snippet": "static int futex_wait_setup(u32 __user *uaddr, u32 val, unsigned int flags,\n\t\t\t   struct futex_q *q, struct futex_hash_bucket **hb)\n{\n\tu32 uval;\n\tint ret;\n\n\t/*\n\t * Access the page AFTER the hash-bucket is locked.\n\t * Order is important:\n\t *\n\t *   Userspace waiter: val = var; if (cond(val)) futex_wait(&var, val);\n\t *   Userspace waker:  if (cond(var)) { var = new; futex_wake(&var); }\n\t *\n\t * The basic logical guarantee of a futex is that it blocks ONLY\n\t * if cond(var) is known to be true at the time of blocking, for\n\t * any cond.  If we locked the hash-bucket after testing *uaddr, that\n\t * would open a race condition where we could block indefinitely with\n\t * cond(var) false, which would violate the guarantee.\n\t *\n\t * On the other hand, we insert q and release the hash-bucket only\n\t * after testing *uaddr.  This guarantees that futex_wait() will NOT\n\t * absorb a wakeup if *uaddr does not match the desired values\n\t * while the syscall executes.\n\t */\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q->key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\nretry_private:\n\t*hb = queue_lock(q);\n\n\tret = get_futex_value_locked(&uval, uaddr);\n\n\tif (ret) {\n\t\tqueue_unlock(*hb);\n\n\t\tret = get_user(uval, uaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&q->key);\n\t\tgoto retry;\n\t}\n\n\tif (uval != val) {\n\t\tqueue_unlock(*hb);\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout:\n\tif (ret)\n\t\tput_futex_key(&q->key);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_wait_setup(u32 __user *uaddr, u32 val, unsigned int flags,\n\t\t\t   struct futex_q *q, struct futex_hash_bucket **hb)\n{\n\tu32 uval;\n\tint ret;\n\n\t/*\n\t * Access the page AFTER the hash-bucket is locked.\n\t * Order is important:\n\t *\n\t *   Userspace waiter: val = var; if (cond(val)) futex_wait(&var, val);\n\t *   Userspace waker:  if (cond(var)) { var = new; futex_wake(&var); }\n\t *\n\t * The basic logical guarantee of a futex is that it blocks ONLY\n\t * if cond(var) is known to be true at the time of blocking, for\n\t * any cond.  If we locked the hash-bucket after testing *uaddr, that\n\t * would open a race condition where we could block indefinitely with\n\t * cond(var) false, which would violate the guarantee.\n\t *\n\t * On the other hand, we insert q and release the hash-bucket only\n\t * after testing *uaddr.  This guarantees that futex_wait() will NOT\n\t * absorb a wakeup if *uaddr does not match the desired values\n\t * while the syscall executes.\n\t */\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q->key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\nretry_private:\n\t*hb = queue_lock(q);\n\n\tret = get_futex_value_locked(&uval, uaddr);\n\n\tif (ret) {\n\t\tqueue_unlock(*hb);\n\n\t\tret = get_user(uval, uaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&q->key);\n\t\tgoto retry;\n\t}\n\n\tif (uval != val) {\n\t\tqueue_unlock(*hb);\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout:\n\tif (ret)\n\t\tput_futex_key(&q->key);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret != 0"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_futex_key",
          "args": [
            "uaddr2",
            "flags & FLAGS_SHARED",
            "&key2",
            "VERIFY_WRITE"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "499-705",
          "snippet": "static int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_init_waiter",
          "args": [
            "&rt_waiter"
          ],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1149-1155",
          "snippet": "void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tdebug_rt_mutex_init_waiter(waiter);\n\tRB_CLEAR_NODE(&waiter->pi_tree_entry);\n\tRB_CLEAR_NODE(&waiter->tree_entry);\n\twaiter->task = NULL;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tdebug_rt_mutex_init_waiter(waiter);\n\tRB_CLEAR_NODE(&waiter->pi_tree_entry);\n\tRB_CLEAR_NODE(&waiter->tree_entry);\n\twaiter->task = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires_range_ns",
          "args": [
            "&to->timer",
            "*abs_time",
            "current->timer_slack_ns"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_sleeper",
          "args": [
            "to",
            "current"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1651-1655",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init_on_stack",
          "args": [
            "&to->timer",
            "(flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "432-437",
          "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_FUTEX_PI"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define FLAGS_CLOCKRT\t\t0x02\n\nstatic const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};\nstatic long futex_wait_restart(struct restart_block *restart);\n\nstatic int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = FUTEX_KEY_INIT;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (uaddr == uaddr2)\n\t\treturn -EINVAL;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\trt_mutex_init_waiter(&rt_waiter);\n\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (match_futex(&q.key, &key2)) {\n\t\tqueue_unlock(hb);\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current);\n\t\t\tif (ret && rt_mutex_owner(&q.pi_state->pi_mutex) == current) {\n\t\t\t\tpi_state = q.pi_state;\n\t\t\t\tget_pi_state(pi_state);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Drop the reference to the pi state which\n\t\t\t * the requeue_pi() code acquired for us.\n\t\t\t */\n\t\t\tput_pi_state(q.pi_state);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\tstruct rt_mutex *pi_mutex;\n\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_wait_proxy_lock(pi_mutex, to, &rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\tif (ret && !rt_mutex_cleanup_proxy_lock(pi_mutex, &rt_waiter))\n\t\t\tret = 0;\n\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/*\n\t\t * If fixup_pi_state_owner() faulted and was unable to handle\n\t\t * the fault, unlock the rt_mutex and return the fault to\n\t\t * userspace.\n\t\t */\n\t\tif (ret && rt_mutex_owner(&q.pi_state->pi_mutex) == current) {\n\t\t\tpi_state = q.pi_state;\n\t\t\tget_pi_state(pi_state);\n\t\t}\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\tif (pi_state) {\n\t\trt_mutex_futex_unlock(&pi_state->pi_mutex);\n\t\tput_pi_state(pi_state);\n\t}\n\n\tif (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(&q.key);\nout_key2:\n\tput_futex_key(&key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "handle_early_requeue_pi_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3032-3063",
    "snippet": "static inline\nint handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,\n\t\t\t\t   struct futex_q *q, union futex_key *key2,\n\t\t\t\t   struct hrtimer_sleeper *timeout)\n{\n\tint ret = 0;\n\n\t/*\n\t * With the hb lock held, we avoid races while we process the wakeup.\n\t * We only need to hold hb (and not hb2) to ensure atomicity as the\n\t * wakeup code can't change q.key from uaddr to uaddr2 if we hold hb.\n\t * It can't be requeued from uaddr2 to something else since we don't\n\t * support a PI aware source futex for requeue.\n\t */\n\tif (!match_futex(&q->key, key2)) {\n\t\tWARN_ON(q->lock_ptr && (&hb->lock != q->lock_ptr));\n\t\t/*\n\t\t * We were woken prior to requeue by a timeout or a signal.\n\t\t * Unqueue the futex_q and determine which it was.\n\t\t */\n\t\tplist_del(&q->list, &hb->chain);\n\t\thb_waiters_dec(hb);\n\n\t\t/* Handle spurious wakeups gracefully */\n\t\tret = -EWOULDBLOCK;\n\t\tif (timeout && !timeout->task)\n\t\t\tret = -ETIMEDOUT;\n\t\telse if (signal_pending(current))\n\t\t\tret = -ERESTARTNOINTR;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hb_waiters_dec",
          "args": [
            "hb"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "hb_waiters_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "370-375",
          "snippet": "static inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_del",
          "args": [
            "&q->list",
            "&hb->chain"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "q->lock_ptr && (&hb->lock != q->lock_ptr)"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_futex",
          "args": [
            "&q->key",
            "key2"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "match_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "409-415",
          "snippet": "static inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline\nint handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,\n\t\t\t\t   struct futex_q *q, union futex_key *key2,\n\t\t\t\t   struct hrtimer_sleeper *timeout)\n{\n\tint ret = 0;\n\n\t/*\n\t * With the hb lock held, we avoid races while we process the wakeup.\n\t * We only need to hold hb (and not hb2) to ensure atomicity as the\n\t * wakeup code can't change q.key from uaddr to uaddr2 if we hold hb.\n\t * It can't be requeued from uaddr2 to something else since we don't\n\t * support a PI aware source futex for requeue.\n\t */\n\tif (!match_futex(&q->key, key2)) {\n\t\tWARN_ON(q->lock_ptr && (&hb->lock != q->lock_ptr));\n\t\t/*\n\t\t * We were woken prior to requeue by a timeout or a signal.\n\t\t * Unqueue the futex_q and determine which it was.\n\t\t */\n\t\tplist_del(&q->list, &hb->chain);\n\t\thb_waiters_dec(hb);\n\n\t\t/* Handle spurious wakeups gracefully */\n\t\tret = -EWOULDBLOCK;\n\t\tif (timeout && !timeout->task)\n\t\t\tret = -ETIMEDOUT;\n\t\telse if (signal_pending(current))\n\t\t\tret = -ERESTARTNOINTR;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "futex_unlock_pi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2895-3014",
    "snippet": "static int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)\n{\n\tu32 uninitialized_var(curval), uval, vpid = task_pid_vnr(current);\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -EFAULT;\n\t/*\n\t * We release only a lock we actually own:\n\t */\n\tif ((uval & FUTEX_TID_MASK) != vpid)\n\t\treturn -EPERM;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\thb = hash_futex(&key);\n\tspin_lock(&hb->lock);\n\n\t/*\n\t * Check waiters first. We do not trust user space values at\n\t * all and we at least want to know if user space fiddled\n\t * with the futex value instead of blindly unlocking.\n\t */\n\ttop_waiter = futex_top_waiter(hb, &key);\n\tif (top_waiter) {\n\t\tstruct futex_pi_state *pi_state = top_waiter->pi_state;\n\n\t\tret = -EINVAL;\n\t\tif (!pi_state)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * If current does not own the pi_state then the futex is\n\t\t * inconsistent and user space fiddled with the futex value.\n\t\t */\n\t\tif (pi_state->owner != current)\n\t\t\tgoto out_unlock;\n\n\t\tget_pi_state(pi_state);\n\t\t/*\n\t\t * By taking wait_lock while still holding hb->lock, we ensure\n\t\t * there is no point where we hold neither; and therefore\n\t\t * wake_futex_pi() must observe a state consistent with what we\n\t\t * observed.\n\t\t */\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\tspin_unlock(&hb->lock);\n\n\t\t/* drops pi_state->pi_mutex.wait_lock */\n\t\tret = wake_futex_pi(uaddr, uval, pi_state);\n\n\t\tput_pi_state(pi_state);\n\n\t\t/*\n\t\t * Success, we're done! No tricky corner cases.\n\t\t */\n\t\tif (!ret)\n\t\t\tgoto out_putkey;\n\t\t/*\n\t\t * The atomic access to the futex value generated a\n\t\t * pagefault, so retry the user-access and the wakeup:\n\t\t */\n\t\tif (ret == -EFAULT)\n\t\t\tgoto pi_faulted;\n\t\t/*\n\t\t * A unconditional UNLOCK_PI op raced against a waiter\n\t\t * setting the FUTEX_WAITERS bit. Try again.\n\t\t */\n\t\tif (ret == -EAGAIN) {\n\t\t\tput_futex_key(&key);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * wake_futex_pi has detected invalid state. Tell user\n\t\t * space.\n\t\t */\n\t\tgoto out_putkey;\n\t}\n\n\t/*\n\t * We have no kernel internal state, i.e. no waiters in the\n\t * kernel. Waiters which are about to queue themselves are stuck\n\t * on hb->lock. So we can safely ignore them. We do neither\n\t * preserve the WAITERS bit not the OWNER_DIED one. We are the\n\t * owner.\n\t */\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, 0)) {\n\t\tspin_unlock(&hb->lock);\n\t\tgoto pi_faulted;\n\t}\n\n\t/*\n\t * If uval has changed, let user space handle it.\n\t */\n\tret = (curval == uval) ? 0 : -EAGAIN;\n\nout_unlock:\n\tspin_unlock(&hb->lock);\nout_putkey:\n\tput_futex_key(&key);\n\treturn ret;\n\npi_faulted:\n\tput_futex_key(&key);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (!ret)\n\t\tgoto retry;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fault_in_user_writeable",
          "args": [
            "uaddr"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "fault_in_user_writeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "724-735",
          "snippet": "static int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_futex_key",
          "args": [
            "&key"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "put_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "707-710",
          "snippet": "static inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hb->lock"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg_futex_value_locked",
          "args": [
            "&curval",
            "uaddr",
            "uval",
            "0"
          ],
          "line": 2990
        },
        "resolved": true,
        "details": {
          "function_name": "cmpxchg_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "756-766",
          "snippet": "static int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pi_state",
          "args": [
            "pi_state"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "put_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "825-863",
          "snippet": "static void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_futex_pi",
          "args": [
            "uaddr",
            "uval",
            "pi_state"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "wake_futex_pi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1409-1485",
          "snippet": "static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_pi_state *pi_state)\n{\n\tu32 uninitialized_var(curval), newval;\n\tstruct task_struct *new_owner;\n\tbool postunlock = false;\n\tDEFINE_WAKE_Q(wake_q);\n\tint ret = 0;\n\n\tnew_owner = rt_mutex_next_owner(&pi_state->pi_mutex);\n\tif (WARN_ON_ONCE(!new_owner)) {\n\t\t/*\n\t\t * As per the comment in futex_unlock_pi() this should not happen.\n\t\t *\n\t\t * When this happens, give up our locks and try again, giving\n\t\t * the futex_lock_pi() instance time to complete, either by\n\t\t * waiting on the rtmutex or removing itself from the futex\n\t\t * queue.\n\t\t */\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * We pass it to the next owner. The WAITERS bit is always kept\n\t * enabled while there is PI state around. We cleanup the owner\n\t * died bit, because we are the owner.\n\t */\n\tnewval = FUTEX_WAITERS | task_pid_vnr(new_owner);\n\n\tif (unlikely(should_fail_futex(true)))\n\t\tret = -EFAULT;\n\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)) {\n\t\tret = -EFAULT;\n\n\t} else if (curval != uval) {\n\t\t/*\n\t\t * If a unconditional UNLOCK_PI operation (user space did not\n\t\t * try the TID->0 transition) raced with a waiter setting the\n\t\t * FUTEX_WAITERS flag between get_user() and locking the hash\n\t\t * bucket lock, retry the operation.\n\t\t */\n\t\tif ((FUTEX_TID_MASK & curval) == uval)\n\t\t\tret = -EAGAIN;\n\t\telse\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/*\n\t * This is a point of no return; once we modify the uval there is no\n\t * going back and subsequent operations must not fail.\n\t */\n\n\traw_spin_lock(&pi_state->owner->pi_lock);\n\tWARN_ON(list_empty(&pi_state->list));\n\tlist_del_init(&pi_state->list);\n\traw_spin_unlock(&pi_state->owner->pi_lock);\n\n\traw_spin_lock(&new_owner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &new_owner->pi_state_list);\n\tpi_state->owner = new_owner;\n\traw_spin_unlock(&new_owner->pi_lock);\n\n\tpostunlock = __rt_mutex_futex_unlock(&pi_state->pi_mutex, &wake_q);\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_pi_state *pi_state)\n{\n\tu32 uninitialized_var(curval), newval;\n\tstruct task_struct *new_owner;\n\tbool postunlock = false;\n\tDEFINE_WAKE_Q(wake_q);\n\tint ret = 0;\n\n\tnew_owner = rt_mutex_next_owner(&pi_state->pi_mutex);\n\tif (WARN_ON_ONCE(!new_owner)) {\n\t\t/*\n\t\t * As per the comment in futex_unlock_pi() this should not happen.\n\t\t *\n\t\t * When this happens, give up our locks and try again, giving\n\t\t * the futex_lock_pi() instance time to complete, either by\n\t\t * waiting on the rtmutex or removing itself from the futex\n\t\t * queue.\n\t\t */\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * We pass it to the next owner. The WAITERS bit is always kept\n\t * enabled while there is PI state around. We cleanup the owner\n\t * died bit, because we are the owner.\n\t */\n\tnewval = FUTEX_WAITERS | task_pid_vnr(new_owner);\n\n\tif (unlikely(should_fail_futex(true)))\n\t\tret = -EFAULT;\n\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)) {\n\t\tret = -EFAULT;\n\n\t} else if (curval != uval) {\n\t\t/*\n\t\t * If a unconditional UNLOCK_PI operation (user space did not\n\t\t * try the TID->0 transition) raced with a waiter setting the\n\t\t * FUTEX_WAITERS flag between get_user() and locking the hash\n\t\t * bucket lock, retry the operation.\n\t\t */\n\t\tif ((FUTEX_TID_MASK & curval) == uval)\n\t\t\tret = -EAGAIN;\n\t\telse\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/*\n\t * This is a point of no return; once we modify the uval there is no\n\t * going back and subsequent operations must not fail.\n\t */\n\n\traw_spin_lock(&pi_state->owner->pi_lock);\n\tWARN_ON(list_empty(&pi_state->list));\n\tlist_del_init(&pi_state->list);\n\traw_spin_unlock(&pi_state->owner->pi_lock);\n\n\traw_spin_lock(&new_owner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &new_owner->pi_state_list);\n\tpi_state->owner = new_owner;\n\traw_spin_unlock(&new_owner->pi_lock);\n\n\tpostunlock = __rt_mutex_futex_unlock(&pi_state->pi_mutex, &wake_q);\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pi_state->pi_mutex.wait_lock"
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pi_state",
          "args": [
            "pi_state"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "get_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "816-819",
          "snippet": "static void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_top_waiter",
          "args": [
            "hb",
            "&key"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "futex_top_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "744-754",
          "snippet": "static struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hb->lock"
          ],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_futex",
          "args": [
            "&key"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "hash_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "393-399",
          "snippet": "static struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define futex_hashsize (__futex_data.hashsize)",
            "#define futex_queues   (__futex_data.queues)"
          ],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define futex_hashsize (__futex_data.hashsize)\n#define futex_queues   (__futex_data.queues)\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_futex_key",
          "args": [
            "uaddr",
            "flags & FLAGS_SHARED",
            "&key",
            "VERIFY_WRITE"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "499-705",
          "snippet": "static int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "uval",
            "uaddr"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_FUTEX_PI"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)\n{\n\tu32 uninitialized_var(curval), uval, vpid = task_pid_vnr(current);\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -EFAULT;\n\t/*\n\t * We release only a lock we actually own:\n\t */\n\tif ((uval & FUTEX_TID_MASK) != vpid)\n\t\treturn -EPERM;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\thb = hash_futex(&key);\n\tspin_lock(&hb->lock);\n\n\t/*\n\t * Check waiters first. We do not trust user space values at\n\t * all and we at least want to know if user space fiddled\n\t * with the futex value instead of blindly unlocking.\n\t */\n\ttop_waiter = futex_top_waiter(hb, &key);\n\tif (top_waiter) {\n\t\tstruct futex_pi_state *pi_state = top_waiter->pi_state;\n\n\t\tret = -EINVAL;\n\t\tif (!pi_state)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * If current does not own the pi_state then the futex is\n\t\t * inconsistent and user space fiddled with the futex value.\n\t\t */\n\t\tif (pi_state->owner != current)\n\t\t\tgoto out_unlock;\n\n\t\tget_pi_state(pi_state);\n\t\t/*\n\t\t * By taking wait_lock while still holding hb->lock, we ensure\n\t\t * there is no point where we hold neither; and therefore\n\t\t * wake_futex_pi() must observe a state consistent with what we\n\t\t * observed.\n\t\t */\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\tspin_unlock(&hb->lock);\n\n\t\t/* drops pi_state->pi_mutex.wait_lock */\n\t\tret = wake_futex_pi(uaddr, uval, pi_state);\n\n\t\tput_pi_state(pi_state);\n\n\t\t/*\n\t\t * Success, we're done! No tricky corner cases.\n\t\t */\n\t\tif (!ret)\n\t\t\tgoto out_putkey;\n\t\t/*\n\t\t * The atomic access to the futex value generated a\n\t\t * pagefault, so retry the user-access and the wakeup:\n\t\t */\n\t\tif (ret == -EFAULT)\n\t\t\tgoto pi_faulted;\n\t\t/*\n\t\t * A unconditional UNLOCK_PI op raced against a waiter\n\t\t * setting the FUTEX_WAITERS bit. Try again.\n\t\t */\n\t\tif (ret == -EAGAIN) {\n\t\t\tput_futex_key(&key);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * wake_futex_pi has detected invalid state. Tell user\n\t\t * space.\n\t\t */\n\t\tgoto out_putkey;\n\t}\n\n\t/*\n\t * We have no kernel internal state, i.e. no waiters in the\n\t * kernel. Waiters which are about to queue themselves are stuck\n\t * on hb->lock. So we can safely ignore them. We do neither\n\t * preserve the WAITERS bit not the OWNER_DIED one. We are the\n\t * owner.\n\t */\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, 0)) {\n\t\tspin_unlock(&hb->lock);\n\t\tgoto pi_faulted;\n\t}\n\n\t/*\n\t * If uval has changed, let user space handle it.\n\t */\n\tret = (curval == uval) ? 0 : -EAGAIN;\n\nout_unlock:\n\tspin_unlock(&hb->lock);\nout_putkey:\n\tput_futex_key(&key);\n\treturn ret;\n\npi_faulted:\n\tput_futex_key(&key);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (!ret)\n\t\tgoto retry;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "futex_lock_pi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2711-2888",
    "snippet": "static int futex_lock_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t ktime_t *time, int trylock)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (refill_pi_state_cache())\n\t\treturn -ENOMEM;\n\n\tif (time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, CLOCK_REALTIME,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires(&to->timer, *time);\n\t}\n\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q.key, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = queue_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current, 0);\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * Atomic work succeeded and we got the lock,\n\t\t * or failed. Either way, we do _not_ block.\n\t\t */\n\t\tswitch (ret) {\n\t\tcase 1:\n\t\t\t/* We got the lock. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_put_key;\n\t\tcase -EFAULT:\n\t\t\tgoto uaddr_faulted;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Task is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tqueue_unlock(hb);\n\t\t\tput_futex_key(&q.key);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock_put_key;\n\t\t}\n\t}\n\n\tWARN_ON(!q.pi_state);\n\n\t/*\n\t * Only actually queue now that the atomic ops are done:\n\t */\n\t__queue_me(&q, hb);\n\n\tif (trylock) {\n\t\tret = rt_mutex_futex_trylock(&q.pi_state->pi_mutex);\n\t\t/* Fixup the trylock return value: */\n\t\tret = ret ? 0 : -EWOULDBLOCK;\n\t\tgoto no_block;\n\t}\n\n\trt_mutex_init_waiter(&rt_waiter);\n\n\t/*\n\t * On PREEMPT_RT_FULL, when hb->lock becomes an rt_mutex, we must not\n\t * hold it while doing rt_mutex_start_proxy(), because then it will\n\t * include hb->lock in the blocking chain, even through we'll not in\n\t * fact hold it while blocking. This will lead it to report -EDEADLK\n\t * and BUG when futex_unlock_pi() interleaves with this.\n\t *\n\t * Therefore acquire wait_lock while holding hb->lock, but drop the\n\t * latter before calling rt_mutex_start_proxy_lock(). This still fully\n\t * serializes against futex_unlock_pi() as that does the exact same\n\t * lock handoff sequence.\n\t */\n\traw_spin_lock_irq(&q.pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q.lock_ptr);\n\tret = __rt_mutex_start_proxy_lock(&q.pi_state->pi_mutex, &rt_waiter, current);\n\traw_spin_unlock_irq(&q.pi_state->pi_mutex.wait_lock);\n\n\tif (ret) {\n\t\tif (ret == 1)\n\t\t\tret = 0;\n\n\t\tspin_lock(q.lock_ptr);\n\t\tgoto no_block;\n\t}\n\n\n\tif (unlikely(to))\n\t\thrtimer_start_expires(&to->timer, HRTIMER_MODE_ABS);\n\n\tret = rt_mutex_wait_proxy_lock(&q.pi_state->pi_mutex, to, &rt_waiter);\n\n\tspin_lock(q.lock_ptr);\n\t/*\n\t * If we failed to acquire the lock (signal/timeout), we must\n\t * first acquire the hb->lock before removing the lock from the\n\t * rt_mutex waitqueue, such that we can keep the hb and rt_mutex\n\t * wait lists consistent.\n\t *\n\t * In particular; it is important that futex_unlock_pi() can not\n\t * observe this inconsistency.\n\t */\n\tif (ret && !rt_mutex_cleanup_proxy_lock(&q.pi_state->pi_mutex, &rt_waiter))\n\t\tret = 0;\n\nno_block:\n\t/*\n\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t * haven't already.\n\t */\n\tres = fixup_owner(uaddr, &q, !ret);\n\t/*\n\t * If fixup_owner() returned an error, proprogate that.  If it acquired\n\t * the lock, clear our -ETIMEDOUT or -EINTR.\n\t */\n\tif (res)\n\t\tret = (res < 0) ? res : 0;\n\n\t/*\n\t * If fixup_owner() faulted and was unable to handle the fault, unlock\n\t * it and return the fault to userspace.\n\t */\n\tif (ret && (rt_mutex_owner(&q.pi_state->pi_mutex) == current)) {\n\t\tpi_state = q.pi_state;\n\t\tget_pi_state(pi_state);\n\t}\n\n\t/* Unqueue and drop the lock */\n\tunqueue_me_pi(&q);\n\n\tif (pi_state) {\n\t\trt_mutex_futex_unlock(&pi_state->pi_mutex);\n\t\tput_pi_state(pi_state);\n\t}\n\n\tgoto out_put_key;\n\nout_unlock_put_key:\n\tqueue_unlock(hb);\n\nout_put_key:\n\tput_futex_key(&q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret != -EINTR ? ret : -ERESTARTNOINTR;\n\nuaddr_faulted:\n\tqueue_unlock(hb);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (ret)\n\t\tgoto out_put_key;\n\n\tif (!(flags & FLAGS_SHARED))\n\t\tgoto retry_private;\n\n\tput_futex_key(&q.key);\n\tgoto retry;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_futex_key",
          "args": [
            "&q.key"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "put_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "707-710",
          "snippet": "static inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fault_in_user_writeable",
          "args": [
            "uaddr"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "fault_in_user_writeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "724-735",
          "snippet": "static int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_unlock",
          "args": [
            "hb"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "queue_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2164-2170",
          "snippet": "static inline void\nqueue_unlock(struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tspin_unlock(&hb->lock);\n\thb_waiters_dec(hb);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void\nqueue_unlock(struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tspin_unlock(&hb->lock);\n\thb_waiters_dec(hb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&to->timer"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "440-443",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&to->timer"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pi_state",
          "args": [
            "pi_state"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "put_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "825-863",
          "snippet": "static void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_futex_unlock",
          "args": [
            "&pi_state->pi_mutex"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_futex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1636-1648",
          "snippet": "void __sched rt_mutex_futex_unlock(struct rt_mutex *lock)\n{\n\tDEFINE_WAKE_Q(wake_q);\n\tunsigned long flags;\n\tbool postunlock;\n\n\traw_spin_lock_irqsave(&lock->wait_lock, flags);\n\tpostunlock = __rt_mutex_futex_unlock(lock, &wake_q);\n\traw_spin_unlock_irqrestore(&lock->wait_lock, flags);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_futex_unlock(struct rt_mutex *lock)\n{\n\tDEFINE_WAKE_Q(wake_q);\n\tunsigned long flags;\n\tbool postunlock;\n\n\traw_spin_lock_irqsave(&lock->wait_lock, flags);\n\tpostunlock = __rt_mutex_futex_unlock(lock, &wake_q);\n\traw_spin_unlock_irqrestore(&lock->wait_lock, flags);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unqueue_me_pi",
          "args": [
            "&q"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "unqueue_me_pi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2270-2280",
          "snippet": "static void unqueue_me_pi(struct futex_q *q)\n\t__releases(q->lock_ptr)\n{\n\t__unqueue_futex(q);\n\n\tBUG_ON(!q->pi_state);\n\tput_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void unqueue_me_pi(struct futex_q *q)\n\t__releases(q->lock_ptr)\n{\n\t__unqueue_futex(q);\n\n\tBUG_ON(!q->pi_state);\n\tput_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pi_state",
          "args": [
            "pi_state"
          ],
          "line": 2851
        },
        "resolved": true,
        "details": {
          "function_name": "get_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "816-819",
          "snippet": "static void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_owner",
          "args": [
            "&q.pi_state->pi_mutex"
          ],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex_common.h",
          "lines": "108-113",
          "snippet": "static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}",
          "includes": [
            "# include \"rtmutex.h\"",
            "# include \"rtmutex-debug.h\"",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>"
          ],
          "macros_used": [
            "#define RT_MUTEX_HAS_WAITERS\t1UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"rtmutex.h\"\n# include \"rtmutex-debug.h\"\n#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n\n#define RT_MUTEX_HAS_WAITERS\t1UL\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_owner",
          "args": [
            "uaddr",
            "&q",
            "!ret"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2451-2495",
          "snippet": "static int fixup_owner(u32 __user *uaddr, struct futex_q *q, int locked)\n{\n\tint ret = 0;\n\n\tif (locked) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case:\n\t\t *\n\t\t * Speculative pi_state->owner read (we don't hold wait_lock);\n\t\t * since we own the lock pi_state->owner == current is the\n\t\t * stable state, anything else needs more attention.\n\t\t */\n\t\tif (q->pi_state->owner != current)\n\t\t\tret = fixup_pi_state_owner(uaddr, q, current);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we didn't get the lock; check if anybody stole it from us. In\n\t * that case, we need to fix up the uval to point to them instead of\n\t * us, otherwise bad things happen. [10]\n\t *\n\t * Another speculative read; pi_state->owner == current is unstable\n\t * but needs our attention.\n\t */\n\tif (q->pi_state->owner == current) {\n\t\tret = fixup_pi_state_owner(uaddr, q, NULL);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Paranoia check. If we did not take the lock, then we should not be\n\t * the owner of the rt_mutex.\n\t */\n\tif (rt_mutex_owner(&q->pi_state->pi_mutex) == current) {\n\t\tprintk(KERN_ERR \"fixup_owner: ret = %d pi-mutex: %p \"\n\t\t\t\t\"pi-state %p\\n\", ret,\n\t\t\t\tq->pi_state->pi_mutex.owner,\n\t\t\t\tq->pi_state->owner);\n\t}\n\nout:\n\treturn ret ? ret : locked;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fixup_owner(u32 __user *uaddr, struct futex_q *q, int locked)\n{\n\tint ret = 0;\n\n\tif (locked) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case:\n\t\t *\n\t\t * Speculative pi_state->owner read (we don't hold wait_lock);\n\t\t * since we own the lock pi_state->owner == current is the\n\t\t * stable state, anything else needs more attention.\n\t\t */\n\t\tif (q->pi_state->owner != current)\n\t\t\tret = fixup_pi_state_owner(uaddr, q, current);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we didn't get the lock; check if anybody stole it from us. In\n\t * that case, we need to fix up the uval to point to them instead of\n\t * us, otherwise bad things happen. [10]\n\t *\n\t * Another speculative read; pi_state->owner == current is unstable\n\t * but needs our attention.\n\t */\n\tif (q->pi_state->owner == current) {\n\t\tret = fixup_pi_state_owner(uaddr, q, NULL);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Paranoia check. If we did not take the lock, then we should not be\n\t * the owner of the rt_mutex.\n\t */\n\tif (rt_mutex_owner(&q->pi_state->pi_mutex) == current) {\n\t\tprintk(KERN_ERR \"fixup_owner: ret = %d pi-mutex: %p \"\n\t\t\t\t\"pi-state %p\\n\", ret,\n\t\t\t\tq->pi_state->pi_mutex.owner,\n\t\t\t\tq->pi_state->owner);\n\t}\n\nout:\n\treturn ret ? ret : locked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_cleanup_proxy_lock",
          "args": [
            "&q.pi_state->pi_mutex",
            "&rt_waiter"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_cleanup_proxy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1862-1897",
          "snippet": "bool rt_mutex_cleanup_proxy_lock(struct rt_mutex *lock,\n\t\t\t\t struct rt_mutex_waiter *waiter)\n{\n\tbool cleanup = false;\n\n\traw_spin_lock_irq(&lock->wait_lock);\n\t/*\n\t * Do an unconditional try-lock, this deals with the lock stealing\n\t * state where __rt_mutex_futex_unlock() -> mark_wakeup_next_waiter()\n\t * sets a NULL owner.\n\t *\n\t * We're not interested in the return value, because the subsequent\n\t * test on rt_mutex_owner() will infer that. If the trylock succeeded,\n\t * we will own the lock and it will have removed the waiter. If we\n\t * failed the trylock, we're still not owner and we need to remove\n\t * ourselves.\n\t */\n\ttry_to_take_rt_mutex(lock, current, waiter);\n\t/*\n\t * Unless we're the owner; we're still enqueued on the wait_list.\n\t * So check if we became owner, if not, take us off the wait_list.\n\t */\n\tif (rt_mutex_owner(lock) != current) {\n\t\tremove_waiter(lock, waiter);\n\t\tcleanup = true;\n\t}\n\t/*\n\t * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might\n\t * have to fix that up.\n\t */\n\tfixup_rt_mutex_waiters(lock);\n\n\traw_spin_unlock_irq(&lock->wait_lock);\n\n\treturn cleanup;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nbool rt_mutex_cleanup_proxy_lock(struct rt_mutex *lock,\n\t\t\t\t struct rt_mutex_waiter *waiter)\n{\n\tbool cleanup = false;\n\n\traw_spin_lock_irq(&lock->wait_lock);\n\t/*\n\t * Do an unconditional try-lock, this deals with the lock stealing\n\t * state where __rt_mutex_futex_unlock() -> mark_wakeup_next_waiter()\n\t * sets a NULL owner.\n\t *\n\t * We're not interested in the return value, because the subsequent\n\t * test on rt_mutex_owner() will infer that. If the trylock succeeded,\n\t * we will own the lock and it will have removed the waiter. If we\n\t * failed the trylock, we're still not owner and we need to remove\n\t * ourselves.\n\t */\n\ttry_to_take_rt_mutex(lock, current, waiter);\n\t/*\n\t * Unless we're the owner; we're still enqueued on the wait_list.\n\t * So check if we became owner, if not, take us off the wait_list.\n\t */\n\tif (rt_mutex_owner(lock) != current) {\n\t\tremove_waiter(lock, waiter);\n\t\tcleanup = true;\n\t}\n\t/*\n\t * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might\n\t * have to fix that up.\n\t */\n\tfixup_rt_mutex_waiters(lock);\n\n\traw_spin_unlock_irq(&lock->wait_lock);\n\n\treturn cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "q.lock_ptr"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_wait_proxy_lock",
          "args": [
            "&q.pi_state->pi_mutex",
            "to",
            "&rt_waiter"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_wait_proxy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1823-1841",
          "snippet": "int rt_mutex_wait_proxy_lock(struct rt_mutex *lock,\n\t\t\t       struct hrtimer_sleeper *to,\n\t\t\t       struct rt_mutex_waiter *waiter)\n{\n\tint ret;\n\n\traw_spin_lock_irq(&lock->wait_lock);\n\t/* sleep on the mutex */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tret = __rt_mutex_slowlock(lock, TASK_INTERRUPTIBLE, to, waiter);\n\t/*\n\t * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might\n\t * have to fix that up.\n\t */\n\tfixup_rt_mutex_waiters(lock);\n\traw_spin_unlock_irq(&lock->wait_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint rt_mutex_wait_proxy_lock(struct rt_mutex *lock,\n\t\t\t       struct hrtimer_sleeper *to,\n\t\t\t       struct rt_mutex_waiter *waiter)\n{\n\tint ret;\n\n\traw_spin_lock_irq(&lock->wait_lock);\n\t/* sleep on the mutex */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tret = __rt_mutex_slowlock(lock, TASK_INTERRUPTIBLE, to, waiter);\n\t/*\n\t * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might\n\t * have to fix that up.\n\t */\n\tfixup_rt_mutex_waiters(lock);\n\traw_spin_unlock_irq(&lock->wait_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "&to->timer",
            "HRTIMER_MODE_ABS"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "to"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&q.pi_state->pi_mutex.wait_lock"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rt_mutex_start_proxy_lock",
          "args": [
            "&q.pi_state->pi_mutex",
            "&rt_waiter",
            "current"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_start_proxy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1729-1758",
          "snippet": "int __rt_mutex_start_proxy_lock(struct rt_mutex *lock,\n\t\t\t      struct rt_mutex_waiter *waiter,\n\t\t\t      struct task_struct *task)\n{\n\tint ret;\n\n\tif (try_to_take_rt_mutex(lock, task, NULL))\n\t\treturn 1;\n\n\t/* We enforce deadlock detection for futexes */\n\tret = task_blocks_on_rt_mutex(lock, waiter, task,\n\t\t\t\t      RT_MUTEX_FULL_CHAINWALK);\n\n\tif (ret && !rt_mutex_owner(lock)) {\n\t\t/*\n\t\t * Reset the return value. We might have\n\t\t * returned with -EDEADLK and the owner\n\t\t * released the lock while we were walking the\n\t\t * pi chain.  Let the waiter sort it out.\n\t\t */\n\t\tret = 0;\n\t}\n\n\tif (unlikely(ret))\n\t\tremove_waiter(lock, waiter);\n\n\tdebug_rt_mutex_print_deadlock(waiter);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __rt_mutex_start_proxy_lock(struct rt_mutex *lock,\n\t\t\t      struct rt_mutex_waiter *waiter,\n\t\t\t      struct task_struct *task)\n{\n\tint ret;\n\n\tif (try_to_take_rt_mutex(lock, task, NULL))\n\t\treturn 1;\n\n\t/* We enforce deadlock detection for futexes */\n\tret = task_blocks_on_rt_mutex(lock, waiter, task,\n\t\t\t\t      RT_MUTEX_FULL_CHAINWALK);\n\n\tif (ret && !rt_mutex_owner(lock)) {\n\t\t/*\n\t\t * Reset the return value. We might have\n\t\t * returned with -EDEADLK and the owner\n\t\t * released the lock while we were walking the\n\t\t * pi chain.  Let the waiter sort it out.\n\t\t */\n\t\tret = 0;\n\t}\n\n\tif (unlikely(ret))\n\t\tremove_waiter(lock, waiter);\n\n\tdebug_rt_mutex_print_deadlock(waiter);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "q.lock_ptr"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&q.pi_state->pi_mutex.wait_lock"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_init_waiter",
          "args": [
            "&rt_waiter"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1149-1155",
          "snippet": "void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tdebug_rt_mutex_init_waiter(waiter);\n\tRB_CLEAR_NODE(&waiter->pi_tree_entry);\n\tRB_CLEAR_NODE(&waiter->tree_entry);\n\twaiter->task = NULL;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tdebug_rt_mutex_init_waiter(waiter);\n\tRB_CLEAR_NODE(&waiter->pi_tree_entry);\n\tRB_CLEAR_NODE(&waiter->tree_entry);\n\twaiter->task = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_futex_trylock",
          "args": [
            "&q.pi_state->pi_mutex"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_futex_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1535-1538",
          "snippet": "int __sched __rt_mutex_futex_trylock(struct rt_mutex *lock)\n{\n\treturn __rt_mutex_slowtrylock(lock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched __rt_mutex_futex_trylock(struct rt_mutex *lock)\n{\n\treturn __rt_mutex_slowtrylock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__queue_me",
          "args": [
            "&q",
            "hb"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2172-2189",
          "snippet": "static inline void __queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tint prio;\n\n\t/*\n\t * The priority used to register this element is\n\t * - either the real thread-priority for the real-time threads\n\t * (i.e. threads with a priority lower than MAX_RT_PRIO)\n\t * - or MAX_RT_PRIO for non-RT threads.\n\t * Thus, all RT-threads are woken first in priority order, and\n\t * the others are woken last, in FIFO order.\n\t */\n\tprio = min(current->normal_prio, MAX_RT_PRIO);\n\n\tplist_node_init(&q->list, prio);\n\tplist_add(&q->list, &hb->chain);\n\tq->task = current;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void __queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tint prio;\n\n\t/*\n\t * The priority used to register this element is\n\t * - either the real thread-priority for the real-time threads\n\t * (i.e. threads with a priority lower than MAX_RT_PRIO)\n\t * - or MAX_RT_PRIO for non-RT threads.\n\t * Thus, all RT-threads are woken first in priority order, and\n\t * the others are woken last, in FIFO order.\n\t */\n\tprio = min(current->normal_prio, MAX_RT_PRIO);\n\n\tplist_node_init(&q->list, prio);\n\tplist_add(&q->list, &hb->chain);\n\tq->task = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!q.pi_state"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "futex_lock_pi_atomic",
          "args": [
            "uaddr",
            "hb",
            "&q.key",
            "&q.pi_state",
            "current",
            "0"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "futex_lock_pi_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1282-1356",
          "snippet": "static int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,\n\t\t\t\tunion futex_key *key,\n\t\t\t\tstruct futex_pi_state **ps,\n\t\t\t\tstruct task_struct *task, int set_waiters)\n{\n\tu32 uval, newval, vpid = task_pid_vnr(task);\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\t/*\n\t * Read the user space value first so we can validate a few\n\t * things before proceeding further.\n\t */\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Detect deadlocks.\n\t */\n\tif ((unlikely((uval & FUTEX_TID_MASK) == vpid)))\n\t\treturn -EDEADLK;\n\n\tif ((unlikely(should_fail_futex(true))))\n\t\treturn -EDEADLK;\n\n\t/*\n\t * Lookup existing state first. If it exists, try to attach to\n\t * its pi_state.\n\t */\n\ttop_waiter = futex_top_waiter(hb, key);\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * No waiter and user TID is 0. We are here because the\n\t * waiters or the owner died bit is set or called from\n\t * requeue_cmp_pi or for whatever reason something took the\n\t * syscall.\n\t */\n\tif (!(uval & FUTEX_TID_MASK)) {\n\t\t/*\n\t\t * We take over the futex. No other waiters and the user space\n\t\t * TID is 0. We preserve the owner died bit.\n\t\t */\n\t\tnewval = uval & FUTEX_OWNER_DIED;\n\t\tnewval |= vpid;\n\n\t\t/* The futex requeue_pi code can enforce the waiters bit */\n\t\tif (set_waiters)\n\t\t\tnewval |= FUTEX_WAITERS;\n\n\t\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\t\t/* If the take over worked, return 1 */\n\t\treturn ret < 0 ? ret : 1;\n\t}\n\n\t/*\n\t * First waiter. Set the waiters bit before attaching ourself to\n\t * the owner. If owner tries to unlock, it will be forced into\n\t * the kernel and blocked on hb->lock.\n\t */\n\tnewval = uval | FUTEX_WAITERS;\n\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * If the update of the user space value succeeded, we try to\n\t * attach to the owner. If that fails, no harm done, we only\n\t * set the FUTEX_WAITERS bit in the user space variable.\n\t */\n\treturn attach_to_pi_owner(uval, key, ps);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,\n\t\t\t\tunion futex_key *key,\n\t\t\t\tstruct futex_pi_state **ps,\n\t\t\t\tstruct task_struct *task, int set_waiters)\n{\n\tu32 uval, newval, vpid = task_pid_vnr(task);\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\t/*\n\t * Read the user space value first so we can validate a few\n\t * things before proceeding further.\n\t */\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Detect deadlocks.\n\t */\n\tif ((unlikely((uval & FUTEX_TID_MASK) == vpid)))\n\t\treturn -EDEADLK;\n\n\tif ((unlikely(should_fail_futex(true))))\n\t\treturn -EDEADLK;\n\n\t/*\n\t * Lookup existing state first. If it exists, try to attach to\n\t * its pi_state.\n\t */\n\ttop_waiter = futex_top_waiter(hb, key);\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * No waiter and user TID is 0. We are here because the\n\t * waiters or the owner died bit is set or called from\n\t * requeue_cmp_pi or for whatever reason something took the\n\t * syscall.\n\t */\n\tif (!(uval & FUTEX_TID_MASK)) {\n\t\t/*\n\t\t * We take over the futex. No other waiters and the user space\n\t\t * TID is 0. We preserve the owner died bit.\n\t\t */\n\t\tnewval = uval & FUTEX_OWNER_DIED;\n\t\tnewval |= vpid;\n\n\t\t/* The futex requeue_pi code can enforce the waiters bit */\n\t\tif (set_waiters)\n\t\t\tnewval |= FUTEX_WAITERS;\n\n\t\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\t\t/* If the take over worked, return 1 */\n\t\treturn ret < 0 ? ret : 1;\n\t}\n\n\t/*\n\t * First waiter. Set the waiters bit before attaching ourself to\n\t * the owner. If owner tries to unlock, it will be forced into\n\t * the kernel and blocked on hb->lock.\n\t */\n\tnewval = uval | FUTEX_WAITERS;\n\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * If the update of the user space value succeeded, we try to\n\t * attach to the owner. If that fails, no harm done, we only\n\t * set the FUTEX_WAITERS bit in the user space variable.\n\t */\n\treturn attach_to_pi_owner(uval, key, ps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_lock",
          "args": [
            "&q"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "queue_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2141-2162",
          "snippet": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n\t__acquires(&hb->lock)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\n\t/*\n\t * Increment the counter before taking the lock so that\n\t * a potential waker won't miss a to-be-slept task that is\n\t * waiting for the spinlock. This is safe as all queue_lock()\n\t * users end up calling queue_me(). Similarly, for housekeeping,\n\t * decrement the counter at queue_unlock() when some error has\n\t * occurred and we don't end up adding the task to the list.\n\t */\n\thb_waiters_inc(hb);\n\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock); /* implies smp_mb(); (A) */\n\treturn hb;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n\t__acquires(&hb->lock)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\n\t/*\n\t * Increment the counter before taking the lock so that\n\t * a potential waker won't miss a to-be-slept task that is\n\t * waiting for the spinlock. This is safe as all queue_lock()\n\t * users end up calling queue_me(). Similarly, for housekeeping,\n\t * decrement the counter at queue_unlock() when some error has\n\t * occurred and we don't end up adding the task to the list.\n\t */\n\thb_waiters_inc(hb);\n\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock); /* implies smp_mb(); (A) */\n\treturn hb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret != 0"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_futex_key",
          "args": [
            "uaddr",
            "flags & FLAGS_SHARED",
            "&q.key",
            "VERIFY_WRITE"
          ],
          "line": 2736
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "499-705",
          "snippet": "static int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&to->timer",
            "*time"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_sleeper",
          "args": [
            "to",
            "current"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1651-1655",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init_on_stack",
          "args": [
            "&to->timer",
            "CLOCK_REALTIME",
            "HRTIMER_MODE_ABS"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "432-437",
          "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refill_pi_state_cache",
          "args": [],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "refill_pi_state_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "783-804",
          "snippet": "static int refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), GFP_KERNEL);\n\n\tif (!pi_state)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pi_state->list);\n\t/* pi_mutex gets initialized later */\n\tpi_state->owner = NULL;\n\tatomic_set(&pi_state->refcount, 1);\n\tpi_state->key = FUTEX_KEY_INIT;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), GFP_KERNEL);\n\n\tif (!pi_state)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pi_state->list);\n\t/* pi_mutex gets initialized later */\n\tpi_state->owner = NULL;\n\tatomic_set(&pi_state->refcount, 1);\n\tpi_state->key = FUTEX_KEY_INIT;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_FUTEX_PI"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};\n\nstatic int futex_lock_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t ktime_t *time, int trylock)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (refill_pi_state_cache())\n\t\treturn -ENOMEM;\n\n\tif (time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, CLOCK_REALTIME,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires(&to->timer, *time);\n\t}\n\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q.key, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = queue_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current, 0);\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * Atomic work succeeded and we got the lock,\n\t\t * or failed. Either way, we do _not_ block.\n\t\t */\n\t\tswitch (ret) {\n\t\tcase 1:\n\t\t\t/* We got the lock. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_put_key;\n\t\tcase -EFAULT:\n\t\t\tgoto uaddr_faulted;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Task is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tqueue_unlock(hb);\n\t\t\tput_futex_key(&q.key);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock_put_key;\n\t\t}\n\t}\n\n\tWARN_ON(!q.pi_state);\n\n\t/*\n\t * Only actually queue now that the atomic ops are done:\n\t */\n\t__queue_me(&q, hb);\n\n\tif (trylock) {\n\t\tret = rt_mutex_futex_trylock(&q.pi_state->pi_mutex);\n\t\t/* Fixup the trylock return value: */\n\t\tret = ret ? 0 : -EWOULDBLOCK;\n\t\tgoto no_block;\n\t}\n\n\trt_mutex_init_waiter(&rt_waiter);\n\n\t/*\n\t * On PREEMPT_RT_FULL, when hb->lock becomes an rt_mutex, we must not\n\t * hold it while doing rt_mutex_start_proxy(), because then it will\n\t * include hb->lock in the blocking chain, even through we'll not in\n\t * fact hold it while blocking. This will lead it to report -EDEADLK\n\t * and BUG when futex_unlock_pi() interleaves with this.\n\t *\n\t * Therefore acquire wait_lock while holding hb->lock, but drop the\n\t * latter before calling rt_mutex_start_proxy_lock(). This still fully\n\t * serializes against futex_unlock_pi() as that does the exact same\n\t * lock handoff sequence.\n\t */\n\traw_spin_lock_irq(&q.pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q.lock_ptr);\n\tret = __rt_mutex_start_proxy_lock(&q.pi_state->pi_mutex, &rt_waiter, current);\n\traw_spin_unlock_irq(&q.pi_state->pi_mutex.wait_lock);\n\n\tif (ret) {\n\t\tif (ret == 1)\n\t\t\tret = 0;\n\n\t\tspin_lock(q.lock_ptr);\n\t\tgoto no_block;\n\t}\n\n\n\tif (unlikely(to))\n\t\thrtimer_start_expires(&to->timer, HRTIMER_MODE_ABS);\n\n\tret = rt_mutex_wait_proxy_lock(&q.pi_state->pi_mutex, to, &rt_waiter);\n\n\tspin_lock(q.lock_ptr);\n\t/*\n\t * If we failed to acquire the lock (signal/timeout), we must\n\t * first acquire the hb->lock before removing the lock from the\n\t * rt_mutex waitqueue, such that we can keep the hb and rt_mutex\n\t * wait lists consistent.\n\t *\n\t * In particular; it is important that futex_unlock_pi() can not\n\t * observe this inconsistency.\n\t */\n\tif (ret && !rt_mutex_cleanup_proxy_lock(&q.pi_state->pi_mutex, &rt_waiter))\n\t\tret = 0;\n\nno_block:\n\t/*\n\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t * haven't already.\n\t */\n\tres = fixup_owner(uaddr, &q, !ret);\n\t/*\n\t * If fixup_owner() returned an error, proprogate that.  If it acquired\n\t * the lock, clear our -ETIMEDOUT or -EINTR.\n\t */\n\tif (res)\n\t\tret = (res < 0) ? res : 0;\n\n\t/*\n\t * If fixup_owner() faulted and was unable to handle the fault, unlock\n\t * it and return the fault to userspace.\n\t */\n\tif (ret && (rt_mutex_owner(&q.pi_state->pi_mutex) == current)) {\n\t\tpi_state = q.pi_state;\n\t\tget_pi_state(pi_state);\n\t}\n\n\t/* Unqueue and drop the lock */\n\tunqueue_me_pi(&q);\n\n\tif (pi_state) {\n\t\trt_mutex_futex_unlock(&pi_state->pi_mutex);\n\t\tput_pi_state(pi_state);\n\t}\n\n\tgoto out_put_key;\n\nout_unlock_put_key:\n\tqueue_unlock(hb);\n\nout_put_key:\n\tput_futex_key(&q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret != -EINTR ? ret : -ERESTARTNOINTR;\n\nuaddr_faulted:\n\tqueue_unlock(hb);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (ret)\n\t\tgoto out_put_key;\n\n\tif (!(flags & FLAGS_SHARED))\n\t\tgoto retry_private;\n\n\tput_futex_key(&q.key);\n\tgoto retry;\n}"
  },
  {
    "function_name": "futex_wait_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2686-2699",
    "snippet": "static long futex_wait_restart(struct restart_block *restart)\n{\n\tu32 __user *uaddr = restart->futex.uaddr;\n\tktime_t t, *tp = NULL;\n\n\tif (restart->futex.flags & FLAGS_HAS_TIMEOUT) {\n\t\tt = restart->futex.time;\n\t\ttp = &t;\n\t}\n\trestart->fn = do_no_restart_syscall;\n\n\treturn (long)futex_wait(uaddr, restart->futex.flags,\n\t\t\t\trestart->futex.val, tp, restart->futex.bitset);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define FLAGS_HAS_TIMEOUT\t0x04"
    ],
    "globals_used": [
      "static long futex_wait_restart(struct restart_block *restart);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "futex_wait",
          "args": [
            "uaddr",
            "restart->futex.flags",
            "restart->futex.val",
            "tp",
            "restart->futex.bitset"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "futex_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2611-2683",
          "snippet": "static int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,\n\t\t      ktime_t *abs_time, u32 bitset)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.bitset = bitset;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t/*\n\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n\t * q.key refs.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\t/* unqueue_me() drops q.key ref */\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = *abs_time;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = flags | FLAGS_HAS_TIMEOUT;\n\n\tret = -ERESTART_RESTARTBLOCK;\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define FLAGS_HAS_TIMEOUT\t0x04",
            "#define FLAGS_CLOCKRT\t\t0x02"
          ],
          "globals_used": [
            "static const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};",
            "static long futex_wait_restart(struct restart_block *restart);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define FLAGS_HAS_TIMEOUT\t0x04\n#define FLAGS_CLOCKRT\t\t0x02\n\nstatic const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};\nstatic long futex_wait_restart(struct restart_block *restart);\n\nstatic int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,\n\t\t      ktime_t *abs_time, u32 bitset)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.bitset = bitset;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t/*\n\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n\t * q.key refs.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\t/* unqueue_me() drops q.key ref */\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = *abs_time;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = flags | FLAGS_HAS_TIMEOUT;\n\n\tret = -ERESTART_RESTARTBLOCK;\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define FLAGS_HAS_TIMEOUT\t0x04\n\nstatic long futex_wait_restart(struct restart_block *restart);\n\nstatic long futex_wait_restart(struct restart_block *restart)\n{\n\tu32 __user *uaddr = restart->futex.uaddr;\n\tktime_t t, *tp = NULL;\n\n\tif (restart->futex.flags & FLAGS_HAS_TIMEOUT) {\n\t\tt = restart->futex.time;\n\t\ttp = &t;\n\t}\n\trestart->fn = do_no_restart_syscall;\n\n\treturn (long)futex_wait(uaddr, restart->futex.flags,\n\t\t\t\trestart->futex.val, tp, restart->futex.bitset);\n}"
  },
  {
    "function_name": "futex_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2611-2683",
    "snippet": "static int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,\n\t\t      ktime_t *abs_time, u32 bitset)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.bitset = bitset;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t/*\n\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n\t * q.key refs.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\t/* unqueue_me() drops q.key ref */\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = *abs_time;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = flags | FLAGS_HAS_TIMEOUT;\n\n\tret = -ERESTART_RESTARTBLOCK;\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define FLAGS_HAS_TIMEOUT\t0x04",
      "#define FLAGS_CLOCKRT\t\t0x02"
    ],
    "globals_used": [
      "static const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};",
      "static long futex_wait_restart(struct restart_block *restart);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&to->timer"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "440-443",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&to->timer"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unqueue_me",
          "args": [
            "&q"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "unqueue_me_pi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2270-2280",
          "snippet": "static void unqueue_me_pi(struct futex_q *q)\n\t__releases(q->lock_ptr)\n{\n\t__unqueue_futex(q);\n\n\tBUG_ON(!q->pi_state);\n\tput_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void unqueue_me_pi(struct futex_q *q)\n\t__releases(q->lock_ptr)\n{\n\t__unqueue_futex(q);\n\n\tBUG_ON(!q->pi_state);\n\tput_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_wait_queue_me",
          "args": [
            "hb",
            "&q",
            "to"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "futex_wait_queue_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2503-2533",
          "snippet": "static void futex_wait_queue_me(struct futex_hash_bucket *hb, struct futex_q *q,\n\t\t\t\tstruct hrtimer_sleeper *timeout)\n{\n\t/*\n\t * The task state is guaranteed to be set before another task can\n\t * wake it. set_current_state() is implemented using smp_store_mb() and\n\t * queue_me() calls spin_unlock() upon completion, both serializing\n\t * access to the hash list and forcing another memory barrier.\n\t */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tqueue_me(q, hb);\n\n\t/* Arm the timer */\n\tif (timeout)\n\t\thrtimer_start_expires(&timeout->timer, HRTIMER_MODE_ABS);\n\n\t/*\n\t * If we have been removed from the hash list, then another task\n\t * has tried to wake us, and we can skip the call to schedule().\n\t */\n\tif (likely(!plist_node_empty(&q->list))) {\n\t\t/*\n\t\t * If the timer has already expired, current will already be\n\t\t * flagged for rescheduling. Only call schedule if there\n\t\t * is no timeout, or if it has yet to expire.\n\t\t */\n\t\tif (!timeout || timeout->task)\n\t\t\tfreezable_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void futex_wait_queue_me(struct futex_hash_bucket *hb, struct futex_q *q,\n\t\t\t\tstruct hrtimer_sleeper *timeout)\n{\n\t/*\n\t * The task state is guaranteed to be set before another task can\n\t * wake it. set_current_state() is implemented using smp_store_mb() and\n\t * queue_me() calls spin_unlock() upon completion, both serializing\n\t * access to the hash list and forcing another memory barrier.\n\t */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tqueue_me(q, hb);\n\n\t/* Arm the timer */\n\tif (timeout)\n\t\thrtimer_start_expires(&timeout->timer, HRTIMER_MODE_ABS);\n\n\t/*\n\t * If we have been removed from the hash list, then another task\n\t * has tried to wake us, and we can skip the call to schedule().\n\t */\n\tif (likely(!plist_node_empty(&q->list))) {\n\t\t/*\n\t\t * If the timer has already expired, current will already be\n\t\t * flagged for rescheduling. Only call schedule if there\n\t\t * is no timeout, or if it has yet to expire.\n\t\t */\n\t\tif (!timeout || timeout->task)\n\t\t\tfreezable_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_wait_setup",
          "args": [
            "uaddr",
            "val",
            "flags",
            "&q",
            "&hb"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "futex_wait_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2552-2609",
          "snippet": "static int futex_wait_setup(u32 __user *uaddr, u32 val, unsigned int flags,\n\t\t\t   struct futex_q *q, struct futex_hash_bucket **hb)\n{\n\tu32 uval;\n\tint ret;\n\n\t/*\n\t * Access the page AFTER the hash-bucket is locked.\n\t * Order is important:\n\t *\n\t *   Userspace waiter: val = var; if (cond(val)) futex_wait(&var, val);\n\t *   Userspace waker:  if (cond(var)) { var = new; futex_wake(&var); }\n\t *\n\t * The basic logical guarantee of a futex is that it blocks ONLY\n\t * if cond(var) is known to be true at the time of blocking, for\n\t * any cond.  If we locked the hash-bucket after testing *uaddr, that\n\t * would open a race condition where we could block indefinitely with\n\t * cond(var) false, which would violate the guarantee.\n\t *\n\t * On the other hand, we insert q and release the hash-bucket only\n\t * after testing *uaddr.  This guarantees that futex_wait() will NOT\n\t * absorb a wakeup if *uaddr does not match the desired values\n\t * while the syscall executes.\n\t */\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q->key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\nretry_private:\n\t*hb = queue_lock(q);\n\n\tret = get_futex_value_locked(&uval, uaddr);\n\n\tif (ret) {\n\t\tqueue_unlock(*hb);\n\n\t\tret = get_user(uval, uaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&q->key);\n\t\tgoto retry;\n\t}\n\n\tif (uval != val) {\n\t\tqueue_unlock(*hb);\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout:\n\tif (ret)\n\t\tput_futex_key(&q->key);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_wait_setup(u32 __user *uaddr, u32 val, unsigned int flags,\n\t\t\t   struct futex_q *q, struct futex_hash_bucket **hb)\n{\n\tu32 uval;\n\tint ret;\n\n\t/*\n\t * Access the page AFTER the hash-bucket is locked.\n\t * Order is important:\n\t *\n\t *   Userspace waiter: val = var; if (cond(val)) futex_wait(&var, val);\n\t *   Userspace waker:  if (cond(var)) { var = new; futex_wake(&var); }\n\t *\n\t * The basic logical guarantee of a futex is that it blocks ONLY\n\t * if cond(var) is known to be true at the time of blocking, for\n\t * any cond.  If we locked the hash-bucket after testing *uaddr, that\n\t * would open a race condition where we could block indefinitely with\n\t * cond(var) false, which would violate the guarantee.\n\t *\n\t * On the other hand, we insert q and release the hash-bucket only\n\t * after testing *uaddr.  This guarantees that futex_wait() will NOT\n\t * absorb a wakeup if *uaddr does not match the desired values\n\t * while the syscall executes.\n\t */\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q->key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\nretry_private:\n\t*hb = queue_lock(q);\n\n\tret = get_futex_value_locked(&uval, uaddr);\n\n\tif (ret) {\n\t\tqueue_unlock(*hb);\n\n\t\tret = get_user(uval, uaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&q->key);\n\t\tgoto retry;\n\t}\n\n\tif (uval != val) {\n\t\tqueue_unlock(*hb);\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout:\n\tif (ret)\n\t\tput_futex_key(&q->key);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires_range_ns",
          "args": [
            "&to->timer",
            "*abs_time",
            "current->timer_slack_ns"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_sleeper",
          "args": [
            "to",
            "current"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1651-1655",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init_on_stack",
          "args": [
            "&to->timer",
            "(flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "432-437",
          "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define FLAGS_HAS_TIMEOUT\t0x04\n#define FLAGS_CLOCKRT\t\t0x02\n\nstatic const struct futex_q futex_q_init = {\n\t/* list gets initialized in queue_me()*/\n\t.key = FUTEX_KEY_INIT,\n\t.bitset = FUTEX_BITSET_MATCH_ANY\n};\nstatic long futex_wait_restart(struct restart_block *restart);\n\nstatic int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,\n\t\t      ktime_t *abs_time, u32 bitset)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.bitset = bitset;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t/*\n\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n\t * q.key refs.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\t/* unqueue_me() drops q.key ref */\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = *abs_time;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = flags | FLAGS_HAS_TIMEOUT;\n\n\tret = -ERESTART_RESTARTBLOCK;\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "futex_wait_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2552-2609",
    "snippet": "static int futex_wait_setup(u32 __user *uaddr, u32 val, unsigned int flags,\n\t\t\t   struct futex_q *q, struct futex_hash_bucket **hb)\n{\n\tu32 uval;\n\tint ret;\n\n\t/*\n\t * Access the page AFTER the hash-bucket is locked.\n\t * Order is important:\n\t *\n\t *   Userspace waiter: val = var; if (cond(val)) futex_wait(&var, val);\n\t *   Userspace waker:  if (cond(var)) { var = new; futex_wake(&var); }\n\t *\n\t * The basic logical guarantee of a futex is that it blocks ONLY\n\t * if cond(var) is known to be true at the time of blocking, for\n\t * any cond.  If we locked the hash-bucket after testing *uaddr, that\n\t * would open a race condition where we could block indefinitely with\n\t * cond(var) false, which would violate the guarantee.\n\t *\n\t * On the other hand, we insert q and release the hash-bucket only\n\t * after testing *uaddr.  This guarantees that futex_wait() will NOT\n\t * absorb a wakeup if *uaddr does not match the desired values\n\t * while the syscall executes.\n\t */\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q->key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\nretry_private:\n\t*hb = queue_lock(q);\n\n\tret = get_futex_value_locked(&uval, uaddr);\n\n\tif (ret) {\n\t\tqueue_unlock(*hb);\n\n\t\tret = get_user(uval, uaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&q->key);\n\t\tgoto retry;\n\t}\n\n\tif (uval != val) {\n\t\tqueue_unlock(*hb);\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout:\n\tif (ret)\n\t\tput_futex_key(&q->key);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_futex_key",
          "args": [
            "&q->key"
          ],
          "line": 2607
        },
        "resolved": true,
        "details": {
          "function_name": "put_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "707-710",
          "snippet": "static inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_unlock",
          "args": [
            "*hb"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "queue_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2164-2170",
          "snippet": "static inline void\nqueue_unlock(struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tspin_unlock(&hb->lock);\n\thb_waiters_dec(hb);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void\nqueue_unlock(struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tspin_unlock(&hb->lock);\n\thb_waiters_dec(hb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "uval",
            "uaddr"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_futex_value_locked",
          "args": [
            "&uval",
            "uaddr"
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "768-777",
          "snippet": "static int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_lock",
          "args": [
            "q"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "queue_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2141-2162",
          "snippet": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n\t__acquires(&hb->lock)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\n\t/*\n\t * Increment the counter before taking the lock so that\n\t * a potential waker won't miss a to-be-slept task that is\n\t * waiting for the spinlock. This is safe as all queue_lock()\n\t * users end up calling queue_me(). Similarly, for housekeeping,\n\t * decrement the counter at queue_unlock() when some error has\n\t * occurred and we don't end up adding the task to the list.\n\t */\n\thb_waiters_inc(hb);\n\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock); /* implies smp_mb(); (A) */\n\treturn hb;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n\t__acquires(&hb->lock)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\n\t/*\n\t * Increment the counter before taking the lock so that\n\t * a potential waker won't miss a to-be-slept task that is\n\t * waiting for the spinlock. This is safe as all queue_lock()\n\t * users end up calling queue_me(). Similarly, for housekeeping,\n\t * decrement the counter at queue_unlock() when some error has\n\t * occurred and we don't end up adding the task to the list.\n\t */\n\thb_waiters_inc(hb);\n\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock); /* implies smp_mb(); (A) */\n\treturn hb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret != 0"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_futex_key",
          "args": [
            "uaddr",
            "flags & FLAGS_SHARED",
            "&q->key",
            "VERIFY_READ"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "499-705",
          "snippet": "static int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_wait_setup(u32 __user *uaddr, u32 val, unsigned int flags,\n\t\t\t   struct futex_q *q, struct futex_hash_bucket **hb)\n{\n\tu32 uval;\n\tint ret;\n\n\t/*\n\t * Access the page AFTER the hash-bucket is locked.\n\t * Order is important:\n\t *\n\t *   Userspace waiter: val = var; if (cond(val)) futex_wait(&var, val);\n\t *   Userspace waker:  if (cond(var)) { var = new; futex_wake(&var); }\n\t *\n\t * The basic logical guarantee of a futex is that it blocks ONLY\n\t * if cond(var) is known to be true at the time of blocking, for\n\t * any cond.  If we locked the hash-bucket after testing *uaddr, that\n\t * would open a race condition where we could block indefinitely with\n\t * cond(var) false, which would violate the guarantee.\n\t *\n\t * On the other hand, we insert q and release the hash-bucket only\n\t * after testing *uaddr.  This guarantees that futex_wait() will NOT\n\t * absorb a wakeup if *uaddr does not match the desired values\n\t * while the syscall executes.\n\t */\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q->key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\nretry_private:\n\t*hb = queue_lock(q);\n\n\tret = get_futex_value_locked(&uval, uaddr);\n\n\tif (ret) {\n\t\tqueue_unlock(*hb);\n\n\t\tret = get_user(uval, uaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&q->key);\n\t\tgoto retry;\n\t}\n\n\tif (uval != val) {\n\t\tqueue_unlock(*hb);\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout:\n\tif (ret)\n\t\tput_futex_key(&q->key);\n\treturn ret;\n}"
  },
  {
    "function_name": "futex_wait_queue_me",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2503-2533",
    "snippet": "static void futex_wait_queue_me(struct futex_hash_bucket *hb, struct futex_q *q,\n\t\t\t\tstruct hrtimer_sleeper *timeout)\n{\n\t/*\n\t * The task state is guaranteed to be set before another task can\n\t * wake it. set_current_state() is implemented using smp_store_mb() and\n\t * queue_me() calls spin_unlock() upon completion, both serializing\n\t * access to the hash list and forcing another memory barrier.\n\t */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tqueue_me(q, hb);\n\n\t/* Arm the timer */\n\tif (timeout)\n\t\thrtimer_start_expires(&timeout->timer, HRTIMER_MODE_ABS);\n\n\t/*\n\t * If we have been removed from the hash list, then another task\n\t * has tried to wake us, and we can skip the call to schedule().\n\t */\n\tif (likely(!plist_node_empty(&q->list))) {\n\t\t/*\n\t\t * If the timer has already expired, current will already be\n\t\t * flagged for rescheduling. Only call schedule if there\n\t\t * is no timeout, or if it has yet to expire.\n\t\t */\n\t\tif (!timeout || timeout->task)\n\t\t\tfreezable_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!plist_node_empty(&q->list)"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_node_empty",
          "args": [
            "&q->list"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "&timeout->timer",
            "HRTIMER_MODE_ABS"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_me",
          "args": [
            "q",
            "hb"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "queue_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2203-2208",
          "snippet": "static inline void queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\t__queue_me(q, hb);\n\tspin_unlock(&hb->lock);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\t__queue_me(q, hb);\n\tspin_unlock(&hb->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void futex_wait_queue_me(struct futex_hash_bucket *hb, struct futex_q *q,\n\t\t\t\tstruct hrtimer_sleeper *timeout)\n{\n\t/*\n\t * The task state is guaranteed to be set before another task can\n\t * wake it. set_current_state() is implemented using smp_store_mb() and\n\t * queue_me() calls spin_unlock() upon completion, both serializing\n\t * access to the hash list and forcing another memory barrier.\n\t */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tqueue_me(q, hb);\n\n\t/* Arm the timer */\n\tif (timeout)\n\t\thrtimer_start_expires(&timeout->timer, HRTIMER_MODE_ABS);\n\n\t/*\n\t * If we have been removed from the hash list, then another task\n\t * has tried to wake us, and we can skip the call to schedule().\n\t */\n\tif (likely(!plist_node_empty(&q->list))) {\n\t\t/*\n\t\t * If the timer has already expired, current will already be\n\t\t * flagged for rescheduling. Only call schedule if there\n\t\t * is no timeout, or if it has yet to expire.\n\t\t */\n\t\tif (!timeout || timeout->task)\n\t\t\tfreezable_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}"
  },
  {
    "function_name": "fixup_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2451-2495",
    "snippet": "static int fixup_owner(u32 __user *uaddr, struct futex_q *q, int locked)\n{\n\tint ret = 0;\n\n\tif (locked) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case:\n\t\t *\n\t\t * Speculative pi_state->owner read (we don't hold wait_lock);\n\t\t * since we own the lock pi_state->owner == current is the\n\t\t * stable state, anything else needs more attention.\n\t\t */\n\t\tif (q->pi_state->owner != current)\n\t\t\tret = fixup_pi_state_owner(uaddr, q, current);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we didn't get the lock; check if anybody stole it from us. In\n\t * that case, we need to fix up the uval to point to them instead of\n\t * us, otherwise bad things happen. [10]\n\t *\n\t * Another speculative read; pi_state->owner == current is unstable\n\t * but needs our attention.\n\t */\n\tif (q->pi_state->owner == current) {\n\t\tret = fixup_pi_state_owner(uaddr, q, NULL);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Paranoia check. If we did not take the lock, then we should not be\n\t * the owner of the rt_mutex.\n\t */\n\tif (rt_mutex_owner(&q->pi_state->pi_mutex) == current) {\n\t\tprintk(KERN_ERR \"fixup_owner: ret = %d pi-mutex: %p \"\n\t\t\t\t\"pi-state %p\\n\", ret,\n\t\t\t\tq->pi_state->pi_mutex.owner,\n\t\t\t\tq->pi_state->owner);\n\t}\n\nout:\n\treturn ret ? ret : locked;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"fixup_owner: ret = %d pi-mutex: %p \"\n\t\t\t\t\"pi-state %p\\n\"",
            "ret",
            "q->pi_state->pi_mutex.owner",
            "q->pi_state->owner"
          ],
          "line": 2487
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_owner",
          "args": [
            "&q->pi_state->pi_mutex"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex_common.h",
          "lines": "108-113",
          "snippet": "static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}",
          "includes": [
            "# include \"rtmutex.h\"",
            "# include \"rtmutex-debug.h\"",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>"
          ],
          "macros_used": [
            "#define RT_MUTEX_HAS_WAITERS\t1UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"rtmutex.h\"\n# include \"rtmutex-debug.h\"\n#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n\n#define RT_MUTEX_HAS_WAITERS\t1UL\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_pi_state_owner",
          "args": [
            "uaddr",
            "q",
            "NULL"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_pi_state_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2282-2432",
          "snippet": "static int fixup_pi_state_owner(u32 __user *uaddr, struct futex_q *q,\n\t\t\t\tstruct task_struct *argowner)\n{\n\tstruct futex_pi_state *pi_state = q->pi_state;\n\tu32 uval, uninitialized_var(curval), newval;\n\tstruct task_struct *oldowner, *newowner;\n\tu32 newtid;\n\tint ret;\n\n\tlockdep_assert_held(q->lock_ptr);\n\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\toldowner = pi_state->owner;\n\n\t/*\n\t * We are here because either:\n\t *\n\t *  - we stole the lock and pi_state->owner needs updating to reflect\n\t *    that (@argowner == current),\n\t *\n\t * or:\n\t *\n\t *  - someone stole our lock and we need to fix things to point to the\n\t *    new owner (@argowner == NULL).\n\t *\n\t * Either way, we have to replace the TID in the user space variable.\n\t * This must be atomic as we have to preserve the owner died bit here.\n\t *\n\t * Note: We write the user space value _before_ changing the pi_state\n\t * because we can fault here. Imagine swapped out pages or a fork\n\t * that marked all the anonymous memory readonly for cow.\n\t *\n\t * Modifying pi_state _before_ the user space value would leave the\n\t * pi_state in an inconsistent state when we fault here, because we\n\t * need to drop the locks to handle the fault. This might be observed\n\t * in the PID check in lookup_pi_state.\n\t */\nretry:\n\tif (!argowner) {\n\t\tif (oldowner != current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (__rt_mutex_futex_trylock(&pi_state->pi_mutex)) {\n\t\t\t/* We got the lock after all, nothing to fix. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Since we just failed the trylock; there must be an owner.\n\t\t */\n\t\tnewowner = rt_mutex_owner(&pi_state->pi_mutex);\n\t\tBUG_ON(!newowner);\n\t} else {\n\t\tWARN_ON_ONCE(argowner != current);\n\t\tif (oldowner == current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tnewowner = argowner;\n\t}\n\n\tnewtid = task_pid_vnr(newowner) | FUTEX_WAITERS;\n\t/* Owner died? */\n\tif (!pi_state->owner)\n\t\tnewtid |= FUTEX_OWNER_DIED;\n\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\tgoto handle_fault;\n\n\tfor (;;) {\n\t\tnewval = (uval & FUTEX_OWNER_DIED) | newtid;\n\n\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\t\tgoto handle_fault;\n\t\tif (curval == uval)\n\t\t\tbreak;\n\t\tuval = curval;\n\t}\n\n\t/*\n\t * We fixed up user space. Now we need to fix the pi_state\n\t * itself.\n\t */\n\tif (pi_state->owner != NULL) {\n\t\traw_spin_lock(&pi_state->owner->pi_lock);\n\t\tWARN_ON(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock(&pi_state->owner->pi_lock);\n\t}\n\n\tpi_state->owner = newowner;\n\n\traw_spin_lock(&newowner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &newowner->pi_state_list);\n\traw_spin_unlock(&newowner->pi_lock);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\treturn 0;\n\n\t/*\n\t * To handle the page fault we need to drop the locks here. That gives\n\t * the other task (either the highest priority waiter itself or the\n\t * task which stole the rtmutex) the chance to try the fixup of the\n\t * pi_state. So once we are back from handling the fault we need to\n\t * check the pi_state after reacquiring the locks and before trying to\n\t * do another fixup. When the fixup has been done already we simply\n\t * return.\n\t *\n\t * Note: we hold both hb->lock and pi_mutex->wait_lock. We can safely\n\t * drop hb->lock since the caller owns the hb -> futex_q relation.\n\t * Dropping the pi_mutex->wait_lock requires the state revalidate.\n\t */\nhandle_fault:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q->lock_ptr);\n\n\tret = fault_in_user_writeable(uaddr);\n\n\tspin_lock(q->lock_ptr);\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Check if someone else fixed it for us:\n\t */\n\tif (pi_state->owner != oldowner) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tgoto retry;\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fixup_pi_state_owner(u32 __user *uaddr, struct futex_q *q,\n\t\t\t\tstruct task_struct *argowner)\n{\n\tstruct futex_pi_state *pi_state = q->pi_state;\n\tu32 uval, uninitialized_var(curval), newval;\n\tstruct task_struct *oldowner, *newowner;\n\tu32 newtid;\n\tint ret;\n\n\tlockdep_assert_held(q->lock_ptr);\n\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\toldowner = pi_state->owner;\n\n\t/*\n\t * We are here because either:\n\t *\n\t *  - we stole the lock and pi_state->owner needs updating to reflect\n\t *    that (@argowner == current),\n\t *\n\t * or:\n\t *\n\t *  - someone stole our lock and we need to fix things to point to the\n\t *    new owner (@argowner == NULL).\n\t *\n\t * Either way, we have to replace the TID in the user space variable.\n\t * This must be atomic as we have to preserve the owner died bit here.\n\t *\n\t * Note: We write the user space value _before_ changing the pi_state\n\t * because we can fault here. Imagine swapped out pages or a fork\n\t * that marked all the anonymous memory readonly for cow.\n\t *\n\t * Modifying pi_state _before_ the user space value would leave the\n\t * pi_state in an inconsistent state when we fault here, because we\n\t * need to drop the locks to handle the fault. This might be observed\n\t * in the PID check in lookup_pi_state.\n\t */\nretry:\n\tif (!argowner) {\n\t\tif (oldowner != current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (__rt_mutex_futex_trylock(&pi_state->pi_mutex)) {\n\t\t\t/* We got the lock after all, nothing to fix. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Since we just failed the trylock; there must be an owner.\n\t\t */\n\t\tnewowner = rt_mutex_owner(&pi_state->pi_mutex);\n\t\tBUG_ON(!newowner);\n\t} else {\n\t\tWARN_ON_ONCE(argowner != current);\n\t\tif (oldowner == current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tnewowner = argowner;\n\t}\n\n\tnewtid = task_pid_vnr(newowner) | FUTEX_WAITERS;\n\t/* Owner died? */\n\tif (!pi_state->owner)\n\t\tnewtid |= FUTEX_OWNER_DIED;\n\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\tgoto handle_fault;\n\n\tfor (;;) {\n\t\tnewval = (uval & FUTEX_OWNER_DIED) | newtid;\n\n\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\t\tgoto handle_fault;\n\t\tif (curval == uval)\n\t\t\tbreak;\n\t\tuval = curval;\n\t}\n\n\t/*\n\t * We fixed up user space. Now we need to fix the pi_state\n\t * itself.\n\t */\n\tif (pi_state->owner != NULL) {\n\t\traw_spin_lock(&pi_state->owner->pi_lock);\n\t\tWARN_ON(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock(&pi_state->owner->pi_lock);\n\t}\n\n\tpi_state->owner = newowner;\n\n\traw_spin_lock(&newowner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &newowner->pi_state_list);\n\traw_spin_unlock(&newowner->pi_lock);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\treturn 0;\n\n\t/*\n\t * To handle the page fault we need to drop the locks here. That gives\n\t * the other task (either the highest priority waiter itself or the\n\t * task which stole the rtmutex) the chance to try the fixup of the\n\t * pi_state. So once we are back from handling the fault we need to\n\t * check the pi_state after reacquiring the locks and before trying to\n\t * do another fixup. When the fixup has been done already we simply\n\t * return.\n\t *\n\t * Note: we hold both hb->lock and pi_mutex->wait_lock. We can safely\n\t * drop hb->lock since the caller owns the hb -> futex_q relation.\n\t * Dropping the pi_mutex->wait_lock requires the state revalidate.\n\t */\nhandle_fault:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q->lock_ptr);\n\n\tret = fault_in_user_writeable(uaddr);\n\n\tspin_lock(q->lock_ptr);\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Check if someone else fixed it for us:\n\t */\n\tif (pi_state->owner != oldowner) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tgoto retry;\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fixup_owner(u32 __user *uaddr, struct futex_q *q, int locked)\n{\n\tint ret = 0;\n\n\tif (locked) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case:\n\t\t *\n\t\t * Speculative pi_state->owner read (we don't hold wait_lock);\n\t\t * since we own the lock pi_state->owner == current is the\n\t\t * stable state, anything else needs more attention.\n\t\t */\n\t\tif (q->pi_state->owner != current)\n\t\t\tret = fixup_pi_state_owner(uaddr, q, current);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we didn't get the lock; check if anybody stole it from us. In\n\t * that case, we need to fix up the uval to point to them instead of\n\t * us, otherwise bad things happen. [10]\n\t *\n\t * Another speculative read; pi_state->owner == current is unstable\n\t * but needs our attention.\n\t */\n\tif (q->pi_state->owner == current) {\n\t\tret = fixup_pi_state_owner(uaddr, q, NULL);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Paranoia check. If we did not take the lock, then we should not be\n\t * the owner of the rt_mutex.\n\t */\n\tif (rt_mutex_owner(&q->pi_state->pi_mutex) == current) {\n\t\tprintk(KERN_ERR \"fixup_owner: ret = %d pi-mutex: %p \"\n\t\t\t\t\"pi-state %p\\n\", ret,\n\t\t\t\tq->pi_state->pi_mutex.owner,\n\t\t\t\tq->pi_state->owner);\n\t}\n\nout:\n\treturn ret ? ret : locked;\n}"
  },
  {
    "function_name": "fixup_pi_state_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2282-2432",
    "snippet": "static int fixup_pi_state_owner(u32 __user *uaddr, struct futex_q *q,\n\t\t\t\tstruct task_struct *argowner)\n{\n\tstruct futex_pi_state *pi_state = q->pi_state;\n\tu32 uval, uninitialized_var(curval), newval;\n\tstruct task_struct *oldowner, *newowner;\n\tu32 newtid;\n\tint ret;\n\n\tlockdep_assert_held(q->lock_ptr);\n\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\toldowner = pi_state->owner;\n\n\t/*\n\t * We are here because either:\n\t *\n\t *  - we stole the lock and pi_state->owner needs updating to reflect\n\t *    that (@argowner == current),\n\t *\n\t * or:\n\t *\n\t *  - someone stole our lock and we need to fix things to point to the\n\t *    new owner (@argowner == NULL).\n\t *\n\t * Either way, we have to replace the TID in the user space variable.\n\t * This must be atomic as we have to preserve the owner died bit here.\n\t *\n\t * Note: We write the user space value _before_ changing the pi_state\n\t * because we can fault here. Imagine swapped out pages or a fork\n\t * that marked all the anonymous memory readonly for cow.\n\t *\n\t * Modifying pi_state _before_ the user space value would leave the\n\t * pi_state in an inconsistent state when we fault here, because we\n\t * need to drop the locks to handle the fault. This might be observed\n\t * in the PID check in lookup_pi_state.\n\t */\nretry:\n\tif (!argowner) {\n\t\tif (oldowner != current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (__rt_mutex_futex_trylock(&pi_state->pi_mutex)) {\n\t\t\t/* We got the lock after all, nothing to fix. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Since we just failed the trylock; there must be an owner.\n\t\t */\n\t\tnewowner = rt_mutex_owner(&pi_state->pi_mutex);\n\t\tBUG_ON(!newowner);\n\t} else {\n\t\tWARN_ON_ONCE(argowner != current);\n\t\tif (oldowner == current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tnewowner = argowner;\n\t}\n\n\tnewtid = task_pid_vnr(newowner) | FUTEX_WAITERS;\n\t/* Owner died? */\n\tif (!pi_state->owner)\n\t\tnewtid |= FUTEX_OWNER_DIED;\n\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\tgoto handle_fault;\n\n\tfor (;;) {\n\t\tnewval = (uval & FUTEX_OWNER_DIED) | newtid;\n\n\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\t\tgoto handle_fault;\n\t\tif (curval == uval)\n\t\t\tbreak;\n\t\tuval = curval;\n\t}\n\n\t/*\n\t * We fixed up user space. Now we need to fix the pi_state\n\t * itself.\n\t */\n\tif (pi_state->owner != NULL) {\n\t\traw_spin_lock(&pi_state->owner->pi_lock);\n\t\tWARN_ON(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock(&pi_state->owner->pi_lock);\n\t}\n\n\tpi_state->owner = newowner;\n\n\traw_spin_lock(&newowner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &newowner->pi_state_list);\n\traw_spin_unlock(&newowner->pi_lock);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\treturn 0;\n\n\t/*\n\t * To handle the page fault we need to drop the locks here. That gives\n\t * the other task (either the highest priority waiter itself or the\n\t * task which stole the rtmutex) the chance to try the fixup of the\n\t * pi_state. So once we are back from handling the fault we need to\n\t * check the pi_state after reacquiring the locks and before trying to\n\t * do another fixup. When the fixup has been done already we simply\n\t * return.\n\t *\n\t * Note: we hold both hb->lock and pi_mutex->wait_lock. We can safely\n\t * drop hb->lock since the caller owns the hb -> futex_q relation.\n\t * Dropping the pi_mutex->wait_lock requires the state revalidate.\n\t */\nhandle_fault:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q->lock_ptr);\n\n\tret = fault_in_user_writeable(uaddr);\n\n\tspin_lock(q->lock_ptr);\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Check if someone else fixed it for us:\n\t */\n\tif (pi_state->owner != oldowner) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tgoto retry;\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pi_state->pi_mutex.wait_lock"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pi_state->pi_mutex.wait_lock"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "q->lock_ptr"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fault_in_user_writeable",
          "args": [
            "uaddr"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "fault_in_user_writeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "724-735",
          "snippet": "static int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "q->lock_ptr"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&newowner->pi_lock"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pi_state->list",
            "&newowner->pi_state_list"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&pi_state->list)"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pi_state->list"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&pi_state->list"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "list_empty(&pi_state->list)"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_futex_value_locked",
          "args": [
            "&curval",
            "uaddr",
            "uval",
            "newval"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "cmpxchg_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "756-766",
          "snippet": "static int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_futex_value_locked",
          "args": [
            "&uval",
            "uaddr"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "768-777",
          "snippet": "static int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "newowner"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "argowner != current"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!newowner"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_mutex_owner",
          "args": [
            "&pi_state->pi_mutex"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex_common.h",
          "lines": "108-113",
          "snippet": "static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}",
          "includes": [
            "# include \"rtmutex.h\"",
            "# include \"rtmutex-debug.h\"",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>"
          ],
          "macros_used": [
            "#define RT_MUTEX_HAS_WAITERS\t1UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"rtmutex.h\"\n# include \"rtmutex-debug.h\"\n#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n\n#define RT_MUTEX_HAS_WAITERS\t1UL\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rt_mutex_futex_trylock",
          "args": [
            "&pi_state->pi_mutex"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_futex_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1535-1538",
          "snippet": "int __sched __rt_mutex_futex_trylock(struct rt_mutex *lock)\n{\n\treturn __rt_mutex_slowtrylock(lock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched __rt_mutex_futex_trylock(struct rt_mutex *lock)\n{\n\treturn __rt_mutex_slowtrylock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "q->lock_ptr"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fixup_pi_state_owner(u32 __user *uaddr, struct futex_q *q,\n\t\t\t\tstruct task_struct *argowner)\n{\n\tstruct futex_pi_state *pi_state = q->pi_state;\n\tu32 uval, uninitialized_var(curval), newval;\n\tstruct task_struct *oldowner, *newowner;\n\tu32 newtid;\n\tint ret;\n\n\tlockdep_assert_held(q->lock_ptr);\n\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\toldowner = pi_state->owner;\n\n\t/*\n\t * We are here because either:\n\t *\n\t *  - we stole the lock and pi_state->owner needs updating to reflect\n\t *    that (@argowner == current),\n\t *\n\t * or:\n\t *\n\t *  - someone stole our lock and we need to fix things to point to the\n\t *    new owner (@argowner == NULL).\n\t *\n\t * Either way, we have to replace the TID in the user space variable.\n\t * This must be atomic as we have to preserve the owner died bit here.\n\t *\n\t * Note: We write the user space value _before_ changing the pi_state\n\t * because we can fault here. Imagine swapped out pages or a fork\n\t * that marked all the anonymous memory readonly for cow.\n\t *\n\t * Modifying pi_state _before_ the user space value would leave the\n\t * pi_state in an inconsistent state when we fault here, because we\n\t * need to drop the locks to handle the fault. This might be observed\n\t * in the PID check in lookup_pi_state.\n\t */\nretry:\n\tif (!argowner) {\n\t\tif (oldowner != current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (__rt_mutex_futex_trylock(&pi_state->pi_mutex)) {\n\t\t\t/* We got the lock after all, nothing to fix. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Since we just failed the trylock; there must be an owner.\n\t\t */\n\t\tnewowner = rt_mutex_owner(&pi_state->pi_mutex);\n\t\tBUG_ON(!newowner);\n\t} else {\n\t\tWARN_ON_ONCE(argowner != current);\n\t\tif (oldowner == current) {\n\t\t\t/*\n\t\t\t * We raced against a concurrent self; things are\n\t\t\t * already fixed up. Nothing to do.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tnewowner = argowner;\n\t}\n\n\tnewtid = task_pid_vnr(newowner) | FUTEX_WAITERS;\n\t/* Owner died? */\n\tif (!pi_state->owner)\n\t\tnewtid |= FUTEX_OWNER_DIED;\n\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\tgoto handle_fault;\n\n\tfor (;;) {\n\t\tnewval = (uval & FUTEX_OWNER_DIED) | newtid;\n\n\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\t\tgoto handle_fault;\n\t\tif (curval == uval)\n\t\t\tbreak;\n\t\tuval = curval;\n\t}\n\n\t/*\n\t * We fixed up user space. Now we need to fix the pi_state\n\t * itself.\n\t */\n\tif (pi_state->owner != NULL) {\n\t\traw_spin_lock(&pi_state->owner->pi_lock);\n\t\tWARN_ON(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock(&pi_state->owner->pi_lock);\n\t}\n\n\tpi_state->owner = newowner;\n\n\traw_spin_lock(&newowner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &newowner->pi_state_list);\n\traw_spin_unlock(&newowner->pi_lock);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\treturn 0;\n\n\t/*\n\t * To handle the page fault we need to drop the locks here. That gives\n\t * the other task (either the highest priority waiter itself or the\n\t * task which stole the rtmutex) the chance to try the fixup of the\n\t * pi_state. So once we are back from handling the fault we need to\n\t * check the pi_state after reacquiring the locks and before trying to\n\t * do another fixup. When the fixup has been done already we simply\n\t * return.\n\t *\n\t * Note: we hold both hb->lock and pi_mutex->wait_lock. We can safely\n\t * drop hb->lock since the caller owns the hb -> futex_q relation.\n\t * Dropping the pi_mutex->wait_lock requires the state revalidate.\n\t */\nhandle_fault:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q->lock_ptr);\n\n\tret = fault_in_user_writeable(uaddr);\n\n\tspin_lock(q->lock_ptr);\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Check if someone else fixed it for us:\n\t */\n\tif (pi_state->owner != oldowner) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tgoto retry;\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "unqueue_me_pi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2270-2280",
    "snippet": "static void unqueue_me_pi(struct futex_q *q)\n\t__releases(q->lock_ptr)\n{\n\t__unqueue_futex(q);\n\n\tBUG_ON(!q->pi_state);\n\tput_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "q->lock_ptr"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pi_state",
          "args": [
            "q->pi_state"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "put_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "825-863",
          "snippet": "static void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!q->pi_state"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unqueue_futex",
          "args": [
            "q"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "__unqueue_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1364-1375",
          "snippet": "static void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (WARN_ON_SMP(!q->lock_ptr) || WARN_ON(plist_node_empty(&q->list)))\n\t\treturn;\n\tlockdep_assert_held(q->lock_ptr);\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (WARN_ON_SMP(!q->lock_ptr) || WARN_ON(plist_node_empty(&q->list)))\n\t\treturn;\n\tlockdep_assert_held(q->lock_ptr);\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "q->lock_ptr"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void unqueue_me_pi(struct futex_q *q)\n\t__releases(q->lock_ptr)\n{\n\t__unqueue_futex(q);\n\n\tBUG_ON(!q->pi_state);\n\tput_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n}"
  },
  {
    "function_name": "unqueue_me",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2221-2263",
    "snippet": "static int unqueue_me(struct futex_q *q)\n{\n\tspinlock_t *lock_ptr;\n\tint ret = 0;\n\n\t/* In the common case we don't take the spinlock, which is nice. */\nretry:\n\t/*\n\t * q->lock_ptr can change between this read and the following spin_lock.\n\t * Use READ_ONCE to forbid the compiler from reloading q->lock_ptr and\n\t * optimizing lock_ptr out of the logic below.\n\t */\n\tlock_ptr = READ_ONCE(q->lock_ptr);\n\tif (lock_ptr != NULL) {\n\t\tspin_lock(lock_ptr);\n\t\t/*\n\t\t * q->lock_ptr can change between reading it and\n\t\t * spin_lock(), causing us to take the wrong lock.  This\n\t\t * corrects the race condition.\n\t\t *\n\t\t * Reasoning goes like this: if we have the wrong lock,\n\t\t * q->lock_ptr must have changed (maybe several times)\n\t\t * between reading it and the spin_lock().  It can\n\t\t * change again after the spin_lock() but only if it was\n\t\t * already changed before the spin_lock().  It cannot,\n\t\t * however, change back to the original value.  Therefore\n\t\t * we can detect whether we acquired the correct lock.\n\t\t */\n\t\tif (unlikely(lock_ptr != q->lock_ptr)) {\n\t\t\tspin_unlock(lock_ptr);\n\t\t\tgoto retry;\n\t\t}\n\t\t__unqueue_futex(q);\n\n\t\tBUG_ON(q->pi_state);\n\n\t\tspin_unlock(lock_ptr);\n\t\tret = 1;\n\t}\n\n\tdrop_futex_key_refs(&q->key);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_futex_key_refs",
          "args": [
            "&q->key"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "drop_futex_key_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "460-479",
          "snippet": "static void drop_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr) {\n\t\t/* If we're here then we tried to put a key we failed to get */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MMU))\n\t\treturn;\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tiput(key->shared.inode);\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tmmdrop(key->private.mm);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void drop_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr) {\n\t\t/* If we're here then we tried to put a key we failed to get */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MMU))\n\t\treturn;\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tiput(key->shared.inode);\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tmmdrop(key->private.mm);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lock_ptr"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "q->pi_state"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unqueue_futex",
          "args": [
            "q"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "__unqueue_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1364-1375",
          "snippet": "static void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (WARN_ON_SMP(!q->lock_ptr) || WARN_ON(plist_node_empty(&q->list)))\n\t\treturn;\n\tlockdep_assert_held(q->lock_ptr);\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (WARN_ON_SMP(!q->lock_ptr) || WARN_ON(plist_node_empty(&q->list)))\n\t\treturn;\n\tlockdep_assert_held(q->lock_ptr);\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lock_ptr != q->lock_ptr"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lock_ptr"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "q->lock_ptr"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int unqueue_me(struct futex_q *q)\n{\n\tspinlock_t *lock_ptr;\n\tint ret = 0;\n\n\t/* In the common case we don't take the spinlock, which is nice. */\nretry:\n\t/*\n\t * q->lock_ptr can change between this read and the following spin_lock.\n\t * Use READ_ONCE to forbid the compiler from reloading q->lock_ptr and\n\t * optimizing lock_ptr out of the logic below.\n\t */\n\tlock_ptr = READ_ONCE(q->lock_ptr);\n\tif (lock_ptr != NULL) {\n\t\tspin_lock(lock_ptr);\n\t\t/*\n\t\t * q->lock_ptr can change between reading it and\n\t\t * spin_lock(), causing us to take the wrong lock.  This\n\t\t * corrects the race condition.\n\t\t *\n\t\t * Reasoning goes like this: if we have the wrong lock,\n\t\t * q->lock_ptr must have changed (maybe several times)\n\t\t * between reading it and the spin_lock().  It can\n\t\t * change again after the spin_lock() but only if it was\n\t\t * already changed before the spin_lock().  It cannot,\n\t\t * however, change back to the original value.  Therefore\n\t\t * we can detect whether we acquired the correct lock.\n\t\t */\n\t\tif (unlikely(lock_ptr != q->lock_ptr)) {\n\t\t\tspin_unlock(lock_ptr);\n\t\t\tgoto retry;\n\t\t}\n\t\t__unqueue_futex(q);\n\n\t\tBUG_ON(q->pi_state);\n\n\t\tspin_unlock(lock_ptr);\n\t\tret = 1;\n\t}\n\n\tdrop_futex_key_refs(&q->key);\n\treturn ret;\n}"
  },
  {
    "function_name": "queue_me",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2203-2208",
    "snippet": "static inline void queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\t__queue_me(q, hb);\n\tspin_unlock(&hb->lock);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hb->lock"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__queue_me",
          "args": [
            "q",
            "hb"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "2172-2189",
          "snippet": "static inline void __queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tint prio;\n\n\t/*\n\t * The priority used to register this element is\n\t * - either the real thread-priority for the real-time threads\n\t * (i.e. threads with a priority lower than MAX_RT_PRIO)\n\t * - or MAX_RT_PRIO for non-RT threads.\n\t * Thus, all RT-threads are woken first in priority order, and\n\t * the others are woken last, in FIFO order.\n\t */\n\tprio = min(current->normal_prio, MAX_RT_PRIO);\n\n\tplist_node_init(&q->list, prio);\n\tplist_add(&q->list, &hb->chain);\n\tq->task = current;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void __queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tint prio;\n\n\t/*\n\t * The priority used to register this element is\n\t * - either the real thread-priority for the real-time threads\n\t * (i.e. threads with a priority lower than MAX_RT_PRIO)\n\t * - or MAX_RT_PRIO for non-RT threads.\n\t * Thus, all RT-threads are woken first in priority order, and\n\t * the others are woken last, in FIFO order.\n\t */\n\tprio = min(current->normal_prio, MAX_RT_PRIO);\n\n\tplist_node_init(&q->list, prio);\n\tplist_add(&q->list, &hb->chain);\n\tq->task = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&hb->lock"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\t__queue_me(q, hb);\n\tspin_unlock(&hb->lock);\n}"
  },
  {
    "function_name": "__queue_me",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2172-2189",
    "snippet": "static inline void __queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tint prio;\n\n\t/*\n\t * The priority used to register this element is\n\t * - either the real thread-priority for the real-time threads\n\t * (i.e. threads with a priority lower than MAX_RT_PRIO)\n\t * - or MAX_RT_PRIO for non-RT threads.\n\t * Thus, all RT-threads are woken first in priority order, and\n\t * the others are woken last, in FIFO order.\n\t */\n\tprio = min(current->normal_prio, MAX_RT_PRIO);\n\n\tplist_node_init(&q->list, prio);\n\tplist_add(&q->list, &hb->chain);\n\tq->task = current;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_add",
          "args": [
            "&q->list",
            "&hb->chain"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_node_init",
          "args": [
            "&q->list",
            "prio"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "current->normal_prio",
            "MAX_RT_PRIO"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void __queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tint prio;\n\n\t/*\n\t * The priority used to register this element is\n\t * - either the real thread-priority for the real-time threads\n\t * (i.e. threads with a priority lower than MAX_RT_PRIO)\n\t * - or MAX_RT_PRIO for non-RT threads.\n\t * Thus, all RT-threads are woken first in priority order, and\n\t * the others are woken last, in FIFO order.\n\t */\n\tprio = min(current->normal_prio, MAX_RT_PRIO);\n\n\tplist_node_init(&q->list, prio);\n\tplist_add(&q->list, &hb->chain);\n\tq->task = current;\n}"
  },
  {
    "function_name": "queue_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2164-2170",
    "snippet": "static inline void\nqueue_unlock(struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tspin_unlock(&hb->lock);\n\thb_waiters_dec(hb);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hb_waiters_dec",
          "args": [
            "hb"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "hb_waiters_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "370-375",
          "snippet": "static inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hb->lock"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&hb->lock"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void\nqueue_unlock(struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tspin_unlock(&hb->lock);\n\thb_waiters_dec(hb);\n}"
  },
  {
    "function_name": "queue_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "2141-2162",
    "snippet": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n\t__acquires(&hb->lock)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\n\t/*\n\t * Increment the counter before taking the lock so that\n\t * a potential waker won't miss a to-be-slept task that is\n\t * waiting for the spinlock. This is safe as all queue_lock()\n\t * users end up calling queue_me(). Similarly, for housekeeping,\n\t * decrement the counter at queue_unlock() when some error has\n\t * occurred and we don't end up adding the task to the list.\n\t */\n\thb_waiters_inc(hb);\n\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock); /* implies smp_mb(); (A) */\n\treturn hb;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hb->lock"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hb_waiters_inc",
          "args": [
            "hb"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "hb_waiters_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "355-364",
          "snippet": "static inline void hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_inc(&hb->waiters);\n\t/*\n\t * Full barrier (A), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n#endif\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_inc(&hb->waiters);\n\t/*\n\t * Full barrier (A), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_futex",
          "args": [
            "&q->key"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "hash_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "393-399",
          "snippet": "static struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define futex_hashsize (__futex_data.hashsize)",
            "#define futex_queues   (__futex_data.queues)"
          ],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define futex_hashsize (__futex_data.hashsize)\n#define futex_queues   (__futex_data.queues)\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&hb->lock"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n\t__acquires(&hb->lock)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\n\t/*\n\t * Increment the counter before taking the lock so that\n\t * a potential waker won't miss a to-be-slept task that is\n\t * waiting for the spinlock. This is safe as all queue_lock()\n\t * users end up calling queue_me(). Similarly, for housekeeping,\n\t * decrement the counter at queue_unlock() when some error has\n\t * occurred and we don't end up adding the task to the list.\n\t */\n\thb_waiters_inc(hb);\n\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock); /* implies smp_mb(); (A) */\n\treturn hb;\n}"
  },
  {
    "function_name": "futex_requeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1852-2138",
    "snippet": "static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (nr_wake < 0 || nr_requeue < 0)\n\t\treturn -EINVAL;\n\n\t/*\n\t * When PI not supported: return -ENOSYS if requeue_pi is true,\n\t * consequently the compiler knows requeue_pi is always false past\n\t * this point which will optimize away all the conditional code\n\t * further down.\n\t */\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI) && requeue_pi)\n\t\treturn -ENOSYS;\n\n\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;\n\n\t\t\t/* If the above failed, then pi_state is NULL */\n\t\tcase -EFAULT:\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Owner is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always\n\t\t * be paired with each other and no other futex ops.\n\t\t *\n\t\t * We should never be requeueing a futex_q with a pi_state,\n\t\t * which is awaiting a futex_unlock_pi().\n\t\t */\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\n\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);\n\n\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret ? ret : task_count;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_futex_key",
          "args": [
            "&key1"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "put_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "707-710",
          "snippet": "static inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_futex_key_refs",
          "args": [
            "&key1"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "drop_futex_key_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "460-479",
          "snippet": "static void drop_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr) {\n\t\t/* If we're here then we tried to put a key we failed to get */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MMU))\n\t\treturn;\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tiput(key->shared.inode);\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tmmdrop(key->private.mm);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void drop_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr) {\n\t\t/* If we're here then we tried to put a key we failed to get */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MMU))\n\t\treturn;\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tiput(key->shared.inode);\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tmmdrop(key->private.mm);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hb_waiters_dec",
          "args": [
            "hb2"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "hb_waiters_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "370-375",
          "snippet": "static inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_q",
          "args": [
            "&wake_q"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_q",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "423-443",
          "snippet": "void wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\tBUG_ON(!task);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\tBUG_ON(!task);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_unlock_hb",
          "args": [
            "hb1",
            "hb2"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "double_unlock_hb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1503-1509",
          "snippet": "static inline void\ndouble_unlock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tspin_unlock(&hb1->lock);\n\tif (hb1 != hb2)\n\t\tspin_unlock(&hb2->lock);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void\ndouble_unlock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tspin_unlock(&hb1->lock);\n\tif (hb1 != hb2)\n\t\tspin_unlock(&hb2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pi_state",
          "args": [
            "pi_state"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "put_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "825-863",
          "snippet": "static void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "requeue_futex",
          "args": [
            "this",
            "hb1",
            "hb2",
            "&key2"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "requeue_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1714-1732",
          "snippet": "static inline\nvoid requeue_futex(struct futex_q *q, struct futex_hash_bucket *hb1,\n\t\t   struct futex_hash_bucket *hb2, union futex_key *key2)\n{\n\n\t/*\n\t * If key1 and key2 hash to the same bucket, no need to\n\t * requeue.\n\t */\n\tif (likely(&hb1->chain != &hb2->chain)) {\n\t\tplist_del(&q->list, &hb1->chain);\n\t\thb_waiters_dec(hb1);\n\t\thb_waiters_inc(hb2);\n\t\tplist_add(&q->list, &hb2->chain);\n\t\tq->lock_ptr = &hb2->lock;\n\t}\n\tget_futex_key_refs(key2);\n\tq->key = *key2;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline\nvoid requeue_futex(struct futex_q *q, struct futex_hash_bucket *hb1,\n\t\t   struct futex_hash_bucket *hb2, union futex_key *key2)\n{\n\n\t/*\n\t * If key1 and key2 hash to the same bucket, no need to\n\t * requeue.\n\t */\n\tif (likely(&hb1->chain != &hb2->chain)) {\n\t\tplist_del(&q->list, &hb1->chain);\n\t\thb_waiters_dec(hb1);\n\t\thb_waiters_inc(hb2);\n\t\tplist_add(&q->list, &hb2->chain);\n\t\tq->lock_ptr = &hb2->lock;\n\t}\n\tget_futex_key_refs(key2);\n\tq->key = *key2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "requeue_pi_wake_futex",
          "args": [
            "this",
            "&key2",
            "hb2"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "requeue_pi_wake_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1748-1763",
          "snippet": "static inline\nvoid requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,\n\t\t\t   struct futex_hash_bucket *hb)\n{\n\tget_futex_key_refs(key);\n\tq->key = *key;\n\n\t__unqueue_futex(q);\n\n\tWARN_ON(!q->rt_waiter);\n\tq->rt_waiter = NULL;\n\n\tq->lock_ptr = &hb->lock;\n\n\twake_up_state(q->task, TASK_NORMAL);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline\nvoid requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,\n\t\t\t   struct futex_hash_bucket *hb)\n{\n\tget_futex_key_refs(key);\n\tq->key = *key;\n\n\t__unqueue_futex(q);\n\n\tWARN_ON(!q->rt_waiter);\n\tq->rt_waiter = NULL;\n\n\tq->lock_ptr = &hb->lock;\n\n\twake_up_state(q->task, TASK_NORMAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_start_proxy_lock",
          "args": [
            "&pi_state->pi_mutex",
            "this->rt_waiter",
            "this->task"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_start_proxy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1773-1784",
          "snippet": "int rt_mutex_start_proxy_lock(struct rt_mutex *lock,\n\t\t\t      struct rt_mutex_waiter *waiter,\n\t\t\t      struct task_struct *task)\n{\n\tint ret;\n\n\traw_spin_lock_irq(&lock->wait_lock);\n\tret = __rt_mutex_start_proxy_lock(lock, waiter, task);\n\traw_spin_unlock_irq(&lock->wait_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint rt_mutex_start_proxy_lock(struct rt_mutex *lock,\n\t\t\t      struct rt_mutex_waiter *waiter,\n\t\t\t      struct task_struct *task)\n{\n\tint ret;\n\n\traw_spin_lock_irq(&lock->wait_lock);\n\tret = __rt_mutex_start_proxy_lock(lock, waiter, task);\n\traw_spin_unlock_irq(&lock->wait_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pi_state",
          "args": [
            "pi_state"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "get_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "816-819",
          "snippet": "static void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_futex",
          "args": [
            "this->requeue_pi_key",
            "&key2"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "match_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "409-415",
          "snippet": "static inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_wake_futex",
          "args": [
            "&wake_q",
            "this"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "mark_wake_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1383-1404",
          "snippet": "static void mark_wake_futex(struct wake_q_head *wake_q, struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (WARN(q->pi_state || q->rt_waiter, \"refusing to wake PI futex\\n\"))\n\t\treturn;\n\n\t/*\n\t * Queue the task for later wakeup for after we've released\n\t * the hb->lock. wake_q_add() grabs reference to p.\n\t */\n\twake_q_add(wake_q, p);\n\t__unqueue_futex(q);\n\t/*\n\t * The waiting task can free the futex_q as soon as q->lock_ptr = NULL\n\t * is written, without taking any locks. This is possible in the event\n\t * of a spurious wakeup, for example. A memory barrier is required here\n\t * to prevent the following store to lock_ptr from getting ahead of the\n\t * plist_del in __unqueue_futex().\n\t */\n\tsmp_store_release(&q->lock_ptr, NULL);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void mark_wake_futex(struct wake_q_head *wake_q, struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (WARN(q->pi_state || q->rt_waiter, \"refusing to wake PI futex\\n\"))\n\t\treturn;\n\n\t/*\n\t * Queue the task for later wakeup for after we've released\n\t * the hb->lock. wake_q_add() grabs reference to p.\n\t */\n\twake_q_add(wake_q, p);\n\t__unqueue_futex(q);\n\t/*\n\t * The waiting task can free the futex_q as soon as q->lock_ptr = NULL\n\t * is written, without taking any locks. This is possible in the event\n\t * of a spurious wakeup, for example. A memory barrier is required here\n\t * to prevent the following store to lock_ptr from getting ahead of the\n\t * plist_del in __unqueue_futex().\n\t */\n\tsmp_store_release(&q->lock_ptr, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry_safe",
          "args": [
            "this",
            "next",
            "&hb1->chain",
            "list"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fault_in_user_writeable",
          "args": [
            "uaddr2"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "fault_in_user_writeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "724-735",
          "snippet": "static int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_pi_state",
          "args": [
            "uaddr2",
            "ret",
            "hb2",
            "&key2",
            "&pi_state"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1230-1248",
          "snippet": "static int lookup_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t   struct futex_hash_bucket *hb,\n\t\t\t   union futex_key *key, struct futex_pi_state **ps)\n{\n\tstruct futex_q *top_waiter = futex_top_waiter(hb, key);\n\n\t/*\n\t * If there is a waiter on that futex, validate it and\n\t * attach to the pi_state when the validation succeeds.\n\t */\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * We are the first waiter - try to look up the owner based on\n\t * @uval and attach to it.\n\t */\n\treturn attach_to_pi_owner(uval, key, ps);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int lookup_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t   struct futex_hash_bucket *hb,\n\t\t\t   union futex_key *key, struct futex_pi_state **ps)\n{\n\tstruct futex_q *top_waiter = futex_top_waiter(hb, key);\n\n\t/*\n\t * If there is a waiter on that futex, validate it and\n\t * attach to the pi_state when the validation succeeds.\n\t */\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * We are the first waiter - try to look up the owner based on\n\t * @uval and attach to it.\n\t */\n\treturn attach_to_pi_owner(uval, key, ps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pi_state"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "futex_proxy_trylock_atomic",
          "args": [
            "uaddr2",
            "hb1",
            "hb2",
            "&key1",
            "&key2",
            "&pi_state",
            "nr_requeue"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "futex_proxy_trylock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1785-1832",
          "snippet": "static int futex_proxy_trylock_atomic(u32 __user *pifutex,\n\t\t\t\t struct futex_hash_bucket *hb1,\n\t\t\t\t struct futex_hash_bucket *hb2,\n\t\t\t\t union futex_key *key1, union futex_key *key2,\n\t\t\t\t struct futex_pi_state **ps, int set_waiters)\n{\n\tstruct futex_q *top_waiter = NULL;\n\tu32 curval;\n\tint ret, vpid;\n\n\tif (get_futex_value_locked(&curval, pifutex))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Find the top_waiter and determine if there are additional waiters.\n\t * If the caller intends to requeue more than 1 waiter to pifutex,\n\t * force futex_lock_pi_atomic() to set the FUTEX_WAITERS bit now,\n\t * as we have means to handle the possible fault.  If not, don't set\n\t * the bit unecessarily as it will force the subsequent unlock to enter\n\t * the kernel.\n\t */\n\ttop_waiter = futex_top_waiter(hb1, key1);\n\n\t/* There are no waiters, nothing for us to do. */\n\tif (!top_waiter)\n\t\treturn 0;\n\n\t/* Ensure we requeue to the expected futex. */\n\tif (!match_futex(top_waiter->requeue_pi_key, key2))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try to take the lock for top_waiter.  Set the FUTEX_WAITERS bit in\n\t * the contended case or if set_waiters is 1.  The pi_state is returned\n\t * in ps in contended cases.\n\t */\n\tvpid = task_pid_vnr(top_waiter->task);\n\tret = futex_lock_pi_atomic(pifutex, hb2, key2, ps, top_waiter->task,\n\t\t\t\t   set_waiters);\n\tif (ret == 1) {\n\t\trequeue_pi_wake_futex(top_waiter, key2, hb2);\n\t\treturn vpid;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_proxy_trylock_atomic(u32 __user *pifutex,\n\t\t\t\t struct futex_hash_bucket *hb1,\n\t\t\t\t struct futex_hash_bucket *hb2,\n\t\t\t\t union futex_key *key1, union futex_key *key2,\n\t\t\t\t struct futex_pi_state **ps, int set_waiters)\n{\n\tstruct futex_q *top_waiter = NULL;\n\tu32 curval;\n\tint ret, vpid;\n\n\tif (get_futex_value_locked(&curval, pifutex))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Find the top_waiter and determine if there are additional waiters.\n\t * If the caller intends to requeue more than 1 waiter to pifutex,\n\t * force futex_lock_pi_atomic() to set the FUTEX_WAITERS bit now,\n\t * as we have means to handle the possible fault.  If not, don't set\n\t * the bit unecessarily as it will force the subsequent unlock to enter\n\t * the kernel.\n\t */\n\ttop_waiter = futex_top_waiter(hb1, key1);\n\n\t/* There are no waiters, nothing for us to do. */\n\tif (!top_waiter)\n\t\treturn 0;\n\n\t/* Ensure we requeue to the expected futex. */\n\tif (!match_futex(top_waiter->requeue_pi_key, key2))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try to take the lock for top_waiter.  Set the FUTEX_WAITERS bit in\n\t * the contended case or if set_waiters is 1.  The pi_state is returned\n\t * in ps in contended cases.\n\t */\n\tvpid = task_pid_vnr(top_waiter->task);\n\tret = futex_lock_pi_atomic(pifutex, hb2, key2, ps, top_waiter->task,\n\t\t\t\t   set_waiters);\n\tif (ret == 1) {\n\t\trequeue_pi_wake_futex(top_waiter, key2, hb2);\n\t\treturn vpid;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "curval",
            "uaddr1"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_futex_value_locked",
          "args": [
            "&curval",
            "uaddr1"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "768-777",
          "snippet": "static int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "cmpval != NULL"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "double_lock_hb",
          "args": [
            "hb1",
            "hb2"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "double_lock_hb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1490-1501",
          "snippet": "static inline void\ndouble_lock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tif (hb1 <= hb2) {\n\t\tspin_lock(&hb1->lock);\n\t\tif (hb1 < hb2)\n\t\t\tspin_lock_nested(&hb2->lock, SINGLE_DEPTH_NESTING);\n\t} else { /* hb1 > hb2 */\n\t\tspin_lock(&hb2->lock);\n\t\tspin_lock_nested(&hb1->lock, SINGLE_DEPTH_NESTING);\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void\ndouble_lock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tif (hb1 <= hb2) {\n\t\tspin_lock(&hb1->lock);\n\t\tif (hb1 < hb2)\n\t\t\tspin_lock_nested(&hb2->lock, SINGLE_DEPTH_NESTING);\n\t} else { /* hb1 > hb2 */\n\t\tspin_lock(&hb2->lock);\n\t\tspin_lock_nested(&hb1->lock, SINGLE_DEPTH_NESTING);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hb_waiters_inc",
          "args": [
            "hb2"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "hb_waiters_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "355-364",
          "snippet": "static inline void hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_inc(&hb->waiters);\n\t/*\n\t * Full barrier (A), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n#endif\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_inc(&hb->waiters);\n\t/*\n\t * Full barrier (A), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_futex",
          "args": [
            "&key2"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "hash_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "393-399",
          "snippet": "static struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define futex_hashsize (__futex_data.hashsize)",
            "#define futex_queues   (__futex_data.queues)"
          ],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define futex_hashsize (__futex_data.hashsize)\n#define futex_queues   (__futex_data.queues)\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret != 0"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_futex_key",
          "args": [
            "uaddr2",
            "flags & FLAGS_SHARED",
            "&key2",
            "requeue_pi ? VERIFY_WRITE : VERIFY_READ"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "499-705",
          "snippet": "static int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret != 0"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refill_pi_state_cache",
          "args": [],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "refill_pi_state_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "783-804",
          "snippet": "static int refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), GFP_KERNEL);\n\n\tif (!pi_state)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pi_state->list);\n\t/* pi_mutex gets initialized later */\n\tpi_state->owner = NULL;\n\tatomic_set(&pi_state->refcount, 1);\n\tpi_state->key = FUTEX_KEY_INIT;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), GFP_KERNEL);\n\n\tif (!pi_state)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pi_state->list);\n\t/* pi_mutex gets initialized later */\n\tpi_state->owner = NULL;\n\tatomic_set(&pi_state->refcount, 1);\n\tpi_state->key = FUTEX_KEY_INIT;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_FUTEX_PI"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAKE_Q",
          "args": [
            "wake_q"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (nr_wake < 0 || nr_requeue < 0)\n\t\treturn -EINVAL;\n\n\t/*\n\t * When PI not supported: return -ENOSYS if requeue_pi is true,\n\t * consequently the compiler knows requeue_pi is always false past\n\t * this point which will optimize away all the conditional code\n\t * further down.\n\t */\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI) && requeue_pi)\n\t\treturn -ENOSYS;\n\n\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;\n\n\t\t\t/* If the above failed, then pi_state is NULL */\n\t\tcase -EFAULT:\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Two reasons for this:\n\t\t\t * - Owner is exiting and we just wait for the\n\t\t\t *   exit to complete.\n\t\t\t * - The user space value changed.\n\t\t\t */\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always\n\t\t * be paired with each other and no other futex ops.\n\t\t *\n\t\t * We should never be requeueing a futex_q with a pi_state,\n\t\t * which is awaiting a futex_unlock_pi().\n\t\t */\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\n\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);\n\n\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret ? ret : task_count;\n}"
  },
  {
    "function_name": "futex_proxy_trylock_atomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1785-1832",
    "snippet": "static int futex_proxy_trylock_atomic(u32 __user *pifutex,\n\t\t\t\t struct futex_hash_bucket *hb1,\n\t\t\t\t struct futex_hash_bucket *hb2,\n\t\t\t\t union futex_key *key1, union futex_key *key2,\n\t\t\t\t struct futex_pi_state **ps, int set_waiters)\n{\n\tstruct futex_q *top_waiter = NULL;\n\tu32 curval;\n\tint ret, vpid;\n\n\tif (get_futex_value_locked(&curval, pifutex))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Find the top_waiter and determine if there are additional waiters.\n\t * If the caller intends to requeue more than 1 waiter to pifutex,\n\t * force futex_lock_pi_atomic() to set the FUTEX_WAITERS bit now,\n\t * as we have means to handle the possible fault.  If not, don't set\n\t * the bit unecessarily as it will force the subsequent unlock to enter\n\t * the kernel.\n\t */\n\ttop_waiter = futex_top_waiter(hb1, key1);\n\n\t/* There are no waiters, nothing for us to do. */\n\tif (!top_waiter)\n\t\treturn 0;\n\n\t/* Ensure we requeue to the expected futex. */\n\tif (!match_futex(top_waiter->requeue_pi_key, key2))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try to take the lock for top_waiter.  Set the FUTEX_WAITERS bit in\n\t * the contended case or if set_waiters is 1.  The pi_state is returned\n\t * in ps in contended cases.\n\t */\n\tvpid = task_pid_vnr(top_waiter->task);\n\tret = futex_lock_pi_atomic(pifutex, hb2, key2, ps, top_waiter->task,\n\t\t\t\t   set_waiters);\n\tif (ret == 1) {\n\t\trequeue_pi_wake_futex(top_waiter, key2, hb2);\n\t\treturn vpid;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "requeue_pi_wake_futex",
          "args": [
            "top_waiter",
            "key2",
            "hb2"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "requeue_pi_wake_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1748-1763",
          "snippet": "static inline\nvoid requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,\n\t\t\t   struct futex_hash_bucket *hb)\n{\n\tget_futex_key_refs(key);\n\tq->key = *key;\n\n\t__unqueue_futex(q);\n\n\tWARN_ON(!q->rt_waiter);\n\tq->rt_waiter = NULL;\n\n\tq->lock_ptr = &hb->lock;\n\n\twake_up_state(q->task, TASK_NORMAL);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline\nvoid requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,\n\t\t\t   struct futex_hash_bucket *hb)\n{\n\tget_futex_key_refs(key);\n\tq->key = *key;\n\n\t__unqueue_futex(q);\n\n\tWARN_ON(!q->rt_waiter);\n\tq->rt_waiter = NULL;\n\n\tq->lock_ptr = &hb->lock;\n\n\twake_up_state(q->task, TASK_NORMAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_lock_pi_atomic",
          "args": [
            "pifutex",
            "hb2",
            "key2",
            "ps",
            "top_waiter->task",
            "set_waiters"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "futex_lock_pi_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1282-1356",
          "snippet": "static int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,\n\t\t\t\tunion futex_key *key,\n\t\t\t\tstruct futex_pi_state **ps,\n\t\t\t\tstruct task_struct *task, int set_waiters)\n{\n\tu32 uval, newval, vpid = task_pid_vnr(task);\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\t/*\n\t * Read the user space value first so we can validate a few\n\t * things before proceeding further.\n\t */\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Detect deadlocks.\n\t */\n\tif ((unlikely((uval & FUTEX_TID_MASK) == vpid)))\n\t\treturn -EDEADLK;\n\n\tif ((unlikely(should_fail_futex(true))))\n\t\treturn -EDEADLK;\n\n\t/*\n\t * Lookup existing state first. If it exists, try to attach to\n\t * its pi_state.\n\t */\n\ttop_waiter = futex_top_waiter(hb, key);\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * No waiter and user TID is 0. We are here because the\n\t * waiters or the owner died bit is set or called from\n\t * requeue_cmp_pi or for whatever reason something took the\n\t * syscall.\n\t */\n\tif (!(uval & FUTEX_TID_MASK)) {\n\t\t/*\n\t\t * We take over the futex. No other waiters and the user space\n\t\t * TID is 0. We preserve the owner died bit.\n\t\t */\n\t\tnewval = uval & FUTEX_OWNER_DIED;\n\t\tnewval |= vpid;\n\n\t\t/* The futex requeue_pi code can enforce the waiters bit */\n\t\tif (set_waiters)\n\t\t\tnewval |= FUTEX_WAITERS;\n\n\t\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\t\t/* If the take over worked, return 1 */\n\t\treturn ret < 0 ? ret : 1;\n\t}\n\n\t/*\n\t * First waiter. Set the waiters bit before attaching ourself to\n\t * the owner. If owner tries to unlock, it will be forced into\n\t * the kernel and blocked on hb->lock.\n\t */\n\tnewval = uval | FUTEX_WAITERS;\n\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * If the update of the user space value succeeded, we try to\n\t * attach to the owner. If that fails, no harm done, we only\n\t * set the FUTEX_WAITERS bit in the user space variable.\n\t */\n\treturn attach_to_pi_owner(uval, key, ps);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,\n\t\t\t\tunion futex_key *key,\n\t\t\t\tstruct futex_pi_state **ps,\n\t\t\t\tstruct task_struct *task, int set_waiters)\n{\n\tu32 uval, newval, vpid = task_pid_vnr(task);\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\t/*\n\t * Read the user space value first so we can validate a few\n\t * things before proceeding further.\n\t */\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Detect deadlocks.\n\t */\n\tif ((unlikely((uval & FUTEX_TID_MASK) == vpid)))\n\t\treturn -EDEADLK;\n\n\tif ((unlikely(should_fail_futex(true))))\n\t\treturn -EDEADLK;\n\n\t/*\n\t * Lookup existing state first. If it exists, try to attach to\n\t * its pi_state.\n\t */\n\ttop_waiter = futex_top_waiter(hb, key);\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * No waiter and user TID is 0. We are here because the\n\t * waiters or the owner died bit is set or called from\n\t * requeue_cmp_pi or for whatever reason something took the\n\t * syscall.\n\t */\n\tif (!(uval & FUTEX_TID_MASK)) {\n\t\t/*\n\t\t * We take over the futex. No other waiters and the user space\n\t\t * TID is 0. We preserve the owner died bit.\n\t\t */\n\t\tnewval = uval & FUTEX_OWNER_DIED;\n\t\tnewval |= vpid;\n\n\t\t/* The futex requeue_pi code can enforce the waiters bit */\n\t\tif (set_waiters)\n\t\t\tnewval |= FUTEX_WAITERS;\n\n\t\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\t\t/* If the take over worked, return 1 */\n\t\treturn ret < 0 ? ret : 1;\n\t}\n\n\t/*\n\t * First waiter. Set the waiters bit before attaching ourself to\n\t * the owner. If owner tries to unlock, it will be forced into\n\t * the kernel and blocked on hb->lock.\n\t */\n\tnewval = uval | FUTEX_WAITERS;\n\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * If the update of the user space value succeeded, we try to\n\t * attach to the owner. If that fails, no harm done, we only\n\t * set the FUTEX_WAITERS bit in the user space variable.\n\t */\n\treturn attach_to_pi_owner(uval, key, ps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "top_waiter->task"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_futex",
          "args": [
            "top_waiter->requeue_pi_key",
            "key2"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "match_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "409-415",
          "snippet": "static inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_top_waiter",
          "args": [
            "hb1",
            "key1"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "futex_top_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "744-754",
          "snippet": "static struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "should_fail_futex(true)"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fail_futex",
          "args": [
            "true"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "should_fail_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "335-338",
          "snippet": "static inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_futex_value_locked",
          "args": [
            "&curval",
            "pifutex"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "768-777",
          "snippet": "static int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_proxy_trylock_atomic(u32 __user *pifutex,\n\t\t\t\t struct futex_hash_bucket *hb1,\n\t\t\t\t struct futex_hash_bucket *hb2,\n\t\t\t\t union futex_key *key1, union futex_key *key2,\n\t\t\t\t struct futex_pi_state **ps, int set_waiters)\n{\n\tstruct futex_q *top_waiter = NULL;\n\tu32 curval;\n\tint ret, vpid;\n\n\tif (get_futex_value_locked(&curval, pifutex))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Find the top_waiter and determine if there are additional waiters.\n\t * If the caller intends to requeue more than 1 waiter to pifutex,\n\t * force futex_lock_pi_atomic() to set the FUTEX_WAITERS bit now,\n\t * as we have means to handle the possible fault.  If not, don't set\n\t * the bit unecessarily as it will force the subsequent unlock to enter\n\t * the kernel.\n\t */\n\ttop_waiter = futex_top_waiter(hb1, key1);\n\n\t/* There are no waiters, nothing for us to do. */\n\tif (!top_waiter)\n\t\treturn 0;\n\n\t/* Ensure we requeue to the expected futex. */\n\tif (!match_futex(top_waiter->requeue_pi_key, key2))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try to take the lock for top_waiter.  Set the FUTEX_WAITERS bit in\n\t * the contended case or if set_waiters is 1.  The pi_state is returned\n\t * in ps in contended cases.\n\t */\n\tvpid = task_pid_vnr(top_waiter->task);\n\tret = futex_lock_pi_atomic(pifutex, hb2, key2, ps, top_waiter->task,\n\t\t\t\t   set_waiters);\n\tif (ret == 1) {\n\t\trequeue_pi_wake_futex(top_waiter, key2, hb2);\n\t\treturn vpid;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "requeue_pi_wake_futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1748-1763",
    "snippet": "static inline\nvoid requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,\n\t\t\t   struct futex_hash_bucket *hb)\n{\n\tget_futex_key_refs(key);\n\tq->key = *key;\n\n\t__unqueue_futex(q);\n\n\tWARN_ON(!q->rt_waiter);\n\tq->rt_waiter = NULL;\n\n\tq->lock_ptr = &hb->lock;\n\n\twake_up_state(q->task, TASK_NORMAL);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "q->task",
            "TASK_NORMAL"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!q->rt_waiter"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unqueue_futex",
          "args": [
            "q"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "__unqueue_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1364-1375",
          "snippet": "static void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (WARN_ON_SMP(!q->lock_ptr) || WARN_ON(plist_node_empty(&q->list)))\n\t\treturn;\n\tlockdep_assert_held(q->lock_ptr);\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (WARN_ON_SMP(!q->lock_ptr) || WARN_ON(plist_node_empty(&q->list)))\n\t\treturn;\n\tlockdep_assert_held(q->lock_ptr);\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_futex_key_refs",
          "args": [
            "key"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_key_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "422-452",
          "snippet": "static void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\t/*\n\t * On MMU less systems futexes are always \"private\" as there is no per\n\t * process address space. We need the smp wmb nevertheless - yes,\n\t * arch/blackfin has MMU less SMP ...\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU)) {\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tihold(key->shared.inode); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tfutex_get_mm(key); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Private futexes do not hold reference on an inode or\n\t\t * mm, therefore the only purpose of calling get_futex_key_refs\n\t\t * is because we need the barrier for the lockless waiter check.\n\t\t */\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\t/*\n\t * On MMU less systems futexes are always \"private\" as there is no per\n\t * process address space. We need the smp wmb nevertheless - yes,\n\t * arch/blackfin has MMU less SMP ...\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU)) {\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tihold(key->shared.inode); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tfutex_get_mm(key); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Private futexes do not hold reference on an inode or\n\t\t * mm, therefore the only purpose of calling get_futex_key_refs\n\t\t * is because we need the barrier for the lockless waiter check.\n\t\t */\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline\nvoid requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,\n\t\t\t   struct futex_hash_bucket *hb)\n{\n\tget_futex_key_refs(key);\n\tq->key = *key;\n\n\t__unqueue_futex(q);\n\n\tWARN_ON(!q->rt_waiter);\n\tq->rt_waiter = NULL;\n\n\tq->lock_ptr = &hb->lock;\n\n\twake_up_state(q->task, TASK_NORMAL);\n}"
  },
  {
    "function_name": "requeue_futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1714-1732",
    "snippet": "static inline\nvoid requeue_futex(struct futex_q *q, struct futex_hash_bucket *hb1,\n\t\t   struct futex_hash_bucket *hb2, union futex_key *key2)\n{\n\n\t/*\n\t * If key1 and key2 hash to the same bucket, no need to\n\t * requeue.\n\t */\n\tif (likely(&hb1->chain != &hb2->chain)) {\n\t\tplist_del(&q->list, &hb1->chain);\n\t\thb_waiters_dec(hb1);\n\t\thb_waiters_inc(hb2);\n\t\tplist_add(&q->list, &hb2->chain);\n\t\tq->lock_ptr = &hb2->lock;\n\t}\n\tget_futex_key_refs(key2);\n\tq->key = *key2;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_futex_key_refs",
          "args": [
            "key2"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_key_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "422-452",
          "snippet": "static void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\t/*\n\t * On MMU less systems futexes are always \"private\" as there is no per\n\t * process address space. We need the smp wmb nevertheless - yes,\n\t * arch/blackfin has MMU less SMP ...\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU)) {\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tihold(key->shared.inode); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tfutex_get_mm(key); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Private futexes do not hold reference on an inode or\n\t\t * mm, therefore the only purpose of calling get_futex_key_refs\n\t\t * is because we need the barrier for the lockless waiter check.\n\t\t */\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\t/*\n\t * On MMU less systems futexes are always \"private\" as there is no per\n\t * process address space. We need the smp wmb nevertheless - yes,\n\t * arch/blackfin has MMU less SMP ...\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU)) {\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tihold(key->shared.inode); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tfutex_get_mm(key); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Private futexes do not hold reference on an inode or\n\t\t * mm, therefore the only purpose of calling get_futex_key_refs\n\t\t * is because we need the barrier for the lockless waiter check.\n\t\t */\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_add",
          "args": [
            "&q->list",
            "&hb2->chain"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hb_waiters_inc",
          "args": [
            "hb2"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "hb_waiters_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "355-364",
          "snippet": "static inline void hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_inc(&hb->waiters);\n\t/*\n\t * Full barrier (A), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n#endif\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_inc(&hb->waiters);\n\t/*\n\t * Full barrier (A), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "hb_waiters_dec",
          "args": [
            "hb1"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "hb_waiters_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "370-375",
          "snippet": "static inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_del",
          "args": [
            "&q->list",
            "&hb1->chain"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "&hb1->chain != &hb2->chain"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline\nvoid requeue_futex(struct futex_q *q, struct futex_hash_bucket *hb1,\n\t\t   struct futex_hash_bucket *hb2, union futex_key *key2)\n{\n\n\t/*\n\t * If key1 and key2 hash to the same bucket, no need to\n\t * requeue.\n\t */\n\tif (likely(&hb1->chain != &hb2->chain)) {\n\t\tplist_del(&q->list, &hb1->chain);\n\t\thb_waiters_dec(hb1);\n\t\thb_waiters_inc(hb2);\n\t\tplist_add(&q->list, &hb2->chain);\n\t\tq->lock_ptr = &hb2->lock;\n\t}\n\tget_futex_key_refs(key2);\n\tq->key = *key2;\n}"
  },
  {
    "function_name": "futex_wake_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1614-1705",
    "snippet": "static int\nfutex_wake_op(u32 __user *uaddr1, unsigned int flags, u32 __user *uaddr2,\n\t      int nr_wake, int nr_wake2, int op)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tint ret, op_ret;\n\tDEFINE_WAKE_Q(wake_q);\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\tdouble_lock_hb(hb1, hb2);\n\top_ret = futex_atomic_op_inuser(op, uaddr2);\n\tif (unlikely(op_ret < 0)) {\n\n\t\tdouble_unlock_hb(hb1, hb2);\n\n#ifndef CONFIG_MMU\n\t\t/*\n\t\t * we don't get EFAULT from MMU faults if we don't have an MMU,\n\t\t * but we might get them from range checking\n\t\t */\n\t\tret = op_ret;\n\t\tgoto out_put_keys;\n#endif\n\n\t\tif (unlikely(op_ret != -EFAULT)) {\n\t\t\tret = op_ret;\n\t\t\tgoto out_put_keys;\n\t\t}\n\n\t\tret = fault_in_user_writeable(uaddr2);\n\t\tif (ret)\n\t\t\tgoto out_put_keys;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&key2);\n\t\tput_futex_key(&key1);\n\t\tgoto retry;\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (match_futex (&this->key, &key1)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (op_ret > 0) {\n\t\top_ret = 0;\n\t\tplist_for_each_entry_safe(this, next, &hb2->chain, list) {\n\t\t\tif (match_futex (&this->key, &key2)) {\n\t\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\t\tif (++op_ret >= nr_wake2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret += op_ret;\n\t}\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_futex_key",
          "args": [
            "&key1"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "put_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "707-710",
          "snippet": "static inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_q",
          "args": [
            "&wake_q"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_q",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "423-443",
          "snippet": "void wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\tBUG_ON(!task);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\tBUG_ON(!task);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_unlock_hb",
          "args": [
            "hb1",
            "hb2"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "double_unlock_hb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1503-1509",
          "snippet": "static inline void\ndouble_unlock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tspin_unlock(&hb1->lock);\n\tif (hb1 != hb2)\n\t\tspin_unlock(&hb2->lock);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void\ndouble_unlock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tspin_unlock(&hb1->lock);\n\tif (hb1 != hb2)\n\t\tspin_unlock(&hb2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_wake_futex",
          "args": [
            "&wake_q",
            "this"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "mark_wake_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1383-1404",
          "snippet": "static void mark_wake_futex(struct wake_q_head *wake_q, struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (WARN(q->pi_state || q->rt_waiter, \"refusing to wake PI futex\\n\"))\n\t\treturn;\n\n\t/*\n\t * Queue the task for later wakeup for after we've released\n\t * the hb->lock. wake_q_add() grabs reference to p.\n\t */\n\twake_q_add(wake_q, p);\n\t__unqueue_futex(q);\n\t/*\n\t * The waiting task can free the futex_q as soon as q->lock_ptr = NULL\n\t * is written, without taking any locks. This is possible in the event\n\t * of a spurious wakeup, for example. A memory barrier is required here\n\t * to prevent the following store to lock_ptr from getting ahead of the\n\t * plist_del in __unqueue_futex().\n\t */\n\tsmp_store_release(&q->lock_ptr, NULL);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void mark_wake_futex(struct wake_q_head *wake_q, struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (WARN(q->pi_state || q->rt_waiter, \"refusing to wake PI futex\\n\"))\n\t\treturn;\n\n\t/*\n\t * Queue the task for later wakeup for after we've released\n\t * the hb->lock. wake_q_add() grabs reference to p.\n\t */\n\twake_q_add(wake_q, p);\n\t__unqueue_futex(q);\n\t/*\n\t * The waiting task can free the futex_q as soon as q->lock_ptr = NULL\n\t * is written, without taking any locks. This is possible in the event\n\t * of a spurious wakeup, for example. A memory barrier is required here\n\t * to prevent the following store to lock_ptr from getting ahead of the\n\t * plist_del in __unqueue_futex().\n\t */\n\tsmp_store_release(&q->lock_ptr, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_futex",
          "args": [
            "&this->key",
            "&key2"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "match_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "409-415",
          "snippet": "static inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry_safe",
          "args": [
            "this",
            "next",
            "&hb2->chain",
            "list"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry_safe",
          "args": [
            "this",
            "next",
            "&hb1->chain",
            "list"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fault_in_user_writeable",
          "args": [
            "uaddr2"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "fault_in_user_writeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "724-735",
          "snippet": "static int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "op_ret != -EFAULT"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "op_ret < 0"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "futex_atomic_op_inuser",
          "args": [
            "op",
            "uaddr2"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "futex_atomic_op_inuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1563-1608",
          "snippet": "static int futex_atomic_op_inuser(unsigned int encoded_op, u32 __user *uaddr)\n{\n\tunsigned int op =\t  (encoded_op & 0x70000000) >> 28;\n\tunsigned int cmp =\t  (encoded_op & 0x0f000000) >> 24;\n\tint oparg = sign_extend32((encoded_op & 0x00fff000) >> 12, 11);\n\tint cmparg = sign_extend32(encoded_op & 0x00000fff, 11);\n\tint oldval, ret;\n\n\tif (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28)) {\n\t\tif (oparg < 0 || oparg > 31) {\n\t\t\tchar comm[sizeof(current->comm)];\n\t\t\t/*\n\t\t\t * kill this print and return -EINVAL when userspace\n\t\t\t * is sane again\n\t\t\t */\n\t\t\tpr_info_ratelimited(\"futex_wake_op: %s tries to shift op by %d; fix this program\\n\",\n\t\t\t\t\tget_task_comm(comm, current), oparg);\n\t\t\toparg &= 31;\n\t\t}\n\t\toparg = 1 << oparg;\n\t}\n\n\tif (!access_ok(VERIFY_WRITE, uaddr, sizeof(u32)))\n\t\treturn -EFAULT;\n\n\tret = arch_futex_atomic_op_inuser(op, oparg, &oldval, uaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (cmp) {\n\tcase FUTEX_OP_CMP_EQ:\n\t\treturn oldval == cmparg;\n\tcase FUTEX_OP_CMP_NE:\n\t\treturn oldval != cmparg;\n\tcase FUTEX_OP_CMP_LT:\n\t\treturn oldval < cmparg;\n\tcase FUTEX_OP_CMP_GE:\n\t\treturn oldval >= cmparg;\n\tcase FUTEX_OP_CMP_LE:\n\t\treturn oldval <= cmparg;\n\tcase FUTEX_OP_CMP_GT:\n\t\treturn oldval > cmparg;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int futex_atomic_op_inuser(unsigned int encoded_op, u32 __user *uaddr)\n{\n\tunsigned int op =\t  (encoded_op & 0x70000000) >> 28;\n\tunsigned int cmp =\t  (encoded_op & 0x0f000000) >> 24;\n\tint oparg = sign_extend32((encoded_op & 0x00fff000) >> 12, 11);\n\tint cmparg = sign_extend32(encoded_op & 0x00000fff, 11);\n\tint oldval, ret;\n\n\tif (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28)) {\n\t\tif (oparg < 0 || oparg > 31) {\n\t\t\tchar comm[sizeof(current->comm)];\n\t\t\t/*\n\t\t\t * kill this print and return -EINVAL when userspace\n\t\t\t * is sane again\n\t\t\t */\n\t\t\tpr_info_ratelimited(\"futex_wake_op: %s tries to shift op by %d; fix this program\\n\",\n\t\t\t\t\tget_task_comm(comm, current), oparg);\n\t\t\toparg &= 31;\n\t\t}\n\t\toparg = 1 << oparg;\n\t}\n\n\tif (!access_ok(VERIFY_WRITE, uaddr, sizeof(u32)))\n\t\treturn -EFAULT;\n\n\tret = arch_futex_atomic_op_inuser(op, oparg, &oldval, uaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (cmp) {\n\tcase FUTEX_OP_CMP_EQ:\n\t\treturn oldval == cmparg;\n\tcase FUTEX_OP_CMP_NE:\n\t\treturn oldval != cmparg;\n\tcase FUTEX_OP_CMP_LT:\n\t\treturn oldval < cmparg;\n\tcase FUTEX_OP_CMP_GE:\n\t\treturn oldval >= cmparg;\n\tcase FUTEX_OP_CMP_LE:\n\t\treturn oldval <= cmparg;\n\tcase FUTEX_OP_CMP_GT:\n\t\treturn oldval > cmparg;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_lock_hb",
          "args": [
            "hb1",
            "hb2"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "double_lock_hb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1490-1501",
          "snippet": "static inline void\ndouble_lock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tif (hb1 <= hb2) {\n\t\tspin_lock(&hb1->lock);\n\t\tif (hb1 < hb2)\n\t\t\tspin_lock_nested(&hb2->lock, SINGLE_DEPTH_NESTING);\n\t} else { /* hb1 > hb2 */\n\t\tspin_lock(&hb2->lock);\n\t\tspin_lock_nested(&hb1->lock, SINGLE_DEPTH_NESTING);\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void\ndouble_lock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tif (hb1 <= hb2) {\n\t\tspin_lock(&hb1->lock);\n\t\tif (hb1 < hb2)\n\t\t\tspin_lock_nested(&hb2->lock, SINGLE_DEPTH_NESTING);\n\t} else { /* hb1 > hb2 */\n\t\tspin_lock(&hb2->lock);\n\t\tspin_lock_nested(&hb1->lock, SINGLE_DEPTH_NESTING);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_futex",
          "args": [
            "&key2"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "hash_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "393-399",
          "snippet": "static struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define futex_hashsize (__futex_data.hashsize)",
            "#define futex_queues   (__futex_data.queues)"
          ],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define futex_hashsize (__futex_data.hashsize)\n#define futex_queues   (__futex_data.queues)\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret != 0"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_futex_key",
          "args": [
            "uaddr2",
            "flags & FLAGS_SHARED",
            "&key2",
            "VERIFY_WRITE"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "499-705",
          "snippet": "static int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret != 0"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAKE_Q",
          "args": [
            "wake_q"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int\nfutex_wake_op(u32 __user *uaddr1, unsigned int flags, u32 __user *uaddr2,\n\t      int nr_wake, int nr_wake2, int op)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tint ret, op_ret;\n\tDEFINE_WAKE_Q(wake_q);\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\tdouble_lock_hb(hb1, hb2);\n\top_ret = futex_atomic_op_inuser(op, uaddr2);\n\tif (unlikely(op_ret < 0)) {\n\n\t\tdouble_unlock_hb(hb1, hb2);\n\n#ifndef CONFIG_MMU\n\t\t/*\n\t\t * we don't get EFAULT from MMU faults if we don't have an MMU,\n\t\t * but we might get them from range checking\n\t\t */\n\t\tret = op_ret;\n\t\tgoto out_put_keys;\n#endif\n\n\t\tif (unlikely(op_ret != -EFAULT)) {\n\t\t\tret = op_ret;\n\t\t\tgoto out_put_keys;\n\t\t}\n\n\t\tret = fault_in_user_writeable(uaddr2);\n\t\tif (ret)\n\t\t\tgoto out_put_keys;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&key2);\n\t\tput_futex_key(&key1);\n\t\tgoto retry;\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (match_futex (&this->key, &key1)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (op_ret > 0) {\n\t\top_ret = 0;\n\t\tplist_for_each_entry_safe(this, next, &hb2->chain, list) {\n\t\t\tif (match_futex (&this->key, &key2)) {\n\t\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\t\tif (++op_ret >= nr_wake2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret += op_ret;\n\t}\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "futex_atomic_op_inuser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1563-1608",
    "snippet": "static int futex_atomic_op_inuser(unsigned int encoded_op, u32 __user *uaddr)\n{\n\tunsigned int op =\t  (encoded_op & 0x70000000) >> 28;\n\tunsigned int cmp =\t  (encoded_op & 0x0f000000) >> 24;\n\tint oparg = sign_extend32((encoded_op & 0x00fff000) >> 12, 11);\n\tint cmparg = sign_extend32(encoded_op & 0x00000fff, 11);\n\tint oldval, ret;\n\n\tif (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28)) {\n\t\tif (oparg < 0 || oparg > 31) {\n\t\t\tchar comm[sizeof(current->comm)];\n\t\t\t/*\n\t\t\t * kill this print and return -EINVAL when userspace\n\t\t\t * is sane again\n\t\t\t */\n\t\t\tpr_info_ratelimited(\"futex_wake_op: %s tries to shift op by %d; fix this program\\n\",\n\t\t\t\t\tget_task_comm(comm, current), oparg);\n\t\t\toparg &= 31;\n\t\t}\n\t\toparg = 1 << oparg;\n\t}\n\n\tif (!access_ok(VERIFY_WRITE, uaddr, sizeof(u32)))\n\t\treturn -EFAULT;\n\n\tret = arch_futex_atomic_op_inuser(op, oparg, &oldval, uaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (cmp) {\n\tcase FUTEX_OP_CMP_EQ:\n\t\treturn oldval == cmparg;\n\tcase FUTEX_OP_CMP_NE:\n\t\treturn oldval != cmparg;\n\tcase FUTEX_OP_CMP_LT:\n\t\treturn oldval < cmparg;\n\tcase FUTEX_OP_CMP_GE:\n\t\treturn oldval >= cmparg;\n\tcase FUTEX_OP_CMP_LE:\n\t\treturn oldval <= cmparg;\n\tcase FUTEX_OP_CMP_GT:\n\t\treturn oldval > cmparg;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__read_mostly __aligned(2*sizeof(long));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_futex_atomic_op_inuser",
          "args": [
            "op",
            "oparg",
            "&oldval",
            "uaddr"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "uaddr",
            "sizeof(u32)"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info_ratelimited",
          "args": [
            "\"futex_wake_op: %s tries to shift op by %d; fix this program\\n\"",
            "get_task_comm(comm, current)",
            "oparg"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "comm",
            "current"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sign_extend32",
          "args": [
            "encoded_op & 0x00000fff",
            "11"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sign_extend32",
          "args": [
            "(encoded_op & 0x00fff000) >> 12",
            "11"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int futex_atomic_op_inuser(unsigned int encoded_op, u32 __user *uaddr)\n{\n\tunsigned int op =\t  (encoded_op & 0x70000000) >> 28;\n\tunsigned int cmp =\t  (encoded_op & 0x0f000000) >> 24;\n\tint oparg = sign_extend32((encoded_op & 0x00fff000) >> 12, 11);\n\tint cmparg = sign_extend32(encoded_op & 0x00000fff, 11);\n\tint oldval, ret;\n\n\tif (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28)) {\n\t\tif (oparg < 0 || oparg > 31) {\n\t\t\tchar comm[sizeof(current->comm)];\n\t\t\t/*\n\t\t\t * kill this print and return -EINVAL when userspace\n\t\t\t * is sane again\n\t\t\t */\n\t\t\tpr_info_ratelimited(\"futex_wake_op: %s tries to shift op by %d; fix this program\\n\",\n\t\t\t\t\tget_task_comm(comm, current), oparg);\n\t\t\toparg &= 31;\n\t\t}\n\t\toparg = 1 << oparg;\n\t}\n\n\tif (!access_ok(VERIFY_WRITE, uaddr, sizeof(u32)))\n\t\treturn -EFAULT;\n\n\tret = arch_futex_atomic_op_inuser(op, oparg, &oldval, uaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (cmp) {\n\tcase FUTEX_OP_CMP_EQ:\n\t\treturn oldval == cmparg;\n\tcase FUTEX_OP_CMP_NE:\n\t\treturn oldval != cmparg;\n\tcase FUTEX_OP_CMP_LT:\n\t\treturn oldval < cmparg;\n\tcase FUTEX_OP_CMP_GE:\n\t\treturn oldval >= cmparg;\n\tcase FUTEX_OP_CMP_LE:\n\t\treturn oldval <= cmparg;\n\tcase FUTEX_OP_CMP_GT:\n\t\treturn oldval > cmparg;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
  },
  {
    "function_name": "futex_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1514-1561",
    "snippet": "static int\nfutex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *this, *next;\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tint ret;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\thb = hash_futex(&key);\n\n\t/* Make sure we really have tasks to wakeup */\n\tif (!hb_waiters_pending(hb))\n\t\tgoto out_put_key;\n\n\tspin_lock(&hb->lock);\n\n\tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n\t\tif (match_futex (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check if one of the bits is set in both bitsets */\n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\n\twake_up_q(&wake_q);\nout_put_key:\n\tput_futex_key(&key);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_futex_key",
          "args": [
            "&key"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "put_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "707-710",
          "snippet": "static inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_q",
          "args": [
            "&wake_q"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_q",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "423-443",
          "snippet": "void wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\tBUG_ON(!task);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\tBUG_ON(!task);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hb->lock"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_wake_futex",
          "args": [
            "&wake_q",
            "this"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "mark_wake_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1383-1404",
          "snippet": "static void mark_wake_futex(struct wake_q_head *wake_q, struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (WARN(q->pi_state || q->rt_waiter, \"refusing to wake PI futex\\n\"))\n\t\treturn;\n\n\t/*\n\t * Queue the task for later wakeup for after we've released\n\t * the hb->lock. wake_q_add() grabs reference to p.\n\t */\n\twake_q_add(wake_q, p);\n\t__unqueue_futex(q);\n\t/*\n\t * The waiting task can free the futex_q as soon as q->lock_ptr = NULL\n\t * is written, without taking any locks. This is possible in the event\n\t * of a spurious wakeup, for example. A memory barrier is required here\n\t * to prevent the following store to lock_ptr from getting ahead of the\n\t * plist_del in __unqueue_futex().\n\t */\n\tsmp_store_release(&q->lock_ptr, NULL);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void mark_wake_futex(struct wake_q_head *wake_q, struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (WARN(q->pi_state || q->rt_waiter, \"refusing to wake PI futex\\n\"))\n\t\treturn;\n\n\t/*\n\t * Queue the task for later wakeup for after we've released\n\t * the hb->lock. wake_q_add() grabs reference to p.\n\t */\n\twake_q_add(wake_q, p);\n\t__unqueue_futex(q);\n\t/*\n\t * The waiting task can free the futex_q as soon as q->lock_ptr = NULL\n\t * is written, without taking any locks. This is possible in the event\n\t * of a spurious wakeup, for example. A memory barrier is required here\n\t * to prevent the following store to lock_ptr from getting ahead of the\n\t * plist_del in __unqueue_futex().\n\t */\n\tsmp_store_release(&q->lock_ptr, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_futex",
          "args": [
            "&this->key",
            "&key"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "match_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "409-415",
          "snippet": "static inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry_safe",
          "args": [
            "this",
            "next",
            "&hb->chain",
            "list"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hb->lock"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hb_waiters_pending",
          "args": [
            "hb"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "hb_waiters_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "377-384",
          "snippet": "static inline int hb_waiters_pending(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\treturn atomic_read(&hb->waiters);\n#else\n\treturn 1;\n#endif\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int hb_waiters_pending(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\treturn atomic_read(&hb->waiters);\n#else\n\treturn 1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_futex",
          "args": [
            "&key"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "hash_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "393-399",
          "snippet": "static struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define futex_hashsize (__futex_data.hashsize)",
            "#define futex_queues   (__futex_data.queues)"
          ],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define futex_hashsize (__futex_data.hashsize)\n#define futex_queues   (__futex_data.queues)\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret != 0"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_futex_key",
          "args": [
            "uaddr",
            "flags & FLAGS_SHARED",
            "&key",
            "VERIFY_READ"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "499-705",
          "snippet": "static int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAKE_Q",
          "args": [
            "wake_q"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int\nfutex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *this, *next;\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tint ret;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\thb = hash_futex(&key);\n\n\t/* Make sure we really have tasks to wakeup */\n\tif (!hb_waiters_pending(hb))\n\t\tgoto out_put_key;\n\n\tspin_lock(&hb->lock);\n\n\tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n\t\tif (match_futex (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check if one of the bits is set in both bitsets */\n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\n\twake_up_q(&wake_q);\nout_put_key:\n\tput_futex_key(&key);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "double_unlock_hb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1503-1509",
    "snippet": "static inline void\ndouble_unlock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tspin_unlock(&hb1->lock);\n\tif (hb1 != hb2)\n\t\tspin_unlock(&hb2->lock);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hb2->lock"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void\ndouble_unlock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tspin_unlock(&hb1->lock);\n\tif (hb1 != hb2)\n\t\tspin_unlock(&hb2->lock);\n}"
  },
  {
    "function_name": "double_lock_hb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1490-1501",
    "snippet": "static inline void\ndouble_lock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tif (hb1 <= hb2) {\n\t\tspin_lock(&hb1->lock);\n\t\tif (hb1 < hb2)\n\t\t\tspin_lock_nested(&hb2->lock, SINGLE_DEPTH_NESTING);\n\t} else { /* hb1 > hb2 */\n\t\tspin_lock(&hb2->lock);\n\t\tspin_lock_nested(&hb1->lock, SINGLE_DEPTH_NESTING);\n\t}\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&hb1->lock",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "351-356",
          "snippet": "void __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hb2->lock"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void\ndouble_lock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tif (hb1 <= hb2) {\n\t\tspin_lock(&hb1->lock);\n\t\tif (hb1 < hb2)\n\t\t\tspin_lock_nested(&hb2->lock, SINGLE_DEPTH_NESTING);\n\t} else { /* hb1 > hb2 */\n\t\tspin_lock(&hb2->lock);\n\t\tspin_lock_nested(&hb1->lock, SINGLE_DEPTH_NESTING);\n\t}\n}"
  },
  {
    "function_name": "wake_futex_pi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1409-1485",
    "snippet": "static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_pi_state *pi_state)\n{\n\tu32 uninitialized_var(curval), newval;\n\tstruct task_struct *new_owner;\n\tbool postunlock = false;\n\tDEFINE_WAKE_Q(wake_q);\n\tint ret = 0;\n\n\tnew_owner = rt_mutex_next_owner(&pi_state->pi_mutex);\n\tif (WARN_ON_ONCE(!new_owner)) {\n\t\t/*\n\t\t * As per the comment in futex_unlock_pi() this should not happen.\n\t\t *\n\t\t * When this happens, give up our locks and try again, giving\n\t\t * the futex_lock_pi() instance time to complete, either by\n\t\t * waiting on the rtmutex or removing itself from the futex\n\t\t * queue.\n\t\t */\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * We pass it to the next owner. The WAITERS bit is always kept\n\t * enabled while there is PI state around. We cleanup the owner\n\t * died bit, because we are the owner.\n\t */\n\tnewval = FUTEX_WAITERS | task_pid_vnr(new_owner);\n\n\tif (unlikely(should_fail_futex(true)))\n\t\tret = -EFAULT;\n\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)) {\n\t\tret = -EFAULT;\n\n\t} else if (curval != uval) {\n\t\t/*\n\t\t * If a unconditional UNLOCK_PI operation (user space did not\n\t\t * try the TID->0 transition) raced with a waiter setting the\n\t\t * FUTEX_WAITERS flag between get_user() and locking the hash\n\t\t * bucket lock, retry the operation.\n\t\t */\n\t\tif ((FUTEX_TID_MASK & curval) == uval)\n\t\t\tret = -EAGAIN;\n\t\telse\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/*\n\t * This is a point of no return; once we modify the uval there is no\n\t * going back and subsequent operations must not fail.\n\t */\n\n\traw_spin_lock(&pi_state->owner->pi_lock);\n\tWARN_ON(list_empty(&pi_state->list));\n\tlist_del_init(&pi_state->list);\n\traw_spin_unlock(&pi_state->owner->pi_lock);\n\n\traw_spin_lock(&new_owner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &new_owner->pi_state_list);\n\tpi_state->owner = new_owner;\n\traw_spin_unlock(&new_owner->pi_lock);\n\n\tpostunlock = __rt_mutex_futex_unlock(&pi_state->pi_mutex, &wake_q);\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rt_mutex_postunlock",
          "args": [
            "&wake_q"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_postunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1446-1452",
          "snippet": "void rt_mutex_postunlock(struct wake_q_head *wake_q)\n{\n\twake_up_q(wake_q);\n\n\t/* Pairs with preempt_disable() in rt_mutex_slowunlock() */\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid rt_mutex_postunlock(struct wake_q_head *wake_q)\n{\n\twake_up_q(wake_q);\n\n\t/* Pairs with preempt_disable() in rt_mutex_slowunlock() */\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pi_state->pi_mutex.wait_lock"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rt_mutex_futex_unlock",
          "args": [
            "&pi_state->pi_mutex",
            "&wake_q"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_futex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1613-1634",
          "snippet": "bool __sched __rt_mutex_futex_unlock(struct rt_mutex *lock,\n\t\t\t\t    struct wake_q_head *wake_q)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n\n\tdebug_rt_mutex_unlock(lock);\n\n\tif (!rt_mutex_has_waiters(lock)) {\n\t\tlock->owner = NULL;\n\t\treturn false; /* done */\n\t}\n\n\t/*\n\t * We've already deboosted, mark_wakeup_next_waiter() will\n\t * retain preempt_disabled when we drop the wait_lock, to\n\t * avoid inversion prior to the wakeup.  preempt_disable()\n\t * therein pairs with rt_mutex_postunlock().\n\t */\n\tmark_wakeup_next_waiter(wake_q, lock);\n\n\treturn true; /* call postunlock() */\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nbool __sched __rt_mutex_futex_unlock(struct rt_mutex *lock,\n\t\t\t\t    struct wake_q_head *wake_q)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n\n\tdebug_rt_mutex_unlock(lock);\n\n\tif (!rt_mutex_has_waiters(lock)) {\n\t\tlock->owner = NULL;\n\t\treturn false; /* done */\n\t}\n\n\t/*\n\t * We've already deboosted, mark_wakeup_next_waiter() will\n\t * retain preempt_disabled when we drop the wait_lock, to\n\t * avoid inversion prior to the wakeup.  preempt_disable()\n\t * therein pairs with rt_mutex_postunlock().\n\t */\n\tmark_wakeup_next_waiter(wake_q, lock);\n\n\treturn true; /* call postunlock() */\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&new_owner->pi_lock"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pi_state->list",
            "&new_owner->pi_state_list"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&pi_state->list)"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pi_state->list"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&new_owner->pi_lock"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&pi_state->list"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "list_empty(&pi_state->list)"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_futex_value_locked",
          "args": [
            "&curval",
            "uaddr",
            "uval",
            "newval"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "cmpxchg_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "756-766",
          "snippet": "static int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "should_fail_futex(true)"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fail_futex",
          "args": [
            "true"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "should_fail_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "335-338",
          "snippet": "static inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "new_owner"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!new_owner"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_mutex_next_owner",
          "args": [
            "&pi_state->pi_mutex"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_next_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1798-1804",
          "snippet": "struct task_struct *rt_mutex_next_owner(struct rt_mutex *lock)\n{\n\tif (!rt_mutex_has_waiters(lock))\n\t\treturn NULL;\n\n\treturn rt_mutex_top_waiter(lock)->task;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nstruct task_struct *rt_mutex_next_owner(struct rt_mutex *lock)\n{\n\tif (!rt_mutex_has_waiters(lock))\n\t\treturn NULL;\n\n\treturn rt_mutex_top_waiter(lock)->task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAKE_Q",
          "args": [
            "wake_q"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_pi_state *pi_state)\n{\n\tu32 uninitialized_var(curval), newval;\n\tstruct task_struct *new_owner;\n\tbool postunlock = false;\n\tDEFINE_WAKE_Q(wake_q);\n\tint ret = 0;\n\n\tnew_owner = rt_mutex_next_owner(&pi_state->pi_mutex);\n\tif (WARN_ON_ONCE(!new_owner)) {\n\t\t/*\n\t\t * As per the comment in futex_unlock_pi() this should not happen.\n\t\t *\n\t\t * When this happens, give up our locks and try again, giving\n\t\t * the futex_lock_pi() instance time to complete, either by\n\t\t * waiting on the rtmutex or removing itself from the futex\n\t\t * queue.\n\t\t */\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * We pass it to the next owner. The WAITERS bit is always kept\n\t * enabled while there is PI state around. We cleanup the owner\n\t * died bit, because we are the owner.\n\t */\n\tnewval = FUTEX_WAITERS | task_pid_vnr(new_owner);\n\n\tif (unlikely(should_fail_futex(true)))\n\t\tret = -EFAULT;\n\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)) {\n\t\tret = -EFAULT;\n\n\t} else if (curval != uval) {\n\t\t/*\n\t\t * If a unconditional UNLOCK_PI operation (user space did not\n\t\t * try the TID->0 transition) raced with a waiter setting the\n\t\t * FUTEX_WAITERS flag between get_user() and locking the hash\n\t\t * bucket lock, retry the operation.\n\t\t */\n\t\tif ((FUTEX_TID_MASK & curval) == uval)\n\t\t\tret = -EAGAIN;\n\t\telse\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/*\n\t * This is a point of no return; once we modify the uval there is no\n\t * going back and subsequent operations must not fail.\n\t */\n\n\traw_spin_lock(&pi_state->owner->pi_lock);\n\tWARN_ON(list_empty(&pi_state->list));\n\tlist_del_init(&pi_state->list);\n\traw_spin_unlock(&pi_state->owner->pi_lock);\n\n\traw_spin_lock(&new_owner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &new_owner->pi_state_list);\n\tpi_state->owner = new_owner;\n\traw_spin_unlock(&new_owner->pi_lock);\n\n\tpostunlock = __rt_mutex_futex_unlock(&pi_state->pi_mutex, &wake_q);\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mark_wake_futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1383-1404",
    "snippet": "static void mark_wake_futex(struct wake_q_head *wake_q, struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (WARN(q->pi_state || q->rt_waiter, \"refusing to wake PI futex\\n\"))\n\t\treturn;\n\n\t/*\n\t * Queue the task for later wakeup for after we've released\n\t * the hb->lock. wake_q_add() grabs reference to p.\n\t */\n\twake_q_add(wake_q, p);\n\t__unqueue_futex(q);\n\t/*\n\t * The waiting task can free the futex_q as soon as q->lock_ptr = NULL\n\t * is written, without taking any locks. This is possible in the event\n\t * of a spurious wakeup, for example. A memory barrier is required here\n\t * to prevent the following store to lock_ptr from getting ahead of the\n\t * plist_del in __unqueue_futex().\n\t */\n\tsmp_store_release(&q->lock_ptr, NULL);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&q->lock_ptr",
            "NULL"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unqueue_futex",
          "args": [
            "q"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "__unqueue_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1364-1375",
          "snippet": "static void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (WARN_ON_SMP(!q->lock_ptr) || WARN_ON(plist_node_empty(&q->list)))\n\t\treturn;\n\tlockdep_assert_held(q->lock_ptr);\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (WARN_ON_SMP(!q->lock_ptr) || WARN_ON(plist_node_empty(&q->list)))\n\t\treturn;\n\tlockdep_assert_held(q->lock_ptr);\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_q_add",
          "args": [
            "wake_q",
            "p"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "wake_q_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "399-421",
          "snippet": "void wake_q_add(struct wake_q_head *head, struct task_struct *task)\n{\n\tstruct wake_q_node *node = &task->wake_q;\n\n\t/*\n\t * Atomically grab the task, if ->wake_q is !nil already it means\n\t * its already queued (either by us or someone else) and will get the\n\t * wakeup due to that.\n\t *\n\t * This cmpxchg() executes a full barrier, which pairs with the full\n\t * barrier executed by the wakeup in wake_up_q().\n\t */\n\tif (cmpxchg(&node->next, NULL, WAKE_Q_TAIL))\n\t\treturn;\n\n\tget_task_struct(task);\n\n\t/*\n\t * The head is context local, there can be no concurrency.\n\t */\n\t*head->lastp = node;\n\thead->lastp = &node->next;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid wake_q_add(struct wake_q_head *head, struct task_struct *task)\n{\n\tstruct wake_q_node *node = &task->wake_q;\n\n\t/*\n\t * Atomically grab the task, if ->wake_q is !nil already it means\n\t * its already queued (either by us or someone else) and will get the\n\t * wakeup due to that.\n\t *\n\t * This cmpxchg() executes a full barrier, which pairs with the full\n\t * barrier executed by the wakeup in wake_up_q().\n\t */\n\tif (cmpxchg(&node->next, NULL, WAKE_Q_TAIL))\n\t\treturn;\n\n\tget_task_struct(task);\n\n\t/*\n\t * The head is context local, there can be no concurrency.\n\t */\n\t*head->lastp = node;\n\thead->lastp = &node->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "q->pi_state || q->rt_waiter",
            "\"refusing to wake PI futex\\n\""
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void mark_wake_futex(struct wake_q_head *wake_q, struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (WARN(q->pi_state || q->rt_waiter, \"refusing to wake PI futex\\n\"))\n\t\treturn;\n\n\t/*\n\t * Queue the task for later wakeup for after we've released\n\t * the hb->lock. wake_q_add() grabs reference to p.\n\t */\n\twake_q_add(wake_q, p);\n\t__unqueue_futex(q);\n\t/*\n\t * The waiting task can free the futex_q as soon as q->lock_ptr = NULL\n\t * is written, without taking any locks. This is possible in the event\n\t * of a spurious wakeup, for example. A memory barrier is required here\n\t * to prevent the following store to lock_ptr from getting ahead of the\n\t * plist_del in __unqueue_futex().\n\t */\n\tsmp_store_release(&q->lock_ptr, NULL);\n}"
  },
  {
    "function_name": "__unqueue_futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1364-1375",
    "snippet": "static void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (WARN_ON_SMP(!q->lock_ptr) || WARN_ON(plist_node_empty(&q->list)))\n\t\treturn;\n\tlockdep_assert_held(q->lock_ptr);\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hb_waiters_dec",
          "args": [
            "hb"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "hb_waiters_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "370-375",
          "snippet": "static inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_del",
          "args": [
            "&q->list",
            "&hb->chain"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "q->lock_ptr",
            "structfutex_hash_bucket",
            "lock"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "q->lock_ptr"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "plist_node_empty(&q->list)"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_node_empty",
          "args": [
            "&q->list"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_SMP",
          "args": [
            "!q->lock_ptr"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (WARN_ON_SMP(!q->lock_ptr) || WARN_ON(plist_node_empty(&q->list)))\n\t\treturn;\n\tlockdep_assert_held(q->lock_ptr);\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}"
  },
  {
    "function_name": "futex_lock_pi_atomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1282-1356",
    "snippet": "static int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,\n\t\t\t\tunion futex_key *key,\n\t\t\t\tstruct futex_pi_state **ps,\n\t\t\t\tstruct task_struct *task, int set_waiters)\n{\n\tu32 uval, newval, vpid = task_pid_vnr(task);\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\t/*\n\t * Read the user space value first so we can validate a few\n\t * things before proceeding further.\n\t */\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Detect deadlocks.\n\t */\n\tif ((unlikely((uval & FUTEX_TID_MASK) == vpid)))\n\t\treturn -EDEADLK;\n\n\tif ((unlikely(should_fail_futex(true))))\n\t\treturn -EDEADLK;\n\n\t/*\n\t * Lookup existing state first. If it exists, try to attach to\n\t * its pi_state.\n\t */\n\ttop_waiter = futex_top_waiter(hb, key);\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * No waiter and user TID is 0. We are here because the\n\t * waiters or the owner died bit is set or called from\n\t * requeue_cmp_pi or for whatever reason something took the\n\t * syscall.\n\t */\n\tif (!(uval & FUTEX_TID_MASK)) {\n\t\t/*\n\t\t * We take over the futex. No other waiters and the user space\n\t\t * TID is 0. We preserve the owner died bit.\n\t\t */\n\t\tnewval = uval & FUTEX_OWNER_DIED;\n\t\tnewval |= vpid;\n\n\t\t/* The futex requeue_pi code can enforce the waiters bit */\n\t\tif (set_waiters)\n\t\t\tnewval |= FUTEX_WAITERS;\n\n\t\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\t\t/* If the take over worked, return 1 */\n\t\treturn ret < 0 ? ret : 1;\n\t}\n\n\t/*\n\t * First waiter. Set the waiters bit before attaching ourself to\n\t * the owner. If owner tries to unlock, it will be forced into\n\t * the kernel and blocked on hb->lock.\n\t */\n\tnewval = uval | FUTEX_WAITERS;\n\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * If the update of the user space value succeeded, we try to\n\t * attach to the owner. If that fails, no harm done, we only\n\t * set the FUTEX_WAITERS bit in the user space variable.\n\t */\n\treturn attach_to_pi_owner(uval, key, ps);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attach_to_pi_owner",
          "args": [
            "uval",
            "key",
            "ps"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "attach_to_pi_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1155-1228",
          "snippet": "static int attach_to_pi_owner(u32 uval, union futex_key *key,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tstruct futex_pi_state *pi_state;\n\tstruct task_struct *p;\n\n\t/*\n\t * We are the first waiter - try to look up the real owner and attach\n\t * the new pi_state to it, but bail out when TID = 0 [1]\n\t */\n\tif (!pid)\n\t\treturn -ESRCH;\n\tp = find_get_task_by_vpid(pid);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (unlikely(p->flags & PF_KTHREAD)) {\n\t\tput_task_struct(p);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We need to look at the task state flags to figure out,\n\t * whether the task is exiting. To protect against the do_exit\n\t * change of the task flags, we do this protected by\n\t * p->pi_lock:\n\t */\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->flags & PF_EXITING)) {\n\t\t/*\n\t\t * The task is on the way out. When PF_EXITPIDONE is\n\t\t * set, we know that the task has finished the\n\t\t * cleanup:\n\t\t */\n\t\tint ret = (p->flags & PF_EXITPIDONE) ? -ESRCH : -EAGAIN;\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * No existing pi state. First waiter. [2]\n\t *\n\t * This creates pi_state, we have hb->lock held, this means nothing can\n\t * observe this state, wait_lock is irrelevant.\n\t */\n\tpi_state = alloc_pi_state();\n\n\t/*\n\t * Initialize the pi_mutex in locked state and make @p\n\t * the owner of it:\n\t */\n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t/* Store the key for possible exit cleanups: */\n\tpi_state->key = *key;\n\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\t/*\n\t * Assignment without holding pi_state->pi_mutex.wait_lock is safe\n\t * because there is no concurrency as the object is not published yet.\n\t */\n\tpi_state->owner = p;\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\t*ps = pi_state;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int attach_to_pi_owner(u32 uval, union futex_key *key,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tstruct futex_pi_state *pi_state;\n\tstruct task_struct *p;\n\n\t/*\n\t * We are the first waiter - try to look up the real owner and attach\n\t * the new pi_state to it, but bail out when TID = 0 [1]\n\t */\n\tif (!pid)\n\t\treturn -ESRCH;\n\tp = find_get_task_by_vpid(pid);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (unlikely(p->flags & PF_KTHREAD)) {\n\t\tput_task_struct(p);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We need to look at the task state flags to figure out,\n\t * whether the task is exiting. To protect against the do_exit\n\t * change of the task flags, we do this protected by\n\t * p->pi_lock:\n\t */\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->flags & PF_EXITING)) {\n\t\t/*\n\t\t * The task is on the way out. When PF_EXITPIDONE is\n\t\t * set, we know that the task has finished the\n\t\t * cleanup:\n\t\t */\n\t\tint ret = (p->flags & PF_EXITPIDONE) ? -ESRCH : -EAGAIN;\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * No existing pi state. First waiter. [2]\n\t *\n\t * This creates pi_state, we have hb->lock held, this means nothing can\n\t * observe this state, wait_lock is irrelevant.\n\t */\n\tpi_state = alloc_pi_state();\n\n\t/*\n\t * Initialize the pi_mutex in locked state and make @p\n\t * the owner of it:\n\t */\n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t/* Store the key for possible exit cleanups: */\n\tpi_state->key = *key;\n\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\t/*\n\t * Assignment without holding pi_state->pi_mutex.wait_lock is safe\n\t * because there is no concurrency as the object is not published yet.\n\t */\n\tpi_state->owner = p;\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\t*ps = pi_state;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_pi_update_atomic",
          "args": [
            "uaddr",
            "uval",
            "newval"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "lock_pi_update_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1250-1262",
          "snippet": "static int lock_pi_update_atomic(u32 __user *uaddr, u32 uval, u32 newval)\n{\n\tu32 uninitialized_var(curval);\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\tif (unlikely(cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)))\n\t\treturn -EFAULT;\n\n\t/* If user space value changed, let the caller retry */\n\treturn curval != uval ? -EAGAIN : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int lock_pi_update_atomic(u32 __user *uaddr, u32 uval, u32 newval)\n{\n\tu32 uninitialized_var(curval);\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\tif (unlikely(cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)))\n\t\treturn -EFAULT;\n\n\t/* If user space value changed, let the caller retry */\n\treturn curval != uval ? -EAGAIN : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_to_pi_state",
          "args": [
            "uaddr",
            "uval",
            "top_waiter->pi_state",
            "ps"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "attach_to_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1033-1149",
          "snippet": "static int attach_to_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t      struct futex_pi_state *pi_state,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tu32 uval2;\n\tint ret;\n\n\t/*\n\t * Userspace might have messed up non-PI and PI futexes [3]\n\t */\n\tif (unlikely(!pi_state))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We get here with hb->lock held, and having found a\n\t * futex_top_waiter(). This means that futex_lock_pi() of said futex_q\n\t * has dropped the hb->lock in between queue_me() and unqueue_me_pi(),\n\t * which in turn means that futex_lock_pi() still has a reference on\n\t * our pi_state.\n\t *\n\t * The waiter holding a reference on @pi_state also protects against\n\t * the unlocked put_pi_state() in futex_unlock_pi(), futex_lock_pi()\n\t * and futex_wait_requeue_pi() as it cannot go to 0 and consequently\n\t * free pi_state before we can take a reference ourselves.\n\t */\n\tWARN_ON(!atomic_read(&pi_state->refcount));\n\n\t/*\n\t * Now that we have a pi_state, we can acquire wait_lock\n\t * and do the state validation.\n\t */\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Since {uval, pi_state} is serialized by wait_lock, and our current\n\t * uval was read without holding it, it can have changed. Verify it\n\t * still is what we expect it to be, otherwise retry the entire\n\t * operation.\n\t */\n\tif (get_futex_value_locked(&uval2, uaddr))\n\t\tgoto out_efault;\n\n\tif (uval != uval2)\n\t\tgoto out_eagain;\n\n\t/*\n\t * Handle the owner died case:\n\t */\n\tif (uval & FUTEX_OWNER_DIED) {\n\t\t/*\n\t\t * exit_pi_state_list sets owner to NULL and wakes the\n\t\t * topmost waiter. The task which acquires the\n\t\t * pi_state->rt_mutex will fixup owner.\n\t\t */\n\t\tif (!pi_state->owner) {\n\t\t\t/*\n\t\t\t * No pi state owner, but the user space TID\n\t\t\t * is not 0. Inconsistent state. [5]\n\t\t\t */\n\t\t\tif (pid)\n\t\t\t\tgoto out_einval;\n\t\t\t/*\n\t\t\t * Take a ref on the state and return success. [4]\n\t\t\t */\n\t\t\tgoto out_attach;\n\t\t}\n\n\t\t/*\n\t\t * If TID is 0, then either the dying owner has not\n\t\t * yet executed exit_pi_state_list() or some waiter\n\t\t * acquired the rtmutex in the pi state, but did not\n\t\t * yet fixup the TID in user space.\n\t\t *\n\t\t * Take a ref on the state and return success. [6]\n\t\t */\n\t\tif (!pid)\n\t\t\tgoto out_attach;\n\t} else {\n\t\t/*\n\t\t * If the owner died bit is not set, then the pi_state\n\t\t * must have an owner. [7]\n\t\t */\n\t\tif (!pi_state->owner)\n\t\t\tgoto out_einval;\n\t}\n\n\t/*\n\t * Bail out if user space manipulated the futex value. If pi\n\t * state exists then the owner TID must be the same as the\n\t * user space TID. [9/10]\n\t */\n\tif (pid != task_pid_vnr(pi_state->owner))\n\t\tgoto out_einval;\n\nout_attach:\n\tget_pi_state(pi_state);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t*ps = pi_state;\n\treturn 0;\n\nout_einval:\n\tret = -EINVAL;\n\tgoto out_error;\n\nout_eagain:\n\tret = -EAGAIN;\n\tgoto out_error;\n\nout_efault:\n\tret = -EFAULT;\n\tgoto out_error;\n\nout_error:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int attach_to_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t      struct futex_pi_state *pi_state,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tu32 uval2;\n\tint ret;\n\n\t/*\n\t * Userspace might have messed up non-PI and PI futexes [3]\n\t */\n\tif (unlikely(!pi_state))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We get here with hb->lock held, and having found a\n\t * futex_top_waiter(). This means that futex_lock_pi() of said futex_q\n\t * has dropped the hb->lock in between queue_me() and unqueue_me_pi(),\n\t * which in turn means that futex_lock_pi() still has a reference on\n\t * our pi_state.\n\t *\n\t * The waiter holding a reference on @pi_state also protects against\n\t * the unlocked put_pi_state() in futex_unlock_pi(), futex_lock_pi()\n\t * and futex_wait_requeue_pi() as it cannot go to 0 and consequently\n\t * free pi_state before we can take a reference ourselves.\n\t */\n\tWARN_ON(!atomic_read(&pi_state->refcount));\n\n\t/*\n\t * Now that we have a pi_state, we can acquire wait_lock\n\t * and do the state validation.\n\t */\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Since {uval, pi_state} is serialized by wait_lock, and our current\n\t * uval was read without holding it, it can have changed. Verify it\n\t * still is what we expect it to be, otherwise retry the entire\n\t * operation.\n\t */\n\tif (get_futex_value_locked(&uval2, uaddr))\n\t\tgoto out_efault;\n\n\tif (uval != uval2)\n\t\tgoto out_eagain;\n\n\t/*\n\t * Handle the owner died case:\n\t */\n\tif (uval & FUTEX_OWNER_DIED) {\n\t\t/*\n\t\t * exit_pi_state_list sets owner to NULL and wakes the\n\t\t * topmost waiter. The task which acquires the\n\t\t * pi_state->rt_mutex will fixup owner.\n\t\t */\n\t\tif (!pi_state->owner) {\n\t\t\t/*\n\t\t\t * No pi state owner, but the user space TID\n\t\t\t * is not 0. Inconsistent state. [5]\n\t\t\t */\n\t\t\tif (pid)\n\t\t\t\tgoto out_einval;\n\t\t\t/*\n\t\t\t * Take a ref on the state and return success. [4]\n\t\t\t */\n\t\t\tgoto out_attach;\n\t\t}\n\n\t\t/*\n\t\t * If TID is 0, then either the dying owner has not\n\t\t * yet executed exit_pi_state_list() or some waiter\n\t\t * acquired the rtmutex in the pi state, but did not\n\t\t * yet fixup the TID in user space.\n\t\t *\n\t\t * Take a ref on the state and return success. [6]\n\t\t */\n\t\tif (!pid)\n\t\t\tgoto out_attach;\n\t} else {\n\t\t/*\n\t\t * If the owner died bit is not set, then the pi_state\n\t\t * must have an owner. [7]\n\t\t */\n\t\tif (!pi_state->owner)\n\t\t\tgoto out_einval;\n\t}\n\n\t/*\n\t * Bail out if user space manipulated the futex value. If pi\n\t * state exists then the owner TID must be the same as the\n\t * user space TID. [9/10]\n\t */\n\tif (pid != task_pid_vnr(pi_state->owner))\n\t\tgoto out_einval;\n\nout_attach:\n\tget_pi_state(pi_state);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t*ps = pi_state;\n\treturn 0;\n\nout_einval:\n\tret = -EINVAL;\n\tgoto out_error;\n\nout_eagain:\n\tret = -EAGAIN;\n\tgoto out_error;\n\nout_efault:\n\tret = -EFAULT;\n\tgoto out_error;\n\nout_error:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_top_waiter",
          "args": [
            "hb",
            "key"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "futex_top_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "744-754",
          "snippet": "static struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "should_fail_futex(true)"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fail_futex",
          "args": [
            "true"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "should_fail_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "335-338",
          "snippet": "static inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(uval & FUTEX_TID_MASK) == vpid"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "should_fail_futex(true)"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_futex_value_locked",
          "args": [
            "&uval",
            "uaddr"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "768-777",
          "snippet": "static int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "task"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,\n\t\t\t\tunion futex_key *key,\n\t\t\t\tstruct futex_pi_state **ps,\n\t\t\t\tstruct task_struct *task, int set_waiters)\n{\n\tu32 uval, newval, vpid = task_pid_vnr(task);\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\t/*\n\t * Read the user space value first so we can validate a few\n\t * things before proceeding further.\n\t */\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Detect deadlocks.\n\t */\n\tif ((unlikely((uval & FUTEX_TID_MASK) == vpid)))\n\t\treturn -EDEADLK;\n\n\tif ((unlikely(should_fail_futex(true))))\n\t\treturn -EDEADLK;\n\n\t/*\n\t * Lookup existing state first. If it exists, try to attach to\n\t * its pi_state.\n\t */\n\ttop_waiter = futex_top_waiter(hb, key);\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * No waiter and user TID is 0. We are here because the\n\t * waiters or the owner died bit is set or called from\n\t * requeue_cmp_pi or for whatever reason something took the\n\t * syscall.\n\t */\n\tif (!(uval & FUTEX_TID_MASK)) {\n\t\t/*\n\t\t * We take over the futex. No other waiters and the user space\n\t\t * TID is 0. We preserve the owner died bit.\n\t\t */\n\t\tnewval = uval & FUTEX_OWNER_DIED;\n\t\tnewval |= vpid;\n\n\t\t/* The futex requeue_pi code can enforce the waiters bit */\n\t\tif (set_waiters)\n\t\t\tnewval |= FUTEX_WAITERS;\n\n\t\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\t\t/* If the take over worked, return 1 */\n\t\treturn ret < 0 ? ret : 1;\n\t}\n\n\t/*\n\t * First waiter. Set the waiters bit before attaching ourself to\n\t * the owner. If owner tries to unlock, it will be forced into\n\t * the kernel and blocked on hb->lock.\n\t */\n\tnewval = uval | FUTEX_WAITERS;\n\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * If the update of the user space value succeeded, we try to\n\t * attach to the owner. If that fails, no harm done, we only\n\t * set the FUTEX_WAITERS bit in the user space variable.\n\t */\n\treturn attach_to_pi_owner(uval, key, ps);\n}"
  },
  {
    "function_name": "lock_pi_update_atomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1250-1262",
    "snippet": "static int lock_pi_update_atomic(u32 __user *uaddr, u32 uval, u32 newval)\n{\n\tu32 uninitialized_var(curval);\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\tif (unlikely(cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)))\n\t\treturn -EFAULT;\n\n\t/* If user space value changed, let the caller retry */\n\treturn curval != uval ? -EAGAIN : 0;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_futex_value_locked",
          "args": [
            "&curval",
            "uaddr",
            "uval",
            "newval"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "cmpxchg_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "756-766",
          "snippet": "static int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "should_fail_futex(true)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fail_futex",
          "args": [
            "true"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "should_fail_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "335-338",
          "snippet": "static inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int lock_pi_update_atomic(u32 __user *uaddr, u32 uval, u32 newval)\n{\n\tu32 uninitialized_var(curval);\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\tif (unlikely(cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)))\n\t\treturn -EFAULT;\n\n\t/* If user space value changed, let the caller retry */\n\treturn curval != uval ? -EAGAIN : 0;\n}"
  },
  {
    "function_name": "lookup_pi_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1230-1248",
    "snippet": "static int lookup_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t   struct futex_hash_bucket *hb,\n\t\t\t   union futex_key *key, struct futex_pi_state **ps)\n{\n\tstruct futex_q *top_waiter = futex_top_waiter(hb, key);\n\n\t/*\n\t * If there is a waiter on that futex, validate it and\n\t * attach to the pi_state when the validation succeeds.\n\t */\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * We are the first waiter - try to look up the owner based on\n\t * @uval and attach to it.\n\t */\n\treturn attach_to_pi_owner(uval, key, ps);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attach_to_pi_owner",
          "args": [
            "uval",
            "key",
            "ps"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "attach_to_pi_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1155-1228",
          "snippet": "static int attach_to_pi_owner(u32 uval, union futex_key *key,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tstruct futex_pi_state *pi_state;\n\tstruct task_struct *p;\n\n\t/*\n\t * We are the first waiter - try to look up the real owner and attach\n\t * the new pi_state to it, but bail out when TID = 0 [1]\n\t */\n\tif (!pid)\n\t\treturn -ESRCH;\n\tp = find_get_task_by_vpid(pid);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (unlikely(p->flags & PF_KTHREAD)) {\n\t\tput_task_struct(p);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We need to look at the task state flags to figure out,\n\t * whether the task is exiting. To protect against the do_exit\n\t * change of the task flags, we do this protected by\n\t * p->pi_lock:\n\t */\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->flags & PF_EXITING)) {\n\t\t/*\n\t\t * The task is on the way out. When PF_EXITPIDONE is\n\t\t * set, we know that the task has finished the\n\t\t * cleanup:\n\t\t */\n\t\tint ret = (p->flags & PF_EXITPIDONE) ? -ESRCH : -EAGAIN;\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * No existing pi state. First waiter. [2]\n\t *\n\t * This creates pi_state, we have hb->lock held, this means nothing can\n\t * observe this state, wait_lock is irrelevant.\n\t */\n\tpi_state = alloc_pi_state();\n\n\t/*\n\t * Initialize the pi_mutex in locked state and make @p\n\t * the owner of it:\n\t */\n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t/* Store the key for possible exit cleanups: */\n\tpi_state->key = *key;\n\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\t/*\n\t * Assignment without holding pi_state->pi_mutex.wait_lock is safe\n\t * because there is no concurrency as the object is not published yet.\n\t */\n\tpi_state->owner = p;\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\t*ps = pi_state;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int attach_to_pi_owner(u32 uval, union futex_key *key,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tstruct futex_pi_state *pi_state;\n\tstruct task_struct *p;\n\n\t/*\n\t * We are the first waiter - try to look up the real owner and attach\n\t * the new pi_state to it, but bail out when TID = 0 [1]\n\t */\n\tif (!pid)\n\t\treturn -ESRCH;\n\tp = find_get_task_by_vpid(pid);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (unlikely(p->flags & PF_KTHREAD)) {\n\t\tput_task_struct(p);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We need to look at the task state flags to figure out,\n\t * whether the task is exiting. To protect against the do_exit\n\t * change of the task flags, we do this protected by\n\t * p->pi_lock:\n\t */\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->flags & PF_EXITING)) {\n\t\t/*\n\t\t * The task is on the way out. When PF_EXITPIDONE is\n\t\t * set, we know that the task has finished the\n\t\t * cleanup:\n\t\t */\n\t\tint ret = (p->flags & PF_EXITPIDONE) ? -ESRCH : -EAGAIN;\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * No existing pi state. First waiter. [2]\n\t *\n\t * This creates pi_state, we have hb->lock held, this means nothing can\n\t * observe this state, wait_lock is irrelevant.\n\t */\n\tpi_state = alloc_pi_state();\n\n\t/*\n\t * Initialize the pi_mutex in locked state and make @p\n\t * the owner of it:\n\t */\n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t/* Store the key for possible exit cleanups: */\n\tpi_state->key = *key;\n\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\t/*\n\t * Assignment without holding pi_state->pi_mutex.wait_lock is safe\n\t * because there is no concurrency as the object is not published yet.\n\t */\n\tpi_state->owner = p;\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\t*ps = pi_state;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_to_pi_state",
          "args": [
            "uaddr",
            "uval",
            "top_waiter->pi_state",
            "ps"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "attach_to_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "1033-1149",
          "snippet": "static int attach_to_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t      struct futex_pi_state *pi_state,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tu32 uval2;\n\tint ret;\n\n\t/*\n\t * Userspace might have messed up non-PI and PI futexes [3]\n\t */\n\tif (unlikely(!pi_state))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We get here with hb->lock held, and having found a\n\t * futex_top_waiter(). This means that futex_lock_pi() of said futex_q\n\t * has dropped the hb->lock in between queue_me() and unqueue_me_pi(),\n\t * which in turn means that futex_lock_pi() still has a reference on\n\t * our pi_state.\n\t *\n\t * The waiter holding a reference on @pi_state also protects against\n\t * the unlocked put_pi_state() in futex_unlock_pi(), futex_lock_pi()\n\t * and futex_wait_requeue_pi() as it cannot go to 0 and consequently\n\t * free pi_state before we can take a reference ourselves.\n\t */\n\tWARN_ON(!atomic_read(&pi_state->refcount));\n\n\t/*\n\t * Now that we have a pi_state, we can acquire wait_lock\n\t * and do the state validation.\n\t */\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Since {uval, pi_state} is serialized by wait_lock, and our current\n\t * uval was read without holding it, it can have changed. Verify it\n\t * still is what we expect it to be, otherwise retry the entire\n\t * operation.\n\t */\n\tif (get_futex_value_locked(&uval2, uaddr))\n\t\tgoto out_efault;\n\n\tif (uval != uval2)\n\t\tgoto out_eagain;\n\n\t/*\n\t * Handle the owner died case:\n\t */\n\tif (uval & FUTEX_OWNER_DIED) {\n\t\t/*\n\t\t * exit_pi_state_list sets owner to NULL and wakes the\n\t\t * topmost waiter. The task which acquires the\n\t\t * pi_state->rt_mutex will fixup owner.\n\t\t */\n\t\tif (!pi_state->owner) {\n\t\t\t/*\n\t\t\t * No pi state owner, but the user space TID\n\t\t\t * is not 0. Inconsistent state. [5]\n\t\t\t */\n\t\t\tif (pid)\n\t\t\t\tgoto out_einval;\n\t\t\t/*\n\t\t\t * Take a ref on the state and return success. [4]\n\t\t\t */\n\t\t\tgoto out_attach;\n\t\t}\n\n\t\t/*\n\t\t * If TID is 0, then either the dying owner has not\n\t\t * yet executed exit_pi_state_list() or some waiter\n\t\t * acquired the rtmutex in the pi state, but did not\n\t\t * yet fixup the TID in user space.\n\t\t *\n\t\t * Take a ref on the state and return success. [6]\n\t\t */\n\t\tif (!pid)\n\t\t\tgoto out_attach;\n\t} else {\n\t\t/*\n\t\t * If the owner died bit is not set, then the pi_state\n\t\t * must have an owner. [7]\n\t\t */\n\t\tif (!pi_state->owner)\n\t\t\tgoto out_einval;\n\t}\n\n\t/*\n\t * Bail out if user space manipulated the futex value. If pi\n\t * state exists then the owner TID must be the same as the\n\t * user space TID. [9/10]\n\t */\n\tif (pid != task_pid_vnr(pi_state->owner))\n\t\tgoto out_einval;\n\nout_attach:\n\tget_pi_state(pi_state);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t*ps = pi_state;\n\treturn 0;\n\nout_einval:\n\tret = -EINVAL;\n\tgoto out_error;\n\nout_eagain:\n\tret = -EAGAIN;\n\tgoto out_error;\n\nout_efault:\n\tret = -EFAULT;\n\tgoto out_error;\n\nout_error:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int attach_to_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t      struct futex_pi_state *pi_state,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tu32 uval2;\n\tint ret;\n\n\t/*\n\t * Userspace might have messed up non-PI and PI futexes [3]\n\t */\n\tif (unlikely(!pi_state))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We get here with hb->lock held, and having found a\n\t * futex_top_waiter(). This means that futex_lock_pi() of said futex_q\n\t * has dropped the hb->lock in between queue_me() and unqueue_me_pi(),\n\t * which in turn means that futex_lock_pi() still has a reference on\n\t * our pi_state.\n\t *\n\t * The waiter holding a reference on @pi_state also protects against\n\t * the unlocked put_pi_state() in futex_unlock_pi(), futex_lock_pi()\n\t * and futex_wait_requeue_pi() as it cannot go to 0 and consequently\n\t * free pi_state before we can take a reference ourselves.\n\t */\n\tWARN_ON(!atomic_read(&pi_state->refcount));\n\n\t/*\n\t * Now that we have a pi_state, we can acquire wait_lock\n\t * and do the state validation.\n\t */\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Since {uval, pi_state} is serialized by wait_lock, and our current\n\t * uval was read without holding it, it can have changed. Verify it\n\t * still is what we expect it to be, otherwise retry the entire\n\t * operation.\n\t */\n\tif (get_futex_value_locked(&uval2, uaddr))\n\t\tgoto out_efault;\n\n\tif (uval != uval2)\n\t\tgoto out_eagain;\n\n\t/*\n\t * Handle the owner died case:\n\t */\n\tif (uval & FUTEX_OWNER_DIED) {\n\t\t/*\n\t\t * exit_pi_state_list sets owner to NULL and wakes the\n\t\t * topmost waiter. The task which acquires the\n\t\t * pi_state->rt_mutex will fixup owner.\n\t\t */\n\t\tif (!pi_state->owner) {\n\t\t\t/*\n\t\t\t * No pi state owner, but the user space TID\n\t\t\t * is not 0. Inconsistent state. [5]\n\t\t\t */\n\t\t\tif (pid)\n\t\t\t\tgoto out_einval;\n\t\t\t/*\n\t\t\t * Take a ref on the state and return success. [4]\n\t\t\t */\n\t\t\tgoto out_attach;\n\t\t}\n\n\t\t/*\n\t\t * If TID is 0, then either the dying owner has not\n\t\t * yet executed exit_pi_state_list() or some waiter\n\t\t * acquired the rtmutex in the pi state, but did not\n\t\t * yet fixup the TID in user space.\n\t\t *\n\t\t * Take a ref on the state and return success. [6]\n\t\t */\n\t\tif (!pid)\n\t\t\tgoto out_attach;\n\t} else {\n\t\t/*\n\t\t * If the owner died bit is not set, then the pi_state\n\t\t * must have an owner. [7]\n\t\t */\n\t\tif (!pi_state->owner)\n\t\t\tgoto out_einval;\n\t}\n\n\t/*\n\t * Bail out if user space manipulated the futex value. If pi\n\t * state exists then the owner TID must be the same as the\n\t * user space TID. [9/10]\n\t */\n\tif (pid != task_pid_vnr(pi_state->owner))\n\t\tgoto out_einval;\n\nout_attach:\n\tget_pi_state(pi_state);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t*ps = pi_state;\n\treturn 0;\n\nout_einval:\n\tret = -EINVAL;\n\tgoto out_error;\n\nout_eagain:\n\tret = -EAGAIN;\n\tgoto out_error;\n\nout_efault:\n\tret = -EFAULT;\n\tgoto out_error;\n\nout_error:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_top_waiter",
          "args": [
            "hb",
            "key"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "futex_top_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "744-754",
          "snippet": "static struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int lookup_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t   struct futex_hash_bucket *hb,\n\t\t\t   union futex_key *key, struct futex_pi_state **ps)\n{\n\tstruct futex_q *top_waiter = futex_top_waiter(hb, key);\n\n\t/*\n\t * If there is a waiter on that futex, validate it and\n\t * attach to the pi_state when the validation succeeds.\n\t */\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t/*\n\t * We are the first waiter - try to look up the owner based on\n\t * @uval and attach to it.\n\t */\n\treturn attach_to_pi_owner(uval, key, ps);\n}"
  },
  {
    "function_name": "attach_to_pi_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1155-1228",
    "snippet": "static int attach_to_pi_owner(u32 uval, union futex_key *key,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tstruct futex_pi_state *pi_state;\n\tstruct task_struct *p;\n\n\t/*\n\t * We are the first waiter - try to look up the real owner and attach\n\t * the new pi_state to it, but bail out when TID = 0 [1]\n\t */\n\tif (!pid)\n\t\treturn -ESRCH;\n\tp = find_get_task_by_vpid(pid);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (unlikely(p->flags & PF_KTHREAD)) {\n\t\tput_task_struct(p);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We need to look at the task state flags to figure out,\n\t * whether the task is exiting. To protect against the do_exit\n\t * change of the task flags, we do this protected by\n\t * p->pi_lock:\n\t */\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->flags & PF_EXITING)) {\n\t\t/*\n\t\t * The task is on the way out. When PF_EXITPIDONE is\n\t\t * set, we know that the task has finished the\n\t\t * cleanup:\n\t\t */\n\t\tint ret = (p->flags & PF_EXITPIDONE) ? -ESRCH : -EAGAIN;\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * No existing pi state. First waiter. [2]\n\t *\n\t * This creates pi_state, we have hb->lock held, this means nothing can\n\t * observe this state, wait_lock is irrelevant.\n\t */\n\tpi_state = alloc_pi_state();\n\n\t/*\n\t * Initialize the pi_mutex in locked state and make @p\n\t * the owner of it:\n\t */\n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t/* Store the key for possible exit cleanups: */\n\tpi_state->key = *key;\n\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\t/*\n\t * Assignment without holding pi_state->pi_mutex.wait_lock is safe\n\t * because there is no concurrency as the object is not published yet.\n\t */\n\tpi_state->owner = p;\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\t*ps = pi_state;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&p->pi_lock"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pi_state->list",
            "&p->pi_state_list"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&pi_state->list)"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pi_state->list"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_init_proxy_locked",
          "args": [
            "&pi_state->pi_mutex",
            "p"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_proxy_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1702-1708",
          "snippet": "void rt_mutex_init_proxy_locked(struct rt_mutex *lock,\n\t\t\t\tstruct task_struct *proxy_owner)\n{\n\t__rt_mutex_init(lock, NULL, NULL);\n\tdebug_rt_mutex_proxy_lock(lock, proxy_owner);\n\trt_mutex_set_owner(lock, proxy_owner);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid rt_mutex_init_proxy_locked(struct rt_mutex *lock,\n\t\t\t\tstruct task_struct *proxy_owner)\n{\n\t__rt_mutex_init(lock, NULL, NULL);\n\tdebug_rt_mutex_proxy_lock(lock, proxy_owner);\n\trt_mutex_set_owner(lock, proxy_owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pi_state",
          "args": [],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "806-814",
          "snippet": "static struct futex_pi_state *alloc_pi_state(void)\n{\n\tstruct futex_pi_state *pi_state = current->pi_state_cache;\n\n\tWARN_ON(!pi_state);\n\tcurrent->pi_state_cache = NULL;\n\n\treturn pi_state;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic struct futex_pi_state *alloc_pi_state(void)\n{\n\tstruct futex_pi_state *pi_state = current->pi_state_cache;\n\n\tWARN_ON(!pi_state);\n\tcurrent->pi_state_cache = NULL;\n\n\treturn pi_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->flags & PF_EXITING"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&p->pi_lock"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->flags & PF_KTHREAD"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_task_by_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "353-364",
          "snippet": "struct task_struct *find_get_task_by_vpid(pid_t nr)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\ttask = find_task_by_vpid(nr);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\treturn task;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_get_task_by_vpid(pid_t nr)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\ttask = find_task_by_vpid(nr);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\treturn task;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int attach_to_pi_owner(u32 uval, union futex_key *key,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tstruct futex_pi_state *pi_state;\n\tstruct task_struct *p;\n\n\t/*\n\t * We are the first waiter - try to look up the real owner and attach\n\t * the new pi_state to it, but bail out when TID = 0 [1]\n\t */\n\tif (!pid)\n\t\treturn -ESRCH;\n\tp = find_get_task_by_vpid(pid);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (unlikely(p->flags & PF_KTHREAD)) {\n\t\tput_task_struct(p);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We need to look at the task state flags to figure out,\n\t * whether the task is exiting. To protect against the do_exit\n\t * change of the task flags, we do this protected by\n\t * p->pi_lock:\n\t */\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->flags & PF_EXITING)) {\n\t\t/*\n\t\t * The task is on the way out. When PF_EXITPIDONE is\n\t\t * set, we know that the task has finished the\n\t\t * cleanup:\n\t\t */\n\t\tint ret = (p->flags & PF_EXITPIDONE) ? -ESRCH : -EAGAIN;\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * No existing pi state. First waiter. [2]\n\t *\n\t * This creates pi_state, we have hb->lock held, this means nothing can\n\t * observe this state, wait_lock is irrelevant.\n\t */\n\tpi_state = alloc_pi_state();\n\n\t/*\n\t * Initialize the pi_mutex in locked state and make @p\n\t * the owner of it:\n\t */\n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t/* Store the key for possible exit cleanups: */\n\tpi_state->key = *key;\n\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\t/*\n\t * Assignment without holding pi_state->pi_mutex.wait_lock is safe\n\t * because there is no concurrency as the object is not published yet.\n\t */\n\tpi_state->owner = p;\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\t*ps = pi_state;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "attach_to_pi_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "1033-1149",
    "snippet": "static int attach_to_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t      struct futex_pi_state *pi_state,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tu32 uval2;\n\tint ret;\n\n\t/*\n\t * Userspace might have messed up non-PI and PI futexes [3]\n\t */\n\tif (unlikely(!pi_state))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We get here with hb->lock held, and having found a\n\t * futex_top_waiter(). This means that futex_lock_pi() of said futex_q\n\t * has dropped the hb->lock in between queue_me() and unqueue_me_pi(),\n\t * which in turn means that futex_lock_pi() still has a reference on\n\t * our pi_state.\n\t *\n\t * The waiter holding a reference on @pi_state also protects against\n\t * the unlocked put_pi_state() in futex_unlock_pi(), futex_lock_pi()\n\t * and futex_wait_requeue_pi() as it cannot go to 0 and consequently\n\t * free pi_state before we can take a reference ourselves.\n\t */\n\tWARN_ON(!atomic_read(&pi_state->refcount));\n\n\t/*\n\t * Now that we have a pi_state, we can acquire wait_lock\n\t * and do the state validation.\n\t */\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Since {uval, pi_state} is serialized by wait_lock, and our current\n\t * uval was read without holding it, it can have changed. Verify it\n\t * still is what we expect it to be, otherwise retry the entire\n\t * operation.\n\t */\n\tif (get_futex_value_locked(&uval2, uaddr))\n\t\tgoto out_efault;\n\n\tif (uval != uval2)\n\t\tgoto out_eagain;\n\n\t/*\n\t * Handle the owner died case:\n\t */\n\tif (uval & FUTEX_OWNER_DIED) {\n\t\t/*\n\t\t * exit_pi_state_list sets owner to NULL and wakes the\n\t\t * topmost waiter. The task which acquires the\n\t\t * pi_state->rt_mutex will fixup owner.\n\t\t */\n\t\tif (!pi_state->owner) {\n\t\t\t/*\n\t\t\t * No pi state owner, but the user space TID\n\t\t\t * is not 0. Inconsistent state. [5]\n\t\t\t */\n\t\t\tif (pid)\n\t\t\t\tgoto out_einval;\n\t\t\t/*\n\t\t\t * Take a ref on the state and return success. [4]\n\t\t\t */\n\t\t\tgoto out_attach;\n\t\t}\n\n\t\t/*\n\t\t * If TID is 0, then either the dying owner has not\n\t\t * yet executed exit_pi_state_list() or some waiter\n\t\t * acquired the rtmutex in the pi state, but did not\n\t\t * yet fixup the TID in user space.\n\t\t *\n\t\t * Take a ref on the state and return success. [6]\n\t\t */\n\t\tif (!pid)\n\t\t\tgoto out_attach;\n\t} else {\n\t\t/*\n\t\t * If the owner died bit is not set, then the pi_state\n\t\t * must have an owner. [7]\n\t\t */\n\t\tif (!pi_state->owner)\n\t\t\tgoto out_einval;\n\t}\n\n\t/*\n\t * Bail out if user space manipulated the futex value. If pi\n\t * state exists then the owner TID must be the same as the\n\t * user space TID. [9/10]\n\t */\n\tif (pid != task_pid_vnr(pi_state->owner))\n\t\tgoto out_einval;\n\nout_attach:\n\tget_pi_state(pi_state);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t*ps = pi_state;\n\treturn 0;\n\nout_einval:\n\tret = -EINVAL;\n\tgoto out_error;\n\nout_eagain:\n\tret = -EAGAIN;\n\tgoto out_error;\n\nout_efault:\n\tret = -EFAULT;\n\tgoto out_error;\n\nout_error:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pi_state->pi_mutex.wait_lock"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pi_state",
          "args": [
            "pi_state"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "get_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "816-819",
          "snippet": "static void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "pi_state->owner"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_futex_value_locked",
          "args": [
            "&uval2",
            "uaddr"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_value_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "768-777",
          "snippet": "static int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pi_state->pi_mutex.wait_lock"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!atomic_read(&pi_state->refcount)"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pi_state->refcount"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pi_state"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int attach_to_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t      struct futex_pi_state *pi_state,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tu32 uval2;\n\tint ret;\n\n\t/*\n\t * Userspace might have messed up non-PI and PI futexes [3]\n\t */\n\tif (unlikely(!pi_state))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We get here with hb->lock held, and having found a\n\t * futex_top_waiter(). This means that futex_lock_pi() of said futex_q\n\t * has dropped the hb->lock in between queue_me() and unqueue_me_pi(),\n\t * which in turn means that futex_lock_pi() still has a reference on\n\t * our pi_state.\n\t *\n\t * The waiter holding a reference on @pi_state also protects against\n\t * the unlocked put_pi_state() in futex_unlock_pi(), futex_lock_pi()\n\t * and futex_wait_requeue_pi() as it cannot go to 0 and consequently\n\t * free pi_state before we can take a reference ourselves.\n\t */\n\tWARN_ON(!atomic_read(&pi_state->refcount));\n\n\t/*\n\t * Now that we have a pi_state, we can acquire wait_lock\n\t * and do the state validation.\n\t */\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t/*\n\t * Since {uval, pi_state} is serialized by wait_lock, and our current\n\t * uval was read without holding it, it can have changed. Verify it\n\t * still is what we expect it to be, otherwise retry the entire\n\t * operation.\n\t */\n\tif (get_futex_value_locked(&uval2, uaddr))\n\t\tgoto out_efault;\n\n\tif (uval != uval2)\n\t\tgoto out_eagain;\n\n\t/*\n\t * Handle the owner died case:\n\t */\n\tif (uval & FUTEX_OWNER_DIED) {\n\t\t/*\n\t\t * exit_pi_state_list sets owner to NULL and wakes the\n\t\t * topmost waiter. The task which acquires the\n\t\t * pi_state->rt_mutex will fixup owner.\n\t\t */\n\t\tif (!pi_state->owner) {\n\t\t\t/*\n\t\t\t * No pi state owner, but the user space TID\n\t\t\t * is not 0. Inconsistent state. [5]\n\t\t\t */\n\t\t\tif (pid)\n\t\t\t\tgoto out_einval;\n\t\t\t/*\n\t\t\t * Take a ref on the state and return success. [4]\n\t\t\t */\n\t\t\tgoto out_attach;\n\t\t}\n\n\t\t/*\n\t\t * If TID is 0, then either the dying owner has not\n\t\t * yet executed exit_pi_state_list() or some waiter\n\t\t * acquired the rtmutex in the pi state, but did not\n\t\t * yet fixup the TID in user space.\n\t\t *\n\t\t * Take a ref on the state and return success. [6]\n\t\t */\n\t\tif (!pid)\n\t\t\tgoto out_attach;\n\t} else {\n\t\t/*\n\t\t * If the owner died bit is not set, then the pi_state\n\t\t * must have an owner. [7]\n\t\t */\n\t\tif (!pi_state->owner)\n\t\t\tgoto out_einval;\n\t}\n\n\t/*\n\t * Bail out if user space manipulated the futex value. If pi\n\t * state exists then the owner TID must be the same as the\n\t * user space TID. [9/10]\n\t */\n\tif (pid != task_pid_vnr(pi_state->owner))\n\t\tgoto out_einval;\n\nout_attach:\n\tget_pi_state(pi_state);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t*ps = pi_state;\n\treturn 0;\n\nout_einval:\n\tret = -EINVAL;\n\tgoto out_error;\n\nout_eagain:\n\tret = -EAGAIN;\n\tgoto out_error;\n\nout_efault:\n\tret = -EFAULT;\n\tgoto out_error;\n\nout_error:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "exit_pi_state_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "872-941",
    "snippet": "void exit_pi_state_list(struct task_struct *curr)\n{\n\tstruct list_head *next, *head = &curr->pi_state_list;\n\tstruct futex_pi_state *pi_state;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key = FUTEX_KEY_INIT;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\t/*\n\t * We are a ZOMBIE and nobody can enqueue itself on\n\t * pi_state_list anymore, but we have to be careful\n\t * versus waiters unqueueing themselves:\n\t */\n\traw_spin_lock_irq(&curr->pi_lock);\n\twhile (!list_empty(head)) {\n\t\tnext = head->next;\n\t\tpi_state = list_entry(next, struct futex_pi_state, list);\n\t\tkey = pi_state->key;\n\t\thb = hash_futex(&key);\n\n\t\t/*\n\t\t * We can race against put_pi_state() removing itself from the\n\t\t * list (a waiter going away). put_pi_state() will first\n\t\t * decrement the reference count and then modify the list, so\n\t\t * its possible to see the list entry but fail this reference\n\t\t * acquire.\n\t\t *\n\t\t * In that case; drop the locks to let put_pi_state() make\n\t\t * progress and retry the loop.\n\t\t */\n\t\tif (!atomic_inc_not_zero(&pi_state->refcount)) {\n\t\t\traw_spin_unlock_irq(&curr->pi_lock);\n\t\t\tcpu_relax();\n\t\t\traw_spin_lock_irq(&curr->pi_lock);\n\t\t\tcontinue;\n\t\t}\n\t\traw_spin_unlock_irq(&curr->pi_lock);\n\n\t\tspin_lock(&hb->lock);\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\traw_spin_lock(&curr->pi_lock);\n\t\t/*\n\t\t * We dropped the pi-lock, so re-check whether this\n\t\t * task still owns the PI-state:\n\t\t */\n\t\tif (head->next != next) {\n\t\t\t/* retain curr->pi_lock for the loop invariant */\n\t\t\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n\t\t\tspin_unlock(&hb->lock);\n\t\t\tput_pi_state(pi_state);\n\t\t\tcontinue;\n\t\t}\n\n\t\tWARN_ON(pi_state->owner != curr);\n\t\tWARN_ON(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\tpi_state->owner = NULL;\n\n\t\traw_spin_unlock(&curr->pi_lock);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t\tspin_unlock(&hb->lock);\n\n\t\trt_mutex_futex_unlock(&pi_state->pi_mutex);\n\t\tput_pi_state(pi_state);\n\n\t\traw_spin_lock_irq(&curr->pi_lock);\n\t}\n\traw_spin_unlock_irq(&curr->pi_lock);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&curr->pi_lock"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&curr->pi_lock"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pi_state",
          "args": [
            "pi_state"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "put_pi_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "825-863",
          "snippet": "static void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_futex_unlock",
          "args": [
            "&pi_state->pi_mutex"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_futex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1636-1648",
          "snippet": "void __sched rt_mutex_futex_unlock(struct rt_mutex *lock)\n{\n\tDEFINE_WAKE_Q(wake_q);\n\tunsigned long flags;\n\tbool postunlock;\n\n\traw_spin_lock_irqsave(&lock->wait_lock, flags);\n\tpostunlock = __rt_mutex_futex_unlock(lock, &wake_q);\n\traw_spin_unlock_irqrestore(&lock->wait_lock, flags);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_futex_unlock(struct rt_mutex *lock)\n{\n\tDEFINE_WAKE_Q(wake_q);\n\tunsigned long flags;\n\tbool postunlock;\n\n\traw_spin_lock_irqsave(&lock->wait_lock, flags);\n\tpostunlock = __rt_mutex_futex_unlock(lock, &wake_q);\n\traw_spin_unlock_irqrestore(&lock->wait_lock, flags);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hb->lock"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&curr->pi_lock"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&pi_state->list"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "list_empty(&pi_state->list)"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pi_state->list"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pi_state->owner != curr"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&curr->pi_lock"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&pi_state->refcount"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_futex",
          "args": [
            "&key"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "hash_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "393-399",
          "snippet": "static struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define futex_hashsize (__futex_data.hashsize)",
            "#define futex_queues   (__futex_data.queues)"
          ],
          "globals_used": [
            "__read_mostly __aligned(2*sizeof(long));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define futex_hashsize (__futex_data.hashsize)\n#define futex_queues   (__futex_data.queues)\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structfutex_pi_state",
            "list"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nvoid exit_pi_state_list(struct task_struct *curr)\n{\n\tstruct list_head *next, *head = &curr->pi_state_list;\n\tstruct futex_pi_state *pi_state;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key = FUTEX_KEY_INIT;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\t/*\n\t * We are a ZOMBIE and nobody can enqueue itself on\n\t * pi_state_list anymore, but we have to be careful\n\t * versus waiters unqueueing themselves:\n\t */\n\traw_spin_lock_irq(&curr->pi_lock);\n\twhile (!list_empty(head)) {\n\t\tnext = head->next;\n\t\tpi_state = list_entry(next, struct futex_pi_state, list);\n\t\tkey = pi_state->key;\n\t\thb = hash_futex(&key);\n\n\t\t/*\n\t\t * We can race against put_pi_state() removing itself from the\n\t\t * list (a waiter going away). put_pi_state() will first\n\t\t * decrement the reference count and then modify the list, so\n\t\t * its possible to see the list entry but fail this reference\n\t\t * acquire.\n\t\t *\n\t\t * In that case; drop the locks to let put_pi_state() make\n\t\t * progress and retry the loop.\n\t\t */\n\t\tif (!atomic_inc_not_zero(&pi_state->refcount)) {\n\t\t\traw_spin_unlock_irq(&curr->pi_lock);\n\t\t\tcpu_relax();\n\t\t\traw_spin_lock_irq(&curr->pi_lock);\n\t\t\tcontinue;\n\t\t}\n\t\traw_spin_unlock_irq(&curr->pi_lock);\n\n\t\tspin_lock(&hb->lock);\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\traw_spin_lock(&curr->pi_lock);\n\t\t/*\n\t\t * We dropped the pi-lock, so re-check whether this\n\t\t * task still owns the PI-state:\n\t\t */\n\t\tif (head->next != next) {\n\t\t\t/* retain curr->pi_lock for the loop invariant */\n\t\t\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n\t\t\tspin_unlock(&hb->lock);\n\t\t\tput_pi_state(pi_state);\n\t\t\tcontinue;\n\t\t}\n\n\t\tWARN_ON(pi_state->owner != curr);\n\t\tWARN_ON(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\tpi_state->owner = NULL;\n\n\t\traw_spin_unlock(&curr->pi_lock);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t\tspin_unlock(&hb->lock);\n\n\t\trt_mutex_futex_unlock(&pi_state->pi_mutex);\n\t\tput_pi_state(pi_state);\n\n\t\traw_spin_lock_irq(&curr->pi_lock);\n\t}\n\traw_spin_unlock_irq(&curr->pi_lock);\n}"
  },
  {
    "function_name": "put_pi_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "825-863",
    "snippet": "static void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pi_state->refcount",
            "1"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pi_state"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pi_state->pi_mutex.wait_lock"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_proxy_unlock",
          "args": [
            "&pi_state->pi_mutex",
            "owner"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_proxy_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1722-1727",
          "snippet": "void rt_mutex_proxy_unlock(struct rt_mutex *lock,\n\t\t\t   struct task_struct *proxy_owner)\n{\n\tdebug_rt_mutex_proxy_unlock(lock);\n\trt_mutex_set_owner(lock, NULL);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid rt_mutex_proxy_unlock(struct rt_mutex *lock,\n\t\t\t   struct task_struct *proxy_owner)\n{\n\tdebug_rt_mutex_proxy_unlock(lock);\n\trt_mutex_set_owner(lock, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&owner->pi_lock"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&pi_state->list"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&owner->pi_lock"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pi_state->pi_mutex.wait_lock"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&pi_state->refcount"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t/*\n\t * If pi_state->owner is NULL, the owner is most probably dying\n\t * and has cleaned up the pi_state already\n\t */\n\tif (pi_state->owner) {\n\t\tstruct task_struct *owner;\n\n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\towner = pi_state->owner;\n\t\tif (owner) {\n\t\t\traw_spin_lock(&owner->pi_lock);\n\t\t\tlist_del_init(&pi_state->list);\n\t\t\traw_spin_unlock(&owner->pi_lock);\n\t\t}\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, owner);\n\t\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t/*\n\t\t * pi_state->list is already empty.\n\t\t * clear pi_state->owner.\n\t\t * refcount is at 0 - put it back to 1.\n\t\t */\n\t\tpi_state->owner = NULL;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}"
  },
  {
    "function_name": "get_pi_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "816-819",
    "snippet": "static void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!atomic_inc_not_zero(&pi_state->refcount)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&pi_state->refcount"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!atomic_inc_not_zero(&pi_state->refcount));\n}"
  },
  {
    "function_name": "alloc_pi_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "806-814",
    "snippet": "static struct futex_pi_state *alloc_pi_state(void)\n{\n\tstruct futex_pi_state *pi_state = current->pi_state_cache;\n\n\tWARN_ON(!pi_state);\n\tcurrent->pi_state_cache = NULL;\n\n\treturn pi_state;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!pi_state"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic struct futex_pi_state *alloc_pi_state(void)\n{\n\tstruct futex_pi_state *pi_state = current->pi_state_cache;\n\n\tWARN_ON(!pi_state);\n\tcurrent->pi_state_cache = NULL;\n\n\treturn pi_state;\n}"
  },
  {
    "function_name": "refill_pi_state_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "783-804",
    "snippet": "static int refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), GFP_KERNEL);\n\n\tif (!pi_state)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pi_state->list);\n\t/* pi_mutex gets initialized later */\n\tpi_state->owner = NULL;\n\tatomic_set(&pi_state->refcount, 1);\n\tpi_state->key = FUTEX_KEY_INIT;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__read_mostly __aligned(2*sizeof(long));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pi_state->refcount",
            "1"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pi_state->list"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pi_state)",
            "GFP_KERNEL"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "current->pi_state_cache"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), GFP_KERNEL);\n\n\tif (!pi_state)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pi_state->list);\n\t/* pi_mutex gets initialized later */\n\tpi_state->owner = NULL;\n\tatomic_set(&pi_state->refcount, 1);\n\tpi_state->key = FUTEX_KEY_INIT;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_futex_value_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "768-777",
    "snippet": "static int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagefault_enable",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "*dest",
            "from"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagefault_disable",
          "args": [],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __get_user(*dest, from);\n\tpagefault_enable();\n\n\treturn ret ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "cmpxchg_futex_value_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "756-766",
    "snippet": "static int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagefault_enable",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "futex_atomic_cmpxchg_inatomic",
          "args": [
            "curval",
            "uaddr",
            "uval",
            "newval"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagefault_disable",
          "args": [],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "futex_top_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "744-754",
    "snippet": "static struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_futex",
          "args": [
            "&this->key",
            "key"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "match_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "409-415",
          "snippet": "static inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry",
          "args": [
            "this",
            "&hb->chain",
            "list"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "fault_in_user_writeable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "724-735",
    "snippet": "static int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_user_fault",
          "args": [
            "current",
            "mm",
            "(unsigned long)uaddr",
            "FAULT_FLAG_WRITE",
            "NULL"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       FAULT_FLAG_WRITE, NULL);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "put_futex_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "707-710",
    "snippet": "static inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_futex_key_refs",
          "args": [
            "key"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "drop_futex_key_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "460-479",
          "snippet": "static void drop_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr) {\n\t\t/* If we're here then we tried to put a key we failed to get */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MMU))\n\t\treturn;\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tiput(key->shared.inode);\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tmmdrop(key->private.mm);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void drop_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr) {\n\t\t/* If we're here then we tried to put a key we failed to get */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MMU))\n\t\treturn;\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tiput(key->shared.inode);\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tmmdrop(key->private.mm);\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}"
  },
  {
    "function_name": "get_futex_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "499-705",
    "snippet": "static int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__read_mostly __aligned(2*sizeof(long));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "basepage_index",
          "args": [
            "tail"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "inode->i_mapping != mapping"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&inode->i_count"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "mapping->host"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page->mapping"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_futex_key_refs",
          "args": [
            "key"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "get_futex_key_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "422-452",
          "snippet": "static void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\t/*\n\t * On MMU less systems futexes are always \"private\" as there is no per\n\t * process address space. We need the smp wmb nevertheless - yes,\n\t * arch/blackfin has MMU less SMP ...\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU)) {\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tihold(key->shared.inode); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tfutex_get_mm(key); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Private futexes do not hold reference on an inode or\n\t\t * mm, therefore the only purpose of calling get_futex_key_refs\n\t\t * is because we need the barrier for the lockless waiter check.\n\t\t */\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t}\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\t/*\n\t * On MMU less systems futexes are always \"private\" as there is no per\n\t * process address space. We need the smp wmb nevertheless - yes,\n\t * arch/blackfin has MMU less SMP ...\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU)) {\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tihold(key->shared.inode); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tfutex_get_mm(key); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Private futexes do not hold reference on an inode or\n\t\t * mm, therefore the only purpose of calling get_futex_key_refs\n\t\t * is because we need the barrier for the lockless waiter check.\n\t\t */\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "should_fail_futex(fshared)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fail_futex",
          "args": [
            "fshared"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "should_fail_futex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "335-338",
          "snippet": "static inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mapping"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page->mapping"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_fast",
          "args": [
            "address",
            "1",
            "0",
            "&page"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_fast",
          "args": [
            "address",
            "1",
            "1",
            "&page"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "should_fail_futex(fshared)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "should_fail_futex(fshared)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(rw, uaddr, sizeof(u32))"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "rw",
            "uaddr",
            "sizeof(u32)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(address % sizeof(u32)) != 0"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *tail;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\n\t/*\n\t * The futex address must be \"naturally\" aligned.\n\t */\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * PROCESS_PRIVATE futexes are fast.\n\t * As the mm cannot disappear under us and the 'key' only needs\n\t * virtual address, we dont even have to find the underlying vma.\n\t * Note : We do have to check 'uaddr' is a valid user address,\n\t *        but access_ok() should be faster than find_vma()\n\t */\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  /* implies smp_mb(); (B) */\n\t\treturn 0;\n\t}\n\nagain:\n\t/* Ignore any VERIFY_READ mapping (futex common case) */\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t/*\n\t * If write access is not required (eg. FUTEX_WAIT), try\n\t * and get read-only access.\n\t */\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n\t/*\n\t * The treatment of mapping from this point on is critical. The page\n\t * lock protects many things but in this context the page lock\n\t * stabilizes mapping, prevents inode freeing in the shared\n\t * file-backed region case and guards against movement to swap cache.\n\t *\n\t * Strictly speaking the page lock is not needed in all cases being\n\t * considered here and page lock forces unnecessarily serialization\n\t * From this point on, mapping will be re-verified if necessary and\n\t * page lock will be acquired only if it is unavoidable\n\t *\n\t * Mapping checks require the head page for any compound page so the\n\t * head page and mapping is looked up now. For anonymous pages, it\n\t * does not matter if the page splits in the future as the key is\n\t * based on the address. For filesystem-backed pages, the tail is\n\t * required as the index of the page determines the key. For\n\t * base pages, there is no tail page and tail == page.\n\t */\n\ttail = page;\n\tpage = compound_head(page);\n\tmapping = READ_ONCE(page->mapping);\n\n\t/*\n\t * If page->mapping is NULL, then it cannot be a PageAnon\n\t * page; but it might be the ZERO_PAGE or in the gate area or\n\t * in a special mapping (all cases which we are happy to fail);\n\t * or it may have been a good file page when get_user_pages_fast\n\t * found it, but truncated or holepunched or subjected to\n\t * invalidate_complete_page2 before we got the page lock (also\n\t * cases which we are happy to fail).  And we hold a reference,\n\t * so refcount care in invalidate_complete_page's remove_mapping\n\t * prevents drop_caches from setting mapping to NULL beneath us.\n\t *\n\t * The case we do have to guard against is when memory pressure made\n\t * shmem_writepage move it from filecache to swapcache beneath us:\n\t * an unlikely race, but we do need to retry for page->mapping.\n\t */\n\tif (unlikely(!mapping)) {\n\t\tint shmem_swizzled;\n\n\t\t/*\n\t\t * Page lock is required to identify which special case above\n\t\t * applies. If this is really a shmem page then the page lock\n\t\t * will prevent unexpected transitions.\n\t\t */\n\t\tlock_page(page);\n\t\tshmem_swizzled = PageSwapCache(page) || page->mapping;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Private mappings are handled in a simple way.\n\t *\n\t * If the futex key is stored on an anonymous page, then the associated\n\t * object is the mm which is implicitly pinned by the calling process.\n\t *\n\t * NOTE: When userspace waits on a MAP_SHARED mapping, even if\n\t * it's a read-only handle, it's expected that futexes attach to\n\t * the object not the particular process.\n\t */\n\tif (PageAnon(page)) {\n\t\t/*\n\t\t * A RO anonymous page will never change and thus doesn't make\n\t\t * sense for futex operations.\n\t\t */\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; /* ref taken on mm */\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\n\t\tget_futex_key_refs(key); /* implies smp_mb(); (B) */\n\n\t} else {\n\t\tstruct inode *inode;\n\n\t\t/*\n\t\t * The associated futex object in this case is the inode and\n\t\t * the page->mapping must be traversed. Ordinarily this should\n\t\t * be stabilised under page lock but it's not strictly\n\t\t * necessary in this case as we just want to pin the inode, not\n\t\t * update the radix tree or anything like that.\n\t\t *\n\t\t * The RCU read lock is taken as the inode is finally freed\n\t\t * under RCU. If the mapping still matches expectations then the\n\t\t * mapping->host can be safely accessed as being a valid inode.\n\t\t */\n\t\trcu_read_lock();\n\n\t\tif (READ_ONCE(page->mapping) != mapping) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tinode = READ_ONCE(mapping->host);\n\t\tif (!inode) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference unless it is about to be freed. Previously\n\t\t * this reference was taken by ihold under the page lock\n\t\t * pinning the inode in place so i_lock was unnecessary. The\n\t\t * only way for this check to fail is if the inode was\n\t\t * truncated in parallel which is almost certainly an\n\t\t * application bug. In such a case, just retry.\n\t\t *\n\t\t * We are not calling into get_futex_key_refs() in file-backed\n\t\t * cases, therefore a successful atomic_inc return below will\n\t\t * guarantee that get_futex_key() will still imply smp_mb(); (B).\n\t\t */\n\t\tif (!atomic_inc_not_zero(&inode->i_count)) {\n\t\t\trcu_read_unlock();\n\t\t\tput_page(page);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Should be impossible but lets be paranoid for now */\n\t\tif (WARN_ON_ONCE(inode->i_mapping != mapping)) {\n\t\t\terr = -EFAULT;\n\t\t\trcu_read_unlock();\n\t\t\tiput(inode);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= FUT_OFF_INODE; /* inode-based key */\n\t\tkey->shared.inode = inode;\n\t\tkey->shared.pgoff = basepage_index(tail);\n\t\trcu_read_unlock();\n\t}\n\nout:\n\tput_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "drop_futex_key_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "460-479",
    "snippet": "static void drop_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr) {\n\t\t/* If we're here then we tried to put a key we failed to get */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MMU))\n\t\treturn;\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tiput(key->shared.inode);\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tmmdrop(key->private.mm);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "key->private.mm"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "mmdrop_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "689-695",
          "snippet": "static void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "key->shared.inode"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MMU"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void drop_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr) {\n\t\t/* If we're here then we tried to put a key we failed to get */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MMU))\n\t\treturn;\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tiput(key->shared.inode);\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tmmdrop(key->private.mm);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "get_futex_key_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "422-452",
    "snippet": "static void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\t/*\n\t * On MMU less systems futexes are always \"private\" as there is no per\n\t * process address space. We need the smp wmb nevertheless - yes,\n\t * arch/blackfin has MMU less SMP ...\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU)) {\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tihold(key->shared.inode); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tfutex_get_mm(key); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Private futexes do not hold reference on an inode or\n\t\t * mm, therefore the only purpose of calling get_futex_key_refs\n\t\t * is because we need the barrier for the lockless waiter check.\n\t\t */\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t}\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "futex_get_mm",
          "args": [
            "key"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "futex_get_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "341-350",
          "snippet": "static inline void futex_get_mm(union futex_key *key)\n{\n\tmmgrab(key->private.mm);\n\t/*\n\t * Ensure futex_get_mm() implies a full barrier such that\n\t * get_futex_key() implies a full barrier. This is relied upon\n\t * as smp_mb(); (B), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void futex_get_mm(union futex_key *key)\n{\n\tmmgrab(key->private.mm);\n\t/*\n\t * Ensure futex_get_mm() implies a full barrier such that\n\t * get_futex_key() implies a full barrier. This is relied upon\n\t * as smp_mb(); (B), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "key->shared.inode"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MMU"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\t/*\n\t * On MMU less systems futexes are always \"private\" as there is no per\n\t * process address space. We need the smp wmb nevertheless - yes,\n\t * arch/blackfin has MMU less SMP ...\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU)) {\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tihold(key->shared.inode); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tfutex_get_mm(key); /* implies smp_mb(); (B) */\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Private futexes do not hold reference on an inode or\n\t\t * mm, therefore the only purpose of calling get_futex_key_refs\n\t\t * is because we need the barrier for the lockless waiter check.\n\t\t */\n\t\tsmp_mb(); /* explicit smp_mb(); (B) */\n\t}\n}"
  },
  {
    "function_name": "match_futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "409-415",
    "snippet": "static inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}"
  },
  {
    "function_name": "hash_futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "393-399",
    "snippet": "static struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define futex_hashsize (__futex_data.hashsize)",
      "#define futex_queues   (__futex_data.queues)"
    ],
    "globals_used": [
      "__read_mostly __aligned(2*sizeof(long));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash2",
          "args": [
            "(u32*)&key->both.word",
            "(sizeof(key->both.word)+sizeof(key->both.ptr))/4",
            "key->both.offset"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#define futex_hashsize (__futex_data.hashsize)\n#define futex_queues   (__futex_data.queues)\n\n__read_mostly __aligned(2*sizeof(long));\n\nstatic struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}"
  },
  {
    "function_name": "hb_waiters_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "377-384",
    "snippet": "static inline int hb_waiters_pending(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\treturn atomic_read(&hb->waiters);\n#else\n\treturn 1;\n#endif\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&hb->waiters"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline int hb_waiters_pending(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\treturn atomic_read(&hb->waiters);\n#else\n\treturn 1;\n#endif\n}"
  },
  {
    "function_name": "hb_waiters_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "370-375",
    "snippet": "static inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&hb->waiters"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}"
  },
  {
    "function_name": "hb_waiters_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "355-364",
    "snippet": "static inline void hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_inc(&hb->waiters);\n\t/*\n\t * Full barrier (A), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n#endif\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&hb->waiters"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_inc(&hb->waiters);\n\t/*\n\t * Full barrier (A), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n#endif\n}"
  },
  {
    "function_name": "futex_get_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "341-350",
    "snippet": "static inline void futex_get_mm(union futex_key *key)\n{\n\tmmgrab(key->private.mm);\n\t/*\n\t * Ensure futex_get_mm() implies a full barrier such that\n\t * get_futex_key() implies a full barrier. This is relied upon\n\t * as smp_mb(); (B), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "key->private.mm"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline void futex_get_mm(union futex_key *key)\n{\n\tmmgrab(key->private.mm);\n\t/*\n\t * Ensure futex_get_mm() implies a full barrier such that\n\t * get_futex_key() implies a full barrier. This is relied upon\n\t * as smp_mb(); (B), see the ordering comment above.\n\t */\n\tsmp_mb__after_atomic();\n}"
  },
  {
    "function_name": "should_fail_futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "335-338",
    "snippet": "static inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "fail_futex_debugfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "311-328",
    "snippet": "static int __init fail_futex_debugfs(void)\n{\n\tumode_t mode = S_IFREG | S_IRUSR | S_IWUSR;\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr(\"fail_futex\", NULL,\n\t\t\t\t\t&fail_futex.attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\tif (!debugfs_create_bool(\"ignore-private\", mode, dir,\n\t\t\t\t &fail_futex.ignore_private)) {\n\t\tdebugfs_remove_recursive(dir);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "dir"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_bool",
          "args": [
            "\"ignore-private\"",
            "mode",
            "dir",
            "&fail_futex.ignore_private"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fault_create_debugfs_attr",
          "args": [
            "\"fail_futex\"",
            "NULL",
            "&fail_futex.attr"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int __init fail_futex_debugfs(void)\n{\n\tumode_t mode = S_IFREG | S_IRUSR | S_IWUSR;\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr(\"fail_futex\", NULL,\n\t\t\t\t\t&fail_futex.attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\tif (!debugfs_create_bool(\"ignore-private\", mode, dir,\n\t\t\t\t &fail_futex.ignore_private)) {\n\t\tdebugfs_remove_recursive(dir);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "should_fail_futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "301-307",
    "snippet": "static bool should_fail_futex(bool fshared)\n{\n\tif (fail_futex.ignore_private && !fshared)\n\t\treturn false;\n\n\treturn should_fail(&fail_futex.attr, 1);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "should_fail",
          "args": [
            "&fail_futex.attr",
            "1"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic bool should_fail_futex(bool fshared)\n{\n\tif (fail_futex.ignore_private && !fshared)\n\t\treturn false;\n\n\treturn should_fail(&fail_futex.attr, 1);\n}"
  },
  {
    "function_name": "setup_fail_futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "295-298",
    "snippet": "static int __init setup_fail_futex(char *str)\n{\n\treturn setup_fault_attr(&fail_futex.attr, str);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_fault_attr",
          "args": [
            "&fail_futex.attr",
            "str"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nstatic int __init setup_fail_futex(char *str)\n{\n\treturn setup_fault_attr(&fail_futex.attr, str);\n}"
  },
  {
    "function_name": "set_robust_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3298-3312",
    "snippet": "SYSCALL_DEFINE2(set_robust_list, struct robust_list_head __user *, head,\n\t\tsize_t, len)\n{\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -ENOSYS;\n\t/*\n\t * The kernel knows only one size for now:\n\t */\n\tif (unlikely(len != sizeof(*head)))\n\t\treturn -EINVAL;\n\n\tcurrent->robust_list = head;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__read_mostly __aligned(2*sizeof(long));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nSYSCALL_DEFINE2(set_robust_list, struct robust_list_head __user *, head,\n\t\tsize_t, len)\n{\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -ENOSYS;\n\t/*\n\t * The kernel knows only one size for now:\n\t */\n\tif (unlikely(len != sizeof(*head)))\n\t\treturn -EINVAL;\n\n\tcurrent->robust_list = head;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_robust_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3320-3357",
    "snippet": "SYSCALL_DEFINE3(get_robust_list, int, pid,\n\t\tstruct robust_list_head __user * __user *, head_ptr,\n\t\tsize_t __user *, len_ptr)\n{\n\tstruct robust_list_head __user *head;\n\tunsigned long ret;\n\tstruct task_struct *p;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -ENOSYS;\n\n\trcu_read_lock();\n\n\tret = -ESRCH;\n\tif (!pid)\n\t\tp = current;\n\telse {\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = -EPERM;\n\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))\n\t\tgoto err_unlock;\n\n\thead = p->robust_list;\n\trcu_read_unlock();\n\n\tif (put_user(sizeof(*head), len_ptr))\n\t\treturn -EFAULT;\n\treturn put_user(head, head_ptr);\n\nerr_unlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__read_mostly __aligned(2*sizeof(long));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nSYSCALL_DEFINE3(get_robust_list, int, pid,\n\t\tstruct robust_list_head __user * __user *, head_ptr,\n\t\tsize_t __user *, len_ptr)\n{\n\tstruct robust_list_head __user *head;\n\tunsigned long ret;\n\tstruct task_struct *p;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -ENOSYS;\n\n\trcu_read_lock();\n\n\tret = -ESRCH;\n\tif (!pid)\n\t\tp = current;\n\telse {\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = -EPERM;\n\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))\n\t\tgoto err_unlock;\n\n\thead = p->robust_list;\n\trcu_read_unlock();\n\n\tif (put_user(sizeof(*head), len_ptr))\n\t\treturn -EFAULT;\n\treturn put_user(head, head_ptr);\n\nerr_unlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
    "lines": "3557-3590",
    "snippet": "SYSCALL_DEFINE6(futex, u32 __user *, uaddr, int, op, u32, val,\n\t\tstruct timespec __user *, utime, u32 __user *, uaddr2,\n\t\tu32, val3)\n{\n\tstruct timespec ts;\n\tktime_t t, *tp = NULL;\n\tu32 val2 = 0;\n\tint cmd = op & FUTEX_CMD_MASK;\n\n\tif (utime && (cmd == FUTEX_WAIT || cmd == FUTEX_LOCK_PI ||\n\t\t      cmd == FUTEX_WAIT_BITSET ||\n\t\t      cmd == FUTEX_WAIT_REQUEUE_PI)) {\n\t\tif (unlikely(should_fail_futex(!(op & FUTEX_PRIVATE_FLAG))))\n\t\t\treturn -EFAULT;\n\t\tif (copy_from_user(&ts, utime, sizeof(ts)) != 0)\n\t\t\treturn -EFAULT;\n\t\tif (!timespec_valid(&ts))\n\t\t\treturn -EINVAL;\n\n\t\tt = timespec_to_ktime(ts);\n\t\tif (cmd == FUTEX_WAIT)\n\t\t\tt = ktime_add_safe(ktime_get(), t);\n\t\ttp = &t;\n\t}\n\t/*\n\t * requeue parameter in 'utime' if cmd == FUTEX_*_REQUEUE_*.\n\t * number of waiters to wake in 'utime' if cmd == FUTEX_WAKE_OP.\n\t */\n\tif (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE ||\n\t    cmd == FUTEX_CMP_REQUEUE_PI || cmd == FUTEX_WAKE_OP)\n\t\tval2 = (u32) (unsigned long) utime;\n\n\treturn do_futex(uaddr, op, val, tp, uaddr2, val2, val3);\n}",
    "includes": [
      "#include \"locking/rtmutex_common.h\"",
      "#include <asm/futex.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memblock.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/wake_q.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid.h>",
      "#include <linux/magic.h>",
      "#include <linux/export.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/futex.h>",
      "#include <linux/init.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__read_mostly __aligned(2*sizeof(long));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n__read_mostly __aligned(2*sizeof(long));\n\nSYSCALL_DEFINE6(futex, u32 __user *, uaddr, int, op, u32, val,\n\t\tstruct timespec __user *, utime, u32 __user *, uaddr2,\n\t\tu32, val3)\n{\n\tstruct timespec ts;\n\tktime_t t, *tp = NULL;\n\tu32 val2 = 0;\n\tint cmd = op & FUTEX_CMD_MASK;\n\n\tif (utime && (cmd == FUTEX_WAIT || cmd == FUTEX_LOCK_PI ||\n\t\t      cmd == FUTEX_WAIT_BITSET ||\n\t\t      cmd == FUTEX_WAIT_REQUEUE_PI)) {\n\t\tif (unlikely(should_fail_futex(!(op & FUTEX_PRIVATE_FLAG))))\n\t\t\treturn -EFAULT;\n\t\tif (copy_from_user(&ts, utime, sizeof(ts)) != 0)\n\t\t\treturn -EFAULT;\n\t\tif (!timespec_valid(&ts))\n\t\t\treturn -EINVAL;\n\n\t\tt = timespec_to_ktime(ts);\n\t\tif (cmd == FUTEX_WAIT)\n\t\t\tt = ktime_add_safe(ktime_get(), t);\n\t\ttp = &t;\n\t}\n\t/*\n\t * requeue parameter in 'utime' if cmd == FUTEX_*_REQUEUE_*.\n\t * number of waiters to wake in 'utime' if cmd == FUTEX_WAKE_OP.\n\t */\n\tif (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE ||\n\t    cmd == FUTEX_CMP_REQUEUE_PI || cmd == FUTEX_WAKE_OP)\n\t\tval2 = (u32) (unsigned long) utime;\n\n\treturn do_futex(uaddr, op, val, tp, uaddr2, val2, val3);\n}"
  }
]