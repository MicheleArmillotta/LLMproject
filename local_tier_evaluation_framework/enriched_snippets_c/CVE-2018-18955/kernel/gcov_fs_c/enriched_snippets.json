[
  {
    "function_name": "gcov_fs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "762-791",
    "snippet": "static __init int gcov_fs_init(void)\n{\n\tint rc = -EIO;\n\n\tinit_node(&root_node, NULL, NULL, NULL);\n\t/*\n\t * /sys/kernel/debug/gcov will be parent for the reset control file\n\t * and all profiling files.\n\t */\n\troot_node.dentry = debugfs_create_dir(\"gcov\", NULL);\n\tif (!root_node.dentry)\n\t\tgoto err_remove;\n\t/*\n\t * Create reset file which resets all profiling counts when written\n\t * to.\n\t */\n\treset_dentry = debugfs_create_file(\"reset\", 0600, root_node.dentry,\n\t\t\t\t\t   NULL, &gcov_reset_fops);\n\tif (!reset_dentry)\n\t\tgoto err_remove;\n\t/* Replay previous events to get our fs hierarchy up-to-date. */\n\tgcov_enable_events();\n\treturn 0;\n\nerr_remove:\n\tpr_err(\"init failed\\n\");\n\tdebugfs_remove(root_node.dentry);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gcov_node root_node;",
      "static struct dentry *reset_dentry;",
      "static const struct file_operations gcov_reset_fops = {\n\t.write\t= reset_write,\n\t.read\t= reset_read,\n\t.llseek = noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "root_node.dentry"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "171-177",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"init failed\\n\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_enable_events",
          "args": [],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_enable_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/base.c",
          "lines": "116-130",
          "snippet": "void gcov_enable_events(void)\n{\n\tstruct gcov_info *info = NULL;\n\n\tmutex_lock(&gcov_lock);\n\tgcov_events_enabled = 1;\n\n\t/* Perform event callback for previously registered entries. */\n\twhile ((info = gcov_info_next(info))) {\n\t\tgcov_event(GCOV_ADD, info);\n\t\tcond_resched();\n\t}\n\n\tmutex_unlock(&gcov_lock);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int gcov_events_enabled;",
            "static DEFINE_MUTEX(gcov_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_events_enabled;\nstatic DEFINE_MUTEX(gcov_lock);\n\nvoid gcov_enable_events(void)\n{\n\tstruct gcov_info *info = NULL;\n\n\tmutex_lock(&gcov_lock);\n\tgcov_events_enabled = 1;\n\n\t/* Perform event callback for previously registered entries. */\n\twhile ((info = gcov_info_next(info))) {\n\t\tgcov_event(GCOV_ADD, info);\n\t\tcond_resched();\n\t}\n\n\tmutex_unlock(&gcov_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"reset\"",
            "0600",
            "root_node.dentry",
            "NULL",
            "&gcov_reset_fops"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"gcov\"",
            "NULL"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_node",
          "args": [
            "&root_node",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "init_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "413-426",
          "snippet": "static void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic struct dentry *reset_dentry;\nstatic const struct file_operations gcov_reset_fops = {\n\t.write\t= reset_write,\n\t.read\t= reset_read,\n\t.llseek = noop_llseek,\n};\n\nstatic __init int gcov_fs_init(void)\n{\n\tint rc = -EIO;\n\n\tinit_node(&root_node, NULL, NULL, NULL);\n\t/*\n\t * /sys/kernel/debug/gcov will be parent for the reset control file\n\t * and all profiling files.\n\t */\n\troot_node.dentry = debugfs_create_dir(\"gcov\", NULL);\n\tif (!root_node.dentry)\n\t\tgoto err_remove;\n\t/*\n\t * Create reset file which resets all profiling counts when written\n\t * to.\n\t */\n\treset_dentry = debugfs_create_file(\"reset\", 0600, root_node.dentry,\n\t\t\t\t\t   NULL, &gcov_reset_fops);\n\tif (!reset_dentry)\n\t\tgoto err_remove;\n\t/* Replay previous events to get our fs hierarchy up-to-date. */\n\tgcov_enable_events();\n\treturn 0;\n\nerr_remove:\n\tpr_err(\"init failed\\n\");\n\tdebugfs_remove(root_node.dentry);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "gcov_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "736-759",
    "snippet": "void gcov_event(enum gcov_action action, struct gcov_info *info)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tswitch (action) {\n\tcase GCOV_ADD:\n\t\tif (node)\n\t\t\tadd_info(node, info);\n\t\telse\n\t\t\tadd_node(info);\n\t\tbreak;\n\tcase GCOV_REMOVE:\n\t\tif (node)\n\t\t\tremove_info(node, info);\n\t\telse {\n\t\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&node_lock);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(node_lock);",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node_lock"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not remove '%s' (not found)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "88-91",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_info",
          "args": [
            "node",
            "info"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "remove_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "707-730",
          "snippet": "static void remove_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\ti = get_info_index(node, info);\n\tif (i < 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t/* Shrink array. */\n\tnode->loaded_info[i] = node->loaded_info[node->num_loaded - 1];\n\tnode->num_loaded--;\n\tif (node->num_loaded > 0)\n\t\treturn;\n\t/* Last loaded data set was removed. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = NULL;\n\tnode->num_loaded = 0;\n\tif (!node->unloaded_info)\n\t\tremove_node(node);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int gcov_persist = 1;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_persist = 1;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\ti = get_info_index(node, info);\n\tif (i < 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t/* Shrink array. */\n\tnode->loaded_info[i] = node->loaded_info[node->num_loaded - 1];\n\tnode->num_loaded--;\n\tif (node->num_loaded > 0)\n\t\treturn;\n\t/* Last loaded data set was removed. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = NULL;\n\tnode->num_loaded = 0;\n\tif (!node->unloaded_info)\n\t\tremove_node(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_node",
          "args": [
            "info"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "add_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "572-616",
          "snippet": "static void add_node(struct gcov_info *info)\n{\n\tchar *filename;\n\tchar *curr;\n\tchar *next;\n\tstruct gcov_node *parent;\n\tstruct gcov_node *node;\n\n\tfilename = kstrdup(gcov_info_filename(info), GFP_KERNEL);\n\tif (!filename)\n\t\treturn;\n\tparent = &root_node;\n\t/* Create directory nodes along the path. */\n\tfor (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {\n\t\tif (curr == next)\n\t\t\tcontinue;\n\t\t*next = 0;\n\t\tif (strcmp(curr, \".\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(curr, \"..\") == 0) {\n\t\t\tif (!parent->parent)\n\t\t\t\tgoto err_remove;\n\t\t\tparent = parent->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tnode = get_child_by_name(parent, curr);\n\t\tif (!node) {\n\t\t\tnode = new_node(parent, NULL, curr);\n\t\t\tif (!node)\n\t\t\t\tgoto err_remove;\n\t\t}\n\t\tparent = node;\n\t}\n\t/* Create file node. */\n\tnode = new_node(parent, info, curr);\n\tif (!node)\n\t\tgoto err_remove;\nout:\n\tkfree(filename);\n\treturn;\n\nerr_remove:\n\tremove_node(parent);\n\tgoto out;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_node root_node;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_node(struct gcov_info *info)\n{\n\tchar *filename;\n\tchar *curr;\n\tchar *next;\n\tstruct gcov_node *parent;\n\tstruct gcov_node *node;\n\n\tfilename = kstrdup(gcov_info_filename(info), GFP_KERNEL);\n\tif (!filename)\n\t\treturn;\n\tparent = &root_node;\n\t/* Create directory nodes along the path. */\n\tfor (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {\n\t\tif (curr == next)\n\t\t\tcontinue;\n\t\t*next = 0;\n\t\tif (strcmp(curr, \".\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(curr, \"..\") == 0) {\n\t\t\tif (!parent->parent)\n\t\t\t\tgoto err_remove;\n\t\t\tparent = parent->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tnode = get_child_by_name(parent, curr);\n\t\tif (!node) {\n\t\t\tnode = new_node(parent, NULL, curr);\n\t\t\tif (!node)\n\t\t\t\tgoto err_remove;\n\t\t}\n\t\tparent = node;\n\t}\n\t/* Create file node. */\n\tnode = new_node(parent, info, curr);\n\tif (!node)\n\t\tgoto err_remove;\nout:\n\tkfree(filename);\n\treturn;\n\nerr_remove:\n\tremove_node(parent);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_info",
          "args": [
            "node",
            "info"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "add_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "622-670",
          "snippet": "static void add_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tstruct gcov_info **loaded_info;\n\tint num = node->num_loaded;\n\n\t/*\n\t * Prepare new array. This is done first to simplify cleanup in\n\t * case the new data set is incompatible, the node only contains\n\t * unloaded data sets and there's not enough memory for the array.\n\t */\n\tloaded_info = kcalloc(num + 1, sizeof(struct gcov_info *), GFP_KERNEL);\n\tif (!loaded_info) {\n\t\tpr_warn(\"could not add '%s' (out of memory)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tmemcpy(loaded_info, node->loaded_info,\n\t       num * sizeof(struct gcov_info *));\n\tloaded_info[num] = info;\n\t/* Check if the new data set is compatible. */\n\tif (num == 0) {\n\t\t/*\n\t\t * A module was unloaded, modified and reloaded. The new\n\t\t * data set replaces the copy of the last one.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->unloaded_info, info)) {\n\t\t\tpr_warn(\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t\tgcov_info_free(node->unloaded_info);\n\t\t\tnode->unloaded_info = NULL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Two different versions of the same object file are loaded.\n\t\t * The initial one takes precedence.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->loaded_info[0], info)) {\n\t\t\tpr_warn(\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\", gcov_info_filename(info));\n\t\t\tkfree(loaded_info);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* Overwrite previous array. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = loaded_info;\n\tnode->num_loaded = num + 1;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tstruct gcov_info **loaded_info;\n\tint num = node->num_loaded;\n\n\t/*\n\t * Prepare new array. This is done first to simplify cleanup in\n\t * case the new data set is incompatible, the node only contains\n\t * unloaded data sets and there's not enough memory for the array.\n\t */\n\tloaded_info = kcalloc(num + 1, sizeof(struct gcov_info *), GFP_KERNEL);\n\tif (!loaded_info) {\n\t\tpr_warn(\"could not add '%s' (out of memory)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tmemcpy(loaded_info, node->loaded_info,\n\t       num * sizeof(struct gcov_info *));\n\tloaded_info[num] = info;\n\t/* Check if the new data set is compatible. */\n\tif (num == 0) {\n\t\t/*\n\t\t * A module was unloaded, modified and reloaded. The new\n\t\t * data set replaces the copy of the last one.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->unloaded_info, info)) {\n\t\t\tpr_warn(\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t\tgcov_info_free(node->unloaded_info);\n\t\t\tnode->unloaded_info = NULL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Two different versions of the same object file are loaded.\n\t\t * The initial one takes precedence.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->loaded_info[0], info)) {\n\t\t\tpr_warn(\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\", gcov_info_filename(info));\n\t\t\tkfree(loaded_info);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* Overwrite previous array. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = loaded_info;\n\tnode->num_loaded = num + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_by_name",
          "args": [
            "gcov_info_filename(info)"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "239-251",
          "snippet": "static struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(all_head);",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node_lock"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic void remove_node(struct gcov_node *node);\n\nvoid gcov_event(enum gcov_action action, struct gcov_info *info)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tswitch (action) {\n\tcase GCOV_ADD:\n\t\tif (node)\n\t\t\tadd_info(node, info);\n\t\telse\n\t\t\tadd_node(info);\n\t\tbreak;\n\tcase GCOV_REMOVE:\n\t\tif (node)\n\t\t\tremove_info(node, info);\n\t\telse {\n\t\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&node_lock);\n}"
  },
  {
    "function_name": "remove_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "707-730",
    "snippet": "static void remove_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\ti = get_info_index(node, info);\n\tif (i < 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t/* Shrink array. */\n\tnode->loaded_info[i] = node->loaded_info[node->num_loaded - 1];\n\tnode->num_loaded--;\n\tif (node->num_loaded > 0)\n\t\treturn;\n\t/* Last loaded data set was removed. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = NULL;\n\tnode->num_loaded = 0;\n\tif (!node->unloaded_info)\n\t\tremove_node(node);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int gcov_persist = 1;",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_node",
          "args": [
            "node"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "501-510",
          "snippet": "static void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_node root_node;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node->loaded_info"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_info",
          "args": [
            "node",
            "info"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "save_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "689-701",
          "snippet": "static void save_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tif (node->unloaded_info)\n\t\tgcov_info_add(node->unloaded_info, info);\n\telse {\n\t\tnode->unloaded_info = gcov_info_dup(info);\n\t\tif (!node->unloaded_info) {\n\t\t\tpr_warn(\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void save_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tif (node->unloaded_info)\n\t\tgcov_info_add(node->unloaded_info, info);\n\telse {\n\t\tnode->unloaded_info = gcov_info_dup(info);\n\t\tif (!node->unloaded_info) {\n\t\t\tpr_warn(\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not remove '%s' (not found)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "88-91",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_info_index",
          "args": [
            "node",
            "info"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "get_info_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "675-684",
          "snippet": "static int get_info_index(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < node->num_loaded; i++) {\n\t\tif (node->loaded_info[i] == info)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic int get_info_index(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < node->num_loaded; i++) {\n\t\tif (node->loaded_info[i] == info)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_persist = 1;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\ti = get_info_index(node, info);\n\tif (i < 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t/* Shrink array. */\n\tnode->loaded_info[i] = node->loaded_info[node->num_loaded - 1];\n\tnode->num_loaded--;\n\tif (node->num_loaded > 0)\n\t\treturn;\n\t/* Last loaded data set was removed. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = NULL;\n\tnode->num_loaded = 0;\n\tif (!node->unloaded_info)\n\t\tremove_node(node);\n}"
  },
  {
    "function_name": "save_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "689-701",
    "snippet": "static void save_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tif (node->unloaded_info)\n\t\tgcov_info_add(node->unloaded_info, info);\n\telse {\n\t\tnode->unloaded_info = gcov_info_dup(info);\n\t\tif (!node->unloaded_info) {\n\t\t\tpr_warn(\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "88-91",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_dup",
          "args": [
            "info"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "240-282",
          "snippet": "struct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tunsigned int i;\n\tunsigned int active;\n\n\t/* Duplicate gcov_info. */\n\tactive = num_counter_active(info);\n\tdup = kzalloc(sizeof(struct gcov_info) +\n\t\t      sizeof(struct gcov_ctr_info) * active, GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\tdup->version\t\t= info->version;\n\tdup->stamp\t\t= info->stamp;\n\tdup->n_functions\t= info->n_functions;\n\tdup->ctr_mask\t\t= info->ctr_mask;\n\t/* Duplicate filename. */\n\tdup->filename\t\t= kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\t/* Duplicate table of functions. */\n\tdup->functions = kmemdup(info->functions, info->n_functions *\n\t\t\t\t get_fn_size(info), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\t/* Duplicate counter arrays. */\n\tfor (i = 0; i < active ; i++) {\n\t\tstruct gcov_ctr_info *ctr = &info->counts[i];\n\t\tsize_t size = ctr->num * sizeof(gcov_type);\n\n\t\tdup->counts[i].num = ctr->num;\n\t\tdup->counts[i].merge = ctr->merge;\n\t\tdup->counts[i].values = vmalloc(size);\n\t\tif (!dup->counts[i].values)\n\t\t\tgoto err_free;\n\t\tmemcpy(dup->counts[i].values, ctr->values, size);\n\t}\n\treturn dup;\n\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstruct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tunsigned int i;\n\tunsigned int active;\n\n\t/* Duplicate gcov_info. */\n\tactive = num_counter_active(info);\n\tdup = kzalloc(sizeof(struct gcov_info) +\n\t\t      sizeof(struct gcov_ctr_info) * active, GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\tdup->version\t\t= info->version;\n\tdup->stamp\t\t= info->stamp;\n\tdup->n_functions\t= info->n_functions;\n\tdup->ctr_mask\t\t= info->ctr_mask;\n\t/* Duplicate filename. */\n\tdup->filename\t\t= kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\t/* Duplicate table of functions. */\n\tdup->functions = kmemdup(info->functions, info->n_functions *\n\t\t\t\t get_fn_size(info), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\t/* Duplicate counter arrays. */\n\tfor (i = 0; i < active ; i++) {\n\t\tstruct gcov_ctr_info *ctr = &info->counts[i];\n\t\tsize_t size = ctr->num * sizeof(gcov_type);\n\n\t\tdup->counts[i].num = ctr->num;\n\t\tdup->counts[i].merge = ctr->merge;\n\t\tdup->counts[i].values = vmalloc(size);\n\t\tif (!dup->counts[i].values)\n\t\t\tgoto err_free;\n\t\tmemcpy(dup->counts[i].values, ctr->values, size);\n\t}\n\treturn dup;\n\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_add",
          "args": [
            "node->unloaded_info",
            "info"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "202-213",
          "snippet": "void gcov_info_add(struct gcov_info *dest, struct gcov_info *source)\n{\n\tunsigned int i;\n\tunsigned int j;\n\n\tfor (i = 0; i < num_counter_active(dest); i++) {\n\t\tfor (j = 0; j < dest->counts[i].num; j++) {\n\t\t\tdest->counts[i].values[j] +=\n\t\t\t\tsource->counts[i].values[j];\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_add(struct gcov_info *dest, struct gcov_info *source)\n{\n\tunsigned int i;\n\tunsigned int j;\n\n\tfor (i = 0; i < num_counter_active(dest); i++) {\n\t\tfor (j = 0; j < dest->counts[i].num; j++) {\n\t\t\tdest->counts[i].values[j] +=\n\t\t\t\tsource->counts[i].values[j];\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void save_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tif (node->unloaded_info)\n\t\tgcov_info_add(node->unloaded_info, info);\n\telse {\n\t\tnode->unloaded_info = gcov_info_dup(info);\n\t\tif (!node->unloaded_info) {\n\t\t\tpr_warn(\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_info_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "675-684",
    "snippet": "static int get_info_index(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < node->num_loaded; i++) {\n\t\tif (node->loaded_info[i] == info)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic int get_info_index(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < node->num_loaded; i++) {\n\t\tif (node->loaded_info[i] == info)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "add_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "622-670",
    "snippet": "static void add_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tstruct gcov_info **loaded_info;\n\tint num = node->num_loaded;\n\n\t/*\n\t * Prepare new array. This is done first to simplify cleanup in\n\t * case the new data set is incompatible, the node only contains\n\t * unloaded data sets and there's not enough memory for the array.\n\t */\n\tloaded_info = kcalloc(num + 1, sizeof(struct gcov_info *), GFP_KERNEL);\n\tif (!loaded_info) {\n\t\tpr_warn(\"could not add '%s' (out of memory)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tmemcpy(loaded_info, node->loaded_info,\n\t       num * sizeof(struct gcov_info *));\n\tloaded_info[num] = info;\n\t/* Check if the new data set is compatible. */\n\tif (num == 0) {\n\t\t/*\n\t\t * A module was unloaded, modified and reloaded. The new\n\t\t * data set replaces the copy of the last one.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->unloaded_info, info)) {\n\t\t\tpr_warn(\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t\tgcov_info_free(node->unloaded_info);\n\t\t\tnode->unloaded_info = NULL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Two different versions of the same object file are loaded.\n\t\t * The initial one takes precedence.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->loaded_info[0], info)) {\n\t\t\tpr_warn(\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\", gcov_info_filename(info));\n\t\t\tkfree(loaded_info);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* Overwrite previous array. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = loaded_info;\n\tnode->num_loaded = num + 1;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node->loaded_info"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "88-91",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_is_compatible",
          "args": [
            "node->loaded_info[0]",
            "info"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_is_compatible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "190-193",
          "snippet": "int gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)\n{\n\treturn (info1->stamp == info2->stamp);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)\n{\n\treturn (info1->stamp == info2->stamp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_free",
          "args": [
            "node->unloaded_info"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "288-298",
          "snippet": "void gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active ; i++)\n\t\tvfree(info->counts[i].values);\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active ; i++)\n\t\tvfree(info->counts[i].values);\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "loaded_info",
            "node->loaded_info",
            "num * sizeof(struct gcov_info *)"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not add '%s' (out of memory)\\n\"",
            "gcov_info_filename(info)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "num + 1",
            "sizeof(struct gcov_info *)",
            "GFP_KERNEL"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tstruct gcov_info **loaded_info;\n\tint num = node->num_loaded;\n\n\t/*\n\t * Prepare new array. This is done first to simplify cleanup in\n\t * case the new data set is incompatible, the node only contains\n\t * unloaded data sets and there's not enough memory for the array.\n\t */\n\tloaded_info = kcalloc(num + 1, sizeof(struct gcov_info *), GFP_KERNEL);\n\tif (!loaded_info) {\n\t\tpr_warn(\"could not add '%s' (out of memory)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tmemcpy(loaded_info, node->loaded_info,\n\t       num * sizeof(struct gcov_info *));\n\tloaded_info[num] = info;\n\t/* Check if the new data set is compatible. */\n\tif (num == 0) {\n\t\t/*\n\t\t * A module was unloaded, modified and reloaded. The new\n\t\t * data set replaces the copy of the last one.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->unloaded_info, info)) {\n\t\t\tpr_warn(\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t\tgcov_info_free(node->unloaded_info);\n\t\t\tnode->unloaded_info = NULL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Two different versions of the same object file are loaded.\n\t\t * The initial one takes precedence.\n\t\t */\n\t\tif (!gcov_info_is_compatible(node->loaded_info[0], info)) {\n\t\t\tpr_warn(\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\", gcov_info_filename(info));\n\t\t\tkfree(loaded_info);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* Overwrite previous array. */\n\tkfree(node->loaded_info);\n\tnode->loaded_info = loaded_info;\n\tnode->num_loaded = num + 1;\n}"
  },
  {
    "function_name": "add_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "572-616",
    "snippet": "static void add_node(struct gcov_info *info)\n{\n\tchar *filename;\n\tchar *curr;\n\tchar *next;\n\tstruct gcov_node *parent;\n\tstruct gcov_node *node;\n\n\tfilename = kstrdup(gcov_info_filename(info), GFP_KERNEL);\n\tif (!filename)\n\t\treturn;\n\tparent = &root_node;\n\t/* Create directory nodes along the path. */\n\tfor (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {\n\t\tif (curr == next)\n\t\t\tcontinue;\n\t\t*next = 0;\n\t\tif (strcmp(curr, \".\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(curr, \"..\") == 0) {\n\t\t\tif (!parent->parent)\n\t\t\t\tgoto err_remove;\n\t\t\tparent = parent->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tnode = get_child_by_name(parent, curr);\n\t\tif (!node) {\n\t\t\tnode = new_node(parent, NULL, curr);\n\t\t\tif (!node)\n\t\t\t\tgoto err_remove;\n\t\t}\n\t\tparent = node;\n\t}\n\t/* Create file node. */\n\tnode = new_node(parent, info, curr);\n\tif (!node)\n\t\tgoto err_remove;\nout:\n\tkfree(filename);\n\treturn;\n\nerr_remove:\n\tremove_node(parent);\n\tgoto out;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gcov_node root_node;",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_node",
          "args": [
            "parent"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "501-510",
          "snippet": "static void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_node root_node;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filename"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_node",
          "args": [
            "parent",
            "info",
            "curr"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "new_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "432-469",
          "snippet": "static struct gcov_node *new_node(struct gcov_node *parent,\n\t\t\t\t  struct gcov_info *info, const char *name)\n{\n\tstruct gcov_node *node;\n\n\tnode = kzalloc(sizeof(struct gcov_node) + strlen(name) + 1, GFP_KERNEL);\n\tif (!node)\n\t\tgoto err_nomem;\n\tif (info) {\n\t\tnode->loaded_info = kcalloc(1, sizeof(struct gcov_info *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!node->loaded_info)\n\t\t\tgoto err_nomem;\n\t}\n\tinit_node(node, info, name, parent);\n\t/* Differentiate between gcov data file nodes and directory nodes. */\n\tif (info) {\n\t\tnode->dentry = debugfs_create_file(deskew(node->name), 0600,\n\t\t\t\t\tparent->dentry, node, &gcov_data_fops);\n\t} else\n\t\tnode->dentry = debugfs_create_dir(node->name, parent->dentry);\n\tif (!node->dentry) {\n\t\tpr_warn(\"could not create file\\n\");\n\t\tkfree(node);\n\t\treturn NULL;\n\t}\n\tif (info)\n\t\tadd_links(node, parent->dentry);\n\tlist_add(&node->list, &parent->children);\n\tlist_add(&node->all, &all_head);\n\n\treturn node;\n\nerr_nomem:\n\tkfree(node);\n\tpr_warn(\"out of memory\\n\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(all_head);",
            "static void remove_node(struct gcov_node *node);",
            "static const struct file_operations gcov_data_fops = {\n\t.open\t\t= gcov_seq_open,\n\t.release\t= gcov_seq_release,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= gcov_seq_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic void remove_node(struct gcov_node *node);\nstatic const struct file_operations gcov_data_fops = {\n\t.open\t\t= gcov_seq_open,\n\t.release\t= gcov_seq_release,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= gcov_seq_write,\n};\n\nstatic struct gcov_node *new_node(struct gcov_node *parent,\n\t\t\t\t  struct gcov_info *info, const char *name)\n{\n\tstruct gcov_node *node;\n\n\tnode = kzalloc(sizeof(struct gcov_node) + strlen(name) + 1, GFP_KERNEL);\n\tif (!node)\n\t\tgoto err_nomem;\n\tif (info) {\n\t\tnode->loaded_info = kcalloc(1, sizeof(struct gcov_info *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!node->loaded_info)\n\t\t\tgoto err_nomem;\n\t}\n\tinit_node(node, info, name, parent);\n\t/* Differentiate between gcov data file nodes and directory nodes. */\n\tif (info) {\n\t\tnode->dentry = debugfs_create_file(deskew(node->name), 0600,\n\t\t\t\t\tparent->dentry, node, &gcov_data_fops);\n\t} else\n\t\tnode->dentry = debugfs_create_dir(node->name, parent->dentry);\n\tif (!node->dentry) {\n\t\tpr_warn(\"could not create file\\n\");\n\t\tkfree(node);\n\t\treturn NULL;\n\t}\n\tif (info)\n\t\tadd_links(node, parent->dentry);\n\tlist_add(&node->list, &parent->children);\n\tlist_add(&node->all, &all_head);\n\n\treturn node;\n\nerr_nomem:\n\tkfree(node);\n\tpr_warn(\"out of memory\\n\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_child_by_name",
          "args": [
            "parent",
            "curr"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "get_child_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "516-527",
          "snippet": "static struct gcov_node *get_child_by_name(struct gcov_node *parent,\n\t\t\t\t\t   const char *name)\n{\n\tstruct gcov_node *node;\n\n\tlist_for_each_entry(node, &parent->children, list) {\n\t\tif (strcmp(node->name, name) == 0)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_node *get_child_by_name(struct gcov_node *parent,\n\t\t\t\t\t   const char *name)\n{\n\tstruct gcov_node *node;\n\n\tlist_for_each_entry(node, &parent->children, list) {\n\t\tif (strcmp(node->name, name) == 0)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "curr",
            "\"..\""
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "curr",
            "\".\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "curr",
            "'/'"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "gcov_info_filename(info)",
            "GFP_KERNEL"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "88-91",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_node(struct gcov_info *info)\n{\n\tchar *filename;\n\tchar *curr;\n\tchar *next;\n\tstruct gcov_node *parent;\n\tstruct gcov_node *node;\n\n\tfilename = kstrdup(gcov_info_filename(info), GFP_KERNEL);\n\tif (!filename)\n\t\treturn;\n\tparent = &root_node;\n\t/* Create directory nodes along the path. */\n\tfor (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {\n\t\tif (curr == next)\n\t\t\tcontinue;\n\t\t*next = 0;\n\t\tif (strcmp(curr, \".\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(curr, \"..\") == 0) {\n\t\t\tif (!parent->parent)\n\t\t\t\tgoto err_remove;\n\t\t\tparent = parent->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tnode = get_child_by_name(parent, curr);\n\t\tif (!node) {\n\t\t\tnode = new_node(parent, NULL, curr);\n\t\t\tif (!node)\n\t\t\t\tgoto err_remove;\n\t\t}\n\t\tparent = node;\n\t}\n\t/* Create file node. */\n\tnode = new_node(parent, info, curr);\n\tif (!node)\n\t\tgoto err_remove;\nout:\n\tkfree(filename);\n\treturn;\n\nerr_remove:\n\tremove_node(parent);\n\tgoto out;\n}"
  },
  {
    "function_name": "reset_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "555-560",
    "snippet": "static ssize_t reset_read(struct file *file, char __user *addr, size_t len,\n\t\t\t  loff_t *pos)\n{\n\t/* Allow read operation so that a recursive copy won't fail. */\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic ssize_t reset_read(struct file *file, char __user *addr, size_t len,\n\t\t\t  loff_t *pos)\n{\n\t/* Allow read operation so that a recursive copy won't fail. */\n\treturn 0;\n}"
  },
  {
    "function_name": "reset_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "533-552",
    "snippet": "static ssize_t reset_write(struct file *file, const char __user *addr,\n\t\t\t   size_t len, loff_t *pos)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\nrestart:\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tif (node->num_loaded > 0)\n\t\t\treset_node(node);\n\t\telse if (list_empty(&node->children)) {\n\t\t\tremove_node(node);\n\t\t\t/* Several nodes may have gone - restart loop. */\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tmutex_unlock(&node_lock);\n\n\treturn len;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(all_head);",
      "static DEFINE_MUTEX(node_lock);",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node_lock"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_node",
          "args": [
            "node"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "501-510",
          "snippet": "static void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_node root_node;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&node->children"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_node",
          "args": [
            "node"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "reset_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "256-264",
          "snippet": "static void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&all_head",
            "all"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node_lock"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic DEFINE_MUTEX(node_lock);\nstatic void remove_node(struct gcov_node *node);\n\nstatic ssize_t reset_write(struct file *file, const char __user *addr,\n\t\t\t   size_t len, loff_t *pos)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\nrestart:\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tif (node->num_loaded > 0)\n\t\t\treset_node(node);\n\t\telse if (list_empty(&node->children)) {\n\t\t\tremove_node(node);\n\t\t\t/* Several nodes may have gone - restart loop. */\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tmutex_unlock(&node_lock);\n\n\treturn len;\n}"
  },
  {
    "function_name": "get_child_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "516-527",
    "snippet": "static struct gcov_node *get_child_by_name(struct gcov_node *parent,\n\t\t\t\t\t   const char *name)\n{\n\tstruct gcov_node *node;\n\n\tlist_for_each_entry(node, &parent->children, list) {\n\t\tif (strcmp(node->name, name) == 0)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "node->name",
            "name"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&parent->children",
            "list"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_node *get_child_by_name(struct gcov_node *parent,\n\t\t\t\t\t   const char *name)\n{\n\tstruct gcov_node *node;\n\n\tlist_for_each_entry(node, &parent->children, list) {\n\t\tif (strcmp(node->name, name) == 0)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "remove_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "501-510",
    "snippet": "static void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gcov_node root_node;",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_node",
          "args": [
            "node"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "release_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "488-498",
          "snippet": "static void release_node(struct gcov_node *node)\n{\n\tlist_del(&node->list);\n\tlist_del(&node->all);\n\tdebugfs_remove(node->dentry);\n\tremove_links(node);\n\tkfree(node->loaded_info);\n\tif (node->unloaded_info)\n\t\tgcov_info_free(node->unloaded_info);\n\tkfree(node);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void release_node(struct gcov_node *node)\n{\n\tlist_del(&node->list);\n\tlist_del(&node->all);\n\tdebugfs_remove(node->dentry);\n\tremove_links(node);\n\tkfree(node->loaded_info);\n\tif (node->unloaded_info)\n\t\tgcov_info_free(node->unloaded_info);\n\tkfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&node->children"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}"
  },
  {
    "function_name": "release_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "488-498",
    "snippet": "static void release_node(struct gcov_node *node)\n{\n\tlist_del(&node->list);\n\tlist_del(&node->all);\n\tdebugfs_remove(node->dentry);\n\tremove_links(node);\n\tkfree(node->loaded_info);\n\tif (node->unloaded_info)\n\t\tgcov_info_free(node->unloaded_info);\n\tkfree(node);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_free",
          "args": [
            "node->unloaded_info"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "288-298",
          "snippet": "void gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active ; i++)\n\t\tvfree(info->counts[i].values);\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active ; i++)\n\t\tvfree(info->counts[i].values);\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_links",
          "args": [
            "node"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "remove_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "472-482",
          "snippet": "static void remove_links(struct gcov_node *node)\n{\n\tint i;\n\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; gcov_link[i].ext; i++)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_links(struct gcov_node *node)\n{\n\tint i;\n\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; gcov_link[i].ext; i++)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "node->dentry"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "171-177",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&node->all"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void release_node(struct gcov_node *node)\n{\n\tlist_del(&node->list);\n\tlist_del(&node->all);\n\tdebugfs_remove(node->dentry);\n\tremove_links(node);\n\tkfree(node->loaded_info);\n\tif (node->unloaded_info)\n\t\tgcov_info_free(node->unloaded_info);\n\tkfree(node);\n}"
  },
  {
    "function_name": "remove_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "472-482",
    "snippet": "static void remove_links(struct gcov_node *node)\n{\n\tint i;\n\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; gcov_link[i].ext; i++)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node->links"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "node->links[i]"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "171-177",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_links(struct gcov_node *node)\n{\n\tint i;\n\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; gcov_link[i].ext; i++)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}"
  },
  {
    "function_name": "new_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "432-469",
    "snippet": "static struct gcov_node *new_node(struct gcov_node *parent,\n\t\t\t\t  struct gcov_info *info, const char *name)\n{\n\tstruct gcov_node *node;\n\n\tnode = kzalloc(sizeof(struct gcov_node) + strlen(name) + 1, GFP_KERNEL);\n\tif (!node)\n\t\tgoto err_nomem;\n\tif (info) {\n\t\tnode->loaded_info = kcalloc(1, sizeof(struct gcov_info *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!node->loaded_info)\n\t\t\tgoto err_nomem;\n\t}\n\tinit_node(node, info, name, parent);\n\t/* Differentiate between gcov data file nodes and directory nodes. */\n\tif (info) {\n\t\tnode->dentry = debugfs_create_file(deskew(node->name), 0600,\n\t\t\t\t\tparent->dentry, node, &gcov_data_fops);\n\t} else\n\t\tnode->dentry = debugfs_create_dir(node->name, parent->dentry);\n\tif (!node->dentry) {\n\t\tpr_warn(\"could not create file\\n\");\n\t\tkfree(node);\n\t\treturn NULL;\n\t}\n\tif (info)\n\t\tadd_links(node, parent->dentry);\n\tlist_add(&node->list, &parent->children);\n\tlist_add(&node->all, &all_head);\n\n\treturn node;\n\nerr_nomem:\n\tkfree(node);\n\tpr_warn(\"out of memory\\n\");\n\treturn NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(all_head);",
      "static void remove_node(struct gcov_node *node);",
      "static const struct file_operations gcov_data_fops = {\n\t.open\t\t= gcov_seq_open,\n\t.release\t= gcov_seq_release,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= gcov_seq_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"out of memory\\n\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&node->all",
            "&all_head"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_links",
          "args": [
            "node",
            "parent->dentry"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "add_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "367-402",
          "snippet": "static void add_links(struct gcov_node *node, struct dentry *parent)\n{\n\tconst char *basename;\n\tchar *target;\n\tint num;\n\tint i;\n\n\tfor (num = 0; gcov_link[num].ext; num++)\n\t\t/* Nothing. */;\n\tnode->links = kcalloc(num, sizeof(struct dentry *), GFP_KERNEL);\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; i < num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->links[i] = debugfs_create_symlink(deskew(basename),\n\t\t\t\t\t\t\tparent,\ttarget);\n\t\tif (!node->links[i])\n\t\t\tgoto out_err;\n\t\tkfree(target);\n\t}\n\n\treturn;\nout_err:\n\tkfree(target);\n\twhile (i-- > 0)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_links(struct gcov_node *node, struct dentry *parent)\n{\n\tconst char *basename;\n\tchar *target;\n\tint num;\n\tint i;\n\n\tfor (num = 0; gcov_link[num].ext; num++)\n\t\t/* Nothing. */;\n\tnode->links = kcalloc(num, sizeof(struct dentry *), GFP_KERNEL);\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; i < num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->links[i] = debugfs_create_symlink(deskew(basename),\n\t\t\t\t\t\t\tparent,\ttarget);\n\t\tif (!node->links[i])\n\t\t\tgoto out_err;\n\t\tkfree(target);\n\t}\n\n\treturn;\nout_err:\n\tkfree(target);\n\twhile (i-- > 0)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not create file\\n\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "node->name",
            "parent->dentry"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "deskew(node->name)",
            "0600",
            "parent->dentry",
            "node",
            "&gcov_data_fops"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deskew",
          "args": [
            "node->name"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "deskew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "356-361",
          "snippet": "static const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define SKEW_PREFIX\t\".tmp_\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define SKEW_PREFIX\t\".tmp_\"\n\nstatic const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_node",
          "args": [
            "node",
            "info",
            "name",
            "parent"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "init_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "413-426",
          "snippet": "static void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "1",
            "sizeof(struct gcov_info *)",
            "GFP_KERNEL"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct gcov_node) + strlen(name) + 1",
            "GFP_KERNEL"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic void remove_node(struct gcov_node *node);\nstatic const struct file_operations gcov_data_fops = {\n\t.open\t\t= gcov_seq_open,\n\t.release\t= gcov_seq_release,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= gcov_seq_write,\n};\n\nstatic struct gcov_node *new_node(struct gcov_node *parent,\n\t\t\t\t  struct gcov_info *info, const char *name)\n{\n\tstruct gcov_node *node;\n\n\tnode = kzalloc(sizeof(struct gcov_node) + strlen(name) + 1, GFP_KERNEL);\n\tif (!node)\n\t\tgoto err_nomem;\n\tif (info) {\n\t\tnode->loaded_info = kcalloc(1, sizeof(struct gcov_info *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!node->loaded_info)\n\t\t\tgoto err_nomem;\n\t}\n\tinit_node(node, info, name, parent);\n\t/* Differentiate between gcov data file nodes and directory nodes. */\n\tif (info) {\n\t\tnode->dentry = debugfs_create_file(deskew(node->name), 0600,\n\t\t\t\t\tparent->dentry, node, &gcov_data_fops);\n\t} else\n\t\tnode->dentry = debugfs_create_dir(node->name, parent->dentry);\n\tif (!node->dentry) {\n\t\tpr_warn(\"could not create file\\n\");\n\t\tkfree(node);\n\t\treturn NULL;\n\t}\n\tif (info)\n\t\tadd_links(node, parent->dentry);\n\tlist_add(&node->list, &parent->children);\n\tlist_add(&node->all, &all_head);\n\n\treturn node;\n\nerr_nomem:\n\tkfree(node);\n\tpr_warn(\"out of memory\\n\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "413-426",
    "snippet": "static void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "node->name",
            "name"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&node->all"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&node->children"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&node->list"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}"
  },
  {
    "function_name": "add_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "367-402",
    "snippet": "static void add_links(struct gcov_node *node, struct dentry *parent)\n{\n\tconst char *basename;\n\tchar *target;\n\tint num;\n\tint i;\n\n\tfor (num = 0; gcov_link[num].ext; num++)\n\t\t/* Nothing. */;\n\tnode->links = kcalloc(num, sizeof(struct dentry *), GFP_KERNEL);\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; i < num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->links[i] = debugfs_create_symlink(deskew(basename),\n\t\t\t\t\t\t\tparent,\ttarget);\n\t\tif (!node->links[i])\n\t\t\tgoto out_err;\n\t\tkfree(target);\n\t}\n\n\treturn;\nout_err:\n\tkfree(target);\n\twhile (i-- > 0)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node->links"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "node->links[i]"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "171-177",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_symlink",
          "args": [
            "deskew(basename)",
            "parent",
            "target"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deskew",
          "args": [
            "basename"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "deskew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "356-361",
          "snippet": "static const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define SKEW_PREFIX\t\".tmp_\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define SKEW_PREFIX\t\".tmp_\"\n\nstatic const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbasename",
          "args": [
            "target"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_link_target",
          "args": [
            "gcov_info_filename(get_node_info(node))",
            "&gcov_link[i]"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "get_link_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "331-348",
          "snippet": "static char *get_link_target(const char *filename, const struct gcov_link *ext)\n{\n\tconst char *rel;\n\tchar *result;\n\n\tif (strncmp(filename, objtree, strlen(objtree)) == 0) {\n\t\trel = filename + strlen(objtree) + 1;\n\t\tif (ext->dir == SRC_TREE)\n\t\t\tresult = link_target(srctree, rel, ext->ext);\n\t\telse\n\t\t\tresult = link_target(objtree, rel, ext->ext);\n\t} else {\n\t\t/* External compilation. */\n\t\tresult = link_target(NULL, filename, ext->ext);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char objtree[] = OBJTREE;",
            "static const char srctree[] = SRCTREE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic const char objtree[] = OBJTREE;\nstatic const char srctree[] = SRCTREE;\n\nstatic char *get_link_target(const char *filename, const struct gcov_link *ext)\n{\n\tconst char *rel;\n\tchar *result;\n\n\tif (strncmp(filename, objtree, strlen(objtree)) == 0) {\n\t\trel = filename + strlen(objtree) + 1;\n\t\tif (ext->dir == SRC_TREE)\n\t\t\tresult = link_target(srctree, rel, ext->ext);\n\t\telse\n\t\t\tresult = link_target(objtree, rel, ext->ext);\n\t} else {\n\t\t/* External compilation. */\n\t\tresult = link_target(NULL, filename, ext->ext);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "get_node_info(node)"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "88-91",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "node"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "146-152",
          "snippet": "static struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "num",
            "sizeof(struct dentry *)",
            "GFP_KERNEL"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void add_links(struct gcov_node *node, struct dentry *parent)\n{\n\tconst char *basename;\n\tchar *target;\n\tint num;\n\tint i;\n\n\tfor (num = 0; gcov_link[num].ext; num++)\n\t\t/* Nothing. */;\n\tnode->links = kcalloc(num, sizeof(struct dentry *), GFP_KERNEL);\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; i < num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->links[i] = debugfs_create_symlink(deskew(basename),\n\t\t\t\t\t\t\tparent,\ttarget);\n\t\tif (!node->links[i])\n\t\t\tgoto out_err;\n\t\tkfree(target);\n\t}\n\n\treturn;\nout_err:\n\tkfree(target);\n\twhile (i-- > 0)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}"
  },
  {
    "function_name": "deskew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "356-361",
    "snippet": "static const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define SKEW_PREFIX\t\".tmp_\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "basename",
            "SKEW_PREFIX",
            "sizeof(SKEW_PREFIX) - 1"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#define SKEW_PREFIX\t\".tmp_\"\n\nstatic const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}"
  },
  {
    "function_name": "get_link_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "331-348",
    "snippet": "static char *get_link_target(const char *filename, const struct gcov_link *ext)\n{\n\tconst char *rel;\n\tchar *result;\n\n\tif (strncmp(filename, objtree, strlen(objtree)) == 0) {\n\t\trel = filename + strlen(objtree) + 1;\n\t\tif (ext->dir == SRC_TREE)\n\t\t\tresult = link_target(srctree, rel, ext->ext);\n\t\telse\n\t\t\tresult = link_target(objtree, rel, ext->ext);\n\t} else {\n\t\t/* External compilation. */\n\t\tresult = link_target(NULL, filename, ext->ext);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char objtree[] = OBJTREE;",
      "static const char srctree[] = SRCTREE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "link_target",
          "args": [
            "NULL",
            "filename",
            "ext->ext"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "link_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "304-323",
          "snippet": "static char *link_target(const char *dir, const char *path, const char *ext)\n{\n\tchar *target;\n\tchar *old_ext;\n\tchar *copy;\n\n\tcopy = kstrdup(path, GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\told_ext = strrchr(copy, '.');\n\tif (old_ext)\n\t\t*old_ext = '\\0';\n\tif (dir)\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s/%s.%s\", dir, copy, ext);\n\telse\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s.%s\", copy, ext);\n\tkfree(copy);\n\n\treturn target;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic char *link_target(const char *dir, const char *path, const char *ext)\n{\n\tchar *target;\n\tchar *old_ext;\n\tchar *copy;\n\n\tcopy = kstrdup(path, GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\told_ext = strrchr(copy, '.');\n\tif (old_ext)\n\t\t*old_ext = '\\0';\n\tif (dir)\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s/%s.%s\", dir, copy, ext);\n\telse\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s.%s\", copy, ext);\n\tkfree(copy);\n\n\treturn target;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "objtree"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "filename",
            "objtree",
            "strlen(objtree)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic const char objtree[] = OBJTREE;\nstatic const char srctree[] = SRCTREE;\n\nstatic char *get_link_target(const char *filename, const struct gcov_link *ext)\n{\n\tconst char *rel;\n\tchar *result;\n\n\tif (strncmp(filename, objtree, strlen(objtree)) == 0) {\n\t\trel = filename + strlen(objtree) + 1;\n\t\tif (ext->dir == SRC_TREE)\n\t\t\tresult = link_target(srctree, rel, ext->ext);\n\t\telse\n\t\t\tresult = link_target(objtree, rel, ext->ext);\n\t} else {\n\t\t/* External compilation. */\n\t\tresult = link_target(NULL, filename, ext->ext);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "link_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "304-323",
    "snippet": "static char *link_target(const char *dir, const char *path, const char *ext)\n{\n\tchar *target;\n\tchar *old_ext;\n\tchar *copy;\n\n\tcopy = kstrdup(path, GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\told_ext = strrchr(copy, '.');\n\tif (old_ext)\n\t\t*old_ext = '\\0';\n\tif (dir)\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s/%s.%s\", dir, copy, ext);\n\telse\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s.%s\", copy, ext);\n\tkfree(copy);\n\n\treturn target;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "copy"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s.%s\"",
            "copy",
            "ext"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s/%s.%s\"",
            "dir",
            "copy",
            "ext"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "copy",
            "'.'"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "path",
            "GFP_KERNEL"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic char *link_target(const char *dir, const char *path, const char *ext)\n{\n\tchar *target;\n\tchar *old_ext;\n\tchar *copy;\n\n\tcopy = kstrdup(path, GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\told_ext = strrchr(copy, '.');\n\tif (old_ext)\n\t\t*old_ext = '\\0';\n\tif (dir)\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s/%s.%s\", dir, copy, ext);\n\telse\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s.%s\", copy, ext);\n\tkfree(copy);\n\n\treturn target;\n}"
  },
  {
    "function_name": "gcov_seq_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "273-296",
    "snippet": "static ssize_t gcov_seq_write(struct file *file, const char __user *addr,\n\t\t\t      size_t len, loff_t *pos)\n{\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tstruct gcov_node *node;\n\n\tseq = file->private_data;\n\tinfo = gcov_iter_get_info(seq->private);\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tif (node) {\n\t\t/* Reset counts or remove node for unloaded modules. */\n\t\tif (node->num_loaded == 0)\n\t\t\tremove_node(node);\n\t\telse\n\t\t\treset_node(node);\n\t}\n\t/* Reset counts for open file. */\n\tgcov_info_reset(info);\n\tmutex_unlock(&node_lock);\n\n\treturn len;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(node_lock);",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node_lock"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_reset",
          "args": [
            "info"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "172-181",
          "snippet": "void gcov_info_reset(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active; i++) {\n\t\tmemset(info->counts[i].values, 0,\n\t\t       info->counts[i].num * sizeof(gcov_type));\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active; i++) {\n\t\tmemset(info->counts[i].values, 0,\n\t\t       info->counts[i].num * sizeof(gcov_type));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_node",
          "args": [
            "node"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "reset_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "256-264",
          "snippet": "static void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_node",
          "args": [
            "node"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "501-510",
          "snippet": "static void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gcov_node root_node;",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct gcov_node root_node;\nstatic void remove_node(struct gcov_node *node);\n\nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_by_name",
          "args": [
            "gcov_info_filename(info)"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "239-251",
          "snippet": "static struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(all_head);",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "88-91",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node_lock"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_get_info",
          "args": [
            "seq->private"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_get_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "389-392",
          "snippet": "struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstruct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic void remove_node(struct gcov_node *node);\n\nstatic ssize_t gcov_seq_write(struct file *file, const char __user *addr,\n\t\t\t      size_t len, loff_t *pos)\n{\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tstruct gcov_node *node;\n\n\tseq = file->private_data;\n\tinfo = gcov_iter_get_info(seq->private);\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tif (node) {\n\t\t/* Reset counts or remove node for unloaded modules. */\n\t\tif (node->num_loaded == 0)\n\t\t\tremove_node(node);\n\t\telse\n\t\t\treset_node(node);\n\t}\n\t/* Reset counts for open file. */\n\tgcov_info_reset(info);\n\tmutex_unlock(&node_lock);\n\n\treturn len;\n}"
  },
  {
    "function_name": "reset_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "256-264",
    "snippet": "static void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_info_reset",
          "args": [
            "node->loaded_info[i]"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "172-181",
          "snippet": "void gcov_info_reset(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active; i++) {\n\t\tmemset(info->counts[i].values, 0,\n\t\t       info->counts[i].num * sizeof(gcov_type));\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active; i++) {\n\t\tmemset(info->counts[i].values, 0,\n\t\t       info->counts[i].num * sizeof(gcov_type));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}"
  },
  {
    "function_name": "get_node_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "239-251",
    "snippet": "static struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(all_head);",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "gcov_info_filename(info)",
            "name"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcov_info_filename",
          "args": [
            "info"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "88-91",
          "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "node"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "146-152",
          "snippet": "static struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&all_head",
            "all"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(all_head);\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "gcov_seq_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "219-233",
    "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "219-233",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_free",
          "args": [
            "info"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "288-298",
          "snippet": "void gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active ; i++)\n\t\tvfree(info->counts[i].values);\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active ; i++)\n\t\tvfree(info->counts[i].values);\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_free",
          "args": [
            "iter"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "380-383",
          "snippet": "void gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkfree(iter);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkfree(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_get_info",
          "args": [
            "iter"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_get_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "389-392",
          "snippet": "struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstruct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gcov_seq_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "179-213",
    "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(node_lock);",
      "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_info_free",
          "args": [
            "info"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "288-298",
          "snippet": "void gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active ; i++)\n\t\tvfree(info->counts[i].values);\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active ; i++)\n\t\tvfree(info->counts[i].values);\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_free",
          "args": [
            "iter"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "380-383",
          "snippet": "void gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkfree(iter);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkfree(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node_lock"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&gcov_seq_ops"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_new",
          "args": [
            "info"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "363-374",
          "snippet": "struct gcov_iterator *gcov_iter_new(struct gcov_info *info)\n{\n\tstruct gcov_iterator *iter;\n\n\titer = kzalloc(sizeof(struct gcov_iterator) +\n\t\t       num_counter_active(info) * sizeof(struct type_info),\n\t\t       GFP_KERNEL);\n\tif (iter)\n\t\titer->info = info;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstruct gcov_iterator *gcov_iter_new(struct gcov_info *info)\n{\n\tstruct gcov_iterator *iter;\n\n\titer = kzalloc(sizeof(struct gcov_iterator) +\n\t\t       num_counter_active(info) * sizeof(struct type_info),\n\t\t       GFP_KERNEL);\n\tif (iter)\n\t\titer->info = info;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_accumulated_info",
          "args": [
            "node"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "get_accumulated_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "158-173",
          "snippet": "static struct gcov_info *get_accumulated_info(struct gcov_node *node)\n{\n\tstruct gcov_info *info;\n\tint i = 0;\n\n\tif (node->unloaded_info)\n\t\tinfo = gcov_info_dup(node->unloaded_info);\n\telse\n\t\tinfo = gcov_info_dup(node->loaded_info[i++]);\n\tif (!info)\n\t\treturn NULL;\n\tfor (; i < node->num_loaded; i++)\n\t\tgcov_info_add(info, node->loaded_info[i]);\n\n\treturn info;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_info *get_accumulated_info(struct gcov_node *node)\n{\n\tstruct gcov_info *info;\n\tint i = 0;\n\n\tif (node->unloaded_info)\n\t\tinfo = gcov_info_dup(node->unloaded_info);\n\telse\n\t\tinfo = gcov_info_dup(node->loaded_info[i++]);\n\tif (!info)\n\t\treturn NULL;\n\tfor (; i < node->num_loaded; i++)\n\t\tgcov_info_add(info, node->loaded_info[i]);\n\n\treturn info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node_lock"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
  },
  {
    "function_name": "get_accumulated_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "158-173",
    "snippet": "static struct gcov_info *get_accumulated_info(struct gcov_node *node)\n{\n\tstruct gcov_info *info;\n\tint i = 0;\n\n\tif (node->unloaded_info)\n\t\tinfo = gcov_info_dup(node->unloaded_info);\n\telse\n\t\tinfo = gcov_info_dup(node->loaded_info[i++]);\n\tif (!info)\n\t\treturn NULL;\n\tfor (; i < node->num_loaded; i++)\n\t\tgcov_info_add(info, node->loaded_info[i]);\n\n\treturn info;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_info_add",
          "args": [
            "info",
            "node->loaded_info[i]"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "202-213",
          "snippet": "void gcov_info_add(struct gcov_info *dest, struct gcov_info *source)\n{\n\tunsigned int i;\n\tunsigned int j;\n\n\tfor (i = 0; i < num_counter_active(dest); i++) {\n\t\tfor (j = 0; j < dest->counts[i].num; j++) {\n\t\t\tdest->counts[i].values[j] +=\n\t\t\t\tsource->counts[i].values[j];\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_add(struct gcov_info *dest, struct gcov_info *source)\n{\n\tunsigned int i;\n\tunsigned int j;\n\n\tfor (i = 0; i < num_counter_active(dest); i++) {\n\t\tfor (j = 0; j < dest->counts[i].num; j++) {\n\t\t\tdest->counts[i].values[j] +=\n\t\t\t\tsource->counts[i].values[j];\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_info_dup",
          "args": [
            "node->loaded_info[i++]"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "240-282",
          "snippet": "struct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tunsigned int i;\n\tunsigned int active;\n\n\t/* Duplicate gcov_info. */\n\tactive = num_counter_active(info);\n\tdup = kzalloc(sizeof(struct gcov_info) +\n\t\t      sizeof(struct gcov_ctr_info) * active, GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\tdup->version\t\t= info->version;\n\tdup->stamp\t\t= info->stamp;\n\tdup->n_functions\t= info->n_functions;\n\tdup->ctr_mask\t\t= info->ctr_mask;\n\t/* Duplicate filename. */\n\tdup->filename\t\t= kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\t/* Duplicate table of functions. */\n\tdup->functions = kmemdup(info->functions, info->n_functions *\n\t\t\t\t get_fn_size(info), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\t/* Duplicate counter arrays. */\n\tfor (i = 0; i < active ; i++) {\n\t\tstruct gcov_ctr_info *ctr = &info->counts[i];\n\t\tsize_t size = ctr->num * sizeof(gcov_type);\n\n\t\tdup->counts[i].num = ctr->num;\n\t\tdup->counts[i].merge = ctr->merge;\n\t\tdup->counts[i].values = vmalloc(size);\n\t\tif (!dup->counts[i].values)\n\t\t\tgoto err_free;\n\t\tmemcpy(dup->counts[i].values, ctr->values, size);\n\t}\n\treturn dup;\n\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstruct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tunsigned int i;\n\tunsigned int active;\n\n\t/* Duplicate gcov_info. */\n\tactive = num_counter_active(info);\n\tdup = kzalloc(sizeof(struct gcov_info) +\n\t\t      sizeof(struct gcov_ctr_info) * active, GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\tdup->version\t\t= info->version;\n\tdup->stamp\t\t= info->stamp;\n\tdup->n_functions\t= info->n_functions;\n\tdup->ctr_mask\t\t= info->ctr_mask;\n\t/* Duplicate filename. */\n\tdup->filename\t\t= kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\t/* Duplicate table of functions. */\n\tdup->functions = kmemdup(info->functions, info->n_functions *\n\t\t\t\t get_fn_size(info), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\t/* Duplicate counter arrays. */\n\tfor (i = 0; i < active ; i++) {\n\t\tstruct gcov_ctr_info *ctr = &info->counts[i];\n\t\tsize_t size = ctr->num * sizeof(gcov_type);\n\n\t\tdup->counts[i].num = ctr->num;\n\t\tdup->counts[i].merge = ctr->merge;\n\t\tdup->counts[i].values = vmalloc(size);\n\t\tif (!dup->counts[i].values)\n\t\t\tgoto err_free;\n\t\tmemcpy(dup->counts[i].values, ctr->values, size);\n\t}\n\treturn dup;\n\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_info *get_accumulated_info(struct gcov_node *node)\n{\n\tstruct gcov_info *info;\n\tint i = 0;\n\n\tif (node->unloaded_info)\n\t\tinfo = gcov_info_dup(node->unloaded_info);\n\telse\n\t\tinfo = gcov_info_dup(node->loaded_info[i++]);\n\tif (!info)\n\t\treturn NULL;\n\tfor (; i < node->num_loaded; i++)\n\t\tgcov_info_add(info, node->loaded_info[i]);\n\n\treturn info;\n}"
  },
  {
    "function_name": "get_node_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "146-152",
    "snippet": "static struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_node(struct gcov_node *node);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void remove_node(struct gcov_node *node);\n\nstatic struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}"
  },
  {
    "function_name": "gcov_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "129-132",
    "snippet": "static void gcov_seq_stop(struct seq_file *seq, void *data)\n{\n\t/* Unused. */\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void gcov_seq_stop(struct seq_file *seq, void *data)\n{\n\t/* Unused. */\n}"
  },
  {
    "function_name": "gcov_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "120-127",
    "snippet": "static int gcov_seq_show(struct seq_file *seq, void *data)\n{\n\tstruct gcov_iterator *iter = data;\n\n\tif (gcov_iter_write(iter, seq))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_iter_write",
          "args": [
            "iter",
            "seq"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "522-563",
          "snippet": "int gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\n{\n\tint rc = -EINVAL;\n\n\tswitch (iter->record) {\n\tcase RECORD_FILE_MAGIC:\n\t\trc = seq_write_gcov_u32(seq, GCOV_DATA_MAGIC);\n\t\tbreak;\n\tcase RECORD_GCOV_VERSION:\n\t\trc = seq_write_gcov_u32(seq, iter->info->version);\n\t\tbreak;\n\tcase RECORD_TIME_STAMP:\n\t\trc = seq_write_gcov_u32(seq, iter->info->stamp);\n\t\tbreak;\n\tcase RECORD_FUNCTION_TAG:\n\t\trc = seq_write_gcov_u32(seq, GCOV_TAG_FUNCTION);\n\t\tbreak;\n\tcase RECORD_FUNCTON_TAG_LEN:\n\t\trc = seq_write_gcov_u32(seq, 2);\n\t\tbreak;\n\tcase RECORD_FUNCTION_IDENT:\n\t\trc = seq_write_gcov_u32(seq, get_func(iter)->ident);\n\t\tbreak;\n\tcase RECORD_FUNCTION_CHECK:\n\t\trc = seq_write_gcov_u32(seq, get_func(iter)->checksum);\n\t\tbreak;\n\tcase RECORD_COUNT_TAG:\n\t\trc = seq_write_gcov_u32(seq,\n\t\t\tGCOV_TAG_FOR_COUNTER(get_type(iter)->ctr_type));\n\t\tbreak;\n\tcase RECORD_COUNT_LEN:\n\t\trc = seq_write_gcov_u32(seq,\n\t\t\t\tget_func(iter)->n_ctrs[iter->type] * 2);\n\t\tbreak;\n\tcase RECORD_COUNT:\n\t\trc = seq_write_gcov_u64(seq,\n\t\t\titer->info->counts[iter->type].\n\t\t\t\tvalues[iter->count + get_type(iter)->offset]);\n\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define RECORD_COUNT\t\t9",
            "#define RECORD_COUNT_LEN\t8",
            "#define RECORD_COUNT_TAG\t7",
            "#define RECORD_FUNCTION_CHECK\t6",
            "#define RECORD_FUNCTION_IDENT\t5",
            "#define RECORD_FUNCTON_TAG_LEN\t4",
            "#define RECORD_FUNCTION_TAG\t3",
            "#define RECORD_TIME_STAMP\t2",
            "#define RECORD_GCOV_VERSION\t1",
            "#define RECORD_FILE_MAGIC\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define RECORD_COUNT\t\t9\n#define RECORD_COUNT_LEN\t8\n#define RECORD_COUNT_TAG\t7\n#define RECORD_FUNCTION_CHECK\t6\n#define RECORD_FUNCTION_IDENT\t5\n#define RECORD_FUNCTON_TAG_LEN\t4\n#define RECORD_FUNCTION_TAG\t3\n#define RECORD_TIME_STAMP\t2\n#define RECORD_GCOV_VERSION\t1\n#define RECORD_FILE_MAGIC\t0\n\nint gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\n{\n\tint rc = -EINVAL;\n\n\tswitch (iter->record) {\n\tcase RECORD_FILE_MAGIC:\n\t\trc = seq_write_gcov_u32(seq, GCOV_DATA_MAGIC);\n\t\tbreak;\n\tcase RECORD_GCOV_VERSION:\n\t\trc = seq_write_gcov_u32(seq, iter->info->version);\n\t\tbreak;\n\tcase RECORD_TIME_STAMP:\n\t\trc = seq_write_gcov_u32(seq, iter->info->stamp);\n\t\tbreak;\n\tcase RECORD_FUNCTION_TAG:\n\t\trc = seq_write_gcov_u32(seq, GCOV_TAG_FUNCTION);\n\t\tbreak;\n\tcase RECORD_FUNCTON_TAG_LEN:\n\t\trc = seq_write_gcov_u32(seq, 2);\n\t\tbreak;\n\tcase RECORD_FUNCTION_IDENT:\n\t\trc = seq_write_gcov_u32(seq, get_func(iter)->ident);\n\t\tbreak;\n\tcase RECORD_FUNCTION_CHECK:\n\t\trc = seq_write_gcov_u32(seq, get_func(iter)->checksum);\n\t\tbreak;\n\tcase RECORD_COUNT_TAG:\n\t\trc = seq_write_gcov_u32(seq,\n\t\t\tGCOV_TAG_FOR_COUNTER(get_type(iter)->ctr_type));\n\t\tbreak;\n\tcase RECORD_COUNT_LEN:\n\t\trc = seq_write_gcov_u32(seq,\n\t\t\t\tget_func(iter)->n_ctrs[iter->type] * 2);\n\t\tbreak;\n\tcase RECORD_COUNT:\n\t\trc = seq_write_gcov_u64(seq,\n\t\t\titer->info->counts[iter->type].\n\t\t\t\tvalues[iter->count + get_type(iter)->offset]);\n\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_show(struct seq_file *seq, void *data)\n{\n\tstruct gcov_iterator *iter = data;\n\n\tif (gcov_iter_write(iter, seq))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "gcov_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "108-117",
    "snippet": "static void *gcov_seq_next(struct seq_file *seq, void *data, loff_t *pos)\n{\n\tstruct gcov_iterator *iter = data;\n\n\tif (gcov_iter_next(iter))\n\t\treturn NULL;\n\t(*pos)++;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_iter_next",
          "args": [
            "iter"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "433-480",
          "snippet": "int gcov_iter_next(struct gcov_iterator *iter)\n{\n\tswitch (iter->record) {\n\tcase RECORD_FILE_MAGIC:\n\tcase RECORD_GCOV_VERSION:\n\tcase RECORD_FUNCTION_TAG:\n\tcase RECORD_FUNCTON_TAG_LEN:\n\tcase RECORD_FUNCTION_IDENT:\n\tcase RECORD_COUNT_TAG:\n\t\t/* Advance to next record */\n\t\titer->record++;\n\t\tbreak;\n\tcase RECORD_COUNT:\n\t\t/* Advance to next count */\n\t\titer->count++;\n\t\t/* fall through */\n\tcase RECORD_COUNT_LEN:\n\t\tif (iter->count < get_func(iter)->n_ctrs[iter->type]) {\n\t\t\titer->record = 9;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to next counter type */\n\t\tget_type(iter)->offset += iter->count;\n\t\titer->count = 0;\n\t\titer->type++;\n\t\t/* fall through */\n\tcase RECORD_FUNCTION_CHECK:\n\t\tif (iter->type < iter->num_types) {\n\t\t\titer->record = 7;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to next function */\n\t\titer->type = 0;\n\t\titer->function++;\n\t\t/* fall through */\n\tcase RECORD_TIME_STAMP:\n\t\tif (iter->function < iter->info->n_functions)\n\t\t\titer->record = 3;\n\t\telse\n\t\t\titer->record = -1;\n\t\tbreak;\n\t}\n\t/* Check for EOF. */\n\tif (iter->record == -1)\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define RECORD_COUNT\t\t9",
            "#define RECORD_COUNT_LEN\t8",
            "#define RECORD_COUNT_TAG\t7",
            "#define RECORD_FUNCTION_CHECK\t6",
            "#define RECORD_FUNCTION_IDENT\t5",
            "#define RECORD_FUNCTON_TAG_LEN\t4",
            "#define RECORD_FUNCTION_TAG\t3",
            "#define RECORD_TIME_STAMP\t2",
            "#define RECORD_GCOV_VERSION\t1",
            "#define RECORD_FILE_MAGIC\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define RECORD_COUNT\t\t9\n#define RECORD_COUNT_LEN\t8\n#define RECORD_COUNT_TAG\t7\n#define RECORD_FUNCTION_CHECK\t6\n#define RECORD_FUNCTION_IDENT\t5\n#define RECORD_FUNCTON_TAG_LEN\t4\n#define RECORD_FUNCTION_TAG\t3\n#define RECORD_TIME_STAMP\t2\n#define RECORD_GCOV_VERSION\t1\n#define RECORD_FILE_MAGIC\t0\n\nint gcov_iter_next(struct gcov_iterator *iter)\n{\n\tswitch (iter->record) {\n\tcase RECORD_FILE_MAGIC:\n\tcase RECORD_GCOV_VERSION:\n\tcase RECORD_FUNCTION_TAG:\n\tcase RECORD_FUNCTON_TAG_LEN:\n\tcase RECORD_FUNCTION_IDENT:\n\tcase RECORD_COUNT_TAG:\n\t\t/* Advance to next record */\n\t\titer->record++;\n\t\tbreak;\n\tcase RECORD_COUNT:\n\t\t/* Advance to next count */\n\t\titer->count++;\n\t\t/* fall through */\n\tcase RECORD_COUNT_LEN:\n\t\tif (iter->count < get_func(iter)->n_ctrs[iter->type]) {\n\t\t\titer->record = 9;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to next counter type */\n\t\tget_type(iter)->offset += iter->count;\n\t\titer->count = 0;\n\t\titer->type++;\n\t\t/* fall through */\n\tcase RECORD_FUNCTION_CHECK:\n\t\tif (iter->type < iter->num_types) {\n\t\t\titer->record = 7;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to next function */\n\t\titer->type = 0;\n\t\titer->function++;\n\t\t/* fall through */\n\tcase RECORD_TIME_STAMP:\n\t\tif (iter->function < iter->info->n_functions)\n\t\t\titer->record = 3;\n\t\telse\n\t\t\titer->record = -1;\n\t\tbreak;\n\t}\n\t/* Check for EOF. */\n\tif (iter->record == -1)\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void *gcov_seq_next(struct seq_file *seq, void *data, loff_t *pos)\n{\n\tstruct gcov_iterator *iter = data;\n\n\tif (gcov_iter_next(iter))\n\t\treturn NULL;\n\t(*pos)++;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "gcov_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "95-105",
    "snippet": "static void *gcov_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tloff_t i;\n\n\tgcov_iter_start(seq->private);\n\tfor (i = 0; i < *pos; i++) {\n\t\tif (gcov_iter_next(seq->private))\n\t\t\treturn NULL;\n\t}\n\treturn seq->private;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_iter_next",
          "args": [
            "seq->private"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "433-480",
          "snippet": "int gcov_iter_next(struct gcov_iterator *iter)\n{\n\tswitch (iter->record) {\n\tcase RECORD_FILE_MAGIC:\n\tcase RECORD_GCOV_VERSION:\n\tcase RECORD_FUNCTION_TAG:\n\tcase RECORD_FUNCTON_TAG_LEN:\n\tcase RECORD_FUNCTION_IDENT:\n\tcase RECORD_COUNT_TAG:\n\t\t/* Advance to next record */\n\t\titer->record++;\n\t\tbreak;\n\tcase RECORD_COUNT:\n\t\t/* Advance to next count */\n\t\titer->count++;\n\t\t/* fall through */\n\tcase RECORD_COUNT_LEN:\n\t\tif (iter->count < get_func(iter)->n_ctrs[iter->type]) {\n\t\t\titer->record = 9;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to next counter type */\n\t\tget_type(iter)->offset += iter->count;\n\t\titer->count = 0;\n\t\titer->type++;\n\t\t/* fall through */\n\tcase RECORD_FUNCTION_CHECK:\n\t\tif (iter->type < iter->num_types) {\n\t\t\titer->record = 7;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to next function */\n\t\titer->type = 0;\n\t\titer->function++;\n\t\t/* fall through */\n\tcase RECORD_TIME_STAMP:\n\t\tif (iter->function < iter->info->n_functions)\n\t\t\titer->record = 3;\n\t\telse\n\t\t\titer->record = -1;\n\t\tbreak;\n\t}\n\t/* Check for EOF. */\n\tif (iter->record == -1)\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define RECORD_COUNT\t\t9",
            "#define RECORD_COUNT_LEN\t8",
            "#define RECORD_COUNT_TAG\t7",
            "#define RECORD_FUNCTION_CHECK\t6",
            "#define RECORD_FUNCTION_IDENT\t5",
            "#define RECORD_FUNCTON_TAG_LEN\t4",
            "#define RECORD_FUNCTION_TAG\t3",
            "#define RECORD_TIME_STAMP\t2",
            "#define RECORD_GCOV_VERSION\t1",
            "#define RECORD_FILE_MAGIC\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define RECORD_COUNT\t\t9\n#define RECORD_COUNT_LEN\t8\n#define RECORD_COUNT_TAG\t7\n#define RECORD_FUNCTION_CHECK\t6\n#define RECORD_FUNCTION_IDENT\t5\n#define RECORD_FUNCTON_TAG_LEN\t4\n#define RECORD_FUNCTION_TAG\t3\n#define RECORD_TIME_STAMP\t2\n#define RECORD_GCOV_VERSION\t1\n#define RECORD_FILE_MAGIC\t0\n\nint gcov_iter_next(struct gcov_iterator *iter)\n{\n\tswitch (iter->record) {\n\tcase RECORD_FILE_MAGIC:\n\tcase RECORD_GCOV_VERSION:\n\tcase RECORD_FUNCTION_TAG:\n\tcase RECORD_FUNCTON_TAG_LEN:\n\tcase RECORD_FUNCTION_IDENT:\n\tcase RECORD_COUNT_TAG:\n\t\t/* Advance to next record */\n\t\titer->record++;\n\t\tbreak;\n\tcase RECORD_COUNT:\n\t\t/* Advance to next count */\n\t\titer->count++;\n\t\t/* fall through */\n\tcase RECORD_COUNT_LEN:\n\t\tif (iter->count < get_func(iter)->n_ctrs[iter->type]) {\n\t\t\titer->record = 9;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to next counter type */\n\t\tget_type(iter)->offset += iter->count;\n\t\titer->count = 0;\n\t\titer->type++;\n\t\t/* fall through */\n\tcase RECORD_FUNCTION_CHECK:\n\t\tif (iter->type < iter->num_types) {\n\t\t\titer->record = 7;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to next function */\n\t\titer->type = 0;\n\t\titer->function++;\n\t\t/* fall through */\n\tcase RECORD_TIME_STAMP:\n\t\tif (iter->function < iter->info->n_functions)\n\t\t\titer->record = 3;\n\t\telse\n\t\t\titer->record = -1;\n\t\tbreak;\n\t}\n\t/* Check for EOF. */\n\tif (iter->record == -1)\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gcov_iter_start",
          "args": [
            "seq->private"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_iter_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_3_4.c",
          "lines": "398-413",
          "snippet": "void gcov_iter_start(struct gcov_iterator *iter)\n{\n\tint i;\n\n\titer->record = 0;\n\titer->function = 0;\n\titer->type = 0;\n\titer->count = 0;\n\titer->num_types = 0;\n\tfor (i = 0; i < GCOV_COUNTERS; i++) {\n\t\tif (counter_active(iter->info, i)) {\n\t\t\titer->type_info[iter->num_types].ctr_type = i;\n\t\t\titer->type_info[iter->num_types++].offset = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define GCOV_COUNTERS\t\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_COUNTERS\t\t5\n\nvoid gcov_iter_start(struct gcov_iterator *iter)\n{\n\tint i;\n\n\titer->record = 0;\n\titer->function = 0;\n\titer->type = 0;\n\titer->count = 0;\n\titer->num_types = 0;\n\tfor (i = 0; i < GCOV_COUNTERS; i++) {\n\t\tif (counter_active(iter->info, i)) {\n\t\t\titer->type_info[iter->num_types].ctr_type = i;\n\t\t\titer->type_info[iter->num_types++].offset = 0;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void *gcov_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tloff_t i;\n\n\tgcov_iter_start(seq->private);\n\tfor (i = 0; i < *pos; i++) {\n\t\tif (gcov_iter_next(seq->private))\n\t\t\treturn NULL;\n\t}\n\treturn seq->private;\n}"
  },
  {
    "function_name": "gcov_persist_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
    "lines": "74-86",
    "snippet": "static int __init gcov_persist_setup(char *str)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(str, 0, &val)) {\n\t\tpr_warn(\"invalid gcov_persist parameter '%s'\\n\", str);\n\t\treturn 0;\n\t}\n\tgcov_persist = val;\n\tpr_info(\"setting gcov_persist to %d\\n\", gcov_persist);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int gcov_persist = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"setting gcov_persist to %d\\n\"",
            "gcov_persist"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"invalid gcov_persist parameter '%s'\\n\"",
            "str"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "str",
            "0",
            "&val"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_persist = 1;\n\nstatic int __init gcov_persist_setup(char *str)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(str, 0, &val)) {\n\t\tpr_warn(\"invalid gcov_persist parameter '%s'\\n\", str);\n\t\treturn 0;\n\t}\n\tgcov_persist = val;\n\tpr_info(\"setting gcov_persist to %d\\n\", gcov_persist);\n\n\treturn 1;\n}"
  }
]