[
  {
    "function_name": "skb_copy_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1891-1895",
    "snippet": "int __weak skb_copy_bits(const struct sk_buff *skb, int offset, void *to,\n\t\t\t int len)\n{\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
      "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
      "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
      "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_local_storage_proto __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\n\nint __weak skb_copy_bits(const struct sk_buff *skb, int offset, void *to,\n\t\t\t int len)\n{\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "bpf_helper_changes_pkt_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1883-1886",
    "snippet": "bool __weak bpf_helper_changes_pkt_data(void *func)\n{\n\treturn false;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
      "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
      "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
      "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_local_storage_proto __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\n\nbool __weak bpf_helper_changes_pkt_data(void *func)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "bpf_jit_compile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1879-1881",
    "snippet": "void __weak bpf_jit_compile(struct bpf_prog *prog)\n{\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
      "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
      "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
      "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_local_storage_proto __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\n\nvoid __weak bpf_jit_compile(struct bpf_prog *prog)\n{\n}"
  },
  {
    "function_name": "bpf_int_jit_compile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1871-1874",
    "snippet": "struct bpf_prog * __weak bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\treturn prog;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
      "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
      "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
      "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_local_storage_proto __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\n\nstruct bpf_prog * __weak bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\treturn prog;\n}"
  },
  {
    "function_name": "bpf_event_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1849-1854",
    "snippet": "u64 __weak\nbpf_event_output(struct bpf_map *map, u64 flags, void *meta, u64 meta_size,\n\t\t void *ctx, u64 ctx_size, bpf_ctx_copy_t ctx_copy)\n{\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
      "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
      "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
      "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_local_storage_proto __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\n\nu64 __weak\nbpf_event_output(struct bpf_map *map, u64 flags, void *meta, u64 meta_size,\n\t\t void *ctx, u64 ctx_size, bpf_ctx_copy_t ctx_copy)\n{\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "bpf_get_trace_printk_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1844-1847",
    "snippet": "const struct bpf_func_proto * __weak bpf_get_trace_printk_proto(void)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
      "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
      "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
      "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_local_storage_proto __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\n\nconst struct bpf_func_proto * __weak bpf_get_trace_printk_proto(void)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "bpf_user_rnd_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1802-1805",
    "snippet": "void bpf_user_rnd_init_once(void)\n{\n\tprandom_init_once(&bpf_user_rnd_state);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct rnd_state, bpf_user_rnd_state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prandom_init_once",
          "args": [
            "&bpf_user_rnd_state"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic DEFINE_PER_CPU(struct rnd_state, bpf_user_rnd_state);\n\nvoid bpf_user_rnd_init_once(void)\n{\n\tprandom_init_once(&bpf_user_rnd_state);\n}"
  },
  {
    "function_name": "bpf_prog_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1790-1796",
    "snippet": "void bpf_prog_free(struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\n\tINIT_WORK(&aux->work, bpf_prog_free_deferred);\n\tschedule_work(&aux->work);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&aux->work"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&aux->work",
            "bpf_prog_free_deferred"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_free(struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\n\tINIT_WORK(&aux->work, bpf_prog_free_deferred);\n\tschedule_work(&aux->work);\n}"
  },
  {
    "function_name": "bpf_prog_free_deferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1767-1787",
    "snippet": "static void bpf_prog_free_deferred(struct work_struct *work)\n{\n\tstruct bpf_prog_aux *aux;\n\tint i;\n\n\taux = container_of(work, struct bpf_prog_aux, work);\n\tif (bpf_prog_is_dev_bound(aux))\n\t\tbpf_prog_offload_destroy(aux->prog);\n#ifdef CONFIG_PERF_EVENTS\n\tif (aux->prog->has_callchain_buf)\n\t\tput_callchain_buffers();\n#endif\n\tfor (i = 0; i < aux->func_cnt; i++)\n\t\tbpf_jit_free(aux->func[i]);\n\tif (aux->func_cnt) {\n\t\tkfree(aux->func);\n\t\tbpf_prog_unlock_free(aux->prog);\n\t} else {\n\t\tbpf_jit_free(aux->prog);\n\t}\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_jit_free",
          "args": [
            "aux->prog"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "663-675",
          "snippet": "void __weak bpf_jit_free(struct bpf_prog *fp)\n{\n\tif (fp->jited) {\n\t\tstruct bpf_binary_header *hdr = bpf_jit_binary_hdr(fp);\n\n\t\tbpf_jit_binary_unlock_ro(hdr);\n\t\tbpf_jit_binary_free(hdr);\n\n\t\tWARN_ON_ONCE(!bpf_prog_kallsyms_verify_off(fp));\n\t}\n\n\tbpf_prog_unlock_free(fp);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\n\nvoid __weak bpf_jit_free(struct bpf_prog *fp)\n{\n\tif (fp->jited) {\n\t\tstruct bpf_binary_header *hdr = bpf_jit_binary_hdr(fp);\n\n\t\tbpf_jit_binary_unlock_ro(hdr);\n\t\tbpf_jit_binary_free(hdr);\n\n\t\tWARN_ON_ONCE(!bpf_prog_kallsyms_verify_off(fp));\n\t}\n\n\tbpf_prog_unlock_free(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_unlock_free",
          "args": [
            "aux->prog"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "aux->func"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_callchain_buffers",
          "args": [],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "put_callchain_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "145-151",
          "snippet": "void put_callchain_buffers(void)\n{\n\tif (atomic_dec_and_mutex_lock(&nr_callchain_events, &callchain_mutex)) {\n\t\trelease_callchain_buffers();\n\t\tmutex_unlock(&callchain_mutex);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_callchain_events;",
            "static DEFINE_MUTEX(callchain_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic atomic_t nr_callchain_events;\nstatic DEFINE_MUTEX(callchain_mutex);\n\nvoid put_callchain_buffers(void)\n{\n\tif (atomic_dec_and_mutex_lock(&nr_callchain_events, &callchain_mutex)) {\n\t\trelease_callchain_buffers();\n\t\tmutex_unlock(&callchain_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_offload_destroy",
          "args": [
            "aux->prog"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_offload_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/offload.c",
          "lines": "211-219",
          "snippet": "void bpf_prog_offload_destroy(struct bpf_prog *prog)\n{\n\trtnl_lock();\n\tdown_write(&bpf_devs_lock);\n\tif (prog->aux->offload)\n\t\t__bpf_prog_offload_destroy(prog);\n\tup_write(&bpf_devs_lock);\n\trtnl_unlock();\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nvoid bpf_prog_offload_destroy(struct bpf_prog *prog)\n{\n\trtnl_lock();\n\tdown_write(&bpf_devs_lock);\n\tif (prog->aux->offload)\n\t\t__bpf_prog_offload_destroy(prog);\n\tup_write(&bpf_devs_lock);\n\trtnl_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_is_dev_bound",
          "args": [
            "aux"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbpf_prog_aux",
            "work"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_prog_free_deferred(struct work_struct *work)\n{\n\tstruct bpf_prog_aux *aux;\n\tint i;\n\n\taux = container_of(work, struct bpf_prog_aux, work);\n\tif (bpf_prog_is_dev_bound(aux))\n\t\tbpf_prog_offload_destroy(aux->prog);\n#ifdef CONFIG_PERF_EVENTS\n\tif (aux->prog->has_callchain_buf)\n\t\tput_callchain_buffers();\n#endif\n\tfor (i = 0; i < aux->func_cnt; i++)\n\t\tbpf_jit_free(aux->func[i]);\n\tif (aux->func_cnt) {\n\t\tkfree(aux->func);\n\t\tbpf_prog_unlock_free(aux->prog);\n\t} else {\n\t\tbpf_jit_free(aux->prog);\n\t}\n}"
  },
  {
    "function_name": "bpf_prog_array_copy_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1747-1765",
    "snippet": "int bpf_prog_array_copy_info(struct bpf_prog_array __rcu *array,\n\t\t\t     u32 *prog_ids, u32 request_cnt,\n\t\t\t     u32 *prog_cnt)\n{\n\tu32 cnt = 0;\n\n\tif (array)\n\t\tcnt = bpf_prog_array_length(array);\n\n\t*prog_cnt = cnt;\n\n\t/* return early if user requested only program count or nothing to copy */\n\tif (!request_cnt || !cnt)\n\t\treturn 0;\n\n\t/* this function is called under trace/bpf_trace.c: bpf_event_mutex */\n\treturn bpf_prog_array_copy_core(array, prog_ids, request_cnt) ? -ENOSPC\n\t\t\t\t\t\t\t\t     : 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_copy_core",
          "args": [
            "array",
            "prog_ids",
            "request_cnt"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1618-1637",
          "snippet": "static bool bpf_prog_array_copy_core(struct bpf_prog_array __rcu *array,\n\t\t\t\t     u32 *prog_ids,\n\t\t\t\t     u32 request_cnt)\n{\n\tstruct bpf_prog_array_item *item;\n\tint i = 0;\n\n\titem = rcu_dereference_check(array, 1)->items;\n\tfor (; item->prog; item++) {\n\t\tif (item->prog == &dummy_bpf_prog.prog)\n\t\t\tcontinue;\n\t\tprog_ids[i] = item->prog->aux->id;\n\t\tif (++i == request_cnt) {\n\t\t\titem++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn !!(item->prog);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nstatic bool bpf_prog_array_copy_core(struct bpf_prog_array __rcu *array,\n\t\t\t\t     u32 *prog_ids,\n\t\t\t\t     u32 request_cnt)\n{\n\tstruct bpf_prog_array_item *item;\n\tint i = 0;\n\n\titem = rcu_dereference_check(array, 1)->items;\n\tfor (; item->prog; item++) {\n\t\tif (item->prog == &dummy_bpf_prog.prog)\n\t\t\tcontinue;\n\t\tprog_ids[i] = item->prog->aux->id;\n\t\tif (++i == request_cnt) {\n\t\t\titem++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn !!(item->prog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_length",
          "args": [
            "array"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1603-1615",
          "snippet": "int bpf_prog_array_length(struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\trcu_read_lock();\n\titem = rcu_dereference(array)->items;\n\tfor (; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\trcu_read_unlock();\n\treturn cnt;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nint bpf_prog_array_length(struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\trcu_read_lock();\n\titem = rcu_dereference(array)->items;\n\tfor (; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\trcu_read_unlock();\n\treturn cnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_info(struct bpf_prog_array __rcu *array,\n\t\t\t     u32 *prog_ids, u32 request_cnt,\n\t\t\t     u32 *prog_cnt)\n{\n\tu32 cnt = 0;\n\n\tif (array)\n\t\tcnt = bpf_prog_array_length(array);\n\n\t*prog_cnt = cnt;\n\n\t/* return early if user requested only program count or nothing to copy */\n\tif (!request_cnt || !cnt)\n\t\treturn 0;\n\n\t/* this function is called under trace/bpf_trace.c: bpf_event_mutex */\n\treturn bpf_prog_array_copy_core(array, prog_ids, request_cnt) ? -ENOSPC\n\t\t\t\t\t\t\t\t     : 0;\n}"
  },
  {
    "function_name": "bpf_prog_array_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1683-1745",
    "snippet": "int bpf_prog_array_copy(struct bpf_prog_array __rcu *old_array,\n\t\t\tstruct bpf_prog *exclude_prog,\n\t\t\tstruct bpf_prog *include_prog,\n\t\t\tstruct bpf_prog_array **new_array)\n{\n\tint new_prog_cnt, carry_prog_cnt = 0;\n\tstruct bpf_prog_array_item *existing;\n\tstruct bpf_prog_array *array;\n\tbool found_exclude = false;\n\tint new_prog_idx = 0;\n\n\t/* Figure out how many existing progs we need to carry over to\n\t * the new array.\n\t */\n\tif (old_array) {\n\t\texisting = old_array->items;\n\t\tfor (; existing->prog; existing++) {\n\t\t\tif (existing->prog == exclude_prog) {\n\t\t\t\tfound_exclude = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (existing->prog != &dummy_bpf_prog.prog)\n\t\t\t\tcarry_prog_cnt++;\n\t\t\tif (existing->prog == include_prog)\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tif (exclude_prog && !found_exclude)\n\t\treturn -ENOENT;\n\n\t/* How many progs (not NULL) will be in the new array? */\n\tnew_prog_cnt = carry_prog_cnt;\n\tif (include_prog)\n\t\tnew_prog_cnt += 1;\n\n\t/* Do we have any prog (not NULL) in the new array? */\n\tif (!new_prog_cnt) {\n\t\t*new_array = NULL;\n\t\treturn 0;\n\t}\n\n\t/* +1 as the end of prog_array is marked with NULL */\n\tarray = bpf_prog_array_alloc(new_prog_cnt + 1, GFP_KERNEL);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\t/* Fill in the new prog array */\n\tif (carry_prog_cnt) {\n\t\texisting = old_array->items;\n\t\tfor (; existing->prog; existing++)\n\t\t\tif (existing->prog != exclude_prog &&\n\t\t\t    existing->prog != &dummy_bpf_prog.prog) {\n\t\t\t\tarray->items[new_prog_idx++].prog =\n\t\t\t\t\texisting->prog;\n\t\t\t}\n\t}\n\tif (include_prog)\n\t\tarray->items[new_prog_idx++].prog = include_prog;\n\tarray->items[new_prog_idx].prog = NULL;\n\t*new_array = array;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_alloc",
          "args": [
            "new_prog_cnt + 1",
            "GFP_KERNEL"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1584-1593",
          "snippet": "struct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nstruct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nint bpf_prog_array_copy(struct bpf_prog_array __rcu *old_array,\n\t\t\tstruct bpf_prog *exclude_prog,\n\t\t\tstruct bpf_prog *include_prog,\n\t\t\tstruct bpf_prog_array **new_array)\n{\n\tint new_prog_cnt, carry_prog_cnt = 0;\n\tstruct bpf_prog_array_item *existing;\n\tstruct bpf_prog_array *array;\n\tbool found_exclude = false;\n\tint new_prog_idx = 0;\n\n\t/* Figure out how many existing progs we need to carry over to\n\t * the new array.\n\t */\n\tif (old_array) {\n\t\texisting = old_array->items;\n\t\tfor (; existing->prog; existing++) {\n\t\t\tif (existing->prog == exclude_prog) {\n\t\t\t\tfound_exclude = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (existing->prog != &dummy_bpf_prog.prog)\n\t\t\t\tcarry_prog_cnt++;\n\t\t\tif (existing->prog == include_prog)\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tif (exclude_prog && !found_exclude)\n\t\treturn -ENOENT;\n\n\t/* How many progs (not NULL) will be in the new array? */\n\tnew_prog_cnt = carry_prog_cnt;\n\tif (include_prog)\n\t\tnew_prog_cnt += 1;\n\n\t/* Do we have any prog (not NULL) in the new array? */\n\tif (!new_prog_cnt) {\n\t\t*new_array = NULL;\n\t\treturn 0;\n\t}\n\n\t/* +1 as the end of prog_array is marked with NULL */\n\tarray = bpf_prog_array_alloc(new_prog_cnt + 1, GFP_KERNEL);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\t/* Fill in the new prog array */\n\tif (carry_prog_cnt) {\n\t\texisting = old_array->items;\n\t\tfor (; existing->prog; existing++)\n\t\t\tif (existing->prog != exclude_prog &&\n\t\t\t    existing->prog != &dummy_bpf_prog.prog) {\n\t\t\t\tarray->items[new_prog_idx++].prog =\n\t\t\t\t\texisting->prog;\n\t\t\t}\n\t}\n\tif (include_prog)\n\t\tarray->items[new_prog_idx++].prog = include_prog;\n\tarray->items[new_prog_idx].prog = NULL;\n\t*new_array = array;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_prog_array_delete_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1671-1681",
    "snippet": "void bpf_prog_array_delete_safe(struct bpf_prog_array __rcu *array,\n\t\t\t\tstruct bpf_prog *old_prog)\n{\n\tstruct bpf_prog_array_item *item = array->items;\n\n\tfor (; item->prog; item++)\n\t\tif (item->prog == old_prog) {\n\t\t\tWRITE_ONCE(item->prog, &dummy_bpf_prog.prog);\n\t\t\tbreak;\n\t\t}\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "item->prog",
            "&dummy_bpf_prog.prog"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nvoid bpf_prog_array_delete_safe(struct bpf_prog_array __rcu *array,\n\t\t\t\tstruct bpf_prog *old_prog)\n{\n\tstruct bpf_prog_array_item *item = array->items;\n\n\tfor (; item->prog; item++)\n\t\tif (item->prog == old_prog) {\n\t\t\tWRITE_ONCE(item->prog, &dummy_bpf_prog.prog);\n\t\t\tbreak;\n\t\t}\n}"
  },
  {
    "function_name": "bpf_prog_array_copy_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1639-1669",
    "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ids"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "prog_ids",
            "ids",
            "cnt * sizeof(u32)"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_copy_core",
          "args": [
            "array",
            "ids",
            "cnt"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1618-1637",
          "snippet": "static bool bpf_prog_array_copy_core(struct bpf_prog_array __rcu *array,\n\t\t\t\t     u32 *prog_ids,\n\t\t\t\t     u32 request_cnt)\n{\n\tstruct bpf_prog_array_item *item;\n\tint i = 0;\n\n\titem = rcu_dereference_check(array, 1)->items;\n\tfor (; item->prog; item++) {\n\t\tif (item->prog == &dummy_bpf_prog.prog)\n\t\t\tcontinue;\n\t\tprog_ids[i] = item->prog->aux->id;\n\t\tif (++i == request_cnt) {\n\t\t\titem++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn !!(item->prog);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nstatic bool bpf_prog_array_copy_core(struct bpf_prog_array __rcu *array,\n\t\t\t\t     u32 *prog_ids,\n\t\t\t\t     u32 request_cnt)\n{\n\tstruct bpf_prog_array_item *item;\n\tint i = 0;\n\n\titem = rcu_dereference_check(array, 1)->items;\n\tfor (; item->prog; item++) {\n\t\tif (item->prog == &dummy_bpf_prog.prog)\n\t\t\tcontinue;\n\t\tprog_ids[i] = item->prog->aux->id;\n\t\tif (++i == request_cnt) {\n\t\t\titem++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn !!(item->prog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "cnt",
            "sizeof(u32)",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_prog_array_copy_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1618-1637",
    "snippet": "static bool bpf_prog_array_copy_core(struct bpf_prog_array __rcu *array,\n\t\t\t\t     u32 *prog_ids,\n\t\t\t\t     u32 request_cnt)\n{\n\tstruct bpf_prog_array_item *item;\n\tint i = 0;\n\n\titem = rcu_dereference_check(array, 1)->items;\n\tfor (; item->prog; item++) {\n\t\tif (item->prog == &dummy_bpf_prog.prog)\n\t\t\tcontinue;\n\t\tprog_ids[i] = item->prog->aux->id;\n\t\tif (++i == request_cnt) {\n\t\t\titem++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn !!(item->prog);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "array",
            "1"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nstatic bool bpf_prog_array_copy_core(struct bpf_prog_array __rcu *array,\n\t\t\t\t     u32 *prog_ids,\n\t\t\t\t     u32 request_cnt)\n{\n\tstruct bpf_prog_array_item *item;\n\tint i = 0;\n\n\titem = rcu_dereference_check(array, 1)->items;\n\tfor (; item->prog; item++) {\n\t\tif (item->prog == &dummy_bpf_prog.prog)\n\t\t\tcontinue;\n\t\tprog_ids[i] = item->prog->aux->id;\n\t\tif (++i == request_cnt) {\n\t\t\titem++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn !!(item->prog);\n}"
  },
  {
    "function_name": "bpf_prog_array_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1603-1615",
    "snippet": "int bpf_prog_array_length(struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\trcu_read_lock();\n\titem = rcu_dereference(array)->items;\n\tfor (; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\trcu_read_unlock();\n\treturn cnt;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "array"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nint bpf_prog_array_length(struct bpf_prog_array __rcu *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\trcu_read_lock();\n\titem = rcu_dereference(array)->items;\n\tfor (; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\trcu_read_unlock();\n\treturn cnt;\n}"
  },
  {
    "function_name": "bpf_prog_array_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1595-1601",
    "snippet": "void bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "progs",
            "rcu"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array __rcu *progs)\n{\n\tif (!progs ||\n\t    progs == (struct bpf_prog_array __rcu *)&empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
  },
  {
    "function_name": "bpf_prog_array_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1584-1593",
    "snippet": "struct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1)",
            "flags"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nstruct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}"
  },
  {
    "function_name": "__bpf_prog_ret1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1557-1561",
    "snippet": "static unsigned int __bpf_prog_ret1(const void *ctx,\n\t\t\t\t    const struct bpf_insn *insn)\n{\n\treturn 1;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic unsigned int __bpf_prog_ret1(const void *ctx,\n\t\t\t\t    const struct bpf_insn *insn)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "bpf_prog_select_runtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1513-1554",
    "snippet": "struct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err)\n{\n\t/* In case of BPF to BPF calls, verifier did all the prep\n\t * work with regards to JITing, etc.\n\t */\n\tif (fp->bpf_func)\n\t\tgoto finalize;\n\n\tbpf_prog_select_func(fp);\n\n\t/* eBPF JITs can rewrite the program in case constant\n\t * blinding is active. However, in case of error during\n\t * blinding, bpf_int_jit_compile() must always return a\n\t * valid program, which in this case would simply not\n\t * be JITed, but falls back to the interpreter.\n\t */\n\tif (!bpf_prog_is_dev_bound(fp->aux)) {\n\t\tfp = bpf_int_jit_compile(fp);\n#ifdef CONFIG_BPF_JIT_ALWAYS_ON\n\t\tif (!fp->jited) {\n\t\t\t*err = -ENOTSUPP;\n\t\t\treturn fp;\n\t\t}\n#endif\n\t} else {\n\t\t*err = bpf_prog_offload_compile(fp);\n\t\tif (*err)\n\t\t\treturn fp;\n\t}\n\nfinalize:\n\tbpf_prog_lock_ro(fp);\n\n\t/* The tail call compatibility check can only be done at\n\t * this late stage as we need to determine, if we deal\n\t * with JITed or non JITed program concatenations and not\n\t * all eBPF JITs might immediately support all features.\n\t */\n\t*err = bpf_check_tail_call(fp);\n\n\treturn fp;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_check_tail_call",
          "args": [
            "fp"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_tail_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1474-1492",
          "snippet": "static int bpf_check_tail_call(const struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\tint i;\n\n\tfor (i = 0; i < aux->used_map_cnt; i++) {\n\t\tstruct bpf_map *map = aux->used_maps[i];\n\t\tstruct bpf_array *array;\n\n\t\tif (map->map_type != BPF_MAP_TYPE_PROG_ARRAY)\n\t\t\tcontinue;\n\n\t\tarray = container_of(map, struct bpf_array, map);\n\t\tif (!bpf_prog_array_compatible(array, fp))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_check_tail_call(const struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\tint i;\n\n\tfor (i = 0; i < aux->used_map_cnt; i++) {\n\t\tstruct bpf_map *map = aux->used_maps[i];\n\t\tstruct bpf_array *array;\n\n\t\tif (map->map_type != BPF_MAP_TYPE_PROG_ARRAY)\n\t\t\tcontinue;\n\n\t\tarray = container_of(map, struct bpf_array, map);\n\t\tif (!bpf_prog_array_compatible(array, fp))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_lock_ro",
          "args": [
            "fp"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_offload_compile",
          "args": [
            "fp"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_offload_compile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/offload.c",
          "lines": "242-247",
          "snippet": "int bpf_prog_offload_compile(struct bpf_prog *prog)\n{\n\tprog->bpf_func = bpf_prog_warn_on_exec;\n\n\treturn bpf_prog_offload_translate(prog);\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nint bpf_prog_offload_compile(struct bpf_prog *prog)\n{\n\tprog->bpf_func = bpf_prog_warn_on_exec;\n\n\treturn bpf_prog_offload_translate(prog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_int_jit_compile",
          "args": [
            "fp"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_int_jit_compile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1871-1874",
          "snippet": "struct bpf_prog * __weak bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\treturn prog;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\n\nstruct bpf_prog * __weak bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_is_dev_bound",
          "args": [
            "fp->aux"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_select_func",
          "args": [
            "fp"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_select_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1494-1503",
          "snippet": "static void bpf_prog_select_func(struct bpf_prog *fp)\n{\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tu32 stack_depth = max_t(u32, fp->aux->stack_depth, 1);\n\n\tfp->bpf_func = interpreters[(round_up(stack_depth, 32) / 32) - 1];\n#else\n\tfp->bpf_func = __bpf_prog_ret0_warn;\n#endif\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_prog_select_func(struct bpf_prog *fp)\n{\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tu32 stack_depth = max_t(u32, fp->aux->stack_depth, 1);\n\n\tfp->bpf_func = interpreters[(round_up(stack_depth, 32) / 32) - 1];\n#else\n\tfp->bpf_func = __bpf_prog_ret0_warn;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstruct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err)\n{\n\t/* In case of BPF to BPF calls, verifier did all the prep\n\t * work with regards to JITing, etc.\n\t */\n\tif (fp->bpf_func)\n\t\tgoto finalize;\n\n\tbpf_prog_select_func(fp);\n\n\t/* eBPF JITs can rewrite the program in case constant\n\t * blinding is active. However, in case of error during\n\t * blinding, bpf_int_jit_compile() must always return a\n\t * valid program, which in this case would simply not\n\t * be JITed, but falls back to the interpreter.\n\t */\n\tif (!bpf_prog_is_dev_bound(fp->aux)) {\n\t\tfp = bpf_int_jit_compile(fp);\n#ifdef CONFIG_BPF_JIT_ALWAYS_ON\n\t\tif (!fp->jited) {\n\t\t\t*err = -ENOTSUPP;\n\t\t\treturn fp;\n\t\t}\n#endif\n\t} else {\n\t\t*err = bpf_prog_offload_compile(fp);\n\t\tif (*err)\n\t\t\treturn fp;\n\t}\n\nfinalize:\n\tbpf_prog_lock_ro(fp);\n\n\t/* The tail call compatibility check can only be done at\n\t * this late stage as we need to determine, if we deal\n\t * with JITed or non JITed program concatenations and not\n\t * all eBPF JITs might immediately support all features.\n\t */\n\t*err = bpf_check_tail_call(fp);\n\n\treturn fp;\n}"
  },
  {
    "function_name": "bpf_prog_select_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1494-1503",
    "snippet": "static void bpf_prog_select_func(struct bpf_prog *fp)\n{\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tu32 stack_depth = max_t(u32, fp->aux->stack_depth, 1);\n\n\tfp->bpf_func = interpreters[(round_up(stack_depth, 32) / 32) - 1];\n#else\n\tfp->bpf_func = __bpf_prog_ret0_warn;\n#endif\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "stack_depth",
            "32"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u32",
            "fp->aux->stack_depth",
            "1"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1397-1431",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_prog_select_func(struct bpf_prog *fp)\n{\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tu32 stack_depth = max_t(u32, fp->aux->stack_depth, 1);\n\n\tfp->bpf_func = interpreters[(round_up(stack_depth, 32) / 32) - 1];\n#else\n\tfp->bpf_func = __bpf_prog_ret0_warn;\n#endif\n}"
  },
  {
    "function_name": "bpf_check_tail_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1474-1492",
    "snippet": "static int bpf_check_tail_call(const struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\tint i;\n\n\tfor (i = 0; i < aux->used_map_cnt; i++) {\n\t\tstruct bpf_map *map = aux->used_maps[i];\n\t\tstruct bpf_array *array;\n\n\t\tif (map->map_type != BPF_MAP_TYPE_PROG_ARRAY)\n\t\t\tcontinue;\n\n\t\tarray = container_of(map, struct bpf_array, map);\n\t\tif (!bpf_prog_array_compatible(array, fp))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_compatible",
          "args": [
            "array",
            "fp"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_compatible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1454-1472",
          "snippet": "bool bpf_prog_array_compatible(struct bpf_array *array,\n\t\t\t       const struct bpf_prog *fp)\n{\n\tif (fp->kprobe_override)\n\t\treturn false;\n\n\tif (!array->owner_prog_type) {\n\t\t/* There's no owner yet where we could check for\n\t\t * compatibility.\n\t\t */\n\t\tarray->owner_prog_type = fp->type;\n\t\tarray->owner_jited = fp->jited;\n\n\t\treturn true;\n\t}\n\n\treturn array->owner_prog_type == fp->type &&\n\t       array->owner_jited == fp->jited;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nbool bpf_prog_array_compatible(struct bpf_array *array,\n\t\t\t       const struct bpf_prog *fp)\n{\n\tif (fp->kprobe_override)\n\t\treturn false;\n\n\tif (!array->owner_prog_type) {\n\t\t/* There's no owner yet where we could check for\n\t\t * compatibility.\n\t\t */\n\t\tarray->owner_prog_type = fp->type;\n\t\tarray->owner_jited = fp->jited;\n\n\t\treturn true;\n\t}\n\n\treturn array->owner_prog_type == fp->type &&\n\t       array->owner_jited == fp->jited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_check_tail_call(const struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\tint i;\n\n\tfor (i = 0; i < aux->used_map_cnt; i++) {\n\t\tstruct bpf_map *map = aux->used_maps[i];\n\t\tstruct bpf_array *array;\n\n\t\tif (map->map_type != BPF_MAP_TYPE_PROG_ARRAY)\n\t\t\tcontinue;\n\n\t\tarray = container_of(map, struct bpf_array, map);\n\t\tif (!bpf_prog_array_compatible(array, fp))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_prog_array_compatible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1454-1472",
    "snippet": "bool bpf_prog_array_compatible(struct bpf_array *array,\n\t\t\t       const struct bpf_prog *fp)\n{\n\tif (fp->kprobe_override)\n\t\treturn false;\n\n\tif (!array->owner_prog_type) {\n\t\t/* There's no owner yet where we could check for\n\t\t * compatibility.\n\t\t */\n\t\tarray->owner_prog_type = fp->type;\n\t\tarray->owner_jited = fp->jited;\n\n\t\treturn true;\n\t}\n\n\treturn array->owner_prog_type == fp->type &&\n\t       array->owner_jited == fp->jited;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nbool bpf_prog_array_compatible(struct bpf_array *array,\n\t\t\t       const struct bpf_prog *fp)\n{\n\tif (fp->kprobe_override)\n\t\treturn false;\n\n\tif (!array->owner_prog_type) {\n\t\t/* There's no owner yet where we could check for\n\t\t * compatibility.\n\t\t */\n\t\tarray->owner_prog_type = fp->type;\n\t\tarray->owner_jited = fp->jited;\n\n\t\treturn true;\n\t}\n\n\treturn array->owner_prog_type == fp->type &&\n\t       array->owner_jited == fp->jited;\n}"
  },
  {
    "function_name": "__bpf_prog_ret0_warn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1443-1451",
    "snippet": "static unsigned int __bpf_prog_ret0_warn(const void *ctx,\n\t\t\t\t\t const struct bpf_insn *insn)\n{\n\t/* If this handler ever gets executed, then BPF_JIT_ALWAYS_ON\n\t * is not working properly, so warn about it!\n\t */\n\tWARN_ON_ONCE(1);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic unsigned int __bpf_prog_ret0_warn(const void *ctx,\n\t\t\t\t\t const struct bpf_insn *insn)\n{\n\t/* If this handler ever gets executed, then BPF_JIT_ALWAYS_ON\n\t * is not working properly, so warn about it!\n\t */\n\tWARN_ON_ONCE(1);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_patch_call_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1433-1440",
    "snippet": "void bpf_patch_call_args(struct bpf_insn *insn, u32 stack_depth)\n{\n\tstack_depth = max_t(u32, stack_depth, 1);\n\tinsn->off = (s16) insn->imm;\n\tinsn->imm = interpreters_args[(round_up(stack_depth, 32) / 32) - 1] -\n\t\t__bpf_call_base_args;\n\tinsn->code = BPF_JMP | BPF_CALL_ARGS;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "stack_depth",
            "32"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u32",
            "stack_depth",
            "1"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1397-1431",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_patch_call_args(struct bpf_insn *insn, u32 stack_depth)\n{\n\tstack_depth = max_t(u32, stack_depth, 1);\n\tinsn->off = (s16) insn->imm;\n\tinsn->imm = interpreters_args[(round_up(stack_depth, 32) / 32) - 1] -\n\t\t__bpf_call_base_args;\n\tinsn->code = BPF_JMP | BPF_CALL_ARGS;\n}"
  },
  {
    "function_name": "___bpf_prog_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "1015-1368",
    "snippet": "static u64 ___bpf_prog_run(u64 *regs, const struct bpf_insn *insn, u64 *stack)\n{\n\tu64 tmp;\n#define BPF_INSN_2_LBL(x, y)    [BPF_##x | BPF_##y] = &&x##_##y\n#define BPF_INSN_3_LBL(x, y, z) [BPF_##x | BPF_##y | BPF_##z] = &&x##_##y##_##z\n\tstatic const void *jumptable[256] = {\n\t\t[0 ... 255] = &&default_label,\n\t\t/* Now overwrite non-defaults ... */\n\t\tBPF_INSN_MAP(BPF_INSN_2_LBL, BPF_INSN_3_LBL),\n\t\t/* Non-UAPI available opcodes. */\n\t\t[BPF_JMP | BPF_CALL_ARGS] = &&JMP_CALL_ARGS,\n\t\t[BPF_JMP | BPF_TAIL_CALL] = &&JMP_TAIL_CALL,\n\t};\n#undef BPF_INSN_3_LBL\n#undef BPF_INSN_2_LBL\n\tu32 tail_call_cnt = 0;\n\n#define CONT\t ({ insn++; goto select_insn; })\n#define CONT_JMP ({ insn++; goto select_insn; })\n\nselect_insn:\n\tgoto *jumptable[insn->code];\n\n\t/* ALU */\n#define ALU(OPCODE, OP)\t\t\t\\\n\tALU64_##OPCODE##_X:\t\t\\\n\t\tDST = DST OP SRC;\t\\\n\t\tCONT;\t\t\t\\\n\tALU_##OPCODE##_X:\t\t\\\n\t\tDST = (u32) DST OP (u32) SRC;\t\\\n\t\tCONT;\t\t\t\\\n\tALU64_##OPCODE##_K:\t\t\\\n\t\tDST = DST OP IMM;\t\t\\\n\t\tCONT;\t\t\t\\\n\tALU_##OPCODE##_K:\t\t\\\n\t\tDST = (u32) DST OP (u32) IMM;\t\\\n\t\tCONT;\n\n\tALU(ADD,  +)\n\tALU(SUB,  -)\n\tALU(AND,  &)\n\tALU(OR,   |)\n\tALU(LSH, <<)\n\tALU(RSH, >>)\n\tALU(XOR,  ^)\n\tALU(MUL,  *)\n#undef ALU\n\tALU_NEG:\n\t\tDST = (u32) -DST;\n\t\tCONT;\n\tALU64_NEG:\n\t\tDST = -DST;\n\t\tCONT;\n\tALU_MOV_X:\n\t\tDST = (u32) SRC;\n\t\tCONT;\n\tALU_MOV_K:\n\t\tDST = (u32) IMM;\n\t\tCONT;\n\tALU64_MOV_X:\n\t\tDST = SRC;\n\t\tCONT;\n\tALU64_MOV_K:\n\t\tDST = IMM;\n\t\tCONT;\n\tLD_IMM_DW:\n\t\tDST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;\n\t\tinsn++;\n\t\tCONT;\n\tALU64_ARSH_X:\n\t\t(*(s64 *) &DST) >>= SRC;\n\t\tCONT;\n\tALU64_ARSH_K:\n\t\t(*(s64 *) &DST) >>= IMM;\n\t\tCONT;\n\tALU64_MOD_X:\n\t\tdiv64_u64_rem(DST, SRC, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_X:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) SRC);\n\t\tCONT;\n\tALU64_MOD_K:\n\t\tdiv64_u64_rem(DST, IMM, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_K:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) IMM);\n\t\tCONT;\n\tALU64_DIV_X:\n\t\tDST = div64_u64(DST, SRC);\n\t\tCONT;\n\tALU_DIV_X:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) SRC);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU64_DIV_K:\n\t\tDST = div64_u64(DST, IMM);\n\t\tCONT;\n\tALU_DIV_K:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) IMM);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU_END_TO_BE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_be16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_be32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_be64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tALU_END_TO_LE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_le16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_le32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_le64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\n\t/* CALL */\n\tJMP_CALL:\n\t\t/* Function call scratches BPF_R1-BPF_R5 registers,\n\t\t * preserves BPF_R6-BPF_R9, and stores return value\n\t\t * into BPF_R0.\n\t\t */\n\t\tBPF_R0 = (__bpf_call_base + insn->imm)(BPF_R1, BPF_R2, BPF_R3,\n\t\t\t\t\t\t       BPF_R4, BPF_R5);\n\t\tCONT;\n\n\tJMP_CALL_ARGS:\n\t\tBPF_R0 = (__bpf_call_base_args + insn->imm)(BPF_R1, BPF_R2,\n\t\t\t\t\t\t\t    BPF_R3, BPF_R4,\n\t\t\t\t\t\t\t    BPF_R5,\n\t\t\t\t\t\t\t    insn + insn->off + 1);\n\t\tCONT;\n\n\tJMP_TAIL_CALL: {\n\t\tstruct bpf_map *map = (struct bpf_map *) (unsigned long) BPF_R2;\n\t\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\t\tstruct bpf_prog *prog;\n\t\tu32 index = BPF_R3;\n\n\t\tif (unlikely(index >= array->map.max_entries))\n\t\t\tgoto out;\n\t\tif (unlikely(tail_call_cnt > MAX_TAIL_CALL_CNT))\n\t\t\tgoto out;\n\n\t\ttail_call_cnt++;\n\n\t\tprog = READ_ONCE(array->ptrs[index]);\n\t\tif (!prog)\n\t\t\tgoto out;\n\n\t\t/* ARG1 at this point is guaranteed to point to CTX from\n\t\t * the verifier side due to the fact that the tail call is\n\t\t * handeled like a helper, that is, bpf_tail_call_proto,\n\t\t * where arg1_type is ARG_PTR_TO_CTX.\n\t\t */\n\t\tinsn = prog->insnsi;\n\t\tgoto select_insn;\nout:\n\t\tCONT;\n\t}\n\t/* JMP */\n\tJMP_JA:\n\t\tinsn += insn->off;\n\t\tCONT;\n\tJMP_JEQ_X:\n\t\tif (DST == SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JEQ_K:\n\t\tif (DST == IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JNE_X:\n\t\tif (DST != SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JNE_K:\n\t\tif (DST != IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGT_X:\n\t\tif (DST > SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGT_K:\n\t\tif (DST > IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLT_X:\n\t\tif (DST < SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLT_K:\n\t\tif (DST < IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGE_X:\n\t\tif (DST >= SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGE_K:\n\t\tif (DST >= IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLE_X:\n\t\tif (DST <= SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLE_K:\n\t\tif (DST <= IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGT_X:\n\t\tif (((s64) DST) > ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGT_K:\n\t\tif (((s64) DST) > ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLT_X:\n\t\tif (((s64) DST) < ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLT_K:\n\t\tif (((s64) DST) < ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGE_X:\n\t\tif (((s64) DST) >= ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGE_K:\n\t\tif (((s64) DST) >= ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLE_X:\n\t\tif (((s64) DST) <= ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLE_K:\n\t\tif (((s64) DST) <= ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSET_X:\n\t\tif (DST & SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSET_K:\n\t\tif (DST & IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_EXIT:\n\t\treturn BPF_R0;\n\n\t/* STX and ST and LDX*/\n#define LDST(SIZEOP, SIZE)\t\t\t\t\t\t\\\n\tSTX_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (DST + insn->off) = SRC;\t\\\n\t\tCONT;\t\t\t\t\t\t\t\\\n\tST_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (DST + insn->off) = IMM;\t\\\n\t\tCONT;\t\t\t\t\t\t\t\\\n\tLDX_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\tDST = *(SIZE *)(unsigned long) (SRC + insn->off);\t\\\n\t\tCONT;\n\n\tLDST(B,   u8)\n\tLDST(H,  u16)\n\tLDST(W,  u32)\n\tLDST(DW, u64)\n#undef LDST\n\tSTX_XADD_W: /* lock xadd *(u32 *)(dst_reg + off16) += src_reg */\n\t\tatomic_add((u32) SRC, (atomic_t *)(unsigned long)\n\t\t\t   (DST + insn->off));\n\t\tCONT;\n\tSTX_XADD_DW: /* lock xadd *(u64 *)(dst_reg + off16) += src_reg */\n\t\tatomic64_add((u64) SRC, (atomic64_t *)(unsigned long)\n\t\t\t     (DST + insn->off));\n\t\tCONT;\n\n\tdefault_label:\n\t\t/* If we ever reach this, we have a bug somewhere. Die hard here\n\t\t * instead of just returning 0; we could be somewhere in a subprog,\n\t\t * so execution could continue otherwise which we do /not/ want.\n\t\t *\n\t\t * Note, verifier whitelists all opcodes in bpf_opcode_in_insntable().\n\t\t */\n\t\tpr_warn(\"BPF interpreter: unknown opcode %02x\\n\", insn->code);\n\t\tBUG_ON(1);\n\t\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [
      "#define CONT_JMP ({ insn++; goto select_insn; })",
      "#define CONT\t ({ insn++; goto select_insn; })",
      "#define IMM\tinsn->imm",
      "#define CTX\tregs[BPF_REG_CTX]",
      "#define ARG1\tregs[BPF_REG_ARG1]",
      "#define SRC\tregs[insn->src_reg]",
      "#define DST\tregs[insn->dst_reg]",
      "#define BPF_R9\tregs[BPF_REG_9]",
      "#define BPF_R6\tregs[BPF_REG_6]",
      "#define BPF_R5\tregs[BPF_REG_5]",
      "#define BPF_R4\tregs[BPF_REG_4]",
      "#define BPF_R3\tregs[BPF_REG_3]",
      "#define BPF_R2\tregs[BPF_REG_2]",
      "#define BPF_R1\tregs[BPF_REG_1]",
      "#define BPF_R0\tregs[BPF_REG_0]"
    ],
    "globals_used": [
      "const struct bpf_func_proto bpf_tail_call_proto = {\n\t.func\t\t= NULL,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"BPF interpreter: unknown opcode %02x\\n\"",
            "insn->code"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "(u64) SRC",
            "(atomic64_t *)(unsigned long)\n\t\t\t     (DST + insn->off)"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "(u32) SRC",
            "(atomic_t *)(unsigned long)\n\t\t\t   (DST + insn->off)"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LDST",
          "args": [
            "DW",
            "u64"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LDST",
          "args": [
            "W",
            "u32"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LDST",
          "args": [
            "H",
            "u16"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LDST",
          "args": [
            "B",
            "u8"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU",
          "args": [
            "OR",
            "|)ALU(LSH, <<)\n\tALU(RSH, >>)\n\tALU(XOR,  ^)\n\tALU(MUL,  *)\n#undef ALU\n\tALU_NEG:\n\t\tDST = (u32) -DST;\n\t\tCONT;\n\tALU64_NEG:\n\t\tDST = -DST;\n\t\tCONT;\n\tALU_MOV_X:\n\t\tDST = (u32) SRC;\n\t\tCONT;\n\tALU_MOV_K:\n\t\tDST = (u32) IMM;\n\t\tCONT;\n\tALU64_MOV_X:\n\t\tDST = SRC;\n\t\tCONT;\n\tALU64_MOV_K:\n\t\tDST = IMM;\n\t\tCONT;\n\tLD_IMM_DW:\n\t\tDST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;\n\t\tinsn++;\n\t\tCONT;\n\tALU64_ARSH_X:\n\t\t(*(s64 *) &DST) >>= SRC;\n\t\tCONT;\n\tALU64_ARSH_K:\n\t\t(*(s64 *) &DST) >>= IMM;\n\t\tCONT;\n\tALU64_MOD_X:\n\t\tdiv64_u64_rem(DST, SRC, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_X:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) SRC);\n\t\tCONT;\n\tALU64_MOD_K:\n\t\tdiv64_u64_rem(DST, IMM, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_K:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) IMM);\n\t\tCONT;\n\tALU64_DIV_X:\n\t\tDST = div64_u64(DST, SRC);\n\t\tCONT;\n\tALU_DIV_X:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) SRC);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU64_DIV_K:\n\t\tDST = div64_u64(DST, IMM);\n\t\tCONT;\n\tALU_DIV_K:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) IMM);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU_END_TO_BE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_be16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_be32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_be64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tALU_END_TO_LE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_le16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_le32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_le64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\n\t/* CALL */\n\tJMP_CALL:\n\t\t/* Function call scratches BPF_R1-BPF_R5 registers,\n\t\t * preserves BPF_R6-BPF_R9, and stores return value\n\t\t * into BPF_R0.\n\t\t */\n\t\tBPF_R0 = (__bpf_call_base + insn->imm)(BPF_R1, BPF_R2, BPF_R3,\n\t\t\t\t\t\t       BPF_R4, BPF_R5);\n\t\tCONT;\n\n\tJMP_CALL_ARGS:\n\t\tBPF_R0 = (__bpf_call_base_args + insn->imm)(BPF_R1, BPF_R2,\n\t\t\t\t\t\t\t    BPF_R3, BPF_R4,\n\t\t\t\t\t\t\t    BPF_R5,\n\t\t\t\t\t\t\t    insn + insn->off + 1);\n\t\tCONT;\n\n\tJMP_TAIL_CALL: {\n\t\tstruct bpf_map *map = (struct bpf_map *) (unsigned long) BPF_R2;\n\t\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\t\tstruct bpf_prog *prog;\n\t\tu32 index = BPF_R3;\n\n\t\tif (unlikely(index >= array->map.max_entries))\n\t\t\tgoto out;\n\t\tif (unlikely(tail_call_cnt > MAX_TAIL_CALL_CNT))\n\t\t\tgoto out;\n\n\t\ttail_call_cnt++;\n\n\t\tprog = READ_ONCE(array->ptrs[index]);\n\t\tif (!prog)\n\t\t\tgoto out;\n\n\t\t/* ARG1 at this point is guaranteed to point to CTX from\n\t\t * the verifier side due to the fact that the tail call is\n\t\t * handeled like a helper, that is, bpf_tail_call_proto,\n\t\t * where arg1_type is ARG_PTR_TO_CTX.\n\t\t */\n\t\tinsn = prog->insnsi;\n\t\tgoto select_insn;\nout:\n\t\tCONT;\n\t}\n\t/* JMP */\n\tJMP_JA:\n\t\tinsn += insn->off;\n\t\tCONT;\n\tJMP_JEQ_X:\n\t\tif (DST == SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JEQ_K:\n\t\tif (DST == IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JNE_X:\n\t\tif (DST != SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JNE_K:\n\t\tif (DST != IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGT_X:\n\t\tif (DST > SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGT_K:\n\t\tif (DST > IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLT_X:\n\t\tif (DST < SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLT_K:\n\t\tif (DST < IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGE_X:\n\t\tif (DST >= SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGE_K:\n\t\tif (DST >= IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLE_X:\n\t\tif (DST <= SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLE_K:\n\t\tif (DST <= IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGT_X:\n\t\tif (((s64) DST) > ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGT_K:\n\t\tif (((s64) DST) > ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLT_X:\n\t\tif (((s64) DST) < ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLT_K:\n\t\tif (((s64) DST) < ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGE_X:\n\t\tif (((s64) DST) >= ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGE_K:\n\t\tif (((s64) DST) >= ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLE_X:\n\t\tif (((s64) DST) <= ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLE_K:\n\t\tif (((s64) DST) <= ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSET_X:\n\t\tif (DST & SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSET_K:\n\t\tif (DST & IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_EXIT:\n\t\treturn BPF_R0;\n\n\t/* STX and ST and LDX*/\n#define LDST(SIZEOP",
            "SIZE"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSET_K:\n\t\tif",
          "args": [
            "DST & IMM"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSET_X:\n\t\tif",
          "args": [
            "DST & SRC"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLE_K:\n\t\tif",
          "args": [
            "((s64) DST) <= ((s64) IMM)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLE_X:\n\t\tif",
          "args": [
            "((s64) DST) <= ((s64) SRC)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGE_K:\n\t\tif",
          "args": [
            "((s64) DST) >= ((s64) IMM)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGE_X:\n\t\tif",
          "args": [
            "((s64) DST) >= ((s64) SRC)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLT_K:\n\t\tif",
          "args": [
            "((s64) DST) < ((s64) IMM)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLT_X:\n\t\tif",
          "args": [
            "((s64) DST) < ((s64) SRC)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGT_K:\n\t\tif",
          "args": [
            "((s64) DST) > ((s64) IMM)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGT_X:\n\t\tif",
          "args": [
            "((s64) DST) > ((s64) SRC)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLE_K:\n\t\tif",
          "args": [
            "DST <= IMM"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLE_X:\n\t\tif",
          "args": [
            "DST <= SRC"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGE_K:\n\t\tif",
          "args": [
            "DST >= IMM"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGE_X:\n\t\tif",
          "args": [
            "DST >= SRC"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLT_K:\n\t\tif",
          "args": [
            "DST < IMM"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLT_X:\n\t\tif",
          "args": [
            "DST < SRC"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGT_K:\n\t\tif",
          "args": [
            "DST > IMM"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGT_X:\n\t\tif",
          "args": [
            "DST > SRC"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JNE_K:\n\t\tif",
          "args": [
            "DST != IMM"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JNE_X:\n\t\tif",
          "args": [
            "DST != SRC"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JEQ_K:\n\t\tif",
          "args": [
            "DST == IMM"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU",
          "args": [
            "DST == SRC"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\tif",
          "args": [
            "!prog"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU",
          "args": [
            "LSH",
            "<<)ALU(RSH, >>)\n\tALU(XOR,  ^)\n\tALU(MUL,  *)\n#undef ALU\n\tALU_NEG:\n\t\tDST = (u32) -DST;\n\t\tCONT;\n\tALU64_NEG:\n\t\tDST = -DST;\n\t\tCONT;\n\tALU_MOV_X:\n\t\tDST = (u32) SRC;\n\t\tCONT;\n\tALU_MOV_K:\n\t\tDST = (u32) IMM;\n\t\tCONT;\n\tALU64_MOV_X:\n\t\tDST = SRC;\n\t\tCONT;\n\tALU64_MOV_K:\n\t\tDST = IMM;\n\t\tCONT;\n\tLD_IMM_DW:\n\t\tDST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;\n\t\tinsn++;\n\t\tCONT;\n\tALU64_ARSH_X:\n\t\t(*(s64 *) &DST) >>= SRC;\n\t\tCONT;\n\tALU64_ARSH_K:\n\t\t(*(s64 *) &DST) >>= IMM;\n\t\tCONT;\n\tALU64_MOD_X:\n\t\tdiv64_u64_rem(DST, SRC, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_X:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) SRC);\n\t\tCONT;\n\tALU64_MOD_K:\n\t\tdiv64_u64_rem(DST, IMM, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_K:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) IMM);\n\t\tCONT;\n\tALU64_DIV_X:\n\t\tDST = div64_u64(DST, SRC);\n\t\tCONT;\n\tALU_DIV_X:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) SRC);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU64_DIV_K:\n\t\tDST = div64_u64(DST, IMM);\n\t\tCONT;\n\tALU_DIV_K:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) IMM);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU_END_TO_BE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_be16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_be32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_be64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tALU_END_TO_LE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_le16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_le32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_le64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\n\t/* CALL */\n\tJMP_CALL:\n\t\t/* Function call scratches BPF_R1-BPF_R5 registers,\n\t\t * preserves BPF_R6-BPF_R9, and stores return value\n\t\t * into BPF_R0.\n\t\t */\n\t\tBPF_R0 = (__bpf_call_base + insn->imm)(BPF_R1, BPF_R2, BPF_R3,\n\t\t\t\t\t\t       BPF_R4, BPF_R5);\n\t\tCONT;\n\n\tJMP_CALL_ARGS:\n\t\tBPF_R0 = (__bpf_call_base_args + insn->imm)(BPF_R1, BPF_R2,\n\t\t\t\t\t\t\t    BPF_R3, BPF_R4,\n\t\t\t\t\t\t\t    BPF_R5,\n\t\t\t\t\t\t\t    insn + insn->off + 1);\n\t\tCONT;\n\n\tJMP_TAIL_CALL: {\n\t\tstruct bpf_map *map = (struct bpf_map *) (unsigned long) BPF_R2;\n\t\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\t\tstruct bpf_prog *prog;\n\t\tu32 index = BPF_R3;\n\n\t\tif (unlikely(index >= array->map.max_entries))\n\t\t\tgoto out;\n\t\tif (unlikely(tail_call_cnt > MAX_TAIL_CALL_CNT))\n\t\t\tgoto out;\n\n\t\ttail_call_cnt++;\n\n\t\tprog = READ_ONCE(array->ptrs[index]"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto out;\n\t\tif",
          "args": [
            "unlikely(tail_call_cnt > MAX_TAIL_CALL_CNT)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tail_call_cnt > MAX_TAIL_CALL_CNT"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\tu32 index = BPF_R3;\n\n\t\tif",
          "args": [
            "unlikely(index >= array->map.max_entries)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= array->map.max_entries"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU",
          "args": [
            "BPF_R1",
            "BPF_R2",
            "BPF_R3",
            "BPF_R4",
            "BPF_R5",
            "insn + insn->off + 1"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\tCONT;\n\n\tJMP_CALL_ARGS:\n\t\tBPF_R0 =",
          "args": [
            "__bpf_call_base_args + insn->imm"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU",
          "args": [
            "BPF_R1",
            "BPF_R2",
            "BPF_R3",
            "BPF_R4",
            "BPF_R5"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\n\t/* CALL */\n\tJMP_CALL:\n\t\t/* Function call scratches BPF_R1-BPF_R5 registers,\n\t\t * preserves BPF_R6-BPF_R9, and stores return value\n\t\t * into BPF_R0.\n\t\t */\n\t\tBPF_R0 =",
          "args": [
            "__bpf_call_base + insn->imm"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU",
          "args": [
            "RSH",
            ">>)ALU(XOR,  ^)\n\tALU(MUL,  *)\n#undef ALU\n\tALU_NEG:\n\t\tDST = (u32) -DST;\n\t\tCONT;\n\tALU64_NEG:\n\t\tDST = -DST;\n\t\tCONT;\n\tALU_MOV_X:\n\t\tDST = (u32) SRC;\n\t\tCONT;\n\tALU_MOV_K:\n\t\tDST = (u32) IMM;\n\t\tCONT;\n\tALU64_MOV_X:\n\t\tDST = SRC;\n\t\tCONT;\n\tALU64_MOV_K:\n\t\tDST = IMM;\n\t\tCONT;\n\tLD_IMM_DW:\n\t\tDST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;\n\t\tinsn++;\n\t\tCONT;\n\tALU64_ARSH_X:\n\t\t(*(s64 *) &DST) >>= SRC;\n\t\tCONT;\n\tALU64_ARSH_K:\n\t\t(*(s64 *) &DST) >>= IMM;\n\t\tCONT;\n\tALU64_MOD_X:\n\t\tdiv64_u64_rem(DST, SRC, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_X:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) SRC);\n\t\tCONT;\n\tALU64_MOD_K:\n\t\tdiv64_u64_rem(DST, IMM, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_K:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) IMM);\n\t\tCONT;\n\tALU64_DIV_X:\n\t\tDST = div64_u64(DST, SRC);\n\t\tCONT;\n\tALU_DIV_X:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) SRC);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU64_DIV_K:\n\t\tDST = div64_u64(DST, IMM);\n\t\tCONT;\n\tALU_DIV_K:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) IMM);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU_END_TO_BE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_be16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_be32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_be64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tALU_END_TO_LE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_le16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_le32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64)cpu_to_le64(DST"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST =",
          "args": [
            "__forceu64"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU",
          "args": [
            "XOR",
            "^)ALU(MUL,  *)\n#undef ALU\n\tALU_NEG:\n\t\tDST = (u32) -DST;\n\t\tCONT;\n\tALU64_NEG:\n\t\tDST = -DST;\n\t\tCONT;\n\tALU_MOV_X:\n\t\tDST = (u32) SRC;\n\t\tCONT;\n\tALU_MOV_K:\n\t\tDST = (u32) IMM;\n\t\tCONT;\n\tALU64_MOV_X:\n\t\tDST = SRC;\n\t\tCONT;\n\tALU64_MOV_K:\n\t\tDST = IMM;\n\t\tCONT;\n\tLD_IMM_DW:\n\t\tDST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;\n\t\tinsn++;\n\t\tCONT;\n\tALU64_ARSH_X:\n\t\t(*(s64 *) &DST) >>= SRC;\n\t\tCONT;\n\tALU64_ARSH_K:\n\t\t(*(s64 *) &DST) >>= IMM;\n\t\tCONT;\n\tALU64_MOD_X:\n\t\tdiv64_u64_rem(DST, SRC, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_X:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) SRC);\n\t\tCONT;\n\tALU64_MOD_K:\n\t\tdiv64_u64_rem(DST, IMM, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_K:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) IMM);\n\t\tCONT;\n\tALU64_DIV_X:\n\t\tDST = div64_u64(DST, SRC);\n\t\tCONT;\n\tALU_DIV_X:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) SRC);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU64_DIV_K:\n\t\tDST = div64_u64(DST, IMM);\n\t\tCONT;\n\tALU_DIV_K:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) IMM);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU_END_TO_BE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_be16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_be32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_be64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tALU_END_TO_LE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_le16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32)cpu_to_le32(DST"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST =",
          "args": [
            "__forceu32"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "DST"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU",
          "args": [
            "MUL",
            "*)\n#undef ALU\n\tALU_NEG:\n\t\tDST = (u32) -DST;\n\t\tCONT;\n\tALU64_NEG:\n\t\tDST = -DST;\n\t\tCONT;\n\tALU_MOV_X:\n\t\tDST = (u32) SRC;\n\t\tCONT;\n\tALU_MOV_K:\n\t\tDST = (u32) IMM;\n\t\tCONT;\n\tALU64_MOV_X:\n\t\tDST = SRC;\n\t\tCONT;\n\tALU64_MOV_K:\n\t\tDST = IMM;\n\t\tCONT;\n\tLD_IMM_DW:\n\t\tDST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;\n\t\tinsn++;\n\t\tCONT;\n\tALU64_ARSH_X:\n\t\t(*(s64 *) &DST) >>= SRC;\n\t\tCONT;\n\tALU64_ARSH_K:\n\t\t(*(s64 *) &DST) >>= IMM;\n\t\tCONT;\n\tALU64_MOD_X:\n\t\tdiv64_u64_rem(DST, SRC, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_X:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) SRC);\n\t\tCONT;\n\tALU64_MOD_K:\n\t\tdiv64_u64_rem(DST, IMM, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_K:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) IMM);\n\t\tCONT;\n\tALU64_DIV_X:\n\t\tDST = div64_u64(DST, SRC);\n\t\tCONT;\n\tALU_DIV_X:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) SRC);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU64_DIV_K:\n\t\tDST = div64_u64(DST, IMM);\n\t\tCONT;\n\tALU_DIV_K:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) IMM);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU_END_TO_BE:\n\t\tswitch (IMM){\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_be16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_be32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_be64(DST);\n\t\t\tbreak;\n\t\t}CONT;\n\tALU_END_TO_LE:\n\t\tswitch (IMM"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "DST"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "DST"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "DST"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU_END_TO_BE",
          "args": [
            "IMM"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "(u32) IMM"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "DST",
            "IMM"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "(u32) SRC"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "DST",
            "SRC"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "(u32) IMM"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64_rem",
          "args": [
            "DST",
            "IMM",
            "&tmp"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "(u32) SRC"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64_rem",
          "args": [
            "DST",
            "SRC",
            "&tmp"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU64_ARSH_K",
          "args": [
            "*(s64 *) &DST"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALU64_ARSH_X",
          "args": [
            "*(s64 *) &DST"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_INSN_MAP",
          "args": [
            "BPF_INSN_2_LBL",
            "BPF_INSN_3_LBL"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\n#define CONT_JMP ({ insn++; goto select_insn; })\n#define CONT\t ({ insn++; goto select_insn; })\n#define IMM\tinsn->imm\n#define CTX\tregs[BPF_REG_CTX]\n#define ARG1\tregs[BPF_REG_ARG1]\n#define SRC\tregs[insn->src_reg]\n#define DST\tregs[insn->dst_reg]\n#define BPF_R9\tregs[BPF_REG_9]\n#define BPF_R6\tregs[BPF_REG_6]\n#define BPF_R5\tregs[BPF_REG_5]\n#define BPF_R4\tregs[BPF_REG_4]\n#define BPF_R3\tregs[BPF_REG_3]\n#define BPF_R2\tregs[BPF_REG_2]\n#define BPF_R1\tregs[BPF_REG_1]\n#define BPF_R0\tregs[BPF_REG_0]\n\nconst struct bpf_func_proto bpf_tail_call_proto = {\n\t.func\t\t= NULL,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};\n\nstatic u64 ___bpf_prog_run(u64 *regs, const struct bpf_insn *insn, u64 *stack)\n{\n\tu64 tmp;\n#define BPF_INSN_2_LBL(x, y)    [BPF_##x | BPF_##y] = &&x##_##y\n#define BPF_INSN_3_LBL(x, y, z) [BPF_##x | BPF_##y | BPF_##z] = &&x##_##y##_##z\n\tstatic const void *jumptable[256] = {\n\t\t[0 ... 255] = &&default_label,\n\t\t/* Now overwrite non-defaults ... */\n\t\tBPF_INSN_MAP(BPF_INSN_2_LBL, BPF_INSN_3_LBL),\n\t\t/* Non-UAPI available opcodes. */\n\t\t[BPF_JMP | BPF_CALL_ARGS] = &&JMP_CALL_ARGS,\n\t\t[BPF_JMP | BPF_TAIL_CALL] = &&JMP_TAIL_CALL,\n\t};\n#undef BPF_INSN_3_LBL\n#undef BPF_INSN_2_LBL\n\tu32 tail_call_cnt = 0;\n\n#define CONT\t ({ insn++; goto select_insn; })\n#define CONT_JMP ({ insn++; goto select_insn; })\n\nselect_insn:\n\tgoto *jumptable[insn->code];\n\n\t/* ALU */\n#define ALU(OPCODE, OP)\t\t\t\\\n\tALU64_##OPCODE##_X:\t\t\\\n\t\tDST = DST OP SRC;\t\\\n\t\tCONT;\t\t\t\\\n\tALU_##OPCODE##_X:\t\t\\\n\t\tDST = (u32) DST OP (u32) SRC;\t\\\n\t\tCONT;\t\t\t\\\n\tALU64_##OPCODE##_K:\t\t\\\n\t\tDST = DST OP IMM;\t\t\\\n\t\tCONT;\t\t\t\\\n\tALU_##OPCODE##_K:\t\t\\\n\t\tDST = (u32) DST OP (u32) IMM;\t\\\n\t\tCONT;\n\n\tALU(ADD,  +)\n\tALU(SUB,  -)\n\tALU(AND,  &)\n\tALU(OR,   |)\n\tALU(LSH, <<)\n\tALU(RSH, >>)\n\tALU(XOR,  ^)\n\tALU(MUL,  *)\n#undef ALU\n\tALU_NEG:\n\t\tDST = (u32) -DST;\n\t\tCONT;\n\tALU64_NEG:\n\t\tDST = -DST;\n\t\tCONT;\n\tALU_MOV_X:\n\t\tDST = (u32) SRC;\n\t\tCONT;\n\tALU_MOV_K:\n\t\tDST = (u32) IMM;\n\t\tCONT;\n\tALU64_MOV_X:\n\t\tDST = SRC;\n\t\tCONT;\n\tALU64_MOV_K:\n\t\tDST = IMM;\n\t\tCONT;\n\tLD_IMM_DW:\n\t\tDST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;\n\t\tinsn++;\n\t\tCONT;\n\tALU64_ARSH_X:\n\t\t(*(s64 *) &DST) >>= SRC;\n\t\tCONT;\n\tALU64_ARSH_K:\n\t\t(*(s64 *) &DST) >>= IMM;\n\t\tCONT;\n\tALU64_MOD_X:\n\t\tdiv64_u64_rem(DST, SRC, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_X:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) SRC);\n\t\tCONT;\n\tALU64_MOD_K:\n\t\tdiv64_u64_rem(DST, IMM, &tmp);\n\t\tDST = tmp;\n\t\tCONT;\n\tALU_MOD_K:\n\t\ttmp = (u32) DST;\n\t\tDST = do_div(tmp, (u32) IMM);\n\t\tCONT;\n\tALU64_DIV_X:\n\t\tDST = div64_u64(DST, SRC);\n\t\tCONT;\n\tALU_DIV_X:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) SRC);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU64_DIV_K:\n\t\tDST = div64_u64(DST, IMM);\n\t\tCONT;\n\tALU_DIV_K:\n\t\ttmp = (u32) DST;\n\t\tdo_div(tmp, (u32) IMM);\n\t\tDST = (u32) tmp;\n\t\tCONT;\n\tALU_END_TO_BE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_be16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_be32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_be64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tALU_END_TO_LE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_le16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_le32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_le64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\n\t/* CALL */\n\tJMP_CALL:\n\t\t/* Function call scratches BPF_R1-BPF_R5 registers,\n\t\t * preserves BPF_R6-BPF_R9, and stores return value\n\t\t * into BPF_R0.\n\t\t */\n\t\tBPF_R0 = (__bpf_call_base + insn->imm)(BPF_R1, BPF_R2, BPF_R3,\n\t\t\t\t\t\t       BPF_R4, BPF_R5);\n\t\tCONT;\n\n\tJMP_CALL_ARGS:\n\t\tBPF_R0 = (__bpf_call_base_args + insn->imm)(BPF_R1, BPF_R2,\n\t\t\t\t\t\t\t    BPF_R3, BPF_R4,\n\t\t\t\t\t\t\t    BPF_R5,\n\t\t\t\t\t\t\t    insn + insn->off + 1);\n\t\tCONT;\n\n\tJMP_TAIL_CALL: {\n\t\tstruct bpf_map *map = (struct bpf_map *) (unsigned long) BPF_R2;\n\t\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\t\tstruct bpf_prog *prog;\n\t\tu32 index = BPF_R3;\n\n\t\tif (unlikely(index >= array->map.max_entries))\n\t\t\tgoto out;\n\t\tif (unlikely(tail_call_cnt > MAX_TAIL_CALL_CNT))\n\t\t\tgoto out;\n\n\t\ttail_call_cnt++;\n\n\t\tprog = READ_ONCE(array->ptrs[index]);\n\t\tif (!prog)\n\t\t\tgoto out;\n\n\t\t/* ARG1 at this point is guaranteed to point to CTX from\n\t\t * the verifier side due to the fact that the tail call is\n\t\t * handeled like a helper, that is, bpf_tail_call_proto,\n\t\t * where arg1_type is ARG_PTR_TO_CTX.\n\t\t */\n\t\tinsn = prog->insnsi;\n\t\tgoto select_insn;\nout:\n\t\tCONT;\n\t}\n\t/* JMP */\n\tJMP_JA:\n\t\tinsn += insn->off;\n\t\tCONT;\n\tJMP_JEQ_X:\n\t\tif (DST == SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JEQ_K:\n\t\tif (DST == IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JNE_X:\n\t\tif (DST != SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JNE_K:\n\t\tif (DST != IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGT_X:\n\t\tif (DST > SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGT_K:\n\t\tif (DST > IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLT_X:\n\t\tif (DST < SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLT_K:\n\t\tif (DST < IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGE_X:\n\t\tif (DST >= SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JGE_K:\n\t\tif (DST >= IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLE_X:\n\t\tif (DST <= SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JLE_K:\n\t\tif (DST <= IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGT_X:\n\t\tif (((s64) DST) > ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGT_K:\n\t\tif (((s64) DST) > ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLT_X:\n\t\tif (((s64) DST) < ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLT_K:\n\t\tif (((s64) DST) < ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGE_X:\n\t\tif (((s64) DST) >= ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSGE_K:\n\t\tif (((s64) DST) >= ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLE_X:\n\t\tif (((s64) DST) <= ((s64) SRC)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSLE_K:\n\t\tif (((s64) DST) <= ((s64) IMM)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSET_X:\n\t\tif (DST & SRC) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_JSET_K:\n\t\tif (DST & IMM) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tJMP_EXIT:\n\t\treturn BPF_R0;\n\n\t/* STX and ST and LDX*/\n#define LDST(SIZEOP, SIZE)\t\t\t\t\t\t\\\n\tSTX_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (DST + insn->off) = SRC;\t\\\n\t\tCONT;\t\t\t\t\t\t\t\\\n\tST_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (DST + insn->off) = IMM;\t\\\n\t\tCONT;\t\t\t\t\t\t\t\\\n\tLDX_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\tDST = *(SIZE *)(unsigned long) (SRC + insn->off);\t\\\n\t\tCONT;\n\n\tLDST(B,   u8)\n\tLDST(H,  u16)\n\tLDST(W,  u32)\n\tLDST(DW, u64)\n#undef LDST\n\tSTX_XADD_W: /* lock xadd *(u32 *)(dst_reg + off16) += src_reg */\n\t\tatomic_add((u32) SRC, (atomic_t *)(unsigned long)\n\t\t\t   (DST + insn->off));\n\t\tCONT;\n\tSTX_XADD_DW: /* lock xadd *(u64 *)(dst_reg + off16) += src_reg */\n\t\tatomic64_add((u64) SRC, (atomic64_t *)(unsigned long)\n\t\t\t     (DST + insn->off));\n\t\tCONT;\n\n\tdefault_label:\n\t\t/* If we ever reach this, we have a bug somewhere. Die hard here\n\t\t * instead of just returning 0; we could be somewhere in a subprog,\n\t\t * so execution could continue otherwise which we do /not/ want.\n\t\t *\n\t\t * Note, verifier whitelists all opcodes in bpf_opcode_in_insntable().\n\t\t */\n\t\tpr_warn(\"BPF interpreter: unknown opcode %02x\\n\", insn->code);\n\t\tBUG_ON(1);\n\t\treturn 0;\n}"
  },
  {
    "function_name": "bpf_opcode_in_insntable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "986-1005",
    "snippet": "bool bpf_opcode_in_insntable(u8 code)\n{\n#define BPF_INSN_2_TBL(x, y)    [BPF_##x | BPF_##y] = true\n#define BPF_INSN_3_TBL(x, y, z) [BPF_##x | BPF_##y | BPF_##z] = true\n\tstatic const bool public_insntable[256] = {\n\t\t[0 ... 255] = false,\n\t\t/* Now overwrite non-defaults ... */\n\t\tBPF_INSN_MAP(BPF_INSN_2_TBL, BPF_INSN_3_TBL),\n\t\t/* UAPI exposed, but rewritten opcodes. cBPF carry-over. */\n\t\t[BPF_LD | BPF_ABS | BPF_B] = true,\n\t\t[BPF_LD | BPF_ABS | BPF_H] = true,\n\t\t[BPF_LD | BPF_ABS | BPF_W] = true,\n\t\t[BPF_LD | BPF_IND | BPF_B] = true,\n\t\t[BPF_LD | BPF_IND | BPF_H] = true,\n\t\t[BPF_LD | BPF_IND | BPF_W] = true,\n\t};\n#undef BPF_INSN_3_TBL\n#undef BPF_INSN_2_TBL\n\treturn public_insntable[code];\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_INSN_MAP",
          "args": [
            "BPF_INSN_2_TBL",
            "BPF_INSN_3_TBL"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nbool bpf_opcode_in_insntable(u8 code)\n{\n#define BPF_INSN_2_TBL(x, y)    [BPF_##x | BPF_##y] = true\n#define BPF_INSN_3_TBL(x, y, z) [BPF_##x | BPF_##y | BPF_##z] = true\n\tstatic const bool public_insntable[256] = {\n\t\t[0 ... 255] = false,\n\t\t/* Now overwrite non-defaults ... */\n\t\tBPF_INSN_MAP(BPF_INSN_2_TBL, BPF_INSN_3_TBL),\n\t\t/* UAPI exposed, but rewritten opcodes. cBPF carry-over. */\n\t\t[BPF_LD | BPF_ABS | BPF_B] = true,\n\t\t[BPF_LD | BPF_ABS | BPF_H] = true,\n\t\t[BPF_LD | BPF_ABS | BPF_W] = true,\n\t\t[BPF_LD | BPF_IND | BPF_B] = true,\n\t\t[BPF_LD | BPF_IND | BPF_H] = true,\n\t\t[BPF_LD | BPF_IND | BPF_W] = true,\n\t};\n#undef BPF_INSN_3_TBL\n#undef BPF_INSN_2_TBL\n\treturn public_insntable[code];\n}"
  },
  {
    "function_name": "__bpf_call_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "870-873",
    "snippet": "noinline u64 __bpf_call_base(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nnoinline u64 __bpf_call_base(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_jit_blind_constants",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "809-861",
    "snippet": "struct bpf_prog *bpf_jit_blind_constants(struct bpf_prog *prog)\n{\n\tstruct bpf_insn insn_buff[16], aux[2];\n\tstruct bpf_prog *clone, *tmp;\n\tint insn_delta, insn_cnt;\n\tstruct bpf_insn *insn;\n\tint i, rewritten;\n\n\tif (!bpf_jit_blinding_enabled(prog) || prog->blinded)\n\t\treturn prog;\n\n\tclone = bpf_prog_clone_create(prog, GFP_USER);\n\tif (!clone)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinsn_cnt = clone->len;\n\tinsn = clone->insnsi;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\t/* We temporarily need to hold the original ld64 insn\n\t\t * so that we can still access the first part in the\n\t\t * second blinding run.\n\t\t */\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW) &&\n\t\t    insn[1].code == 0)\n\t\t\tmemcpy(aux, insn, sizeof(aux));\n\n\t\trewritten = bpf_jit_blind_insn(insn, aux, insn_buff);\n\t\tif (!rewritten)\n\t\t\tcontinue;\n\n\t\ttmp = bpf_patch_insn_single(clone, i, insn_buff, rewritten);\n\t\tif (!tmp) {\n\t\t\t/* Patching may have repointed aux->prog during\n\t\t\t * realloc from the original one, so we need to\n\t\t\t * fix it up here on error.\n\t\t\t */\n\t\t\tbpf_jit_prog_release_other(prog, clone);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tclone = tmp;\n\t\tinsn_delta = rewritten - 1;\n\n\t\t/* Walk new program and skip insns we just inserted. */\n\t\tinsn = clone->insnsi + i + insn_delta;\n\t\tinsn_cnt += insn_delta;\n\t\ti        += insn_delta;\n\t}\n\n\tclone->blinded = 1;\n\treturn clone;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_jit_prog_release_other",
          "args": [
            "prog",
            "clone"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_prog_release_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "800-807",
          "snippet": "void bpf_jit_prog_release_other(struct bpf_prog *fp, struct bpf_prog *fp_other)\n{\n\t/* We have to repoint aux->prog to self, as we don't\n\t * know whether fp here is the clone or the original.\n\t */\n\tfp->aux->prog = fp;\n\tbpf_prog_clone_free(fp_other);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_jit_prog_release_other(struct bpf_prog *fp, struct bpf_prog *fp_other)\n{\n\t/* We have to repoint aux->prog to self, as we don't\n\t * know whether fp here is the clone or the original.\n\t */\n\tfp->aux->prog = fp;\n\tbpf_prog_clone_free(fp_other);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_patch_insn_single",
          "args": [
            "clone",
            "i",
            "insn_buff",
            "rewritten"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_patch_insn_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "295-351",
          "snippet": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tconst u32 cnt_max = S16_MAX;\n\tstruct bpf_prog *prog_adj;\n\n\t/* Since our patchlet doesn't expand the image, we're done. */\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\n\tinsn_adj_cnt = prog->len + insn_delta;\n\n\t/* Reject anything that would potentially let the insn->off\n\t * target overflow when we have excessive program expansions.\n\t * We need to probe here before we do any reallocation where\n\t * we afterwards may not fail anymore.\n\t */\n\tif (insn_adj_cnt > cnt_max &&\n\t    bpf_adj_branches(prog, off, insn_delta, true))\n\t\treturn NULL;\n\n\t/* Several new instructions need to be inserted. Make room\n\t * for them. Likely, there's no need for a new allocation as\n\t * last page could have large enough tailroom.\n\t */\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\n\tprog_adj->len = insn_adj_cnt;\n\n\t/* Patching happens in 3 steps:\n\t *\n\t * 1) Move over tail of insnsi from next instruction onwards,\n\t *    so we can patch the single target insn with one or more\n\t *    new ones (patching is always from 1 to n insns, n > 0).\n\t * 2) Inject new instructions at the target location.\n\t * 3) Adjust branch offsets if necessary.\n\t */\n\tinsn_rest = insn_adj_cnt - off - len;\n\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\n\t/* We are guaranteed to not fail at this point, otherwise\n\t * the ship has sailed to reverse to the original state. An\n\t * overflow cannot happen at this point.\n\t */\n\tBUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));\n\n\treturn prog_adj;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstruct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tconst u32 cnt_max = S16_MAX;\n\tstruct bpf_prog *prog_adj;\n\n\t/* Since our patchlet doesn't expand the image, we're done. */\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\n\tinsn_adj_cnt = prog->len + insn_delta;\n\n\t/* Reject anything that would potentially let the insn->off\n\t * target overflow when we have excessive program expansions.\n\t * We need to probe here before we do any reallocation where\n\t * we afterwards may not fail anymore.\n\t */\n\tif (insn_adj_cnt > cnt_max &&\n\t    bpf_adj_branches(prog, off, insn_delta, true))\n\t\treturn NULL;\n\n\t/* Several new instructions need to be inserted. Make room\n\t * for them. Likely, there's no need for a new allocation as\n\t * last page could have large enough tailroom.\n\t */\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\n\tprog_adj->len = insn_adj_cnt;\n\n\t/* Patching happens in 3 steps:\n\t *\n\t * 1) Move over tail of insnsi from next instruction onwards,\n\t *    so we can patch the single target insn with one or more\n\t *    new ones (patching is always from 1 to n insns, n > 0).\n\t * 2) Inject new instructions at the target location.\n\t * 3) Adjust branch offsets if necessary.\n\t */\n\tinsn_rest = insn_adj_cnt - off - len;\n\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\n\t/* We are guaranteed to not fail at this point, otherwise\n\t * the ship has sailed to reverse to the original state. An\n\t * overflow cannot happen at this point.\n\t */\n\tBUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));\n\n\treturn prog_adj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_blind_insn",
          "args": [
            "insn",
            "aux",
            "insn_buff"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_blind_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "677-767",
          "snippet": "static int bpf_jit_blind_insn(const struct bpf_insn *from,\n\t\t\t      const struct bpf_insn *aux,\n\t\t\t      struct bpf_insn *to_buff)\n{\n\tstruct bpf_insn *to = to_buff;\n\tu32 imm_rnd = get_random_int();\n\ts16 off;\n\n\tBUILD_BUG_ON(BPF_REG_AX  + 1 != MAX_BPF_JIT_REG);\n\tBUILD_BUG_ON(MAX_BPF_REG + 1 != MAX_BPF_JIT_REG);\n\n\tif (from->imm == 0 &&\n\t    (from->code == (BPF_ALU   | BPF_MOV | BPF_K) ||\n\t     from->code == (BPF_ALU64 | BPF_MOV | BPF_K))) {\n\t\t*to++ = BPF_ALU64_REG(BPF_XOR, from->dst_reg, from->dst_reg);\n\t\tgoto out;\n\t}\n\n\tswitch (from->code) {\n\tcase BPF_ALU | BPF_ADD | BPF_K:\n\tcase BPF_ALU | BPF_SUB | BPF_K:\n\tcase BPF_ALU | BPF_AND | BPF_K:\n\tcase BPF_ALU | BPF_OR  | BPF_K:\n\tcase BPF_ALU | BPF_XOR | BPF_K:\n\tcase BPF_ALU | BPF_MUL | BPF_K:\n\tcase BPF_ALU | BPF_MOV | BPF_K:\n\tcase BPF_ALU | BPF_DIV | BPF_K:\n\tcase BPF_ALU | BPF_MOD | BPF_K:\n\t\t*to++ = BPF_ALU32_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU32_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU32_REG(from->code, from->dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_ADD | BPF_K:\n\tcase BPF_ALU64 | BPF_SUB | BPF_K:\n\tcase BPF_ALU64 | BPF_AND | BPF_K:\n\tcase BPF_ALU64 | BPF_OR  | BPF_K:\n\tcase BPF_ALU64 | BPF_XOR | BPF_K:\n\tcase BPF_ALU64 | BPF_MUL | BPF_K:\n\tcase BPF_ALU64 | BPF_MOV | BPF_K:\n\tcase BPF_ALU64 | BPF_DIV | BPF_K:\n\tcase BPF_ALU64 | BPF_MOD | BPF_K:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_REG(from->code, from->dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_JMP | BPF_JEQ  | BPF_K:\n\tcase BPF_JMP | BPF_JNE  | BPF_K:\n\tcase BPF_JMP | BPF_JGT  | BPF_K:\n\tcase BPF_JMP | BPF_JLT  | BPF_K:\n\tcase BPF_JMP | BPF_JGE  | BPF_K:\n\tcase BPF_JMP | BPF_JLE  | BPF_K:\n\tcase BPF_JMP | BPF_JSGT | BPF_K:\n\tcase BPF_JMP | BPF_JSLT | BPF_K:\n\tcase BPF_JMP | BPF_JSGE | BPF_K:\n\tcase BPF_JMP | BPF_JSLE | BPF_K:\n\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\t/* Accommodate for extra offset in case of a backjump. */\n\t\toff = from->off;\n\t\tif (off < 0)\n\t\t\toff -= 2;\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_JMP_REG(from->code, from->dst_reg, BPF_REG_AX, off);\n\t\tbreak;\n\n\tcase BPF_LD | BPF_IMM | BPF_DW:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ aux[1].imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_IMM(BPF_LSH, BPF_REG_AX, 32);\n\t\t*to++ = BPF_ALU64_REG(BPF_MOV, aux[0].dst_reg, BPF_REG_AX);\n\t\tbreak;\n\tcase 0: /* Part 2 of BPF_LD | BPF_IMM | BPF_DW. */\n\t\t*to++ = BPF_ALU32_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ aux[0].imm);\n\t\t*to++ = BPF_ALU32_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_REG(BPF_OR,  aux[0].dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_ST | BPF_MEM | BPF_DW:\n\tcase BPF_ST | BPF_MEM | BPF_W:\n\tcase BPF_ST | BPF_MEM | BPF_H:\n\tcase BPF_ST | BPF_MEM | BPF_B:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_STX_MEM(from->code, from->dst_reg, BPF_REG_AX, from->off);\n\t\tbreak;\n\t}\nout:\n\treturn to - to_buff;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_jit_blind_insn(const struct bpf_insn *from,\n\t\t\t      const struct bpf_insn *aux,\n\t\t\t      struct bpf_insn *to_buff)\n{\n\tstruct bpf_insn *to = to_buff;\n\tu32 imm_rnd = get_random_int();\n\ts16 off;\n\n\tBUILD_BUG_ON(BPF_REG_AX  + 1 != MAX_BPF_JIT_REG);\n\tBUILD_BUG_ON(MAX_BPF_REG + 1 != MAX_BPF_JIT_REG);\n\n\tif (from->imm == 0 &&\n\t    (from->code == (BPF_ALU   | BPF_MOV | BPF_K) ||\n\t     from->code == (BPF_ALU64 | BPF_MOV | BPF_K))) {\n\t\t*to++ = BPF_ALU64_REG(BPF_XOR, from->dst_reg, from->dst_reg);\n\t\tgoto out;\n\t}\n\n\tswitch (from->code) {\n\tcase BPF_ALU | BPF_ADD | BPF_K:\n\tcase BPF_ALU | BPF_SUB | BPF_K:\n\tcase BPF_ALU | BPF_AND | BPF_K:\n\tcase BPF_ALU | BPF_OR  | BPF_K:\n\tcase BPF_ALU | BPF_XOR | BPF_K:\n\tcase BPF_ALU | BPF_MUL | BPF_K:\n\tcase BPF_ALU | BPF_MOV | BPF_K:\n\tcase BPF_ALU | BPF_DIV | BPF_K:\n\tcase BPF_ALU | BPF_MOD | BPF_K:\n\t\t*to++ = BPF_ALU32_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU32_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU32_REG(from->code, from->dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_ADD | BPF_K:\n\tcase BPF_ALU64 | BPF_SUB | BPF_K:\n\tcase BPF_ALU64 | BPF_AND | BPF_K:\n\tcase BPF_ALU64 | BPF_OR  | BPF_K:\n\tcase BPF_ALU64 | BPF_XOR | BPF_K:\n\tcase BPF_ALU64 | BPF_MUL | BPF_K:\n\tcase BPF_ALU64 | BPF_MOV | BPF_K:\n\tcase BPF_ALU64 | BPF_DIV | BPF_K:\n\tcase BPF_ALU64 | BPF_MOD | BPF_K:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_REG(from->code, from->dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_JMP | BPF_JEQ  | BPF_K:\n\tcase BPF_JMP | BPF_JNE  | BPF_K:\n\tcase BPF_JMP | BPF_JGT  | BPF_K:\n\tcase BPF_JMP | BPF_JLT  | BPF_K:\n\tcase BPF_JMP | BPF_JGE  | BPF_K:\n\tcase BPF_JMP | BPF_JLE  | BPF_K:\n\tcase BPF_JMP | BPF_JSGT | BPF_K:\n\tcase BPF_JMP | BPF_JSLT | BPF_K:\n\tcase BPF_JMP | BPF_JSGE | BPF_K:\n\tcase BPF_JMP | BPF_JSLE | BPF_K:\n\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\t/* Accommodate for extra offset in case of a backjump. */\n\t\toff = from->off;\n\t\tif (off < 0)\n\t\t\toff -= 2;\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_JMP_REG(from->code, from->dst_reg, BPF_REG_AX, off);\n\t\tbreak;\n\n\tcase BPF_LD | BPF_IMM | BPF_DW:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ aux[1].imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_IMM(BPF_LSH, BPF_REG_AX, 32);\n\t\t*to++ = BPF_ALU64_REG(BPF_MOV, aux[0].dst_reg, BPF_REG_AX);\n\t\tbreak;\n\tcase 0: /* Part 2 of BPF_LD | BPF_IMM | BPF_DW. */\n\t\t*to++ = BPF_ALU32_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ aux[0].imm);\n\t\t*to++ = BPF_ALU32_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_REG(BPF_OR,  aux[0].dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_ST | BPF_MEM | BPF_DW:\n\tcase BPF_ST | BPF_MEM | BPF_W:\n\tcase BPF_ST | BPF_MEM | BPF_H:\n\tcase BPF_ST | BPF_MEM | BPF_B:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_STX_MEM(from->code, from->dst_reg, BPF_REG_AX, from->off);\n\t\tbreak;\n\t}\nout:\n\treturn to - to_buff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "aux",
            "insn",
            "sizeof(aux)"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_clone_create",
          "args": [
            "prog",
            "GFP_USER"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_clone_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "769-785",
          "snippet": "static struct bpf_prog *bpf_prog_clone_create(struct bpf_prog *fp_other,\n\t\t\t\t\t      gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog *fp;\n\n\tfp = __vmalloc(fp_other->pages * PAGE_SIZE, gfp_flags, PAGE_KERNEL);\n\tif (fp != NULL) {\n\t\t/* aux->prog still points to the fp_other one, so\n\t\t * when promoting the clone to the real program,\n\t\t * this still needs to be adapted.\n\t\t */\n\t\tmemcpy(fp, fp_other, fp_other->pages * PAGE_SIZE);\n\t}\n\n\treturn fp;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog *bpf_prog_clone_create(struct bpf_prog *fp_other,\n\t\t\t\t\t      gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog *fp;\n\n\tfp = __vmalloc(fp_other->pages * PAGE_SIZE, gfp_flags, PAGE_KERNEL);\n\tif (fp != NULL) {\n\t\t/* aux->prog still points to the fp_other one, so\n\t\t * when promoting the clone to the real program,\n\t\t * this still needs to be adapted.\n\t\t */\n\t\tmemcpy(fp, fp_other, fp_other->pages * PAGE_SIZE);\n\t}\n\n\treturn fp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_blinding_enabled",
          "args": [
            "prog"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstruct bpf_prog *bpf_jit_blind_constants(struct bpf_prog *prog)\n{\n\tstruct bpf_insn insn_buff[16], aux[2];\n\tstruct bpf_prog *clone, *tmp;\n\tint insn_delta, insn_cnt;\n\tstruct bpf_insn *insn;\n\tint i, rewritten;\n\n\tif (!bpf_jit_blinding_enabled(prog) || prog->blinded)\n\t\treturn prog;\n\n\tclone = bpf_prog_clone_create(prog, GFP_USER);\n\tif (!clone)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinsn_cnt = clone->len;\n\tinsn = clone->insnsi;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\t/* We temporarily need to hold the original ld64 insn\n\t\t * so that we can still access the first part in the\n\t\t * second blinding run.\n\t\t */\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW) &&\n\t\t    insn[1].code == 0)\n\t\t\tmemcpy(aux, insn, sizeof(aux));\n\n\t\trewritten = bpf_jit_blind_insn(insn, aux, insn_buff);\n\t\tif (!rewritten)\n\t\t\tcontinue;\n\n\t\ttmp = bpf_patch_insn_single(clone, i, insn_buff, rewritten);\n\t\tif (!tmp) {\n\t\t\t/* Patching may have repointed aux->prog during\n\t\t\t * realloc from the original one, so we need to\n\t\t\t * fix it up here on error.\n\t\t\t */\n\t\t\tbpf_jit_prog_release_other(prog, clone);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tclone = tmp;\n\t\tinsn_delta = rewritten - 1;\n\n\t\t/* Walk new program and skip insns we just inserted. */\n\t\tinsn = clone->insnsi + i + insn_delta;\n\t\tinsn_cnt += insn_delta;\n\t\ti        += insn_delta;\n\t}\n\n\tclone->blinded = 1;\n\treturn clone;\n}"
  },
  {
    "function_name": "bpf_jit_prog_release_other",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "800-807",
    "snippet": "void bpf_jit_prog_release_other(struct bpf_prog *fp, struct bpf_prog *fp_other)\n{\n\t/* We have to repoint aux->prog to self, as we don't\n\t * know whether fp here is the clone or the original.\n\t */\n\tfp->aux->prog = fp;\n\tbpf_prog_clone_free(fp_other);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_clone_free",
          "args": [
            "fp_other"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_clone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "787-798",
          "snippet": "static void bpf_prog_clone_free(struct bpf_prog *fp)\n{\n\t/* aux was stolen by the other clone, so we cannot free\n\t * it from this path! It will be freed eventually by the\n\t * other program on release.\n\t *\n\t * At this point, we don't need a deferred release since\n\t * clone is guaranteed to not be locked.\n\t */\n\tfp->aux = NULL;\n\t__bpf_prog_free(fp);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_prog_clone_free(struct bpf_prog *fp)\n{\n\t/* aux was stolen by the other clone, so we cannot free\n\t * it from this path! It will be freed eventually by the\n\t * other program on release.\n\t *\n\t * At this point, we don't need a deferred release since\n\t * clone is guaranteed to not be locked.\n\t */\n\tfp->aux = NULL;\n\t__bpf_prog_free(fp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_jit_prog_release_other(struct bpf_prog *fp, struct bpf_prog *fp_other)\n{\n\t/* We have to repoint aux->prog to self, as we don't\n\t * know whether fp here is the clone or the original.\n\t */\n\tfp->aux->prog = fp;\n\tbpf_prog_clone_free(fp_other);\n}"
  },
  {
    "function_name": "bpf_prog_clone_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "787-798",
    "snippet": "static void bpf_prog_clone_free(struct bpf_prog *fp)\n{\n\t/* aux was stolen by the other clone, so we cannot free\n\t * it from this path! It will be freed eventually by the\n\t * other program on release.\n\t *\n\t * At this point, we don't need a deferred release since\n\t * clone is guaranteed to not be locked.\n\t */\n\tfp->aux = NULL;\n\t__bpf_prog_free(fp);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_prog_free",
          "args": [
            "fp"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "144-148",
          "snippet": "void __bpf_prog_free(struct bpf_prog *fp)\n{\n\tkfree(fp->aux);\n\tvfree(fp);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid __bpf_prog_free(struct bpf_prog *fp)\n{\n\tkfree(fp->aux);\n\tvfree(fp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_prog_clone_free(struct bpf_prog *fp)\n{\n\t/* aux was stolen by the other clone, so we cannot free\n\t * it from this path! It will be freed eventually by the\n\t * other program on release.\n\t *\n\t * At this point, we don't need a deferred release since\n\t * clone is guaranteed to not be locked.\n\t */\n\tfp->aux = NULL;\n\t__bpf_prog_free(fp);\n}"
  },
  {
    "function_name": "bpf_prog_clone_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "769-785",
    "snippet": "static struct bpf_prog *bpf_prog_clone_create(struct bpf_prog *fp_other,\n\t\t\t\t\t      gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog *fp;\n\n\tfp = __vmalloc(fp_other->pages * PAGE_SIZE, gfp_flags, PAGE_KERNEL);\n\tif (fp != NULL) {\n\t\t/* aux->prog still points to the fp_other one, so\n\t\t * when promoting the clone to the real program,\n\t\t * this still needs to be adapted.\n\t\t */\n\t\tmemcpy(fp, fp_other, fp_other->pages * PAGE_SIZE);\n\t}\n\n\treturn fp;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fp",
            "fp_other",
            "fp_other->pages * PAGE_SIZE"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "fp_other->pages * PAGE_SIZE",
            "gfp_flags",
            "PAGE_KERNEL"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog *bpf_prog_clone_create(struct bpf_prog *fp_other,\n\t\t\t\t\t      gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog *fp;\n\n\tfp = __vmalloc(fp_other->pages * PAGE_SIZE, gfp_flags, PAGE_KERNEL);\n\tif (fp != NULL) {\n\t\t/* aux->prog still points to the fp_other one, so\n\t\t * when promoting the clone to the real program,\n\t\t * this still needs to be adapted.\n\t\t */\n\t\tmemcpy(fp, fp_other, fp_other->pages * PAGE_SIZE);\n\t}\n\n\treturn fp;\n}"
  },
  {
    "function_name": "bpf_jit_blind_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "677-767",
    "snippet": "static int bpf_jit_blind_insn(const struct bpf_insn *from,\n\t\t\t      const struct bpf_insn *aux,\n\t\t\t      struct bpf_insn *to_buff)\n{\n\tstruct bpf_insn *to = to_buff;\n\tu32 imm_rnd = get_random_int();\n\ts16 off;\n\n\tBUILD_BUG_ON(BPF_REG_AX  + 1 != MAX_BPF_JIT_REG);\n\tBUILD_BUG_ON(MAX_BPF_REG + 1 != MAX_BPF_JIT_REG);\n\n\tif (from->imm == 0 &&\n\t    (from->code == (BPF_ALU   | BPF_MOV | BPF_K) ||\n\t     from->code == (BPF_ALU64 | BPF_MOV | BPF_K))) {\n\t\t*to++ = BPF_ALU64_REG(BPF_XOR, from->dst_reg, from->dst_reg);\n\t\tgoto out;\n\t}\n\n\tswitch (from->code) {\n\tcase BPF_ALU | BPF_ADD | BPF_K:\n\tcase BPF_ALU | BPF_SUB | BPF_K:\n\tcase BPF_ALU | BPF_AND | BPF_K:\n\tcase BPF_ALU | BPF_OR  | BPF_K:\n\tcase BPF_ALU | BPF_XOR | BPF_K:\n\tcase BPF_ALU | BPF_MUL | BPF_K:\n\tcase BPF_ALU | BPF_MOV | BPF_K:\n\tcase BPF_ALU | BPF_DIV | BPF_K:\n\tcase BPF_ALU | BPF_MOD | BPF_K:\n\t\t*to++ = BPF_ALU32_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU32_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU32_REG(from->code, from->dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_ADD | BPF_K:\n\tcase BPF_ALU64 | BPF_SUB | BPF_K:\n\tcase BPF_ALU64 | BPF_AND | BPF_K:\n\tcase BPF_ALU64 | BPF_OR  | BPF_K:\n\tcase BPF_ALU64 | BPF_XOR | BPF_K:\n\tcase BPF_ALU64 | BPF_MUL | BPF_K:\n\tcase BPF_ALU64 | BPF_MOV | BPF_K:\n\tcase BPF_ALU64 | BPF_DIV | BPF_K:\n\tcase BPF_ALU64 | BPF_MOD | BPF_K:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_REG(from->code, from->dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_JMP | BPF_JEQ  | BPF_K:\n\tcase BPF_JMP | BPF_JNE  | BPF_K:\n\tcase BPF_JMP | BPF_JGT  | BPF_K:\n\tcase BPF_JMP | BPF_JLT  | BPF_K:\n\tcase BPF_JMP | BPF_JGE  | BPF_K:\n\tcase BPF_JMP | BPF_JLE  | BPF_K:\n\tcase BPF_JMP | BPF_JSGT | BPF_K:\n\tcase BPF_JMP | BPF_JSLT | BPF_K:\n\tcase BPF_JMP | BPF_JSGE | BPF_K:\n\tcase BPF_JMP | BPF_JSLE | BPF_K:\n\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\t/* Accommodate for extra offset in case of a backjump. */\n\t\toff = from->off;\n\t\tif (off < 0)\n\t\t\toff -= 2;\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_JMP_REG(from->code, from->dst_reg, BPF_REG_AX, off);\n\t\tbreak;\n\n\tcase BPF_LD | BPF_IMM | BPF_DW:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ aux[1].imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_IMM(BPF_LSH, BPF_REG_AX, 32);\n\t\t*to++ = BPF_ALU64_REG(BPF_MOV, aux[0].dst_reg, BPF_REG_AX);\n\t\tbreak;\n\tcase 0: /* Part 2 of BPF_LD | BPF_IMM | BPF_DW. */\n\t\t*to++ = BPF_ALU32_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ aux[0].imm);\n\t\t*to++ = BPF_ALU32_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_REG(BPF_OR,  aux[0].dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_ST | BPF_MEM | BPF_DW:\n\tcase BPF_ST | BPF_MEM | BPF_W:\n\tcase BPF_ST | BPF_MEM | BPF_H:\n\tcase BPF_ST | BPF_MEM | BPF_B:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_STX_MEM(from->code, from->dst_reg, BPF_REG_AX, from->off);\n\t\tbreak;\n\t}\nout:\n\treturn to - to_buff;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_STX_MEM",
          "args": [
            "from->code",
            "from->dst_reg",
            "BPF_REG_AX",
            "from->off"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_XOR",
            "BPF_REG_AX",
            "imm_rnd"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_MOV",
            "BPF_REG_AX",
            "imm_rnd ^ from->imm"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_REG",
          "args": [
            "BPF_OR",
            "aux[0].dst_reg",
            "BPF_REG_AX"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU32_IMM",
          "args": [
            "BPF_XOR",
            "BPF_REG_AX",
            "imm_rnd"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU32_IMM",
          "args": [
            "BPF_MOV",
            "BPF_REG_AX",
            "imm_rnd ^ aux[0].imm"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_REG",
          "args": [
            "BPF_MOV",
            "aux[0].dst_reg",
            "BPF_REG_AX"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_LSH",
            "BPF_REG_AX",
            "32"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_XOR",
            "BPF_REG_AX",
            "imm_rnd"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_MOV",
            "BPF_REG_AX",
            "imm_rnd ^ aux[1].imm"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_REG",
          "args": [
            "from->code",
            "from->dst_reg",
            "BPF_REG_AX",
            "off"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_XOR",
            "BPF_REG_AX",
            "imm_rnd"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_MOV",
            "BPF_REG_AX",
            "imm_rnd ^ from->imm"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_REG",
          "args": [
            "from->code",
            "from->dst_reg",
            "BPF_REG_AX"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_XOR",
            "BPF_REG_AX",
            "imm_rnd"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_MOV",
            "BPF_REG_AX",
            "imm_rnd ^ from->imm"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU32_REG",
          "args": [
            "from->code",
            "from->dst_reg",
            "BPF_REG_AX"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU32_IMM",
          "args": [
            "BPF_XOR",
            "BPF_REG_AX",
            "imm_rnd"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU32_IMM",
          "args": [
            "BPF_MOV",
            "BPF_REG_AX",
            "imm_rnd ^ from->imm"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_REG",
          "args": [
            "BPF_XOR",
            "from->dst_reg",
            "from->dst_reg"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "MAX_BPF_REG + 1 != MAX_BPF_JIT_REG"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "BPF_REG_AX  + 1 != MAX_BPF_JIT_REG"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_jit_blind_insn(const struct bpf_insn *from,\n\t\t\t      const struct bpf_insn *aux,\n\t\t\t      struct bpf_insn *to_buff)\n{\n\tstruct bpf_insn *to = to_buff;\n\tu32 imm_rnd = get_random_int();\n\ts16 off;\n\n\tBUILD_BUG_ON(BPF_REG_AX  + 1 != MAX_BPF_JIT_REG);\n\tBUILD_BUG_ON(MAX_BPF_REG + 1 != MAX_BPF_JIT_REG);\n\n\tif (from->imm == 0 &&\n\t    (from->code == (BPF_ALU   | BPF_MOV | BPF_K) ||\n\t     from->code == (BPF_ALU64 | BPF_MOV | BPF_K))) {\n\t\t*to++ = BPF_ALU64_REG(BPF_XOR, from->dst_reg, from->dst_reg);\n\t\tgoto out;\n\t}\n\n\tswitch (from->code) {\n\tcase BPF_ALU | BPF_ADD | BPF_K:\n\tcase BPF_ALU | BPF_SUB | BPF_K:\n\tcase BPF_ALU | BPF_AND | BPF_K:\n\tcase BPF_ALU | BPF_OR  | BPF_K:\n\tcase BPF_ALU | BPF_XOR | BPF_K:\n\tcase BPF_ALU | BPF_MUL | BPF_K:\n\tcase BPF_ALU | BPF_MOV | BPF_K:\n\tcase BPF_ALU | BPF_DIV | BPF_K:\n\tcase BPF_ALU | BPF_MOD | BPF_K:\n\t\t*to++ = BPF_ALU32_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU32_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU32_REG(from->code, from->dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_ADD | BPF_K:\n\tcase BPF_ALU64 | BPF_SUB | BPF_K:\n\tcase BPF_ALU64 | BPF_AND | BPF_K:\n\tcase BPF_ALU64 | BPF_OR  | BPF_K:\n\tcase BPF_ALU64 | BPF_XOR | BPF_K:\n\tcase BPF_ALU64 | BPF_MUL | BPF_K:\n\tcase BPF_ALU64 | BPF_MOV | BPF_K:\n\tcase BPF_ALU64 | BPF_DIV | BPF_K:\n\tcase BPF_ALU64 | BPF_MOD | BPF_K:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_REG(from->code, from->dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_JMP | BPF_JEQ  | BPF_K:\n\tcase BPF_JMP | BPF_JNE  | BPF_K:\n\tcase BPF_JMP | BPF_JGT  | BPF_K:\n\tcase BPF_JMP | BPF_JLT  | BPF_K:\n\tcase BPF_JMP | BPF_JGE  | BPF_K:\n\tcase BPF_JMP | BPF_JLE  | BPF_K:\n\tcase BPF_JMP | BPF_JSGT | BPF_K:\n\tcase BPF_JMP | BPF_JSLT | BPF_K:\n\tcase BPF_JMP | BPF_JSGE | BPF_K:\n\tcase BPF_JMP | BPF_JSLE | BPF_K:\n\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\t/* Accommodate for extra offset in case of a backjump. */\n\t\toff = from->off;\n\t\tif (off < 0)\n\t\t\toff -= 2;\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_JMP_REG(from->code, from->dst_reg, BPF_REG_AX, off);\n\t\tbreak;\n\n\tcase BPF_LD | BPF_IMM | BPF_DW:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ aux[1].imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_IMM(BPF_LSH, BPF_REG_AX, 32);\n\t\t*to++ = BPF_ALU64_REG(BPF_MOV, aux[0].dst_reg, BPF_REG_AX);\n\t\tbreak;\n\tcase 0: /* Part 2 of BPF_LD | BPF_IMM | BPF_DW. */\n\t\t*to++ = BPF_ALU32_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ aux[0].imm);\n\t\t*to++ = BPF_ALU32_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_ALU64_REG(BPF_OR,  aux[0].dst_reg, BPF_REG_AX);\n\t\tbreak;\n\n\tcase BPF_ST | BPF_MEM | BPF_DW:\n\tcase BPF_ST | BPF_MEM | BPF_W:\n\tcase BPF_ST | BPF_MEM | BPF_H:\n\tcase BPF_ST | BPF_MEM | BPF_B:\n\t\t*to++ = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, imm_rnd ^ from->imm);\n\t\t*to++ = BPF_ALU64_IMM(BPF_XOR, BPF_REG_AX, imm_rnd);\n\t\t*to++ = BPF_STX_MEM(from->code, from->dst_reg, BPF_REG_AX, from->off);\n\t\tbreak;\n\t}\nout:\n\treturn to - to_buff;\n}"
  },
  {
    "function_name": "bpf_jit_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "663-675",
    "snippet": "void __weak bpf_jit_free(struct bpf_prog *fp)\n{\n\tif (fp->jited) {\n\t\tstruct bpf_binary_header *hdr = bpf_jit_binary_hdr(fp);\n\n\t\tbpf_jit_binary_unlock_ro(hdr);\n\t\tbpf_jit_binary_free(hdr);\n\n\t\tWARN_ON_ONCE(!bpf_prog_kallsyms_verify_off(fp));\n\t}\n\n\tbpf_prog_unlock_free(fp);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
      "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
      "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
      "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
      "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
      "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
      "const struct bpf_func_proto bpf_get_local_storage_proto __weak;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_unlock_free",
          "args": [
            "fp"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!bpf_prog_kallsyms_verify_off(fp)"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_verify_off",
          "args": [
            "fp"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_verify_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "478-482",
          "snippet": "static bool bpf_prog_kallsyms_verify_off(const struct bpf_prog *fp)\n{\n\treturn list_empty(&fp->aux->ksym_lnode) ||\n\t       fp->aux->ksym_lnode.prev == LIST_POISON2;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic bool bpf_prog_kallsyms_verify_off(const struct bpf_prog *fp)\n{\n\treturn list_empty(&fp->aux->ksym_lnode) ||\n\t       fp->aux->ksym_lnode.prev == LIST_POISON2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_binary_free",
          "args": [
            "hdr"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_binary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "651-657",
          "snippet": "void bpf_jit_binary_free(struct bpf_binary_header *hdr)\n{\n\tu32 pages = hdr->pages;\n\n\tmodule_memfree(hdr);\n\tbpf_jit_uncharge_modmem(pages);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_jit_binary_free(struct bpf_binary_header *hdr)\n{\n\tu32 pages = hdr->pages;\n\n\tmodule_memfree(hdr);\n\tbpf_jit_uncharge_modmem(pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_binary_unlock_ro",
          "args": [
            "hdr"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_jit_binary_hdr",
          "args": [
            "fp"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\n\nvoid __weak bpf_jit_free(struct bpf_prog *fp)\n{\n\tif (fp->jited) {\n\t\tstruct bpf_binary_header *hdr = bpf_jit_binary_hdr(fp);\n\n\t\tbpf_jit_binary_unlock_ro(hdr);\n\t\tbpf_jit_binary_free(hdr);\n\n\t\tWARN_ON_ONCE(!bpf_prog_kallsyms_verify_off(fp));\n\t}\n\n\tbpf_prog_unlock_free(fp);\n}"
  },
  {
    "function_name": "bpf_jit_binary_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "651-657",
    "snippet": "void bpf_jit_binary_free(struct bpf_binary_header *hdr)\n{\n\tu32 pages = hdr->pages;\n\n\tmodule_memfree(hdr);\n\tbpf_jit_uncharge_modmem(pages);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_jit_uncharge_modmem",
          "args": [
            "pages"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_uncharge_modmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "609-612",
          "snippet": "static void bpf_jit_uncharge_modmem(u32 pages)\n{\n\tatomic_long_sub(pages, &bpf_jit_current);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_jit_uncharge_modmem(u32 pages)\n{\n\tatomic_long_sub(pages, &bpf_jit_current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_memfree",
          "args": [
            "hdr"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "module_memfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "2113-2116",
          "snippet": "void __weak module_memfree(void *module_region)\n{\n\tvfree(module_region);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid __weak module_memfree(void *module_region)\n{\n\tvfree(module_region);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_jit_binary_free(struct bpf_binary_header *hdr)\n{\n\tu32 pages = hdr->pages;\n\n\tmodule_memfree(hdr);\n\tbpf_jit_uncharge_modmem(pages);\n}"
  },
  {
    "function_name": "bpf_jit_binary_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "614-649",
    "snippet": "struct bpf_binary_header *\nbpf_jit_binary_alloc(unsigned int proglen, u8 **image_ptr,\n\t\t     unsigned int alignment,\n\t\t     bpf_jit_fill_hole_t bpf_fill_ill_insns)\n{\n\tstruct bpf_binary_header *hdr;\n\tu32 size, hole, start, pages;\n\n\t/* Most of BPF filters are really small, but if some of them\n\t * fill a page, allow at least 128 extra bytes to insert a\n\t * random section of illegal instructions.\n\t */\n\tsize = round_up(proglen + sizeof(*hdr) + 128, PAGE_SIZE);\n\tpages = size / PAGE_SIZE;\n\n\tif (bpf_jit_charge_modmem(pages))\n\t\treturn NULL;\n\thdr = module_alloc(size);\n\tif (!hdr) {\n\t\tbpf_jit_uncharge_modmem(pages);\n\t\treturn NULL;\n\t}\n\n\t/* Fill space with illegal/arch-dep instructions. */\n\tbpf_fill_ill_insns(hdr, size);\n\n\thdr->pages = pages;\n\thole = min_t(unsigned int, size - (proglen + sizeof(*hdr)),\n\t\t     PAGE_SIZE - sizeof(*hdr));\n\tstart = (get_random_int() % hole) & ~(alignment - 1);\n\n\t/* Leave a random number of instructions before BPF code. */\n\t*image_ptr = &hdr->image[start];\n\n\treturn hdr;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "size - (proglen + sizeof(*hdr))",
            "PAGE_SIZE - sizeof(*hdr)"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_fill_ill_insns",
          "args": [
            "hdr",
            "size"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_jit_uncharge_modmem",
          "args": [
            "pages"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_uncharge_modmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "609-612",
          "snippet": "static void bpf_jit_uncharge_modmem(u32 pages)\n{\n\tatomic_long_sub(pages, &bpf_jit_current);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_jit_uncharge_modmem(u32 pages)\n{\n\tatomic_long_sub(pages, &bpf_jit_current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_alloc",
          "args": [
            "size"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "module_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "2731-2734",
          "snippet": "void * __weak module_alloc(unsigned long size)\n{\n\treturn vmalloc_exec(size);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid * __weak module_alloc(unsigned long size)\n{\n\treturn vmalloc_exec(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_charge_modmem",
          "args": [
            "pages"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_jit_charge_modmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "596-607",
          "snippet": "static int bpf_jit_charge_modmem(u32 pages)\n{\n\tif (atomic_long_add_return(pages, &bpf_jit_current) >\n\t    (bpf_jit_limit >> PAGE_SHIFT)) {\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tatomic_long_sub(pages, &bpf_jit_current);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_jit_charge_modmem(u32 pages)\n{\n\tif (atomic_long_add_return(pages, &bpf_jit_current) >\n\t    (bpf_jit_limit >> PAGE_SHIFT)) {\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tatomic_long_sub(pages, &bpf_jit_current);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "proglen + sizeof(*hdr) + 128",
            "PAGE_SIZE"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstruct bpf_binary_header *\nbpf_jit_binary_alloc(unsigned int proglen, u8 **image_ptr,\n\t\t     unsigned int alignment,\n\t\t     bpf_jit_fill_hole_t bpf_fill_ill_insns)\n{\n\tstruct bpf_binary_header *hdr;\n\tu32 size, hole, start, pages;\n\n\t/* Most of BPF filters are really small, but if some of them\n\t * fill a page, allow at least 128 extra bytes to insert a\n\t * random section of illegal instructions.\n\t */\n\tsize = round_up(proglen + sizeof(*hdr) + 128, PAGE_SIZE);\n\tpages = size / PAGE_SIZE;\n\n\tif (bpf_jit_charge_modmem(pages))\n\t\treturn NULL;\n\thdr = module_alloc(size);\n\tif (!hdr) {\n\t\tbpf_jit_uncharge_modmem(pages);\n\t\treturn NULL;\n\t}\n\n\t/* Fill space with illegal/arch-dep instructions. */\n\tbpf_fill_ill_insns(hdr, size);\n\n\thdr->pages = pages;\n\thole = min_t(unsigned int, size - (proglen + sizeof(*hdr)),\n\t\t     PAGE_SIZE - sizeof(*hdr));\n\tstart = (get_random_int() % hole) & ~(alignment - 1);\n\n\t/* Leave a random number of instructions before BPF code. */\n\t*image_ptr = &hdr->image[start];\n\n\treturn hdr;\n}"
  },
  {
    "function_name": "bpf_jit_uncharge_modmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "609-612",
    "snippet": "static void bpf_jit_uncharge_modmem(u32 pages)\n{\n\tatomic_long_sub(pages, &bpf_jit_current);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_sub",
          "args": [
            "pages",
            "&bpf_jit_current"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_jit_uncharge_modmem(u32 pages)\n{\n\tatomic_long_sub(pages, &bpf_jit_current);\n}"
  },
  {
    "function_name": "bpf_jit_charge_modmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "596-607",
    "snippet": "static int bpf_jit_charge_modmem(u32 pages)\n{\n\tif (atomic_long_add_return(pages, &bpf_jit_current) >\n\t    (bpf_jit_limit >> PAGE_SHIFT)) {\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tatomic_long_sub(pages, &bpf_jit_current);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_sub",
          "args": [
            "pages",
            "&bpf_jit_current"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "pages",
            "&bpf_jit_current"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_jit_charge_modmem(u32 pages)\n{\n\tif (atomic_long_add_return(pages, &bpf_jit_current) >\n\t    (bpf_jit_limit >> PAGE_SHIFT)) {\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tatomic_long_sub(pages, &bpf_jit_current);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_jit_charge_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "586-592",
    "snippet": "static int __init bpf_jit_charge_init(void)\n{\n\t/* Only used as heuristic here to derive limit. */\n\tbpf_jit_limit = min_t(u64, round_up((MODULES_END - MODULES_VADDR) >> 2,\n\t\t\t\t\t    PAGE_SIZE), INT_MAX);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "round_up((MODULES_END - MODULES_VADDR) >> 2,\n\t\t\t\t\t    PAGE_SIZE)",
            "INT_MAX"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "(MODULES_END - MODULES_VADDR) >> 2",
            "PAGE_SIZE"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int __init bpf_jit_charge_init(void)\n{\n\t/* Only used as heuristic here to derive limit. */\n\tbpf_jit_limit = min_t(u64, round_up((MODULES_END - MODULES_VADDR) >> 2,\n\t\t\t\t\t    PAGE_SIZE), INT_MAX);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_get_kallsym",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "553-581",
    "snippet": "int bpf_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t    char *sym)\n{\n\tunsigned long symbol_start, symbol_end;\n\tstruct bpf_prog_aux *aux;\n\tunsigned int it = 0;\n\tint ret = -ERANGE;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn ret;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(aux, &bpf_kallsyms, ksym_lnode) {\n\t\tif (it++ != symnum)\n\t\t\tcontinue;\n\n\t\tbpf_get_prog_addr_region(aux->prog, &symbol_start, &symbol_end);\n\t\tbpf_get_prog_name(aux->prog, sym);\n\n\t\t*value = symbol_start;\n\t\t*type  = BPF_SYM_ELF_TYPE;\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_prog_name",
          "args": [
            "aux->prog",
            "sym"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_prog_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "390-411",
          "snippet": "static void bpf_get_prog_name(const struct bpf_prog *prog, char *sym)\n{\n\tconst char *end = sym + KSYM_NAME_LEN;\n\n\tBUILD_BUG_ON(sizeof(\"bpf_prog_\") +\n\t\t     sizeof(prog->tag) * 2 +\n\t\t     /* name has been null terminated.\n\t\t      * We should need +1 for the '_' preceding\n\t\t      * the name.  However, the null character\n\t\t      * is double counted between the name and the\n\t\t      * sizeof(\"bpf_prog_\") above, so we omit\n\t\t      * the +1 here.\n\t\t      */\n\t\t     sizeof(prog->aux->name) > KSYM_NAME_LEN);\n\n\tsym += snprintf(sym, KSYM_NAME_LEN, \"bpf_prog_\");\n\tsym  = bin2hex(sym, prog->tag, sizeof(prog->tag));\n\tif (prog->aux->name[0])\n\t\tsnprintf(sym, (size_t)(end - sym), \"_%s\", prog->aux->name);\n\telse\n\t\t*sym = 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_get_prog_name(const struct bpf_prog *prog, char *sym)\n{\n\tconst char *end = sym + KSYM_NAME_LEN;\n\n\tBUILD_BUG_ON(sizeof(\"bpf_prog_\") +\n\t\t     sizeof(prog->tag) * 2 +\n\t\t     /* name has been null terminated.\n\t\t      * We should need +1 for the '_' preceding\n\t\t      * the name.  However, the null character\n\t\t      * is double counted between the name and the\n\t\t      * sizeof(\"bpf_prog_\") above, so we omit\n\t\t      * the +1 here.\n\t\t      */\n\t\t     sizeof(prog->aux->name) > KSYM_NAME_LEN);\n\n\tsym += snprintf(sym, KSYM_NAME_LEN, \"bpf_prog_\");\n\tsym  = bin2hex(sym, prog->tag, sizeof(prog->tag));\n\tif (prog->aux->name[0])\n\t\tsnprintf(sym, (size_t)(end - sym), \"_%s\", prog->aux->name);\n\telse\n\t\t*sym = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_prog_addr_region",
          "args": [
            "aux->prog",
            "&symbol_start",
            "&symbol_end"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_prog_addr_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "376-388",
          "snippet": "static __always_inline void\nbpf_get_prog_addr_region(const struct bpf_prog *prog,\n\t\t\t unsigned long *symbol_start,\n\t\t\t unsigned long *symbol_end)\n{\n\tconst struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);\n\tunsigned long addr = (unsigned long)hdr;\n\n\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));\n\n\t*symbol_start = addr;\n\t*symbol_end   = addr + hdr->pages * PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic __always_inline void\nbpf_get_prog_addr_region(const struct bpf_prog *prog,\n\t\t\t unsigned long *symbol_start,\n\t\t\t unsigned long *symbol_end)\n{\n\tconst struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);\n\tunsigned long addr = (unsigned long)hdr;\n\n\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));\n\n\t*symbol_start = addr;\n\t*symbol_end   = addr + hdr->pages * PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "aux",
            "&bpf_kallsyms",
            "ksym_lnode"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_jit_kallsyms_enabled",
          "args": [],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t    char *sym)\n{\n\tunsigned long symbol_start, symbol_end;\n\tstruct bpf_prog_aux *aux;\n\tunsigned int it = 0;\n\tint ret = -ERANGE;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn ret;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(aux, &bpf_kallsyms, ksym_lnode) {\n\t\tif (it++ != symnum)\n\t\t\tcontinue;\n\n\t\tbpf_get_prog_addr_region(aux->prog, &symbol_start, &symbol_end);\n\t\tbpf_get_prog_name(aux->prog, sym);\n\n\t\t*value = symbol_start;\n\t\t*type  = BPF_SYM_ELF_TYPE;\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "is_bpf_text_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "542-551",
    "snippet": "bool is_bpf_text_address(unsigned long addr)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = bpf_prog_kallsyms_find(addr) != NULL;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_find",
          "args": [
            "addr"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "505-516",
          "snippet": "static struct bpf_prog *bpf_prog_kallsyms_find(unsigned long addr)\n{\n\tstruct latch_tree_node *n;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn NULL;\n\n\tn = latch_tree_find((void *)addr, &bpf_tree, &bpf_tree_ops);\n\treturn n ?\n\t       container_of(n, struct bpf_prog_aux, ksym_tnode)->prog :\n\t       NULL;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog *bpf_prog_kallsyms_find(unsigned long addr)\n{\n\tstruct latch_tree_node *n;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn NULL;\n\n\tn = latch_tree_find((void *)addr, &bpf_tree, &bpf_tree_ops);\n\treturn n ?\n\t       container_of(n, struct bpf_prog_aux, ksym_tnode)->prog :\n\t       NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nbool is_bpf_text_address(unsigned long addr)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = bpf_prog_kallsyms_find(addr) != NULL;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__bpf_address_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "518-540",
    "snippet": "const char *__bpf_address_lookup(unsigned long addr, unsigned long *size,\n\t\t\t\t unsigned long *off, char *sym)\n{\n\tunsigned long symbol_start, symbol_end;\n\tstruct bpf_prog *prog;\n\tchar *ret = NULL;\n\n\trcu_read_lock();\n\tprog = bpf_prog_kallsyms_find(addr);\n\tif (prog) {\n\t\tbpf_get_prog_addr_region(prog, &symbol_start, &symbol_end);\n\t\tbpf_get_prog_name(prog, sym);\n\n\t\tret = sym;\n\t\tif (size)\n\t\t\t*size = symbol_end - symbol_start;\n\t\tif (off)\n\t\t\t*off  = addr - symbol_start;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_prog_name",
          "args": [
            "prog",
            "sym"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_prog_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "390-411",
          "snippet": "static void bpf_get_prog_name(const struct bpf_prog *prog, char *sym)\n{\n\tconst char *end = sym + KSYM_NAME_LEN;\n\n\tBUILD_BUG_ON(sizeof(\"bpf_prog_\") +\n\t\t     sizeof(prog->tag) * 2 +\n\t\t     /* name has been null terminated.\n\t\t      * We should need +1 for the '_' preceding\n\t\t      * the name.  However, the null character\n\t\t      * is double counted between the name and the\n\t\t      * sizeof(\"bpf_prog_\") above, so we omit\n\t\t      * the +1 here.\n\t\t      */\n\t\t     sizeof(prog->aux->name) > KSYM_NAME_LEN);\n\n\tsym += snprintf(sym, KSYM_NAME_LEN, \"bpf_prog_\");\n\tsym  = bin2hex(sym, prog->tag, sizeof(prog->tag));\n\tif (prog->aux->name[0])\n\t\tsnprintf(sym, (size_t)(end - sym), \"_%s\", prog->aux->name);\n\telse\n\t\t*sym = 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_get_prog_name(const struct bpf_prog *prog, char *sym)\n{\n\tconst char *end = sym + KSYM_NAME_LEN;\n\n\tBUILD_BUG_ON(sizeof(\"bpf_prog_\") +\n\t\t     sizeof(prog->tag) * 2 +\n\t\t     /* name has been null terminated.\n\t\t      * We should need +1 for the '_' preceding\n\t\t      * the name.  However, the null character\n\t\t      * is double counted between the name and the\n\t\t      * sizeof(\"bpf_prog_\") above, so we omit\n\t\t      * the +1 here.\n\t\t      */\n\t\t     sizeof(prog->aux->name) > KSYM_NAME_LEN);\n\n\tsym += snprintf(sym, KSYM_NAME_LEN, \"bpf_prog_\");\n\tsym  = bin2hex(sym, prog->tag, sizeof(prog->tag));\n\tif (prog->aux->name[0])\n\t\tsnprintf(sym, (size_t)(end - sym), \"_%s\", prog->aux->name);\n\telse\n\t\t*sym = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_prog_addr_region",
          "args": [
            "prog",
            "&symbol_start",
            "&symbol_end"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_prog_addr_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "376-388",
          "snippet": "static __always_inline void\nbpf_get_prog_addr_region(const struct bpf_prog *prog,\n\t\t\t unsigned long *symbol_start,\n\t\t\t unsigned long *symbol_end)\n{\n\tconst struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);\n\tunsigned long addr = (unsigned long)hdr;\n\n\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));\n\n\t*symbol_start = addr;\n\t*symbol_end   = addr + hdr->pages * PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic __always_inline void\nbpf_get_prog_addr_region(const struct bpf_prog *prog,\n\t\t\t unsigned long *symbol_start,\n\t\t\t unsigned long *symbol_end)\n{\n\tconst struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);\n\tunsigned long addr = (unsigned long)hdr;\n\n\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));\n\n\t*symbol_start = addr;\n\t*symbol_end   = addr + hdr->pages * PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_find",
          "args": [
            "addr"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "505-516",
          "snippet": "static struct bpf_prog *bpf_prog_kallsyms_find(unsigned long addr)\n{\n\tstruct latch_tree_node *n;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn NULL;\n\n\tn = latch_tree_find((void *)addr, &bpf_tree, &bpf_tree_ops);\n\treturn n ?\n\t       container_of(n, struct bpf_prog_aux, ksym_tnode)->prog :\n\t       NULL;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog *bpf_prog_kallsyms_find(unsigned long addr)\n{\n\tstruct latch_tree_node *n;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn NULL;\n\n\tn = latch_tree_find((void *)addr, &bpf_tree, &bpf_tree_ops);\n\treturn n ?\n\t       container_of(n, struct bpf_prog_aux, ksym_tnode)->prog :\n\t       NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nconst char *__bpf_address_lookup(unsigned long addr, unsigned long *size,\n\t\t\t\t unsigned long *off, char *sym)\n{\n\tunsigned long symbol_start, symbol_end;\n\tstruct bpf_prog *prog;\n\tchar *ret = NULL;\n\n\trcu_read_lock();\n\tprog = bpf_prog_kallsyms_find(addr);\n\tif (prog) {\n\t\tbpf_get_prog_addr_region(prog, &symbol_start, &symbol_end);\n\t\tbpf_get_prog_name(prog, sym);\n\n\t\tret = sym;\n\t\tif (size)\n\t\t\t*size = symbol_end - symbol_start;\n\t\tif (off)\n\t\t\t*off  = addr - symbol_start;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_prog_kallsyms_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "505-516",
    "snippet": "static struct bpf_prog *bpf_prog_kallsyms_find(unsigned long addr)\n{\n\tstruct latch_tree_node *n;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn NULL;\n\n\tn = latch_tree_find((void *)addr, &bpf_tree, &bpf_tree_ops);\n\treturn n ?\n\t       container_of(n, struct bpf_prog_aux, ksym_tnode)->prog :\n\t       NULL;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "n",
            "structbpf_prog_aux",
            "ksym_tnode"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "latch_tree_find",
          "args": [
            "(void *)addr",
            "&bpf_tree",
            "&bpf_tree_ops"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_jit_kallsyms_enabled",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic struct bpf_prog *bpf_prog_kallsyms_find(unsigned long addr)\n{\n\tstruct latch_tree_node *n;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn NULL;\n\n\tn = latch_tree_find((void *)addr, &bpf_tree, &bpf_tree_ops);\n\treturn n ?\n\t       container_of(n, struct bpf_prog_aux, ksym_tnode)->prog :\n\t       NULL;\n}"
  },
  {
    "function_name": "bpf_prog_kallsyms_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "495-503",
    "snippet": "void bpf_prog_kallsyms_del(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp))\n\t\treturn;\n\n\tspin_lock_bh(&bpf_lock);\n\tbpf_prog_ksym_node_del(fp->aux);\n\tspin_unlock_bh(&bpf_lock);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&bpf_lock"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_ksym_node_del",
          "args": [
            "fp->aux"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_ksym_node_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "464-471",
          "snippet": "static void bpf_prog_ksym_node_del(struct bpf_prog_aux *aux)\n{\n\tif (list_empty(&aux->ksym_lnode))\n\t\treturn;\n\n\tlatch_tree_erase(&aux->ksym_tnode, &bpf_tree, &bpf_tree_ops);\n\tlist_del_rcu(&aux->ksym_lnode);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_prog_ksym_node_del(struct bpf_prog_aux *aux)\n{\n\tif (list_empty(&aux->ksym_lnode))\n\t\treturn;\n\n\tlatch_tree_erase(&aux->ksym_tnode, &bpf_tree, &bpf_tree_ops);\n\tlist_del_rcu(&aux->ksym_lnode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&bpf_lock"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_candidate",
          "args": [
            "fp"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "473-476",
          "snippet": "static bool bpf_prog_kallsyms_candidate(const struct bpf_prog *fp)\n{\n\treturn fp->jited && !bpf_prog_was_classic(fp);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic bool bpf_prog_kallsyms_candidate(const struct bpf_prog *fp)\n{\n\treturn fp->jited && !bpf_prog_was_classic(fp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_kallsyms_del(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp))\n\t\treturn;\n\n\tspin_lock_bh(&bpf_lock);\n\tbpf_prog_ksym_node_del(fp->aux);\n\tspin_unlock_bh(&bpf_lock);\n}"
  },
  {
    "function_name": "bpf_prog_kallsyms_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "484-493",
    "snippet": "void bpf_prog_kallsyms_add(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp) ||\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn;\n\n\tspin_lock_bh(&bpf_lock);\n\tbpf_prog_ksym_node_add(fp->aux);\n\tspin_unlock_bh(&bpf_lock);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&bpf_lock"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_ksym_node_add",
          "args": [
            "fp->aux"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_ksym_node_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "457-462",
          "snippet": "static void bpf_prog_ksym_node_add(struct bpf_prog_aux *aux)\n{\n\tWARN_ON_ONCE(!list_empty(&aux->ksym_lnode));\n\tlist_add_tail_rcu(&aux->ksym_lnode, &bpf_kallsyms);\n\tlatch_tree_insert(&aux->ksym_tnode, &bpf_tree, &bpf_tree_ops);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_prog_ksym_node_add(struct bpf_prog_aux *aux)\n{\n\tWARN_ON_ONCE(!list_empty(&aux->ksym_lnode));\n\tlist_add_tail_rcu(&aux->ksym_lnode, &bpf_kallsyms);\n\tlatch_tree_insert(&aux->ksym_tnode, &bpf_tree, &bpf_tree_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&bpf_lock"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_candidate",
          "args": [
            "fp"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "473-476",
          "snippet": "static bool bpf_prog_kallsyms_candidate(const struct bpf_prog *fp)\n{\n\treturn fp->jited && !bpf_prog_was_classic(fp);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic bool bpf_prog_kallsyms_candidate(const struct bpf_prog *fp)\n{\n\treturn fp->jited && !bpf_prog_was_classic(fp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_kallsyms_add(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp) ||\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn;\n\n\tspin_lock_bh(&bpf_lock);\n\tbpf_prog_ksym_node_add(fp->aux);\n\tspin_unlock_bh(&bpf_lock);\n}"
  },
  {
    "function_name": "bpf_prog_kallsyms_verify_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "478-482",
    "snippet": "static bool bpf_prog_kallsyms_verify_off(const struct bpf_prog *fp)\n{\n\treturn list_empty(&fp->aux->ksym_lnode) ||\n\t       fp->aux->ksym_lnode.prev == LIST_POISON2;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fp->aux->ksym_lnode"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic bool bpf_prog_kallsyms_verify_off(const struct bpf_prog *fp)\n{\n\treturn list_empty(&fp->aux->ksym_lnode) ||\n\t       fp->aux->ksym_lnode.prev == LIST_POISON2;\n}"
  },
  {
    "function_name": "bpf_prog_kallsyms_candidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "473-476",
    "snippet": "static bool bpf_prog_kallsyms_candidate(const struct bpf_prog *fp)\n{\n\treturn fp->jited && !bpf_prog_was_classic(fp);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_was_classic",
          "args": [
            "fp"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic bool bpf_prog_kallsyms_candidate(const struct bpf_prog *fp)\n{\n\treturn fp->jited && !bpf_prog_was_classic(fp);\n}"
  },
  {
    "function_name": "bpf_prog_ksym_node_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "464-471",
    "snippet": "static void bpf_prog_ksym_node_del(struct bpf_prog_aux *aux)\n{\n\tif (list_empty(&aux->ksym_lnode))\n\t\treturn;\n\n\tlatch_tree_erase(&aux->ksym_tnode, &bpf_tree, &bpf_tree_ops);\n\tlist_del_rcu(&aux->ksym_lnode);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&aux->ksym_lnode"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "latch_tree_erase",
          "args": [
            "&aux->ksym_tnode",
            "&bpf_tree",
            "&bpf_tree_ops"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&aux->ksym_lnode"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_prog_ksym_node_del(struct bpf_prog_aux *aux)\n{\n\tif (list_empty(&aux->ksym_lnode))\n\t\treturn;\n\n\tlatch_tree_erase(&aux->ksym_tnode, &bpf_tree, &bpf_tree_ops);\n\tlist_del_rcu(&aux->ksym_lnode);\n}"
  },
  {
    "function_name": "bpf_prog_ksym_node_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "457-462",
    "snippet": "static void bpf_prog_ksym_node_add(struct bpf_prog_aux *aux)\n{\n\tWARN_ON_ONCE(!list_empty(&aux->ksym_lnode));\n\tlist_add_tail_rcu(&aux->ksym_lnode, &bpf_kallsyms);\n\tlatch_tree_insert(&aux->ksym_tnode, &bpf_tree, &bpf_tree_ops);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "latch_tree_insert",
          "args": [
            "&aux->ksym_tnode",
            "&bpf_tree",
            "&bpf_tree_ops"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&aux->ksym_lnode",
            "&bpf_kallsyms"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&aux->ksym_lnode)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&aux->ksym_lnode"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_prog_ksym_node_add(struct bpf_prog_aux *aux)\n{\n\tWARN_ON_ONCE(!list_empty(&aux->ksym_lnode));\n\tlist_add_tail_rcu(&aux->ksym_lnode, &bpf_kallsyms);\n\tlatch_tree_insert(&aux->ksym_tnode, &bpf_tree, &bpf_tree_ops);\n}"
  },
  {
    "function_name": "bpf_tree_comp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "431-446",
    "snippet": "static __always_inline int bpf_tree_comp(void *key, struct latch_tree_node *n)\n{\n\tunsigned long val = (unsigned long)key;\n\tunsigned long symbol_start, symbol_end;\n\tconst struct bpf_prog_aux *aux;\n\n\taux = container_of(n, struct bpf_prog_aux, ksym_tnode);\n\tbpf_get_prog_addr_region(aux->prog, &symbol_start, &symbol_end);\n\n\tif (val < symbol_start)\n\t\treturn -1;\n\tif (val >= symbol_end)\n\t\treturn  1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_get_prog_addr_region",
          "args": [
            "aux->prog",
            "&symbol_start",
            "&symbol_end"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_prog_addr_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "376-388",
          "snippet": "static __always_inline void\nbpf_get_prog_addr_region(const struct bpf_prog *prog,\n\t\t\t unsigned long *symbol_start,\n\t\t\t unsigned long *symbol_end)\n{\n\tconst struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);\n\tunsigned long addr = (unsigned long)hdr;\n\n\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));\n\n\t*symbol_start = addr;\n\t*symbol_end   = addr + hdr->pages * PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic __always_inline void\nbpf_get_prog_addr_region(const struct bpf_prog *prog,\n\t\t\t unsigned long *symbol_start,\n\t\t\t unsigned long *symbol_end)\n{\n\tconst struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);\n\tunsigned long addr = (unsigned long)hdr;\n\n\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));\n\n\t*symbol_start = addr;\n\t*symbol_end   = addr + hdr->pages * PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "n",
            "structbpf_prog_aux",
            "ksym_tnode"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic __always_inline int bpf_tree_comp(void *key, struct latch_tree_node *n)\n{\n\tunsigned long val = (unsigned long)key;\n\tunsigned long symbol_start, symbol_end;\n\tconst struct bpf_prog_aux *aux;\n\n\taux = container_of(n, struct bpf_prog_aux, ksym_tnode);\n\tbpf_get_prog_addr_region(aux->prog, &symbol_start, &symbol_end);\n\n\tif (val < symbol_start)\n\t\treturn -1;\n\tif (val >= symbol_end)\n\t\treturn  1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_tree_less",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "425-429",
    "snippet": "static __always_inline bool bpf_tree_less(struct latch_tree_node *a,\n\t\t\t\t\t  struct latch_tree_node *b)\n{\n\treturn bpf_get_prog_addr_start(a) < bpf_get_prog_addr_start(b);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_get_prog_addr_start",
          "args": [
            "b"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_prog_addr_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "413-423",
          "snippet": "static __always_inline unsigned long\nbpf_get_prog_addr_start(struct latch_tree_node *n)\n{\n\tunsigned long symbol_start, symbol_end;\n\tconst struct bpf_prog_aux *aux;\n\n\taux = container_of(n, struct bpf_prog_aux, ksym_tnode);\n\tbpf_get_prog_addr_region(aux->prog, &symbol_start, &symbol_end);\n\n\treturn symbol_start;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic __always_inline unsigned long\nbpf_get_prog_addr_start(struct latch_tree_node *n)\n{\n\tunsigned long symbol_start, symbol_end;\n\tconst struct bpf_prog_aux *aux;\n\n\taux = container_of(n, struct bpf_prog_aux, ksym_tnode);\n\tbpf_get_prog_addr_region(aux->prog, &symbol_start, &symbol_end);\n\n\treturn symbol_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic __always_inline bool bpf_tree_less(struct latch_tree_node *a,\n\t\t\t\t\t  struct latch_tree_node *b)\n{\n\treturn bpf_get_prog_addr_start(a) < bpf_get_prog_addr_start(b);\n}"
  },
  {
    "function_name": "bpf_get_prog_addr_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "413-423",
    "snippet": "static __always_inline unsigned long\nbpf_get_prog_addr_start(struct latch_tree_node *n)\n{\n\tunsigned long symbol_start, symbol_end;\n\tconst struct bpf_prog_aux *aux;\n\n\taux = container_of(n, struct bpf_prog_aux, ksym_tnode);\n\tbpf_get_prog_addr_region(aux->prog, &symbol_start, &symbol_end);\n\n\treturn symbol_start;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_get_prog_addr_region",
          "args": [
            "aux->prog",
            "&symbol_start",
            "&symbol_end"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_prog_addr_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "376-388",
          "snippet": "static __always_inline void\nbpf_get_prog_addr_region(const struct bpf_prog *prog,\n\t\t\t unsigned long *symbol_start,\n\t\t\t unsigned long *symbol_end)\n{\n\tconst struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);\n\tunsigned long addr = (unsigned long)hdr;\n\n\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));\n\n\t*symbol_start = addr;\n\t*symbol_end   = addr + hdr->pages * PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic __always_inline void\nbpf_get_prog_addr_region(const struct bpf_prog *prog,\n\t\t\t unsigned long *symbol_start,\n\t\t\t unsigned long *symbol_end)\n{\n\tconst struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);\n\tunsigned long addr = (unsigned long)hdr;\n\n\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));\n\n\t*symbol_start = addr;\n\t*symbol_end   = addr + hdr->pages * PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "n",
            "structbpf_prog_aux",
            "ksym_tnode"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic __always_inline unsigned long\nbpf_get_prog_addr_start(struct latch_tree_node *n)\n{\n\tunsigned long symbol_start, symbol_end;\n\tconst struct bpf_prog_aux *aux;\n\n\taux = container_of(n, struct bpf_prog_aux, ksym_tnode);\n\tbpf_get_prog_addr_region(aux->prog, &symbol_start, &symbol_end);\n\n\treturn symbol_start;\n}"
  },
  {
    "function_name": "bpf_get_prog_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "390-411",
    "snippet": "static void bpf_get_prog_name(const struct bpf_prog *prog, char *sym)\n{\n\tconst char *end = sym + KSYM_NAME_LEN;\n\n\tBUILD_BUG_ON(sizeof(\"bpf_prog_\") +\n\t\t     sizeof(prog->tag) * 2 +\n\t\t     /* name has been null terminated.\n\t\t      * We should need +1 for the '_' preceding\n\t\t      * the name.  However, the null character\n\t\t      * is double counted between the name and the\n\t\t      * sizeof(\"bpf_prog_\") above, so we omit\n\t\t      * the +1 here.\n\t\t      */\n\t\t     sizeof(prog->aux->name) > KSYM_NAME_LEN);\n\n\tsym += snprintf(sym, KSYM_NAME_LEN, \"bpf_prog_\");\n\tsym  = bin2hex(sym, prog->tag, sizeof(prog->tag));\n\tif (prog->aux->name[0])\n\t\tsnprintf(sym, (size_t)(end - sym), \"_%s\", prog->aux->name);\n\telse\n\t\t*sym = 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sym",
            "(size_t)(end - sym)",
            "\"_%s\"",
            "prog->aux->name"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin2hex",
          "args": [
            "sym",
            "prog->tag",
            "sizeof(prog->tag)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sym",
            "KSYM_NAME_LEN",
            "\"bpf_prog_\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(\"bpf_prog_\") +\n\t\t     sizeof(prog->tag) * 2 +\n\t\t     /* name has been null terminated.\n\t\t      * We should need +1 for the '_' preceding\n\t\t      * the name.  However, the null character\n\t\t      * is double counted between the name and the\n\t\t      * sizeof(\"bpf_prog_\") above, so we omit\n\t\t      * the +1 here.\n\t\t      */\n\t\t     sizeof(prog->aux->name) > KSYM_NAME_LEN"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic void bpf_get_prog_name(const struct bpf_prog *prog, char *sym)\n{\n\tconst char *end = sym + KSYM_NAME_LEN;\n\n\tBUILD_BUG_ON(sizeof(\"bpf_prog_\") +\n\t\t     sizeof(prog->tag) * 2 +\n\t\t     /* name has been null terminated.\n\t\t      * We should need +1 for the '_' preceding\n\t\t      * the name.  However, the null character\n\t\t      * is double counted between the name and the\n\t\t      * sizeof(\"bpf_prog_\") above, so we omit\n\t\t      * the +1 here.\n\t\t      */\n\t\t     sizeof(prog->aux->name) > KSYM_NAME_LEN);\n\n\tsym += snprintf(sym, KSYM_NAME_LEN, \"bpf_prog_\");\n\tsym  = bin2hex(sym, prog->tag, sizeof(prog->tag));\n\tif (prog->aux->name[0])\n\t\tsnprintf(sym, (size_t)(end - sym), \"_%s\", prog->aux->name);\n\telse\n\t\t*sym = 0;\n}"
  },
  {
    "function_name": "bpf_get_prog_addr_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "376-388",
    "snippet": "static __always_inline void\nbpf_get_prog_addr_region(const struct bpf_prog *prog,\n\t\t\t unsigned long *symbol_start,\n\t\t\t unsigned long *symbol_end)\n{\n\tconst struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);\n\tunsigned long addr = (unsigned long)hdr;\n\n\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));\n\n\t*symbol_start = addr;\n\t*symbol_end   = addr + hdr->pages * PAGE_SIZE;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!bpf_prog_ebpf_jited(prog)"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_ebpf_jited",
          "args": [
            "prog"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_jit_binary_hdr",
          "args": [
            "prog"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic __always_inline void\nbpf_get_prog_addr_region(const struct bpf_prog *prog,\n\t\t\t unsigned long *symbol_start,\n\t\t\t unsigned long *symbol_end)\n{\n\tconst struct bpf_binary_header *hdr = bpf_jit_binary_hdr(prog);\n\tunsigned long addr = (unsigned long)hdr;\n\n\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));\n\n\t*symbol_start = addr;\n\t*symbol_end   = addr + hdr->pages * PAGE_SIZE;\n}"
  },
  {
    "function_name": "bpf_prog_kallsyms_del_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "361-365",
    "snippet": "void bpf_prog_kallsyms_del_all(struct bpf_prog *fp)\n{\n\tbpf_prog_kallsyms_del_subprogs(fp);\n\tbpf_prog_kallsyms_del(fp);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_del",
          "args": [
            "fp"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "495-503",
          "snippet": "void bpf_prog_kallsyms_del(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp))\n\t\treturn;\n\n\tspin_lock_bh(&bpf_lock);\n\tbpf_prog_ksym_node_del(fp->aux);\n\tspin_unlock_bh(&bpf_lock);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_kallsyms_del(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp))\n\t\treturn;\n\n\tspin_lock_bh(&bpf_lock);\n\tbpf_prog_ksym_node_del(fp->aux);\n\tspin_unlock_bh(&bpf_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_del_subprogs",
          "args": [
            "fp"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_del_subprogs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "353-359",
          "snippet": "void bpf_prog_kallsyms_del_subprogs(struct bpf_prog *fp)\n{\n\tint i;\n\n\tfor (i = 0; i < fp->aux->func_cnt; i++)\n\t\tbpf_prog_kallsyms_del(fp->aux->func[i]);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_kallsyms_del_subprogs(struct bpf_prog *fp)\n{\n\tint i;\n\n\tfor (i = 0; i < fp->aux->func_cnt; i++)\n\t\tbpf_prog_kallsyms_del(fp->aux->func[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_kallsyms_del_all(struct bpf_prog *fp)\n{\n\tbpf_prog_kallsyms_del_subprogs(fp);\n\tbpf_prog_kallsyms_del(fp);\n}"
  },
  {
    "function_name": "bpf_prog_kallsyms_del_subprogs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "353-359",
    "snippet": "void bpf_prog_kallsyms_del_subprogs(struct bpf_prog *fp)\n{\n\tint i;\n\n\tfor (i = 0; i < fp->aux->func_cnt; i++)\n\t\tbpf_prog_kallsyms_del(fp->aux->func[i]);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_del",
          "args": [
            "fp->aux->func[i]"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "495-503",
          "snippet": "void bpf_prog_kallsyms_del(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp))\n\t\treturn;\n\n\tspin_lock_bh(&bpf_lock);\n\tbpf_prog_ksym_node_del(fp->aux);\n\tspin_unlock_bh(&bpf_lock);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_kallsyms_del(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp))\n\t\treturn;\n\n\tspin_lock_bh(&bpf_lock);\n\tbpf_prog_ksym_node_del(fp->aux);\n\tspin_unlock_bh(&bpf_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_kallsyms_del_subprogs(struct bpf_prog *fp)\n{\n\tint i;\n\n\tfor (i = 0; i < fp->aux->func_cnt; i++)\n\t\tbpf_prog_kallsyms_del(fp->aux->func[i]);\n}"
  },
  {
    "function_name": "bpf_patch_insn_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "295-351",
    "snippet": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tconst u32 cnt_max = S16_MAX;\n\tstruct bpf_prog *prog_adj;\n\n\t/* Since our patchlet doesn't expand the image, we're done. */\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\n\tinsn_adj_cnt = prog->len + insn_delta;\n\n\t/* Reject anything that would potentially let the insn->off\n\t * target overflow when we have excessive program expansions.\n\t * We need to probe here before we do any reallocation where\n\t * we afterwards may not fail anymore.\n\t */\n\tif (insn_adj_cnt > cnt_max &&\n\t    bpf_adj_branches(prog, off, insn_delta, true))\n\t\treturn NULL;\n\n\t/* Several new instructions need to be inserted. Make room\n\t * for them. Likely, there's no need for a new allocation as\n\t * last page could have large enough tailroom.\n\t */\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\n\tprog_adj->len = insn_adj_cnt;\n\n\t/* Patching happens in 3 steps:\n\t *\n\t * 1) Move over tail of insnsi from next instruction onwards,\n\t *    so we can patch the single target insn with one or more\n\t *    new ones (patching is always from 1 to n insns, n > 0).\n\t * 2) Inject new instructions at the target location.\n\t * 3) Adjust branch offsets if necessary.\n\t */\n\tinsn_rest = insn_adj_cnt - off - len;\n\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\n\t/* We are guaranteed to not fail at this point, otherwise\n\t * the ship has sailed to reverse to the original state. An\n\t * overflow cannot happen at this point.\n\t */\n\tBUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));\n\n\treturn prog_adj;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bpf_adj_branches(prog_adj, off, insn_delta, false)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_adj_branches",
          "args": [
            "prog_adj",
            "off",
            "insn_delta",
            "false"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_adj_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "256-293",
          "snippet": "static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,\n\t\t\t    const bool probe_pass)\n{\n\tu32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint ret = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tu8 code;\n\n\t\t/* In the probing pass we still operate on the original,\n\t\t * unpatched image in order to check overflows before we\n\t\t * do any other adjustments. Therefore skip the patchlet.\n\t\t */\n\t\tif (probe_pass && i == pos) {\n\t\t\ti += delta + 1;\n\t\t\tinsn++;\n\t\t}\n\t\tcode = insn->code;\n\t\tif (BPF_CLASS(code) != BPF_JMP ||\n\t\t    BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\t/* Adjust offset of jmps if we cross patch boundaries. */\n\t\tif (BPF_OP(code) == BPF_CALL) {\n\t\t\tif (insn->src_reg != BPF_PSEUDO_CALL)\n\t\t\t\tcontinue;\n\t\t\tret = bpf_adj_delta_to_imm(insn, pos, delta, i,\n\t\t\t\t\t\t   probe_pass);\n\t\t} else {\n\t\t\tret = bpf_adj_delta_to_off(insn, pos, delta, i,\n\t\t\t\t\t\t   probe_pass);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,\n\t\t\t    const bool probe_pass)\n{\n\tu32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint ret = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tu8 code;\n\n\t\t/* In the probing pass we still operate on the original,\n\t\t * unpatched image in order to check overflows before we\n\t\t * do any other adjustments. Therefore skip the patchlet.\n\t\t */\n\t\tif (probe_pass && i == pos) {\n\t\t\ti += delta + 1;\n\t\t\tinsn++;\n\t\t}\n\t\tcode = insn->code;\n\t\tif (BPF_CLASS(code) != BPF_JMP ||\n\t\t    BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\t/* Adjust offset of jmps if we cross patch boundaries. */\n\t\tif (BPF_OP(code) == BPF_CALL) {\n\t\t\tif (insn->src_reg != BPF_PSEUDO_CALL)\n\t\t\t\tcontinue;\n\t\t\tret = bpf_adj_delta_to_imm(insn, pos, delta, i,\n\t\t\t\t\t\t   probe_pass);\n\t\t} else {\n\t\t\tret = bpf_adj_delta_to_off(insn, pos, delta, i,\n\t\t\t\t\t\t   probe_pass);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "prog_adj->insnsi + off",
            "patch",
            "sizeof(*patch) * len"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "prog_adj->insnsi + off + len",
            "prog_adj->insnsi + off + 1",
            "sizeof(*patch) * insn_rest"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_realloc",
          "args": [
            "prog",
            "bpf_prog_size(insn_adj_cnt)",
            "GFP_USER"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "106-142",
          "snippet": "struct bpf_prog *bpf_prog_realloc(struct bpf_prog *fp_old, unsigned int size,\n\t\t\t\t  gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog *fp;\n\tu32 pages, delta;\n\tint ret;\n\n\tBUG_ON(fp_old == NULL);\n\n\tsize = round_up(size, PAGE_SIZE);\n\tpages = size / PAGE_SIZE;\n\tif (pages <= fp_old->pages)\n\t\treturn fp_old;\n\n\tdelta = pages - fp_old->pages;\n\tret = __bpf_prog_charge(fp_old->aux->user, delta);\n\tif (ret)\n\t\treturn NULL;\n\n\tfp = __vmalloc(size, gfp_flags, PAGE_KERNEL);\n\tif (fp == NULL) {\n\t\t__bpf_prog_uncharge(fp_old->aux->user, delta);\n\t} else {\n\t\tmemcpy(fp, fp_old, fp_old->pages * PAGE_SIZE);\n\t\tfp->pages = pages;\n\t\tfp->aux->prog = fp;\n\n\t\t/* We keep fp->aux from fp_old around in the new\n\t\t * reallocated structure.\n\t\t */\n\t\tfp_old->aux = NULL;\n\t\t__bpf_prog_free(fp_old);\n\t}\n\n\treturn fp;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstruct bpf_prog *bpf_prog_realloc(struct bpf_prog *fp_old, unsigned int size,\n\t\t\t\t  gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog *fp;\n\tu32 pages, delta;\n\tint ret;\n\n\tBUG_ON(fp_old == NULL);\n\n\tsize = round_up(size, PAGE_SIZE);\n\tpages = size / PAGE_SIZE;\n\tif (pages <= fp_old->pages)\n\t\treturn fp_old;\n\n\tdelta = pages - fp_old->pages;\n\tret = __bpf_prog_charge(fp_old->aux->user, delta);\n\tif (ret)\n\t\treturn NULL;\n\n\tfp = __vmalloc(size, gfp_flags, PAGE_KERNEL);\n\tif (fp == NULL) {\n\t\t__bpf_prog_uncharge(fp_old->aux->user, delta);\n\t} else {\n\t\tmemcpy(fp, fp_old, fp_old->pages * PAGE_SIZE);\n\t\tfp->pages = pages;\n\t\tfp->aux->prog = fp;\n\n\t\t/* We keep fp->aux from fp_old around in the new\n\t\t * reallocated structure.\n\t\t */\n\t\tfp_old->aux = NULL;\n\t\t__bpf_prog_free(fp_old);\n\t}\n\n\treturn fp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_size",
          "args": [
            "insn_adj_cnt"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstruct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tconst u32 cnt_max = S16_MAX;\n\tstruct bpf_prog *prog_adj;\n\n\t/* Since our patchlet doesn't expand the image, we're done. */\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\n\tinsn_adj_cnt = prog->len + insn_delta;\n\n\t/* Reject anything that would potentially let the insn->off\n\t * target overflow when we have excessive program expansions.\n\t * We need to probe here before we do any reallocation where\n\t * we afterwards may not fail anymore.\n\t */\n\tif (insn_adj_cnt > cnt_max &&\n\t    bpf_adj_branches(prog, off, insn_delta, true))\n\t\treturn NULL;\n\n\t/* Several new instructions need to be inserted. Make room\n\t * for them. Likely, there's no need for a new allocation as\n\t * last page could have large enough tailroom.\n\t */\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\n\tprog_adj->len = insn_adj_cnt;\n\n\t/* Patching happens in 3 steps:\n\t *\n\t * 1) Move over tail of insnsi from next instruction onwards,\n\t *    so we can patch the single target insn with one or more\n\t *    new ones (patching is always from 1 to n insns, n > 0).\n\t * 2) Inject new instructions at the target location.\n\t * 3) Adjust branch offsets if necessary.\n\t */\n\tinsn_rest = insn_adj_cnt - off - len;\n\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\n\t/* We are guaranteed to not fail at this point, otherwise\n\t * the ship has sailed to reverse to the original state. An\n\t * overflow cannot happen at this point.\n\t */\n\tBUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));\n\n\treturn prog_adj;\n}"
  },
  {
    "function_name": "bpf_adj_branches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "256-293",
    "snippet": "static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,\n\t\t\t    const bool probe_pass)\n{\n\tu32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint ret = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tu8 code;\n\n\t\t/* In the probing pass we still operate on the original,\n\t\t * unpatched image in order to check overflows before we\n\t\t * do any other adjustments. Therefore skip the patchlet.\n\t\t */\n\t\tif (probe_pass && i == pos) {\n\t\t\ti += delta + 1;\n\t\t\tinsn++;\n\t\t}\n\t\tcode = insn->code;\n\t\tif (BPF_CLASS(code) != BPF_JMP ||\n\t\t    BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\t/* Adjust offset of jmps if we cross patch boundaries. */\n\t\tif (BPF_OP(code) == BPF_CALL) {\n\t\t\tif (insn->src_reg != BPF_PSEUDO_CALL)\n\t\t\t\tcontinue;\n\t\t\tret = bpf_adj_delta_to_imm(insn, pos, delta, i,\n\t\t\t\t\t\t   probe_pass);\n\t\t} else {\n\t\t\tret = bpf_adj_delta_to_off(insn, pos, delta, i,\n\t\t\t\t\t\t   probe_pass);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_adj_delta_to_off",
          "args": [
            "insn",
            "pos",
            "delta",
            "i",
            "probe_pass"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_adj_delta_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "239-254",
          "snippet": "static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s32 off_min = S16_MIN, off_max = S16_MAX;\n\ts32 off = insn->off;\n\n\tif (curr < pos && curr + off + 1 > pos)\n\t\toff += delta;\n\telse if (curr > pos + delta && curr + off + 1 <= pos + delta)\n\t\toff -= delta;\n\tif (off < off_min || off > off_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->off = off;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s32 off_min = S16_MIN, off_max = S16_MAX;\n\ts32 off = insn->off;\n\n\tif (curr < pos && curr + off + 1 > pos)\n\t\toff += delta;\n\telse if (curr > pos + delta && curr + off + 1 <= pos + delta)\n\t\toff -= delta;\n\tif (off < off_min || off > off_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->off = off;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_adj_delta_to_imm",
          "args": [
            "insn",
            "pos",
            "delta",
            "i",
            "probe_pass"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_adj_delta_to_imm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "222-237",
          "snippet": "static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s64 imm_min = S32_MIN, imm_max = S32_MAX;\n\ts64 imm = insn->imm;\n\n\tif (curr < pos && curr + imm + 1 > pos)\n\t\timm += delta;\n\telse if (curr > pos + delta && curr + imm + 1 <= pos + delta)\n\t\timm -= delta;\n\tif (imm < imm_min || imm > imm_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->imm = imm;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s64 imm_min = S32_MIN, imm_max = S32_MAX;\n\ts64 imm = insn->imm;\n\n\tif (curr < pos && curr + imm + 1 > pos)\n\t\timm += delta;\n\telse if (curr > pos + delta && curr + imm + 1 <= pos + delta)\n\t\timm -= delta;\n\tif (imm < imm_min || imm > imm_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->imm = imm;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "code"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "code"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_CLASS",
          "args": [
            "code"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,\n\t\t\t    const bool probe_pass)\n{\n\tu32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint ret = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tu8 code;\n\n\t\t/* In the probing pass we still operate on the original,\n\t\t * unpatched image in order to check overflows before we\n\t\t * do any other adjustments. Therefore skip the patchlet.\n\t\t */\n\t\tif (probe_pass && i == pos) {\n\t\t\ti += delta + 1;\n\t\t\tinsn++;\n\t\t}\n\t\tcode = insn->code;\n\t\tif (BPF_CLASS(code) != BPF_JMP ||\n\t\t    BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\t/* Adjust offset of jmps if we cross patch boundaries. */\n\t\tif (BPF_OP(code) == BPF_CALL) {\n\t\t\tif (insn->src_reg != BPF_PSEUDO_CALL)\n\t\t\t\tcontinue;\n\t\t\tret = bpf_adj_delta_to_imm(insn, pos, delta, i,\n\t\t\t\t\t\t   probe_pass);\n\t\t} else {\n\t\t\tret = bpf_adj_delta_to_off(insn, pos, delta, i,\n\t\t\t\t\t\t   probe_pass);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_adj_delta_to_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "239-254",
    "snippet": "static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s32 off_min = S16_MIN, off_max = S16_MAX;\n\ts32 off = insn->off;\n\n\tif (curr < pos && curr + off + 1 > pos)\n\t\toff += delta;\n\telse if (curr > pos + delta && curr + off + 1 <= pos + delta)\n\t\toff -= delta;\n\tif (off < off_min || off > off_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->off = off;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s32 off_min = S16_MIN, off_max = S16_MAX;\n\ts32 off = insn->off;\n\n\tif (curr < pos && curr + off + 1 > pos)\n\t\toff += delta;\n\telse if (curr > pos + delta && curr + off + 1 <= pos + delta)\n\t\toff -= delta;\n\tif (off < off_min || off > off_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->off = off;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_adj_delta_to_imm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "222-237",
    "snippet": "static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s64 imm_min = S32_MIN, imm_max = S32_MAX;\n\ts64 imm = insn->imm;\n\n\tif (curr < pos && curr + imm + 1 > pos)\n\t\timm += delta;\n\telse if (curr > pos + delta && curr + imm + 1 <= pos + delta)\n\t\timm -= delta;\n\tif (imm < imm_min || imm > imm_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->imm = imm;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstatic int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s64 imm_min = S32_MIN, imm_max = S32_MAX;\n\ts64 imm = insn->imm;\n\n\tif (curr < pos && curr + imm + 1 > pos)\n\t\timm += delta;\n\telse if (curr > pos + delta && curr + imm + 1 <= pos + delta)\n\t\timm -= delta;\n\tif (imm < imm_min || imm > imm_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->imm = imm;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_prog_calc_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "150-220",
    "snippet": "int bpf_prog_calc_tag(struct bpf_prog *fp)\n{\n\tconst u32 bits_offset = SHA_MESSAGE_BYTES - sizeof(__be64);\n\tu32 raw_size = bpf_prog_tag_scratch_size(fp);\n\tu32 digest[SHA_DIGEST_WORDS];\n\tu32 ws[SHA_WORKSPACE_WORDS];\n\tu32 i, bsize, psize, blocks;\n\tstruct bpf_insn *dst;\n\tbool was_ld_map;\n\tu8 *raw, *todo;\n\t__be32 *result;\n\t__be64 *bits;\n\n\traw = vmalloc(raw_size);\n\tif (!raw)\n\t\treturn -ENOMEM;\n\n\tsha_init(digest);\n\tmemset(ws, 0, sizeof(ws));\n\n\t/* We need to take out the map fd for the digest calculation\n\t * since they are unstable from user space side.\n\t */\n\tdst = (void *)raw;\n\tfor (i = 0, was_ld_map = false; i < fp->len; i++) {\n\t\tdst[i] = fp->insnsi[i];\n\t\tif (!was_ld_map &&\n\t\t    dst[i].code == (BPF_LD | BPF_IMM | BPF_DW) &&\n\t\t    dst[i].src_reg == BPF_PSEUDO_MAP_FD) {\n\t\t\twas_ld_map = true;\n\t\t\tdst[i].imm = 0;\n\t\t} else if (was_ld_map &&\n\t\t\t   dst[i].code == 0 &&\n\t\t\t   dst[i].dst_reg == 0 &&\n\t\t\t   dst[i].src_reg == 0 &&\n\t\t\t   dst[i].off == 0) {\n\t\t\twas_ld_map = false;\n\t\t\tdst[i].imm = 0;\n\t\t} else {\n\t\t\twas_ld_map = false;\n\t\t}\n\t}\n\n\tpsize = bpf_prog_insn_size(fp);\n\tmemset(&raw[psize], 0, raw_size - psize);\n\traw[psize++] = 0x80;\n\n\tbsize  = round_up(psize, SHA_MESSAGE_BYTES);\n\tblocks = bsize / SHA_MESSAGE_BYTES;\n\ttodo   = raw;\n\tif (bsize - psize >= sizeof(__be64)) {\n\t\tbits = (__be64 *)(todo + bsize - sizeof(__be64));\n\t} else {\n\t\tbits = (__be64 *)(todo + bsize + bits_offset);\n\t\tblocks++;\n\t}\n\t*bits = cpu_to_be64((psize - 1) << 3);\n\n\twhile (blocks--) {\n\t\tsha_transform(digest, todo, ws);\n\t\ttodo += SHA_MESSAGE_BYTES;\n\t}\n\n\tresult = (__force __be32 *)digest;\n\tfor (i = 0; i < SHA_DIGEST_WORDS; i++)\n\t\tresult[i] = cpu_to_be32(digest[i]);\n\tmemcpy(fp->tag, result, sizeof(fp->tag));\n\n\tvfree(raw);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "raw"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fp->tag",
            "result",
            "sizeof(fp->tag)"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "digest[i]"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sha_transform",
          "args": [
            "digest",
            "todo",
            "ws"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "(psize - 1) << 3"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "psize",
            "SHA_MESSAGE_BYTES"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&raw[psize]",
            "0",
            "raw_size - psize"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_insn_size",
          "args": [
            "fp"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ws",
            "0",
            "sizeof(ws)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sha_init",
          "args": [
            "digest"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "raw_size"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_tag_scratch_size",
          "args": [
            "fp"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_calc_tag(struct bpf_prog *fp)\n{\n\tconst u32 bits_offset = SHA_MESSAGE_BYTES - sizeof(__be64);\n\tu32 raw_size = bpf_prog_tag_scratch_size(fp);\n\tu32 digest[SHA_DIGEST_WORDS];\n\tu32 ws[SHA_WORKSPACE_WORDS];\n\tu32 i, bsize, psize, blocks;\n\tstruct bpf_insn *dst;\n\tbool was_ld_map;\n\tu8 *raw, *todo;\n\t__be32 *result;\n\t__be64 *bits;\n\n\traw = vmalloc(raw_size);\n\tif (!raw)\n\t\treturn -ENOMEM;\n\n\tsha_init(digest);\n\tmemset(ws, 0, sizeof(ws));\n\n\t/* We need to take out the map fd for the digest calculation\n\t * since they are unstable from user space side.\n\t */\n\tdst = (void *)raw;\n\tfor (i = 0, was_ld_map = false; i < fp->len; i++) {\n\t\tdst[i] = fp->insnsi[i];\n\t\tif (!was_ld_map &&\n\t\t    dst[i].code == (BPF_LD | BPF_IMM | BPF_DW) &&\n\t\t    dst[i].src_reg == BPF_PSEUDO_MAP_FD) {\n\t\t\twas_ld_map = true;\n\t\t\tdst[i].imm = 0;\n\t\t} else if (was_ld_map &&\n\t\t\t   dst[i].code == 0 &&\n\t\t\t   dst[i].dst_reg == 0 &&\n\t\t\t   dst[i].src_reg == 0 &&\n\t\t\t   dst[i].off == 0) {\n\t\t\twas_ld_map = false;\n\t\t\tdst[i].imm = 0;\n\t\t} else {\n\t\t\twas_ld_map = false;\n\t\t}\n\t}\n\n\tpsize = bpf_prog_insn_size(fp);\n\tmemset(&raw[psize], 0, raw_size - psize);\n\traw[psize++] = 0x80;\n\n\tbsize  = round_up(psize, SHA_MESSAGE_BYTES);\n\tblocks = bsize / SHA_MESSAGE_BYTES;\n\ttodo   = raw;\n\tif (bsize - psize >= sizeof(__be64)) {\n\t\tbits = (__be64 *)(todo + bsize - sizeof(__be64));\n\t} else {\n\t\tbits = (__be64 *)(todo + bsize + bits_offset);\n\t\tblocks++;\n\t}\n\t*bits = cpu_to_be64((psize - 1) << 3);\n\n\twhile (blocks--) {\n\t\tsha_transform(digest, todo, ws);\n\t\ttodo += SHA_MESSAGE_BYTES;\n\t}\n\n\tresult = (__force __be32 *)digest;\n\tfor (i = 0; i < SHA_DIGEST_WORDS; i++)\n\t\tresult[i] = cpu_to_be32(digest[i]);\n\tmemcpy(fp->tag, result, sizeof(fp->tag));\n\n\tvfree(raw);\n\treturn 0;\n}"
  },
  {
    "function_name": "__bpf_prog_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "144-148",
    "snippet": "void __bpf_prog_free(struct bpf_prog *fp)\n{\n\tkfree(fp->aux);\n\tvfree(fp);\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "fp"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fp->aux"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid __bpf_prog_free(struct bpf_prog *fp)\n{\n\tkfree(fp->aux);\n\tvfree(fp);\n}"
  },
  {
    "function_name": "bpf_prog_realloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "106-142",
    "snippet": "struct bpf_prog *bpf_prog_realloc(struct bpf_prog *fp_old, unsigned int size,\n\t\t\t\t  gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog *fp;\n\tu32 pages, delta;\n\tint ret;\n\n\tBUG_ON(fp_old == NULL);\n\n\tsize = round_up(size, PAGE_SIZE);\n\tpages = size / PAGE_SIZE;\n\tif (pages <= fp_old->pages)\n\t\treturn fp_old;\n\n\tdelta = pages - fp_old->pages;\n\tret = __bpf_prog_charge(fp_old->aux->user, delta);\n\tif (ret)\n\t\treturn NULL;\n\n\tfp = __vmalloc(size, gfp_flags, PAGE_KERNEL);\n\tif (fp == NULL) {\n\t\t__bpf_prog_uncharge(fp_old->aux->user, delta);\n\t} else {\n\t\tmemcpy(fp, fp_old, fp_old->pages * PAGE_SIZE);\n\t\tfp->pages = pages;\n\t\tfp->aux->prog = fp;\n\n\t\t/* We keep fp->aux from fp_old around in the new\n\t\t * reallocated structure.\n\t\t */\n\t\tfp_old->aux = NULL;\n\t\t__bpf_prog_free(fp_old);\n\t}\n\n\treturn fp;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_prog_free",
          "args": [
            "fp_old"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "144-148",
          "snippet": "void __bpf_prog_free(struct bpf_prog *fp)\n{\n\tkfree(fp->aux);\n\tvfree(fp);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid __bpf_prog_free(struct bpf_prog *fp)\n{\n\tkfree(fp->aux);\n\tvfree(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fp",
            "fp_old",
            "fp_old->pages * PAGE_SIZE"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_prog_uncharge",
          "args": [
            "fp_old->aux->user",
            "delta"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1128-1132",
          "snippet": "void __bpf_prog_uncharge(struct user_struct *user, u32 pages)\n{\n\tif (user)\n\t\tatomic_long_sub(pages, &user->locked_vm);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid __bpf_prog_uncharge(struct user_struct *user, u32 pages)\n{\n\tif (user)\n\t\tatomic_long_sub(pages, &user->locked_vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "size",
            "gfp_flags",
            "PAGE_KERNEL"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_prog_charge",
          "args": [
            "fp_old->aux->user",
            "delta"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1112-1126",
          "snippet": "int __bpf_prog_charge(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tunsigned long user_bufs;\n\n\tif (user) {\n\t\tuser_bufs = atomic_long_add_return(pages, &user->locked_vm);\n\t\tif (user_bufs > memlock_limit) {\n\t\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint __bpf_prog_charge(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tunsigned long user_bufs;\n\n\tif (user) {\n\t\tuser_bufs = atomic_long_add_return(pages, &user->locked_vm);\n\t\tif (user_bufs > memlock_limit) {\n\t\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "size",
            "PAGE_SIZE"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fp_old == NULL"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstruct bpf_prog *bpf_prog_realloc(struct bpf_prog *fp_old, unsigned int size,\n\t\t\t\t  gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog *fp;\n\tu32 pages, delta;\n\tint ret;\n\n\tBUG_ON(fp_old == NULL);\n\n\tsize = round_up(size, PAGE_SIZE);\n\tpages = size / PAGE_SIZE;\n\tif (pages <= fp_old->pages)\n\t\treturn fp_old;\n\n\tdelta = pages - fp_old->pages;\n\tret = __bpf_prog_charge(fp_old->aux->user, delta);\n\tif (ret)\n\t\treturn NULL;\n\n\tfp = __vmalloc(size, gfp_flags, PAGE_KERNEL);\n\tif (fp == NULL) {\n\t\t__bpf_prog_uncharge(fp_old->aux->user, delta);\n\t} else {\n\t\tmemcpy(fp, fp_old, fp_old->pages * PAGE_SIZE);\n\t\tfp->pages = pages;\n\t\tfp->aux->prog = fp;\n\n\t\t/* We keep fp->aux from fp_old around in the new\n\t\t * reallocated structure.\n\t\t */\n\t\tfp_old->aux = NULL;\n\t\t__bpf_prog_free(fp_old);\n\t}\n\n\treturn fp;\n}"
  },
  {
    "function_name": "bpf_prog_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "78-103",
    "snippet": "struct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog_aux *aux;\n\tstruct bpf_prog *fp;\n\n\tsize = round_up(size, PAGE_SIZE);\n\tfp = __vmalloc(size, gfp_flags, PAGE_KERNEL);\n\tif (fp == NULL)\n\t\treturn NULL;\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL | gfp_extra_flags);\n\tif (aux == NULL) {\n\t\tvfree(fp);\n\t\treturn NULL;\n\t}\n\n\tfp->pages = size / PAGE_SIZE;\n\tfp->aux = aux;\n\tfp->aux->prog = fp;\n\tfp->jit_requested = ebpf_jit_enabled();\n\n\tINIT_LIST_HEAD_RCU(&fp->aux->ksym_lnode);\n\n\treturn fp;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD_RCU",
          "args": [
            "&fp->aux->ksym_lnode"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebpf_jit_enabled",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "fp"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*aux)",
            "GFP_KERNEL | gfp_extra_flags"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "size",
            "gfp_flags",
            "PAGE_KERNEL"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "size",
            "PAGE_SIZE"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstruct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog_aux *aux;\n\tstruct bpf_prog *fp;\n\n\tsize = round_up(size, PAGE_SIZE);\n\tfp = __vmalloc(size, gfp_flags, PAGE_KERNEL);\n\tif (fp == NULL)\n\t\treturn NULL;\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL | gfp_extra_flags);\n\tif (aux == NULL) {\n\t\tvfree(fp);\n\t\treturn NULL;\n\t}\n\n\tfp->pages = size / PAGE_SIZE;\n\tfp->aux = aux;\n\tfp->aux->prog = fp;\n\tfp->jit_requested = ebpf_jit_enabled();\n\n\tINIT_LIST_HEAD_RCU(&fp->aux->ksym_lnode);\n\n\treturn fp;\n}"
  },
  {
    "function_name": "bpf_internal_load_pointer_neg_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
    "lines": "63-76",
    "snippet": "void *bpf_internal_load_pointer_neg_helper(const struct sk_buff *skb, int k, unsigned int size)\n{\n\tu8 *ptr = NULL;\n\n\tif (k >= SKF_NET_OFF)\n\t\tptr = skb_network_header(skb) + k - SKF_NET_OFF;\n\telse if (k >= SKF_LL_OFF)\n\t\tptr = skb_mac_header(skb) + k - SKF_LL_OFF;\n\n\tif (ptr >= skb->head && ptr + size <= skb_tail_pointer(skb))\n\t\treturn ptr;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/bpf_trace.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rbtree_latch.h>",
      "#include <linux/frame.h>",
      "#include <linux/bpf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/random.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/filter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_tail_pointer",
          "args": [
            "skb"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_mac_header",
          "args": [
            "skb"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_network_header",
          "args": [
            "skb"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid *bpf_internal_load_pointer_neg_helper(const struct sk_buff *skb, int k, unsigned int size)\n{\n\tu8 *ptr = NULL;\n\n\tif (k >= SKF_NET_OFF)\n\t\tptr = skb_network_header(skb) + k - SKF_NET_OFF;\n\telse if (k >= SKF_LL_OFF)\n\t\tptr = skb_mac_header(skb) + k - SKF_LL_OFF;\n\n\tif (ptr >= skb->head && ptr + size <= skb_tail_pointer(skb))\n\t\treturn ptr;\n\n\treturn NULL;\n}"
  }
]