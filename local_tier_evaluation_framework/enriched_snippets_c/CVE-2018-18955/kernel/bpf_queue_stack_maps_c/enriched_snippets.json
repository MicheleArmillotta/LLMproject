[
  {
    "function_name": "queue_stack_map_get_next_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "260-264",
    "snippet": "static int queue_stack_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t\tvoid *next_key)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_stack_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t\tvoid *next_key)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "queue_stack_map_delete_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "254-257",
    "snippet": "static int queue_stack_map_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_stack_map_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "queue_stack_map_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "247-251",
    "snippet": "static int queue_stack_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 flags)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_stack_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 flags)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "queue_stack_map_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "241-244",
    "snippet": "static void *queue_stack_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic void *queue_stack_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "queue_stack_map_push_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "200-238",
    "snippet": "static int queue_stack_map_push_elem(struct bpf_map *map, void *value,\n\t\t\t\t     u64 flags)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long irq_flags;\n\tint err = 0;\n\tvoid *dst;\n\n\t/* BPF_EXIST is used to force making room for a new element in case the\n\t * map is full\n\t */\n\tbool replace = (flags & BPF_EXIST);\n\n\t/* Check supported flags for queue and stack maps */\n\tif (flags & BPF_NOEXIST || flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&qs->lock, irq_flags);\n\n\tif (queue_stack_map_is_full(qs)) {\n\t\tif (!replace) {\n\t\t\terr = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t\t/* advance tail pointer to overwrite oldest element */\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\n\tdst = &qs->elements[qs->head * qs->map.value_size];\n\tmemcpy(dst, value, qs->map.value_size);\n\n\tif (unlikely(++qs->head >= qs->size))\n\t\tqs->head = 0;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, irq_flags);\n\treturn err;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&qs->lock",
            "irq_flags"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "++qs->head >= qs->size"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "value",
            "qs->map.value_size"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "++qs->tail >= qs->size"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_stack_map_is_full",
          "args": [
            "qs"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "queue_stack_map_is_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "35-43",
          "snippet": "static bool queue_stack_map_is_full(struct bpf_queue_stack *qs)\n{\n\tu32 head = qs->head + 1;\n\n\tif (unlikely(head >= qs->size))\n\t\thead = 0;\n\n\treturn head == qs->tail;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic bool queue_stack_map_is_full(struct bpf_queue_stack *qs)\n{\n\tu32 head = qs->head + 1;\n\n\tif (unlikely(head >= qs->size))\n\t\thead = 0;\n\n\treturn head == qs->tail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&qs->lock",
            "irq_flags"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_queue_stack",
          "args": [
            "map"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_queue_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "25-28",
          "snippet": "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_stack_map_push_elem(struct bpf_map *map, void *value,\n\t\t\t\t     u64 flags)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long irq_flags;\n\tint err = 0;\n\tvoid *dst;\n\n\t/* BPF_EXIST is used to force making room for a new element in case the\n\t * map is full\n\t */\n\tbool replace = (flags & BPF_EXIST);\n\n\t/* Check supported flags for queue and stack maps */\n\tif (flags & BPF_NOEXIST || flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&qs->lock, irq_flags);\n\n\tif (queue_stack_map_is_full(qs)) {\n\t\tif (!replace) {\n\t\t\terr = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t\t/* advance tail pointer to overwrite oldest element */\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\n\tdst = &qs->elements[qs->head * qs->map.value_size];\n\tmemcpy(dst, value, qs->map.value_size);\n\n\tif (unlikely(++qs->head >= qs->size))\n\t\tqs->head = 0;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, irq_flags);\n\treturn err;\n}"
  },
  {
    "function_name": "stack_map_pop_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "194-197",
    "snippet": "static int stack_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn __stack_map_get(map, value, true);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__stack_map_get",
          "args": [
            "map",
            "value",
            "true"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__stack_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "144-173",
          "snippet": "static int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn __stack_map_get(map, value, true);\n}"
  },
  {
    "function_name": "queue_map_pop_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "188-191",
    "snippet": "static int queue_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn __queue_map_get(map, value, true);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__queue_map_get",
          "args": [
            "map",
            "value",
            "true"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "115-141",
          "snippet": "static int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn __queue_map_get(map, value, true);\n}"
  },
  {
    "function_name": "stack_map_peek_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "182-185",
    "snippet": "static int stack_map_peek_elem(struct bpf_map *map, void *value)\n{\n\treturn __stack_map_get(map, value, false);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__stack_map_get",
          "args": [
            "map",
            "value",
            "false"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "__stack_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "144-173",
          "snippet": "static int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_peek_elem(struct bpf_map *map, void *value)\n{\n\treturn __stack_map_get(map, value, false);\n}"
  },
  {
    "function_name": "queue_map_peek_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "176-179",
    "snippet": "static int queue_map_peek_elem(struct bpf_map *map, void *value)\n{\n\treturn __queue_map_get(map, value, false);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__queue_map_get",
          "args": [
            "map",
            "value",
            "false"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "115-141",
          "snippet": "static int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_map_peek_elem(struct bpf_map *map, void *value)\n{\n\treturn __queue_map_get(map, value, false);\n}"
  },
  {
    "function_name": "__stack_map_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "144-173",
    "snippet": "static int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&qs->lock",
            "flags"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "ptr",
            "qs->map.value_size"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= qs->size"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value",
            "0",
            "qs->map.value_size"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_stack_map_is_empty",
          "args": [
            "qs"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "queue_stack_map_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "30-33",
          "snippet": "static bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&qs->lock",
            "flags"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_queue_stack",
          "args": [
            "map"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_queue_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "25-28",
          "snippet": "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
  },
  {
    "function_name": "__queue_map_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "115-141",
    "snippet": "static int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&qs->lock",
            "flags"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "++qs->tail >= qs->size"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "ptr",
            "qs->map.value_size"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value",
            "0",
            "qs->map.value_size"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_stack_map_is_empty",
          "args": [
            "qs"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "queue_stack_map_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "30-33",
          "snippet": "static bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&qs->lock",
            "flags"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_queue_stack",
          "args": [
            "map"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_queue_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "25-28",
          "snippet": "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
  },
  {
    "function_name": "queue_stack_map_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "101-113",
    "snippet": "static void queue_stack_map_free(struct bpf_map *map)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\n\t/* at this point bpf_prog->aux->refcnt == 0 and this map->refcnt == 0,\n\t * so the programs (can be more than one that used this map) were\n\t * disconnected from events. Wait for outstanding critical sections in\n\t * these programs to complete\n\t */\n\tsynchronize_rcu();\n\n\tbpf_map_area_free(qs);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "qs"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "156-159",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_queue_stack",
          "args": [
            "map"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_queue_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "25-28",
          "snippet": "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic void queue_stack_map_free(struct bpf_map *map)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\n\t/* at this point bpf_prog->aux->refcnt == 0 and this map->refcnt == 0,\n\t * so the programs (can be more than one that used this map) were\n\t * disconnected from events. Wait for outstanding critical sections in\n\t * these programs to complete\n\t */\n\tsynchronize_rcu();\n\n\tbpf_map_area_free(qs);\n}"
  },
  {
    "function_name": "queue_stack_map_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "62-98",
    "snippet": "static struct bpf_map *queue_stack_map_alloc(union bpf_attr *attr)\n{\n\tint ret, numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_queue_stack *qs;\n\tu32 size, value_size;\n\tu64 queue_size, cost;\n\n\tsize = attr->max_entries + 1;\n\tvalue_size = attr->value_size;\n\n\tqueue_size = sizeof(*qs) + (u64) value_size * size;\n\n\tcost = queue_size;\n\tif (cost >= U32_MAX - PAGE_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tcost = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;\n\n\tret = bpf_map_precharge_memlock(cost);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tqs = bpf_map_area_alloc(queue_size, numa_node);\n\tif (!qs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset(qs, 0, sizeof(*qs));\n\n\tbpf_map_init_from_attr(&qs->map, attr);\n\n\tqs->map.pages = cost;\n\tqs->size = size;\n\n\traw_spin_lock_init(&qs->lock);\n\n\treturn &qs->map;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&qs->lock"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&qs->map",
            "attr"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "161-169",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "qs",
            "0",
            "sizeof(*qs)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "queue_size",
            "numa_node"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "137-154",
          "snippet": "void *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_precharge_memlock",
          "args": [
            "cost"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_precharge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "171-182",
          "snippet": "int bpf_map_precharge_memlock(u32 pages)\n{\n\tstruct user_struct *user = get_current_user();\n\tunsigned long memlock_limit, cur;\n\n\tmemlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tcur = atomic_long_read(&user->locked_vm);\n\tfree_uid(user);\n\tif (cur + pages > memlock_limit)\n\t\treturn -EPERM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_map_precharge_memlock(u32 pages)\n{\n\tstruct user_struct *user = get_current_user();\n\tunsigned long memlock_limit, cur;\n\n\tmemlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tcur = atomic_long_read(&user->locked_vm);\n\tfree_uid(user);\n\tif (cur + pages > memlock_limit)\n\t\treturn -EPERM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "cost",
            "PAGE_SIZE"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-E2BIG"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *queue_stack_map_alloc(union bpf_attr *attr)\n{\n\tint ret, numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_queue_stack *qs;\n\tu32 size, value_size;\n\tu64 queue_size, cost;\n\n\tsize = attr->max_entries + 1;\n\tvalue_size = attr->value_size;\n\n\tqueue_size = sizeof(*qs) + (u64) value_size * size;\n\n\tcost = queue_size;\n\tif (cost >= U32_MAX - PAGE_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tcost = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;\n\n\tret = bpf_map_precharge_memlock(cost);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tqs = bpf_map_area_alloc(queue_size, numa_node);\n\tif (!qs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset(qs, 0, sizeof(*qs));\n\n\tbpf_map_init_from_attr(&qs->map, attr);\n\n\tqs->map.pages = cost;\n\tqs->size = size;\n\n\traw_spin_lock_init(&qs->lock);\n\n\treturn &qs->map;\n}"
  },
  {
    "function_name": "queue_stack_map_alloc_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "46-60",
    "snippet": "static int queue_stack_map_alloc_check(union bpf_attr *attr)\n{\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size != 0 ||\n\t    attr->map_flags & ~QUEUE_STACK_CREATE_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tif (attr->value_size > KMALLOC_MAX_SIZE)\n\t\t/* if value_size is bigger, the user space won't be able to\n\t\t * access the elements.\n\t\t */\n\t\treturn -E2BIG;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define QUEUE_STACK_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\n#define QUEUE_STACK_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic int queue_stack_map_alloc_check(union bpf_attr *attr)\n{\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size != 0 ||\n\t    attr->map_flags & ~QUEUE_STACK_CREATE_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tif (attr->value_size > KMALLOC_MAX_SIZE)\n\t\t/* if value_size is bigger, the user space won't be able to\n\t\t * access the elements.\n\t\t */\n\t\treturn -E2BIG;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "queue_stack_map_is_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "35-43",
    "snippet": "static bool queue_stack_map_is_full(struct bpf_queue_stack *qs)\n{\n\tu32 head = qs->head + 1;\n\n\tif (unlikely(head >= qs->size))\n\t\thead = 0;\n\n\treturn head == qs->tail;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "head >= qs->size"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic bool queue_stack_map_is_full(struct bpf_queue_stack *qs)\n{\n\tu32 head = qs->head + 1;\n\n\tif (unlikely(head >= qs->size))\n\t\thead = 0;\n\n\treturn head == qs->tail;\n}"
  },
  {
    "function_name": "queue_stack_map_is_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "30-33",
    "snippet": "static bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}"
  },
  {
    "function_name": "bpf_queue_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "25-28",
    "snippet": "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_queue_stack",
            "map"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}"
  }
]