[
  {
    "function_name": "__put_devmap_managed_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "305-323",
    "snippet": "void __put_devmap_managed_page(struct page *page)\n{\n\tint count = page_ref_dec_return(page);\n\n\t/*\n\t * If refcount is 1 then page is freed and refcount is stable as nobody\n\t * holds a reference on the page.\n\t */\n\tif (count == 1) {\n\t\t/* Clear Active bit in case of parallel mark_page_accessed */\n\t\t__ClearPageActive(page);\n\t\t__ClearPageWaiters(page);\n\n\t\tmem_cgroup_uncharge(page);\n\n\t\tpage->pgmap->page_free(page, page->pgmap->data);\n\t} else if (!count)\n\t\t__put_page(page);\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_page",
          "args": [
            "page"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page->pgmap->page_free",
          "args": [
            "page",
            "page->pgmap->data"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge",
          "args": [
            "page"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageWaiters",
          "args": [
            "page"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageActive",
          "args": [
            "page"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_dec_return",
          "args": [
            "page"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nvoid __put_devmap_managed_page(struct page *page)\n{\n\tint count = page_ref_dec_return(page);\n\n\t/*\n\t * If refcount is 1 then page is freed and refcount is stable as nobody\n\t * holds a reference on the page.\n\t */\n\tif (count == 1) {\n\t\t/* Clear Active bit in case of parallel mark_page_accessed */\n\t\t__ClearPageActive(page);\n\t\t__ClearPageWaiters(page);\n\n\t\tmem_cgroup_uncharge(page);\n\n\t\tpage->pgmap->page_free(page, page->pgmap->data);\n\t} else if (!count)\n\t\t__put_page(page);\n}"
  },
  {
    "function_name": "dev_pagemap_put_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "298-302",
    "snippet": "void dev_pagemap_put_ops(void)\n{\n\tif (atomic_dec_and_test(&devmap_enable))\n\t\tstatic_branch_disable(&devmap_managed_key);\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&devmap_managed_key"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&devmap_enable"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nvoid dev_pagemap_put_ops(void)\n{\n\tif (atomic_dec_and_test(&devmap_enable))\n\t\tstatic_branch_disable(&devmap_managed_key);\n}"
  },
  {
    "function_name": "dev_pagemap_get_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "291-295",
    "snippet": "void dev_pagemap_get_ops(void)\n{\n\tif (atomic_inc_return(&devmap_enable) == 1)\n\t\tstatic_branch_enable(&devmap_managed_key);\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&devmap_managed_key"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&devmap_enable"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nvoid dev_pagemap_get_ops(void)\n{\n\tif (atomic_inc_return(&devmap_enable) == 1)\n\t\tstatic_branch_enable(&devmap_managed_key);\n}"
  },
  {
    "function_name": "get_dev_pagemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "257-279",
    "snippet": "struct dev_pagemap *get_dev_pagemap(unsigned long pfn,\n\t\tstruct dev_pagemap *pgmap)\n{\n\tresource_size_t phys = PFN_PHYS(pfn);\n\n\t/*\n\t * In the cached case we're already holding a live reference.\n\t */\n\tif (pgmap) {\n\t\tif (phys >= pgmap->res.start && phys <= pgmap->res.end)\n\t\t\treturn pgmap;\n\t\tput_dev_pagemap(pgmap);\n\t}\n\n\t/* fall back to slow path lookup */\n\trcu_read_lock();\n\tpgmap = xa_load(&pgmap_array, PHYS_PFN(phys));\n\tif (pgmap && !percpu_ref_tryget_live(pgmap->ref))\n\t\tpgmap = NULL;\n\trcu_read_unlock();\n\n\treturn pgmap;\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_XARRAY(pgmap_array);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_tryget_live",
          "args": [
            "pgmap->ref"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_load",
          "args": [
            "&pgmap_array",
            "PHYS_PFN(phys)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "phys"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_dev_pagemap",
          "args": [
            "pgmap"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "pfn"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nstatic DEFINE_XARRAY(pgmap_array);\n\nstruct dev_pagemap *get_dev_pagemap(unsigned long pfn,\n\t\tstruct dev_pagemap *pgmap)\n{\n\tresource_size_t phys = PFN_PHYS(pfn);\n\n\t/*\n\t * In the cached case we're already holding a live reference.\n\t */\n\tif (pgmap) {\n\t\tif (phys >= pgmap->res.start && phys <= pgmap->res.end)\n\t\t\treturn pgmap;\n\t\tput_dev_pagemap(pgmap);\n\t}\n\n\t/* fall back to slow path lookup */\n\trcu_read_lock();\n\tpgmap = xa_load(&pgmap_array, PHYS_PFN(phys));\n\tif (pgmap && !percpu_ref_tryget_live(pgmap->ref))\n\t\tpgmap = NULL;\n\trcu_read_unlock();\n\n\treturn pgmap;\n}"
  },
  {
    "function_name": "vmem_altmap_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "244-247",
    "snippet": "void vmem_altmap_free(struct vmem_altmap *altmap, unsigned long nr_pfns)\n{\n\taltmap->alloc -= nr_pfns;\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nvoid vmem_altmap_free(struct vmem_altmap *altmap, unsigned long nr_pfns)\n{\n\taltmap->alloc -= nr_pfns;\n}"
  },
  {
    "function_name": "vmem_altmap_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "238-242",
    "snippet": "unsigned long vmem_altmap_offset(struct vmem_altmap *altmap)\n{\n\t/* number of pfns from base where pfn_to_page() is valid */\n\treturn altmap->reserve + altmap->free;\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nunsigned long vmem_altmap_offset(struct vmem_altmap *altmap)\n{\n\t/* number of pfns from base where pfn_to_page() is valid */\n\treturn altmap->reserve + altmap->free;\n}"
  },
  {
    "function_name": "devm_memremap_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "138-235",
    "snippet": "void *devm_memremap_pages(struct device *dev, struct dev_pagemap *pgmap)\n{\n\tresource_size_t align_start, align_size, align_end;\n\tstruct vmem_altmap *altmap = pgmap->altmap_valid ?\n\t\t\t&pgmap->altmap : NULL;\n\tstruct resource *res = &pgmap->res;\n\tstruct dev_pagemap *conflict_pgmap;\n\tpgprot_t pgprot = PAGE_KERNEL;\n\tint error, nid, is_ram;\n\n\talign_start = res->start & ~(SECTION_SIZE - 1);\n\talign_size = ALIGN(res->start + resource_size(res), SECTION_SIZE)\n\t\t- align_start;\n\talign_end = align_start + align_size - 1;\n\n\tconflict_pgmap = get_dev_pagemap(PHYS_PFN(align_start), NULL);\n\tif (conflict_pgmap) {\n\t\tdev_WARN(dev, \"Conflicting mapping in same section\\n\");\n\t\tput_dev_pagemap(conflict_pgmap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tconflict_pgmap = get_dev_pagemap(PHYS_PFN(align_end), NULL);\n\tif (conflict_pgmap) {\n\t\tdev_WARN(dev, \"Conflicting mapping in same section\\n\");\n\t\tput_dev_pagemap(conflict_pgmap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tis_ram = region_intersects(align_start, align_size,\n\t\tIORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);\n\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"%s attempted on mixed region %pr\\n\",\n\t\t\t\t__func__, res);\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\tif (is_ram == REGION_INTERSECTS)\n\t\treturn __va(res->start);\n\n\tif (!pgmap->ref)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpgmap->dev = dev;\n\n\terror = xa_err(xa_store_range(&pgmap_array, PHYS_PFN(res->start),\n\t\t\t\tPHYS_PFN(res->end), pgmap, GFP_KERNEL));\n\tif (error)\n\t\tgoto err_array;\n\n\tnid = dev_to_node(dev);\n\tif (nid < 0)\n\t\tnid = numa_mem_id();\n\n\terror = track_pfn_remap(NULL, &pgprot, PHYS_PFN(align_start), 0,\n\t\t\talign_size);\n\tif (error)\n\t\tgoto err_pfn_remap;\n\n\tmem_hotplug_begin();\n\terror = kasan_add_zero_shadow(__va(align_start), align_size);\n\tif (error) {\n\t\tmem_hotplug_done();\n\t\tgoto err_kasan;\n\t}\n\n\terror = arch_add_memory(nid, align_start, align_size, altmap, false);\n\tif (!error)\n\t\tmove_pfn_range_to_zone(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\t\talign_size >> PAGE_SHIFT, altmap);\n\tmem_hotplug_done();\n\tif (error)\n\t\tgoto err_add_memory;\n\n\t/*\n\t * Initialization of the pages has been deferred until now in order\n\t * to allow us to do the work while not holding the hotplug lock.\n\t */\n\tmemmap_init_zone_device(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, pgmap);\n\tpercpu_ref_get_many(pgmap->ref, pfn_end(pgmap) - pfn_first(pgmap));\n\n\tdevm_add_action(dev, devm_memremap_pages_release, pgmap);\n\n\treturn __va(res->start);\n\n err_add_memory:\n\tkasan_remove_zero_shadow(__va(align_start), align_size);\n err_kasan:\n\tuntrack_pfn(NULL, PHYS_PFN(align_start), align_size);\n err_pfn_remap:\n\tpgmap_array_delete(res);\n err_array:\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define SECTION_SIZE (1UL << PA_SECTION_SHIFT)"
    ],
    "globals_used": [
      "static DEFINE_XARRAY(pgmap_array);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgmap_array_delete",
          "args": [
            "res"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "pgmap_array_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
          "lines": "47-52",
          "snippet": "static void pgmap_array_delete(struct resource *res)\n{\n\txa_store_range(&pgmap_array, PHYS_PFN(res->start), PHYS_PFN(res->end),\n\t\t\tNULL, GFP_KERNEL);\n\tsynchronize_rcu();\n}",
          "includes": [
            "#include <linux/xarray.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/types.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kasan.h>",
            "#include <linux/io.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_XARRAY(pgmap_array);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nstatic DEFINE_XARRAY(pgmap_array);\n\nstatic void pgmap_array_delete(struct resource *res)\n{\n\txa_store_range(&pgmap_array, PHYS_PFN(res->start), PHYS_PFN(res->end),\n\t\t\tNULL, GFP_KERNEL);\n\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "untrack_pfn",
          "args": [
            "NULL",
            "PHYS_PFN(align_start)",
            "align_size"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "align_start"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_remove_zero_shadow",
          "args": [
            "__va(align_start)",
            "align_size"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "align_start"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "__var_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "152-155",
          "snippet": "wait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "devm_add_action",
          "args": [
            "dev",
            "devm_memremap_pages_release",
            "pgmap"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_get_many",
          "args": [
            "pgmap->ref",
            "pfn_end(pgmap) - pfn_first(pgmap)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_first",
          "args": [
            "pgmap"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "pfn_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
          "lines": "54-64",
          "snippet": "static unsigned long pfn_first(struct dev_pagemap *pgmap)\n{\n\tconst struct resource *res = &pgmap->res;\n\tstruct vmem_altmap *altmap = &pgmap->altmap;\n\tunsigned long pfn;\n\n\tpfn = res->start >> PAGE_SHIFT;\n\tif (pgmap->altmap_valid)\n\t\tpfn += vmem_altmap_offset(altmap);\n\treturn pfn;\n}",
          "includes": [
            "#include <linux/xarray.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/types.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kasan.h>",
            "#include <linux/io.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nstatic unsigned long pfn_first(struct dev_pagemap *pgmap)\n{\n\tconst struct resource *res = &pgmap->res;\n\tstruct vmem_altmap *altmap = &pgmap->altmap;\n\tunsigned long pfn;\n\n\tpfn = res->start >> PAGE_SHIFT;\n\tif (pgmap->altmap_valid)\n\t\tpfn += vmem_altmap_offset(altmap);\n\treturn pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_end",
          "args": [
            "pgmap"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "pfn_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
          "lines": "66-71",
          "snippet": "static unsigned long pfn_end(struct dev_pagemap *pgmap)\n{\n\tconst struct resource *res = &pgmap->res;\n\n\treturn (res->start + resource_size(res)) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include <linux/xarray.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/types.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kasan.h>",
            "#include <linux/io.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nstatic unsigned long pfn_end(struct dev_pagemap *pgmap)\n{\n\tconst struct resource *res = &pgmap->res;\n\n\treturn (res->start + resource_size(res)) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmap_init_zone_device",
          "args": [
            "&NODE_DATA(nid)->node_zones[ZONE_DEVICE]",
            "align_start >> PAGE_SHIFT",
            "align_size >> PAGE_SHIFT",
            "pgmap"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_hotplug_done",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_pfn_range_to_zone",
          "args": [
            "&NODE_DATA(nid)->node_zones[ZONE_DEVICE]",
            "align_start >> PAGE_SHIFT",
            "align_size >> PAGE_SHIFT",
            "altmap"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_add_memory",
          "args": [
            "nid",
            "align_start",
            "align_size",
            "altmap",
            "false"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_hotplug_done",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_add_zero_shadow",
          "args": [
            "__va(align_start)",
            "align_size"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_hotplug_begin",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track_pfn_remap",
          "args": [
            "NULL",
            "&pgprot",
            "PHYS_PFN(align_start)",
            "0",
            "align_size"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "align_start"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "dev"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_err",
          "args": [
            "xa_store_range(&pgmap_array, PHYS_PFN(res->start),\n\t\t\t\tPHYS_PFN(res->end), pgmap, GFP_KERNEL)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_store_range",
          "args": [
            "&pgmap_array",
            "PHYS_PFN(res->start)",
            "PHYS_PFN(res->end)",
            "pgmap",
            "GFP_KERNEL"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "res->end"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "res->start"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENXIO"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"%s attempted on mixed region %pr\\n\"",
            "__func__",
            "res"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "region_intersects",
          "args": [
            "align_start",
            "align_size",
            "IORESOURCE_SYSTEM_RAM",
            "IORES_DESC_NONE"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "region_intersects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "512-541",
          "snippet": "int region_intersects(resource_size_t start, size_t size, unsigned long flags,\n\t\t      unsigned long desc)\n{\n\tresource_size_t end = start + size - 1;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tread_lock(&resource_lock);\n\tfor (p = iomem_resource.child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (start >= p->start && start <= p->end)\n\t\t\tis_type ? type++ : other++;\n\t\tif (end >= p->start && end <= p->end)\n\t\t\tis_type ? type++ : other++;\n\t\tif (p->start >= start && p->end <= end)\n\t\t\tis_type ? type++ : other++;\n\t}\n\tread_unlock(&resource_lock);\n\n\tif (other == 0)\n\t\treturn type ? REGION_INTERSECTS : REGION_DISJOINT;\n\n\tif (type)\n\t\treturn REGION_MIXED;\n\n\treturn REGION_DISJOINT;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nint region_intersects(resource_size_t start, size_t size, unsigned long flags,\n\t\t      unsigned long desc)\n{\n\tresource_size_t end = start + size - 1;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tread_lock(&resource_lock);\n\tfor (p = iomem_resource.child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (start >= p->start && start <= p->end)\n\t\t\tis_type ? type++ : other++;\n\t\tif (end >= p->start && end <= p->end)\n\t\t\tis_type ? type++ : other++;\n\t\tif (p->start >= start && p->end <= end)\n\t\t\tis_type ? type++ : other++;\n\t}\n\tread_unlock(&resource_lock);\n\n\tif (other == 0)\n\t\treturn type ? REGION_INTERSECTS : REGION_DISJOINT;\n\n\tif (type)\n\t\treturn REGION_MIXED;\n\n\treturn REGION_DISJOINT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dev_pagemap",
          "args": [
            "conflict_pgmap"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_WARN",
          "args": [
            "dev",
            "\"Conflicting mapping in same section\\n\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dev_pagemap",
          "args": [
            "PHYS_PFN(align_end)",
            "NULL"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "get_dev_pagemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
          "lines": "257-279",
          "snippet": "struct dev_pagemap *get_dev_pagemap(unsigned long pfn,\n\t\tstruct dev_pagemap *pgmap)\n{\n\tresource_size_t phys = PFN_PHYS(pfn);\n\n\t/*\n\t * In the cached case we're already holding a live reference.\n\t */\n\tif (pgmap) {\n\t\tif (phys >= pgmap->res.start && phys <= pgmap->res.end)\n\t\t\treturn pgmap;\n\t\tput_dev_pagemap(pgmap);\n\t}\n\n\t/* fall back to slow path lookup */\n\trcu_read_lock();\n\tpgmap = xa_load(&pgmap_array, PHYS_PFN(phys));\n\tif (pgmap && !percpu_ref_tryget_live(pgmap->ref))\n\t\tpgmap = NULL;\n\trcu_read_unlock();\n\n\treturn pgmap;\n}",
          "includes": [
            "#include <linux/xarray.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/types.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kasan.h>",
            "#include <linux/io.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_XARRAY(pgmap_array);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nstatic DEFINE_XARRAY(pgmap_array);\n\nstruct dev_pagemap *get_dev_pagemap(unsigned long pfn,\n\t\tstruct dev_pagemap *pgmap)\n{\n\tresource_size_t phys = PFN_PHYS(pfn);\n\n\t/*\n\t * In the cached case we're already holding a live reference.\n\t */\n\tif (pgmap) {\n\t\tif (phys >= pgmap->res.start && phys <= pgmap->res.end)\n\t\t\treturn pgmap;\n\t\tput_dev_pagemap(pgmap);\n\t}\n\n\t/* fall back to slow path lookup */\n\trcu_read_lock();\n\tpgmap = xa_load(&pgmap_array, PHYS_PFN(phys));\n\tif (pgmap && !percpu_ref_tryget_live(pgmap->ref))\n\t\tpgmap = NULL;\n\trcu_read_unlock();\n\n\treturn pgmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "align_end"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dev_pagemap",
          "args": [
            "conflict_pgmap"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_WARN",
          "args": [
            "dev",
            "\"Conflicting mapping in same section\\n\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "align_start"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "res->start + resource_size(res)",
            "SECTION_SIZE"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "res"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\n#define SECTION_SIZE (1UL << PA_SECTION_SHIFT)\n\nstatic DEFINE_XARRAY(pgmap_array);\n\nvoid *devm_memremap_pages(struct device *dev, struct dev_pagemap *pgmap)\n{\n\tresource_size_t align_start, align_size, align_end;\n\tstruct vmem_altmap *altmap = pgmap->altmap_valid ?\n\t\t\t&pgmap->altmap : NULL;\n\tstruct resource *res = &pgmap->res;\n\tstruct dev_pagemap *conflict_pgmap;\n\tpgprot_t pgprot = PAGE_KERNEL;\n\tint error, nid, is_ram;\n\n\talign_start = res->start & ~(SECTION_SIZE - 1);\n\talign_size = ALIGN(res->start + resource_size(res), SECTION_SIZE)\n\t\t- align_start;\n\talign_end = align_start + align_size - 1;\n\n\tconflict_pgmap = get_dev_pagemap(PHYS_PFN(align_start), NULL);\n\tif (conflict_pgmap) {\n\t\tdev_WARN(dev, \"Conflicting mapping in same section\\n\");\n\t\tput_dev_pagemap(conflict_pgmap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tconflict_pgmap = get_dev_pagemap(PHYS_PFN(align_end), NULL);\n\tif (conflict_pgmap) {\n\t\tdev_WARN(dev, \"Conflicting mapping in same section\\n\");\n\t\tput_dev_pagemap(conflict_pgmap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tis_ram = region_intersects(align_start, align_size,\n\t\tIORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);\n\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"%s attempted on mixed region %pr\\n\",\n\t\t\t\t__func__, res);\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\tif (is_ram == REGION_INTERSECTS)\n\t\treturn __va(res->start);\n\n\tif (!pgmap->ref)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpgmap->dev = dev;\n\n\terror = xa_err(xa_store_range(&pgmap_array, PHYS_PFN(res->start),\n\t\t\t\tPHYS_PFN(res->end), pgmap, GFP_KERNEL));\n\tif (error)\n\t\tgoto err_array;\n\n\tnid = dev_to_node(dev);\n\tif (nid < 0)\n\t\tnid = numa_mem_id();\n\n\terror = track_pfn_remap(NULL, &pgprot, PHYS_PFN(align_start), 0,\n\t\t\talign_size);\n\tif (error)\n\t\tgoto err_pfn_remap;\n\n\tmem_hotplug_begin();\n\terror = kasan_add_zero_shadow(__va(align_start), align_size);\n\tif (error) {\n\t\tmem_hotplug_done();\n\t\tgoto err_kasan;\n\t}\n\n\terror = arch_add_memory(nid, align_start, align_size, altmap, false);\n\tif (!error)\n\t\tmove_pfn_range_to_zone(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\t\talign_size >> PAGE_SHIFT, altmap);\n\tmem_hotplug_done();\n\tif (error)\n\t\tgoto err_add_memory;\n\n\t/*\n\t * Initialization of the pages has been deferred until now in order\n\t * to allow us to do the work while not holding the hotplug lock.\n\t */\n\tmemmap_init_zone_device(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, pgmap);\n\tpercpu_ref_get_many(pgmap->ref, pfn_end(pgmap) - pfn_first(pgmap));\n\n\tdevm_add_action(dev, devm_memremap_pages_release, pgmap);\n\n\treturn __va(res->start);\n\n err_add_memory:\n\tkasan_remove_zero_shadow(__va(align_start), align_size);\n err_kasan:\n\tuntrack_pfn(NULL, PHYS_PFN(align_start), align_size);\n err_pfn_remap:\n\tpgmap_array_delete(res);\n err_array:\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "devm_memremap_pages_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "83-114",
    "snippet": "static void devm_memremap_pages_release(void *data)\n{\n\tstruct dev_pagemap *pgmap = data;\n\tstruct device *dev = pgmap->dev;\n\tstruct resource *res = &pgmap->res;\n\tresource_size_t align_start, align_size;\n\tunsigned long pfn;\n\n\tfor_each_device_pfn(pfn, pgmap)\n\t\tput_page(pfn_to_page(pfn));\n\n\tif (percpu_ref_tryget_live(pgmap->ref)) {\n\t\tdev_WARN(dev, \"%s: page mapping is still live!\\n\", __func__);\n\t\tpercpu_ref_put(pgmap->ref);\n\t}\n\n\t/* pages are dead and unused, undo the arch mapping */\n\talign_start = res->start & ~(SECTION_SIZE - 1);\n\talign_size = ALIGN(res->start + resource_size(res), SECTION_SIZE)\n\t\t- align_start;\n\n\tmem_hotplug_begin();\n\tarch_remove_memory(align_start, align_size, pgmap->altmap_valid ?\n\t\t\t&pgmap->altmap : NULL);\n\tkasan_remove_zero_shadow(__va(align_start), align_size);\n\tmem_hotplug_done();\n\n\tuntrack_pfn(NULL, PHYS_PFN(align_start), align_size);\n\tpgmap_array_delete(res);\n\tdev_WARN_ONCE(dev, pgmap->altmap.alloc,\n\t\t      \"%s: failed to free all reserved pages\\n\", __func__);\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define SECTION_SIZE (1UL << PA_SECTION_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_WARN_ONCE",
          "args": [
            "dev",
            "pgmap->altmap.alloc",
            "\"%s: failed to free all reserved pages\\n\"",
            "__func__"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgmap_array_delete",
          "args": [
            "res"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "pgmap_array_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
          "lines": "47-52",
          "snippet": "static void pgmap_array_delete(struct resource *res)\n{\n\txa_store_range(&pgmap_array, PHYS_PFN(res->start), PHYS_PFN(res->end),\n\t\t\tNULL, GFP_KERNEL);\n\tsynchronize_rcu();\n}",
          "includes": [
            "#include <linux/xarray.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/types.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kasan.h>",
            "#include <linux/io.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_XARRAY(pgmap_array);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nstatic DEFINE_XARRAY(pgmap_array);\n\nstatic void pgmap_array_delete(struct resource *res)\n{\n\txa_store_range(&pgmap_array, PHYS_PFN(res->start), PHYS_PFN(res->end),\n\t\t\tNULL, GFP_KERNEL);\n\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "untrack_pfn",
          "args": [
            "NULL",
            "PHYS_PFN(align_start)",
            "align_size"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "align_start"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_hotplug_done",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_remove_zero_shadow",
          "args": [
            "__va(align_start)",
            "align_size"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "align_start"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "__var_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "152-155",
          "snippet": "wait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remove_memory",
          "args": [
            "align_start",
            "align_size",
            "pgmap->altmap_valid ?\n\t\t\t&pgmap->altmap : NULL"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_hotplug_begin",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "res->start + resource_size(res)",
            "SECTION_SIZE"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "res"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "pgmap->ref"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_WARN",
          "args": [
            "dev",
            "\"%s: page mapping is still live!\\n\"",
            "__func__"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_tryget_live",
          "args": [
            "pgmap->ref"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_device_pfn",
          "args": [
            "pfn",
            "pgmap"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\n#define SECTION_SIZE (1UL << PA_SECTION_SHIFT)\n\nstatic void devm_memremap_pages_release(void *data)\n{\n\tstruct dev_pagemap *pgmap = data;\n\tstruct device *dev = pgmap->dev;\n\tstruct resource *res = &pgmap->res;\n\tresource_size_t align_start, align_size;\n\tunsigned long pfn;\n\n\tfor_each_device_pfn(pfn, pgmap)\n\t\tput_page(pfn_to_page(pfn));\n\n\tif (percpu_ref_tryget_live(pgmap->ref)) {\n\t\tdev_WARN(dev, \"%s: page mapping is still live!\\n\", __func__);\n\t\tpercpu_ref_put(pgmap->ref);\n\t}\n\n\t/* pages are dead and unused, undo the arch mapping */\n\talign_start = res->start & ~(SECTION_SIZE - 1);\n\talign_size = ALIGN(res->start + resource_size(res), SECTION_SIZE)\n\t\t- align_start;\n\n\tmem_hotplug_begin();\n\tarch_remove_memory(align_start, align_size, pgmap->altmap_valid ?\n\t\t\t&pgmap->altmap : NULL);\n\tkasan_remove_zero_shadow(__va(align_start), align_size);\n\tmem_hotplug_done();\n\n\tuntrack_pfn(NULL, PHYS_PFN(align_start), align_size);\n\tpgmap_array_delete(res);\n\tdev_WARN_ONCE(dev, pgmap->altmap.alloc,\n\t\t      \"%s: failed to free all reserved pages\\n\", __func__);\n}"
  },
  {
    "function_name": "pfn_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "73-78",
    "snippet": "static unsigned long pfn_next(unsigned long pfn)\n{\n\tif (pfn % 1024 == 0)\n\t\tcond_resched();\n\treturn pfn + 1;\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nstatic unsigned long pfn_next(unsigned long pfn)\n{\n\tif (pfn % 1024 == 0)\n\t\tcond_resched();\n\treturn pfn + 1;\n}"
  },
  {
    "function_name": "pfn_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "66-71",
    "snippet": "static unsigned long pfn_end(struct dev_pagemap *pgmap)\n{\n\tconst struct resource *res = &pgmap->res;\n\n\treturn (res->start + resource_size(res)) >> PAGE_SHIFT;\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "res"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nstatic unsigned long pfn_end(struct dev_pagemap *pgmap)\n{\n\tconst struct resource *res = &pgmap->res;\n\n\treturn (res->start + resource_size(res)) >> PAGE_SHIFT;\n}"
  },
  {
    "function_name": "pfn_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "54-64",
    "snippet": "static unsigned long pfn_first(struct dev_pagemap *pgmap)\n{\n\tconst struct resource *res = &pgmap->res;\n\tstruct vmem_altmap *altmap = &pgmap->altmap;\n\tunsigned long pfn;\n\n\tpfn = res->start >> PAGE_SHIFT;\n\tif (pgmap->altmap_valid)\n\t\tpfn += vmem_altmap_offset(altmap);\n\treturn pfn;\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmem_altmap_offset",
          "args": [
            "altmap"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "vmem_altmap_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
          "lines": "238-242",
          "snippet": "unsigned long vmem_altmap_offset(struct vmem_altmap *altmap)\n{\n\t/* number of pfns from base where pfn_to_page() is valid */\n\treturn altmap->reserve + altmap->free;\n}",
          "includes": [
            "#include <linux/xarray.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/types.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kasan.h>",
            "#include <linux/io.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nunsigned long vmem_altmap_offset(struct vmem_altmap *altmap)\n{\n\t/* number of pfns from base where pfn_to_page() is valid */\n\treturn altmap->reserve + altmap->free;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nstatic unsigned long pfn_first(struct dev_pagemap *pgmap)\n{\n\tconst struct resource *res = &pgmap->res;\n\tstruct vmem_altmap *altmap = &pgmap->altmap;\n\tunsigned long pfn;\n\n\tpfn = res->start >> PAGE_SHIFT;\n\tif (pgmap->altmap_valid)\n\t\tpfn += vmem_altmap_offset(altmap);\n\treturn pfn;\n}"
  },
  {
    "function_name": "pgmap_array_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "47-52",
    "snippet": "static void pgmap_array_delete(struct resource *res)\n{\n\txa_store_range(&pgmap_array, PHYS_PFN(res->start), PHYS_PFN(res->end),\n\t\t\tNULL, GFP_KERNEL);\n\tsynchronize_rcu();\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_XARRAY(pgmap_array);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_store_range",
          "args": [
            "&pgmap_array",
            "PHYS_PFN(res->start)",
            "PHYS_PFN(res->end)",
            "NULL",
            "GFP_KERNEL"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "res->end"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "res->start"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nstatic DEFINE_XARRAY(pgmap_array);\n\nstatic void pgmap_array_delete(struct resource *res)\n{\n\txa_store_range(&pgmap_array, PHYS_PFN(res->start), PHYS_PFN(res->end),\n\t\t\tNULL, GFP_KERNEL);\n\tsynchronize_rcu();\n}"
  },
  {
    "function_name": "device_private_entry_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/memremap.c",
    "lines": "20-43",
    "snippet": "vm_fault_t device_private_entry_fault(struct vm_area_struct *vma,\n\t\t       unsigned long addr,\n\t\t       swp_entry_t entry,\n\t\t       unsigned int flags,\n\t\t       pmd_t *pmdp)\n{\n\tstruct page *page = device_private_entry_to_page(entry);\n\n\t/*\n\t * The page_fault() callback must migrate page back to system memory\n\t * so that CPU can access it. This might fail for various reasons\n\t * (device issue, device was unsafely unplugged, ...). When such\n\t * error conditions happen, the callback must return VM_FAULT_SIGBUS.\n\t *\n\t * Note that because memory cgroup charges are accounted to the device\n\t * memory, this should never fail because of memory restrictions (but\n\t * allocation of regular system page might still fail because we are\n\t * out of memory).\n\t *\n\t * There is a more in-depth description of what that callback can and\n\t * cannot do, in include/linux/memremap.h\n\t */\n\treturn page->pgmap->page_fault(vma, addr, page, flags, pmdp);\n}",
    "includes": [
      "#include <linux/xarray.h>",
      "#include <linux/wait_bit.h>",
      "#include <linux/types.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kasan.h>",
      "#include <linux/io.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page->pgmap->page_fault",
          "args": [
            "vma",
            "addr",
            "page",
            "flags",
            "pmdp"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_private_entry_to_page",
          "args": [
            "entry"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xarray.h>\n#include <linux/wait_bit.h>\n#include <linux/types.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pfn_t.h>\n#include <linux/mm.h>\n#include <linux/memory_hotplug.h>\n#include <linux/kasan.h>\n#include <linux/io.h>\n#include <linux/device.h>\n\nvm_fault_t device_private_entry_fault(struct vm_area_struct *vma,\n\t\t       unsigned long addr,\n\t\t       swp_entry_t entry,\n\t\t       unsigned int flags,\n\t\t       pmd_t *pmdp)\n{\n\tstruct page *page = device_private_entry_to_page(entry);\n\n\t/*\n\t * The page_fault() callback must migrate page back to system memory\n\t * so that CPU can access it. This might fail for various reasons\n\t * (device issue, device was unsafely unplugged, ...). When such\n\t * error conditions happen, the callback must return VM_FAULT_SIGBUS.\n\t *\n\t * Note that because memory cgroup charges are accounted to the device\n\t * memory, this should never fail because of memory restrictions (but\n\t * allocation of regular system page might still fail because we are\n\t * out of memory).\n\t *\n\t * There is a more in-depth description of what that callback can and\n\t * cannot do, in include/linux/memremap.h\n\t */\n\treturn page->pgmap->page_fault(vma, addr, page, flags, pmdp);\n}"
  }
]