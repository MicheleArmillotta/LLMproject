[
  {
    "function_name": "init_trace_printk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "377-380",
    "snippet": "static __init int init_trace_printk(void)\n{\n\treturn register_module_notifier(&module_trace_bprintk_format_nb);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "notifier_block module_trace_bprintk_format_nb = {\n\t.notifier_call = module_trace_bprintk_format_notify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&module_trace_bprintk_format_nb"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "304-307",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nnotifier_block module_trace_bprintk_format_nb = {\n\t.notifier_call = module_trace_bprintk_format_notify,\n};\n\nstatic __init int init_trace_printk(void)\n{\n\treturn register_module_notifier(&module_trace_bprintk_format_nb);\n}"
  },
  {
    "function_name": "init_trace_printk_function_export",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "361-373",
    "snippet": "static __init int init_trace_printk_function_export(void)\n{\n\tstruct dentry *d_tracer;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\ttrace_create_file(\"printk_formats\", 0444, d_tracer,\n\t\t\t\t    NULL, &ftrace_formats_fops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct",
      "static const struct file_operations ftrace_formats_fops = {\n\t.open = ftrace_formats_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"printk_formats\"",
            "0444",
            "d_tracer",
            "NULL",
            "&ftrace_formats_fops"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "7459-7472",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d_tracer"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8023-8050",
          "snippet": "struct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nstruct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\nstatic const struct file_operations ftrace_formats_fops = {\n\t.open = ftrace_formats_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic __init int init_trace_printk_function_export(void)\n{\n\tstruct dentry *d_tracer;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\ttrace_create_file(\"printk_formats\", 0444, d_tracer,\n\t\t\t\t    NULL, &ftrace_formats_fops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_formats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "348-352",
    "snippet": "static int\nftrace_formats_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &show_format_seq_ops);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct",
      "static const struct seq_operations show_format_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&show_format_seq_ops"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\nstatic const struct seq_operations show_format_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};\n\nstatic int\nftrace_formats_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &show_format_seq_ops);\n}"
  },
  {
    "function_name": "t_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "336-339",
    "snippet": "static void t_stop(struct seq_file *m, void *p)\n{\n\tformat_mod_stop();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "format_mod_stop",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "format_mod_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "184-184",
          "snippet": "static inline void format_mod_stop(void) { }",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic inline void format_mod_stop(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tformat_mod_stop();\n}"
  },
  {
    "function_name": "t_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "299-334",
    "snippet": "static int t_show(struct seq_file *m, void *v)\n{\n\tconst char **fmt = v;\n\tconst char *str = *fmt;\n\tint i;\n\n\tif (!*fmt)\n\t\treturn 0;\n\n\tseq_printf(m, \"0x%lx : \\\"\", *(unsigned long *)fmt);\n\n\t/*\n\t * Tabs and new lines need to be converted.\n\t */\n\tfor (i = 0; str[i]; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '\\n':\n\t\t\tseq_puts(m, \"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tseq_puts(m, \"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tseq_putc(m, '\\\\');\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tseq_puts(m, \"\\\\\\\"\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_putc(m, str[i]);\n\t\t}\n\t}\n\tseq_puts(m, \"\\\"\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\\"\\n\""
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "str[i]"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"0x%lx : \\\"\"",
            "*(unsigned long *)fmt"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tconst char **fmt = v;\n\tconst char *str = *fmt;\n\tint i;\n\n\tif (!*fmt)\n\t\treturn 0;\n\n\tseq_printf(m, \"0x%lx : \\\"\", *(unsigned long *)fmt);\n\n\t/*\n\t * Tabs and new lines need to be converted.\n\t */\n\tfor (i = 0; str[i]; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '\\n':\n\t\t\tseq_puts(m, \"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tseq_puts(m, \"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tseq_putc(m, '\\\\');\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tseq_puts(m, \"\\\\\\\"\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_putc(m, str[i]);\n\t\t}\n\t}\n\tseq_puts(m, \"\\\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "t_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "293-297",
    "snippet": "static void *t_next(struct seq_file *m, void * v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn find_next(v, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next",
          "args": [
            "v",
            "pos"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "find_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "253-284",
          "snippet": "static const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic void *t_next(struct seq_file *m, void * v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn find_next(v, pos);\n}"
  },
  {
    "function_name": "t_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "286-291",
    "snippet": "static void *\nt_start(struct seq_file *m, loff_t *pos)\n{\n\tformat_mod_start();\n\treturn find_next(NULL, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next",
          "args": [
            "NULL",
            "pos"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "find_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "253-284",
          "snippet": "static const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_mod_start",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "format_mod_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "183-183",
          "snippet": "static inline void format_mod_start(void) { }",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic inline void format_mod_start(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic void *\nt_start(struct seq_file *m, loff_t *pos)\n{\n\tformat_mod_start();\n\treturn find_next(NULL, pos);\n}"
  },
  {
    "function_name": "find_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "253-284",
    "snippet": "static const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_mod_format",
          "args": [
            "start_index",
            "v",
            "fmt",
            "pos"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_mod_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "178-182",
          "snippet": "static inline const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic inline const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t/*\n\t * The __tracepoint_str section is treated the same as the\n\t * __trace_printk_fmt section. The difference is that the\n\t * __trace_printk_fmt section should only be used by trace_printk()\n\t * in a debugging environment, as if anything exists in that section\n\t * the trace_prink() helper buffers are allocated, which would just\n\t * waste space in a production environment.\n\t *\n\t * The __tracepoint_str sections on the other hand are used by\n\t * tracepoints which need to map pointers to their strings to\n\t * the ASCII text for userspace.\n\t */\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}"
  },
  {
    "function_name": "__ftrace_vprintk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "244-250",
    "snippet": "int __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_vprintk",
          "args": [
            "ip",
            "fmt",
            "ap"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_vprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "244-250",
          "snippet": "int __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nint __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}"
  },
  {
    "function_name": "__trace_printk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "229-241",
    "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_vprintk",
          "args": [
            "ip",
            "fmt",
            "ap"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_vprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "244-250",
          "snippet": "int __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nint __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ftrace_vbprintk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "217-226",
    "snippet": "int __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_vbprintk",
          "args": [
            "ip",
            "fmt",
            "ap"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_vbprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "217-226",
          "snippet": "int __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fmt"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nint __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}"
  },
  {
    "function_name": "__trace_bprintk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "199-214",
    "snippet": "int __trace_bprintk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vbprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_vbprintk",
          "args": [
            "ip",
            "fmt",
            "ap"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_vbprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "217-226",
          "snippet": "int __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nint __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fmt"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nint __trace_bprintk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vbprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_printk_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "189-192",
    "snippet": "void trace_printk_control(bool enabled)\n{\n\ttrace_printk_enabled = enabled;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nvoid trace_printk_control(bool enabled)\n{\n\ttrace_printk_enabled = enabled;\n}"
  },
  {
    "function_name": "format_mod_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "184-184",
    "snippet": "static inline void format_mod_stop(void) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic inline void format_mod_stop(void) { }"
  },
  {
    "function_name": "format_mod_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "183-183",
    "snippet": "static inline void format_mod_start(void) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic inline void format_mod_start(void) { }"
  },
  {
    "function_name": "find_next_mod_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "178-182",
    "snippet": "static inline const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic inline const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "module_trace_bprintk_format_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "172-177",
    "snippet": "__init static int\nmodule_trace_bprintk_format_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\n__init static int\nmodule_trace_bprintk_format_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "format_mod_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "166-169",
    "snippet": "static void format_mod_stop(void)\n{\n\tmutex_unlock(&btrace_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrace_mutex"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic void format_mod_stop(void)\n{\n\tmutex_unlock(&btrace_mutex);\n}"
  },
  {
    "function_name": "format_mod_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "161-164",
    "snippet": "static void format_mod_start(void)\n{\n\tmutex_lock(&btrace_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&btrace_mutex"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic void format_mod_start(void)\n{\n\tmutex_lock(&btrace_mutex);\n}"
  },
  {
    "function_name": "find_next_mod_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "121-159",
    "snippet": "static const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\tstruct trace_bprintk_fmt *mod_fmt;\n\n\tif (list_empty(&trace_bprintk_fmt_list))\n\t\treturn NULL;\n\n\t/*\n\t * v will point to the address of the fmt record from t_next\n\t * v will be NULL from t_start.\n\t * If this is the first pointer or called from start\n\t * then we need to walk the list.\n\t */\n\tif (!v || start_index == *pos) {\n\t\tstruct trace_bprintk_fmt *p;\n\n\t\t/* search the module list */\n\t\tlist_for_each_entry(p, &trace_bprintk_fmt_list, list) {\n\t\t\tif (start_index == *pos)\n\t\t\t\treturn &p->fmt;\n\t\t\tstart_index++;\n\t\t}\n\t\t/* pos > index */\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * v points to the address of the fmt field in the mod list\n\t * structure that holds the module print format.\n\t */\n\tmod_fmt = container_of(v, typeof(*mod_fmt), fmt);\n\tif (mod_fmt->list.next == &trace_bprintk_fmt_list)\n\t\treturn NULL;\n\n\tmod_fmt = container_of(mod_fmt->list.next, typeof(*mod_fmt), list);\n\n\treturn &mod_fmt->fmt;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "mod_fmt->list.next",
            "typeof(*mod_fmt)",
            "list"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*mod_fmt"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "v",
            "typeof(*mod_fmt)",
            "fmt"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*mod_fmt"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&trace_bprintk_fmt_list",
            "list"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&trace_bprintk_fmt_list"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\tstruct trace_bprintk_fmt *mod_fmt;\n\n\tif (list_empty(&trace_bprintk_fmt_list))\n\t\treturn NULL;\n\n\t/*\n\t * v will point to the address of the fmt record from t_next\n\t * v will be NULL from t_start.\n\t * If this is the first pointer or called from start\n\t * then we need to walk the list.\n\t */\n\tif (!v || start_index == *pos) {\n\t\tstruct trace_bprintk_fmt *p;\n\n\t\t/* search the module list */\n\t\tlist_for_each_entry(p, &trace_bprintk_fmt_list, list) {\n\t\t\tif (start_index == *pos)\n\t\t\t\treturn &p->fmt;\n\t\t\tstart_index++;\n\t\t}\n\t\t/* pos > index */\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * v points to the address of the fmt field in the mod list\n\t * structure that holds the module print format.\n\t */\n\tmod_fmt = container_of(v, typeof(*mod_fmt), fmt);\n\tif (mod_fmt->list.next == &trace_bprintk_fmt_list)\n\t\treturn NULL;\n\n\tmod_fmt = container_of(mod_fmt->list.next, typeof(*mod_fmt), list);\n\n\treturn &mod_fmt->fmt;\n}"
  },
  {
    "function_name": "module_trace_bprintk_format_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "87-99",
    "snippet": "static int module_trace_bprintk_format_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tif (mod->num_trace_bprintk_fmt) {\n\t\tconst char **start = mod->trace_bprintk_fmt_start;\n\t\tconst char **end = start + mod->num_trace_bprintk_fmt;\n\n\t\tif (val == MODULE_STATE_COMING)\n\t\t\thold_module_trace_bprintk_format(start, end);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hold_module_trace_bprintk_format",
          "args": [
            "start",
            "end"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "hold_module_trace_bprintk_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "51-85",
          "snippet": "static\nvoid hold_module_trace_bprintk_format(const char **start, const char **end)\n{\n\tconst char **iter;\n\tchar *fmt;\n\n\t/* allocate the trace_printk per cpu buffers */\n\tif (start != end)\n\t\ttrace_printk_init_buffers();\n\n\tmutex_lock(&btrace_mutex);\n\tfor (iter = start; iter < end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\tif (!IS_ERR(tb_fmt))\n\t\t\t\t*iter = tb_fmt->fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt = NULL;\n\t\ttb_fmt = kmalloc(sizeof(*tb_fmt), GFP_KERNEL);\n\t\tif (tb_fmt) {\n\t\t\tfmt = kmalloc(strlen(*iter) + 1, GFP_KERNEL);\n\t\t\tif (fmt) {\n\t\t\t\tlist_add_tail(&tb_fmt->list, &trace_bprintk_fmt_list);\n\t\t\t\tstrcpy(fmt, *iter);\n\t\t\t\ttb_fmt->fmt = fmt;\n\t\t\t} else\n\t\t\t\tkfree(tb_fmt);\n\t\t}\n\t\t*iter = fmt;\n\n\t}\n\tmutex_unlock(&btrace_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__initdata_or_module static\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic\nvoid hold_module_trace_bprintk_format(const char **start, const char **end)\n{\n\tconst char **iter;\n\tchar *fmt;\n\n\t/* allocate the trace_printk per cpu buffers */\n\tif (start != end)\n\t\ttrace_printk_init_buffers();\n\n\tmutex_lock(&btrace_mutex);\n\tfor (iter = start; iter < end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\tif (!IS_ERR(tb_fmt))\n\t\t\t\t*iter = tb_fmt->fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt = NULL;\n\t\ttb_fmt = kmalloc(sizeof(*tb_fmt), GFP_KERNEL);\n\t\tif (tb_fmt) {\n\t\t\tfmt = kmalloc(strlen(*iter) + 1, GFP_KERNEL);\n\t\t\tif (fmt) {\n\t\t\t\tlist_add_tail(&tb_fmt->list, &trace_bprintk_fmt_list);\n\t\t\t\tstrcpy(fmt, *iter);\n\t\t\t\ttb_fmt->fmt = fmt;\n\t\t\t} else\n\t\t\t\tkfree(tb_fmt);\n\t\t}\n\t\t*iter = fmt;\n\n\t}\n\tmutex_unlock(&btrace_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic int module_trace_bprintk_format_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tif (mod->num_trace_bprintk_fmt) {\n\t\tconst char **start = mod->trace_bprintk_fmt_start;\n\t\tconst char **end = start + mod->num_trace_bprintk_fmt;\n\n\t\tif (val == MODULE_STATE_COMING)\n\t\t\thold_module_trace_bprintk_format(start, end);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hold_module_trace_bprintk_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "51-85",
    "snippet": "static\nvoid hold_module_trace_bprintk_format(const char **start, const char **end)\n{\n\tconst char **iter;\n\tchar *fmt;\n\n\t/* allocate the trace_printk per cpu buffers */\n\tif (start != end)\n\t\ttrace_printk_init_buffers();\n\n\tmutex_lock(&btrace_mutex);\n\tfor (iter = start; iter < end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\tif (!IS_ERR(tb_fmt))\n\t\t\t\t*iter = tb_fmt->fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt = NULL;\n\t\ttb_fmt = kmalloc(sizeof(*tb_fmt), GFP_KERNEL);\n\t\tif (tb_fmt) {\n\t\t\tfmt = kmalloc(strlen(*iter) + 1, GFP_KERNEL);\n\t\t\tif (fmt) {\n\t\t\t\tlist_add_tail(&tb_fmt->list, &trace_bprintk_fmt_list);\n\t\t\t\tstrcpy(fmt, *iter);\n\t\t\t\ttb_fmt->fmt = fmt;\n\t\t\t} else\n\t\t\t\tkfree(tb_fmt);\n\t\t}\n\t\t*iter = fmt;\n\n\t}\n\tmutex_unlock(&btrace_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrace_mutex"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tb_fmt"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fmt",
            "*iter"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tb_fmt->list",
            "&trace_bprintk_fmt_list"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "strlen(*iter) + 1",
            "GFP_KERNEL"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*iter"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tb_fmt"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_format",
          "args": [
            "*iter"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "37-49",
          "snippet": "static inline struct trace_bprintk_fmt *lookup_format(const char *fmt)\n{\n\tstruct trace_bprintk_fmt *pos;\n\n\tif (!fmt)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry(pos, &trace_bprintk_fmt_list, list) {\n\t\tif (!strcmp(pos->fmt, fmt))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__initdata_or_module static\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic inline struct trace_bprintk_fmt *lookup_format(const char *fmt)\n{\n\tstruct trace_bprintk_fmt *pos;\n\n\tif (!fmt)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry(pos, &trace_bprintk_fmt_list, list) {\n\t\tif (!strcmp(pos->fmt, fmt))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&btrace_mutex"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_printk_init_buffers",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_init_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2842-2880",
          "snippet": "void trace_printk_init_buffers(void)\n{\n\tif (buffers_allocated)\n\t\treturn;\n\n\tif (alloc_percpu_trace_buffer())\n\t\treturn;\n\n\t/* trace_printk() is for debug use only. Don't use it in production. */\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** trace_printk() being used. Allocating extra memory.  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** This means that this is a DEBUG kernel and it is     **\\n\");\n\tpr_warn(\"** unsafe for production use.                           **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** If you see this message and you are not debugging    **\\n\");\n\tpr_warn(\"** the kernel, report this immediately to your vendor!  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\n\t/* Expand the buffers to set size */\n\ttracing_update_buffers();\n\n\tbuffers_allocated = 1;\n\n\t/*\n\t * trace_printk_init_buffers() can be called by modules.\n\t * If that happens, then we need to start cmdline recording\n\t * directly here. If the global_trace.buffer is already\n\t * allocated here, then this was called by module code.\n\t */\n\tif (global_trace.trace_buffer.buffer)\n\t\ttracing_start_cmdline_record();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static int buffers_allocated;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic int buffers_allocated;\n\nvoid trace_printk_init_buffers(void)\n{\n\tif (buffers_allocated)\n\t\treturn;\n\n\tif (alloc_percpu_trace_buffer())\n\t\treturn;\n\n\t/* trace_printk() is for debug use only. Don't use it in production. */\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** trace_printk() being used. Allocating extra memory.  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** This means that this is a DEBUG kernel and it is     **\\n\");\n\tpr_warn(\"** unsafe for production use.                           **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** If you see this message and you are not debugging    **\\n\");\n\tpr_warn(\"** the kernel, report this immediately to your vendor!  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\n\t/* Expand the buffers to set size */\n\ttracing_update_buffers();\n\n\tbuffers_allocated = 1;\n\n\t/*\n\t * trace_printk_init_buffers() can be called by modules.\n\t * If that happens, then we need to start cmdline recording\n\t * directly here. If the global_trace.buffer is already\n\t * allocated here, then this was called by module code.\n\t */\n\tif (global_trace.trace_buffer.buffer)\n\t\ttracing_start_cmdline_record();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic\nvoid hold_module_trace_bprintk_format(const char **start, const char **end)\n{\n\tconst char **iter;\n\tchar *fmt;\n\n\t/* allocate the trace_printk per cpu buffers */\n\tif (start != end)\n\t\ttrace_printk_init_buffers();\n\n\tmutex_lock(&btrace_mutex);\n\tfor (iter = start; iter < end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\tif (!IS_ERR(tb_fmt))\n\t\t\t\t*iter = tb_fmt->fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt = NULL;\n\t\ttb_fmt = kmalloc(sizeof(*tb_fmt), GFP_KERNEL);\n\t\tif (tb_fmt) {\n\t\t\tfmt = kmalloc(strlen(*iter) + 1, GFP_KERNEL);\n\t\t\tif (fmt) {\n\t\t\t\tlist_add_tail(&tb_fmt->list, &trace_bprintk_fmt_list);\n\t\t\t\tstrcpy(fmt, *iter);\n\t\t\t\ttb_fmt->fmt = fmt;\n\t\t\t} else\n\t\t\t\tkfree(tb_fmt);\n\t\t}\n\t\t*iter = fmt;\n\n\t}\n\tmutex_unlock(&btrace_mutex);\n}"
  },
  {
    "function_name": "lookup_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
    "lines": "37-49",
    "snippet": "static inline struct trace_bprintk_fmt *lookup_format(const char *fmt)\n{\n\tstruct trace_bprintk_fmt *pos;\n\n\tif (!fmt)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry(pos, &trace_bprintk_fmt_list, list) {\n\t\tif (!strcmp(pos->fmt, fmt))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/string.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__initdata_or_module static\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pos->fmt",
            "fmt"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "&trace_bprintk_fmt_list",
            "list"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n__initdata_or_module static\nstruct;\n\nstatic inline struct trace_bprintk_fmt *lookup_format(const char *fmt)\n{\n\tstruct trace_bprintk_fmt *pos;\n\n\tif (!fmt)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry(pos, &trace_bprintk_fmt_list, list) {\n\t\tif (!strcmp(pos->fmt, fmt))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}"
  }
]