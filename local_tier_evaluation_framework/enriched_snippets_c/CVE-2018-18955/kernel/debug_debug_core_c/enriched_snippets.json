[
  {
    "function_name": "opt_kgdb_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "1078-1087",
    "snippet": "static int __init opt_kgdb_wait(char *str)\n{\n\tkgdb_break_asap = 1;\n\n\tkdb_init(KDB_INIT_EARLY);\n\tif (kgdb_io_module_registered)\n\t\tkgdb_initial_breakpoint();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdb_break_asap;",
      "int\t\t\tkgdb_io_module_registered;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_initial_breakpoint",
          "args": [],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_initial_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "969-975",
          "snippet": "static void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kgdb_break_asap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\n\nstatic void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_init",
          "args": [
            "KDB_INIT_EARLY"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2920-2939",
          "snippet": "void __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\nint\t\t\tkgdb_io_module_registered;\n\nstatic int __init opt_kgdb_wait(char *str)\n{\n\tkgdb_break_asap = 1;\n\n\tkdb_init(KDB_INIT_EARLY);\n\tif (kgdb_io_module_registered)\n\t\tkgdb_initial_breakpoint();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "1068-1075",
    "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_t\t\t\tkgdb_setting_breakpoint;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&kgdb_setting_breakpoint"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kgdb_breakpoint",
          "args": [],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&kgdb_setting_breakpoint"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
  },
  {
    "function_name": "dbg_io_get_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "1048-1058",
    "snippet": "int dbg_io_get_char(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\tif (ret == NO_POLL_CHAR)\n\t\treturn -1;\n\tif (!dbg_kdb_mode)\n\t\treturn ret;\n\tif (ret == 127)\n\t\treturn 8;\n\treturn ret;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kgdb_io\t\t*dbg_io_ops;",
      "int dbg_kdb_mode = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_io_ops->read_char",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_kdb_mode = 1;\n\nint dbg_io_get_char(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\tif (ret == NO_POLL_CHAR)\n\t\treturn -1;\n\tif (!dbg_kdb_mode)\n\t\treturn ret;\n\tif (ret == 127)\n\t\treturn 8;\n\treturn ret;\n}"
  },
  {
    "function_name": "kgdb_unregister_io_module",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "1026-1045",
    "snippet": "void kgdb_unregister_io_module(struct kgdb_io *old_dbg_io_ops)\n{\n\tBUG_ON(kgdb_connected);\n\n\t/*\n\t * KGDB is no longer able to communicate out, so\n\t * unregister our callbacks and reset state.\n\t */\n\tkgdb_unregister_callbacks();\n\n\tspin_lock(&kgdb_registration_lock);\n\n\tWARN_ON_ONCE(dbg_io_ops != old_dbg_io_ops);\n\tdbg_io_ops = NULL;\n\n\tspin_unlock(&kgdb_registration_lock);\n\n\tpr_info(\"Unregistered I/O driver %s, debugger disabled\\n\",\n\t\told_dbg_io_ops->name);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\t\tkgdb_connected;",
      "struct kgdb_io\t\t*dbg_io_ops;",
      "static DEFINE_SPINLOCK(kgdb_registration_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Unregistered I/O driver %s, debugger disabled\\n\"",
            "old_dbg_io_ops->name"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kgdb_registration_lock"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dbg_io_ops != old_dbg_io_ops"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kgdb_registration_lock"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_unregister_callbacks",
          "args": [],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_unregister_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "920-942",
          "snippet": "static void kgdb_unregister_callbacks(void)\n{\n\t/*\n\t * When this routine is called KGDB should unregister from the\n\t * panic handler and clean up, making sure it is not handling any\n\t * break exceptions at the time.\n\t */\n\tif (kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 0;\n\t\tunregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tunregister_module_notifier(&dbg_module_load_nb);\n\t\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t       &kgdb_panic_event_nb);\n\t\tkgdb_arch_exit();\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tunregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_con_registered) {\n\t\t\tunregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\tkgdb_io_module_registered;",
            "static int kgdb_con_registered;",
            "static struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};",
            "static struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};",
            "static struct notifier_block kgdb_panic_event_nb = {\n       .notifier_call\t= kgdb_panic_event,\n       .priority\t= INT_MAX,\n};",
            "static struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int kgdb_con_registered;\nstatic struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};\nstatic struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};\nstatic struct notifier_block kgdb_panic_event_nb = {\n       .notifier_call\t= kgdb_panic_event,\n       .priority\t= INT_MAX,\n};\nstatic struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};\n\nstatic void kgdb_unregister_callbacks(void)\n{\n\t/*\n\t * When this routine is called KGDB should unregister from the\n\t * panic handler and clean up, making sure it is not handling any\n\t * break exceptions at the time.\n\t */\n\tif (kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 0;\n\t\tunregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tunregister_module_notifier(&dbg_module_load_nb);\n\t\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t       &kgdb_panic_event_nb);\n\t\tkgdb_arch_exit();\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tunregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_con_registered) {\n\t\t\tunregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "kgdb_connected"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nstruct kgdb_io\t\t*dbg_io_ops;\nstatic DEFINE_SPINLOCK(kgdb_registration_lock);\n\nvoid kgdb_unregister_io_module(struct kgdb_io *old_dbg_io_ops)\n{\n\tBUG_ON(kgdb_connected);\n\n\t/*\n\t * KGDB is no longer able to communicate out, so\n\t * unregister our callbacks and reset state.\n\t */\n\tkgdb_unregister_callbacks();\n\n\tspin_lock(&kgdb_registration_lock);\n\n\tWARN_ON_ONCE(dbg_io_ops != old_dbg_io_ops);\n\tdbg_io_ops = NULL;\n\n\tspin_unlock(&kgdb_registration_lock);\n\n\tpr_info(\"Unregistered I/O driver %s, debugger disabled\\n\",\n\t\told_dbg_io_ops->name);\n}"
  },
  {
    "function_name": "kgdb_register_io_module",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "983-1017",
    "snippet": "int kgdb_register_io_module(struct kgdb_io *new_dbg_io_ops)\n{\n\tint err;\n\n\tspin_lock(&kgdb_registration_lock);\n\n\tif (dbg_io_ops) {\n\t\tspin_unlock(&kgdb_registration_lock);\n\n\t\tpr_err(\"Another I/O driver is already registered with KGDB\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (new_dbg_io_ops->init) {\n\t\terr = new_dbg_io_ops->init();\n\t\tif (err) {\n\t\t\tspin_unlock(&kgdb_registration_lock);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdbg_io_ops = new_dbg_io_ops;\n\n\tspin_unlock(&kgdb_registration_lock);\n\n\tpr_info(\"Registered I/O driver %s\\n\", new_dbg_io_ops->name);\n\n\t/* Arm KGDB now. */\n\tkgdb_register_callbacks();\n\n\tif (kgdb_break_asap)\n\t\tkgdb_initial_breakpoint();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdb_break_asap;",
      "struct kgdb_io\t\t*dbg_io_ops;",
      "static DEFINE_SPINLOCK(kgdb_registration_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_initial_breakpoint",
          "args": [],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_initial_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "969-975",
          "snippet": "static void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kgdb_break_asap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\n\nstatic void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_register_callbacks",
          "args": [],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_register_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "899-918",
          "snippet": "static void kgdb_register_callbacks(void)\n{\n\tif (!kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 1;\n\t\tkgdb_arch_init();\n\t\tif (!dbg_is_early)\n\t\t\tkgdb_arch_late();\n\t\tregister_module_notifier(&dbg_module_load_nb);\n\t\tregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t       &kgdb_panic_event_nb);\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_use_con && !kgdb_con_registered) {\n\t\t\tregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\tkgdb_io_module_registered;",
            "static int kgdb_con_registered;",
            "static int kgdb_use_con;",
            "bool dbg_is_early = true;",
            "static struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};",
            "static struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};",
            "static struct notifier_block kgdb_panic_event_nb = {\n       .notifier_call\t= kgdb_panic_event,\n       .priority\t= INT_MAX,\n};",
            "static struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int kgdb_con_registered;\nstatic int kgdb_use_con;\nbool dbg_is_early = true;\nstatic struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};\nstatic struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};\nstatic struct notifier_block kgdb_panic_event_nb = {\n       .notifier_call\t= kgdb_panic_event,\n       .priority\t= INT_MAX,\n};\nstatic struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};\n\nstatic void kgdb_register_callbacks(void)\n{\n\tif (!kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 1;\n\t\tkgdb_arch_init();\n\t\tif (!dbg_is_early)\n\t\t\tkgdb_arch_late();\n\t\tregister_module_notifier(&dbg_module_load_nb);\n\t\tregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t       &kgdb_panic_event_nb);\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_use_con && !kgdb_con_registered) {\n\t\t\tregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Registered I/O driver %s\\n\"",
            "new_dbg_io_ops->name"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kgdb_registration_lock"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_dbg_io_ops->init",
          "args": [],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Another I/O driver is already registered with KGDB\\n\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kgdb_registration_lock"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\nstruct kgdb_io\t\t*dbg_io_ops;\nstatic DEFINE_SPINLOCK(kgdb_registration_lock);\n\nint kgdb_register_io_module(struct kgdb_io *new_dbg_io_ops)\n{\n\tint err;\n\n\tspin_lock(&kgdb_registration_lock);\n\n\tif (dbg_io_ops) {\n\t\tspin_unlock(&kgdb_registration_lock);\n\n\t\tpr_err(\"Another I/O driver is already registered with KGDB\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (new_dbg_io_ops->init) {\n\t\terr = new_dbg_io_ops->init();\n\t\tif (err) {\n\t\t\tspin_unlock(&kgdb_registration_lock);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdbg_io_ops = new_dbg_io_ops;\n\n\tspin_unlock(&kgdb_registration_lock);\n\n\tpr_info(\"Registered I/O driver %s\\n\", new_dbg_io_ops->name);\n\n\t/* Arm KGDB now. */\n\tkgdb_register_callbacks();\n\n\tif (kgdb_break_asap)\n\t\tkgdb_initial_breakpoint();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_initial_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "969-975",
    "snippet": "static void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdb_break_asap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_breakpoint",
          "args": [],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "1068-1075",
          "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Waiting for connection from remote gdb...\\n\""
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\n\nstatic void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}"
  },
  {
    "function_name": "kgdb_schedule_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "958-966",
    "snippet": "void kgdb_schedule_breakpoint(void)\n{\n\tif (atomic_read(&kgdb_break_tasklet_var) ||\n\t\tatomic_read(&kgdb_active) != -1 ||\n\t\tatomic_read(&kgdb_setting_breakpoint))\n\t\treturn;\n\tatomic_inc(&kgdb_break_tasklet_var);\n\ttasklet_schedule(&kgdb_tasklet_breakpoint);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);",
      "static atomic_t\t\t\tkgdb_break_tasklet_var;",
      "atomic_t\t\t\tkgdb_setting_breakpoint;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasklet_schedule",
          "args": [
            "&kgdb_tasklet_breakpoint"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "__tasklet_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "487-491",
          "snippet": "void __tasklet_schedule(struct tasklet_struct *t)\n{\n\t__tasklet_schedule_common(t, &tasklet_vec,\n\t\t\t\t  TASKLET_SOFTIRQ);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);\n\nvoid __tasklet_schedule(struct tasklet_struct *t)\n{\n\t__tasklet_schedule_common(t, &tasklet_vec,\n\t\t\t\t  TASKLET_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&kgdb_break_tasklet_var"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_setting_breakpoint"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_active"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_break_tasklet_var"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\nstatic atomic_t\t\t\tkgdb_break_tasklet_var;\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nvoid kgdb_schedule_breakpoint(void)\n{\n\tif (atomic_read(&kgdb_break_tasklet_var) ||\n\t\tatomic_read(&kgdb_active) != -1 ||\n\t\tatomic_read(&kgdb_setting_breakpoint))\n\t\treturn;\n\tatomic_inc(&kgdb_break_tasklet_var);\n\ttasklet_schedule(&kgdb_tasklet_breakpoint);\n}"
  },
  {
    "function_name": "kgdb_tasklet_bpt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "950-954",
    "snippet": "static void kgdb_tasklet_bpt(unsigned long ing)\n{\n\tkgdb_breakpoint();\n\tatomic_set(&kgdb_break_tasklet_var, 0);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t\t\t\tkgdb_break_tasklet_var;",
      "static DECLARE_TASKLET(kgdb_tasklet_breakpoint, kgdb_tasklet_bpt, 0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kgdb_break_tasklet_var",
            "0"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_breakpoint",
          "args": [],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "1068-1075",
          "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic atomic_t\t\t\tkgdb_break_tasklet_var;\nstatic DECLARE_TASKLET(kgdb_tasklet_breakpoint, kgdb_tasklet_bpt, 0);\n\nstatic void kgdb_tasklet_bpt(unsigned long ing)\n{\n\tkgdb_breakpoint();\n\tatomic_set(&kgdb_break_tasklet_var, 0);\n}"
  },
  {
    "function_name": "kgdb_unregister_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "920-942",
    "snippet": "static void kgdb_unregister_callbacks(void)\n{\n\t/*\n\t * When this routine is called KGDB should unregister from the\n\t * panic handler and clean up, making sure it is not handling any\n\t * break exceptions at the time.\n\t */\n\tif (kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 0;\n\t\tunregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tunregister_module_notifier(&dbg_module_load_nb);\n\t\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t       &kgdb_panic_event_nb);\n\t\tkgdb_arch_exit();\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tunregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_con_registered) {\n\t\t\tunregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tkgdb_io_module_registered;",
      "static int kgdb_con_registered;",
      "static struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};",
      "static struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};",
      "static struct notifier_block kgdb_panic_event_nb = {\n       .notifier_call\t= kgdb_panic_event,\n       .priority\t= INT_MAX,\n};",
      "static struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_console",
          "args": [
            "&kgdbcons"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2745-2788",
          "snippet": "int unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!res && (console->flags & CON_EXTENDED))\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct console *console_drivers;",
            "static int nr_ext_console_drivers;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstruct console *console_drivers;\nstatic int nr_ext_console_drivers;\n\nint unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!res && (console->flags & CON_EXTENDED))\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_sysrq_key",
          "args": [
            "'g'",
            "&sysrq_dbg_op"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_exit",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_notifier_chain_unregister",
          "args": [
            "&panic_notifier_list",
            "&kgdb_panic_event_nb"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "143-154",
          "snippet": "int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_module_notifier",
          "args": [
            "&dbg_module_load_nb"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "304-307",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_reboot_notifier",
          "args": [
            "&dbg_reboot_notifier"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_reboot_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/reboot.c",
          "lines": "102-105",
          "snippet": "int unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n\nint unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int kgdb_con_registered;\nstatic struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};\nstatic struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};\nstatic struct notifier_block kgdb_panic_event_nb = {\n       .notifier_call\t= kgdb_panic_event,\n       .priority\t= INT_MAX,\n};\nstatic struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};\n\nstatic void kgdb_unregister_callbacks(void)\n{\n\t/*\n\t * When this routine is called KGDB should unregister from the\n\t * panic handler and clean up, making sure it is not handling any\n\t * break exceptions at the time.\n\t */\n\tif (kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 0;\n\t\tunregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tunregister_module_notifier(&dbg_module_load_nb);\n\t\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t       &kgdb_panic_event_nb);\n\t\tkgdb_arch_exit();\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tunregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_con_registered) {\n\t\t\tunregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kgdb_register_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "899-918",
    "snippet": "static void kgdb_register_callbacks(void)\n{\n\tif (!kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 1;\n\t\tkgdb_arch_init();\n\t\tif (!dbg_is_early)\n\t\t\tkgdb_arch_late();\n\t\tregister_module_notifier(&dbg_module_load_nb);\n\t\tregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t       &kgdb_panic_event_nb);\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_use_con && !kgdb_con_registered) {\n\t\t\tregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 1;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tkgdb_io_module_registered;",
      "static int kgdb_con_registered;",
      "static int kgdb_use_con;",
      "bool dbg_is_early = true;",
      "static struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};",
      "static struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};",
      "static struct notifier_block kgdb_panic_event_nb = {\n       .notifier_call\t= kgdb_panic_event,\n       .priority\t= INT_MAX,\n};",
      "static struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_console",
          "args": [
            "&kgdbcons"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2745-2788",
          "snippet": "int unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!res && (console->flags & CON_EXTENDED))\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct console *console_drivers;",
            "static int nr_ext_console_drivers;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstruct console *console_drivers;\nstatic int nr_ext_console_drivers;\n\nint unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!res && (console->flags & CON_EXTENDED))\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_sysrq_key",
          "args": [
            "'g'",
            "&sysrq_dbg_op"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_notifier_chain_register",
          "args": [
            "&panic_notifier_list",
            "&kgdb_panic_event_nb"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "121-131",
          "snippet": "int atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_reboot_notifier",
          "args": [
            "&dbg_reboot_notifier"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_reboot_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/reboot.c",
          "lines": "102-105",
          "snippet": "int unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n\nint unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&dbg_module_load_nb"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "304-307",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_late",
          "args": [],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "860-862",
          "snippet": "void __weak kgdb_arch_late(void)\n{\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nvoid __weak kgdb_arch_late(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_init",
          "args": [],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "213-216",
          "snippet": "int __weak kgdb_arch_init(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_init(void)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int kgdb_con_registered;\nstatic int kgdb_use_con;\nbool dbg_is_early = true;\nstatic struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};\nstatic struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};\nstatic struct notifier_block kgdb_panic_event_nb = {\n       .notifier_call\t= kgdb_panic_event,\n       .priority\t= INT_MAX,\n};\nstatic struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};\n\nstatic void kgdb_register_callbacks(void)\n{\n\tif (!kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 1;\n\t\tkgdb_arch_init();\n\t\tif (!dbg_is_early)\n\t\t\tkgdb_arch_late();\n\t\tregister_module_notifier(&dbg_module_load_nb);\n\t\tregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t       &kgdb_panic_event_nb);\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_use_con && !kgdb_con_registered) {\n\t\t\tregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 1;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "dbg_notify_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "872-891",
    "snippet": "static int\ndbg_notify_reboot(struct notifier_block *this, unsigned long code, void *x)\n{\n\t/*\n\t * Take the following action on reboot notify depending on value:\n\t *    1 == Enter debugger\n\t *    0 == [the default] detatch debug client\n\t *   -1 == Do nothing... and use this until the board resets\n\t */\n\tswitch (kgdbreboot) {\n\tcase 1:\n\t\tkgdb_breakpoint();\n\tcase -1:\n\t\tgoto done;\n\t}\n\tif (!dbg_kdb_mode)\n\t\tgdbstub_exit(code);\ndone:\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdbreboot;",
      "int dbg_kdb_mode = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gdbstub_exit",
          "args": [
            "code"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/gdbstub.c",
          "lines": "1114-1146",
          "snippet": "void gdbstub_exit(int status)\n{\n\tunsigned char checksum, ch, buffer[3];\n\tint loop;\n\n\tif (!kgdb_connected)\n\t\treturn;\n\tkgdb_connected = 0;\n\n\tif (!dbg_io_ops || dbg_kdb_mode)\n\t\treturn;\n\n\tbuffer[0] = 'W';\n\tbuffer[1] = hex_asc_hi(status);\n\tbuffer[2] = hex_asc_lo(status);\n\n\tdbg_io_ops->write_char('$');\n\tchecksum = 0;\n\n\tfor (loop = 0; loop < 3; loop++) {\n\t\tch = buffer[loop];\n\t\tchecksum += ch;\n\t\tdbg_io_ops->write_char(ch);\n\t}\n\n\tdbg_io_ops->write_char('#');\n\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\n\t/* make sure the output is flushed, lest the bootloader clobber it */\n\tif (dbg_io_ops->flush)\n\t\tdbg_io_ops->flush();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid gdbstub_exit(int status)\n{\n\tunsigned char checksum, ch, buffer[3];\n\tint loop;\n\n\tif (!kgdb_connected)\n\t\treturn;\n\tkgdb_connected = 0;\n\n\tif (!dbg_io_ops || dbg_kdb_mode)\n\t\treturn;\n\n\tbuffer[0] = 'W';\n\tbuffer[1] = hex_asc_hi(status);\n\tbuffer[2] = hex_asc_lo(status);\n\n\tdbg_io_ops->write_char('$');\n\tchecksum = 0;\n\n\tfor (loop = 0; loop < 3; loop++) {\n\t\tch = buffer[loop];\n\t\tchecksum += ch;\n\t\tdbg_io_ops->write_char(ch);\n\t}\n\n\tdbg_io_ops->write_char('#');\n\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\n\t/* make sure the output is flushed, lest the bootloader clobber it */\n\tif (dbg_io_ops->flush)\n\t\tdbg_io_ops->flush();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_breakpoint",
          "args": [],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "1068-1075",
          "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdbreboot;\nint dbg_kdb_mode = 1;\n\nstatic int\ndbg_notify_reboot(struct notifier_block *this, unsigned long code, void *x)\n{\n\t/*\n\t * Take the following action on reboot notify depending on value:\n\t *    1 == Enter debugger\n\t *    0 == [the default] detatch debug client\n\t *   -1 == Do nothing... and use this until the board resets\n\t */\n\tswitch (kgdbreboot) {\n\tcase 1:\n\t\tkgdb_breakpoint();\n\tcase -1:\n\t\tgoto done;\n\t}\n\tif (!dbg_kdb_mode)\n\t\tgdbstub_exit(code);\ndone:\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "dbg_late_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "864-870",
    "snippet": "void __init dbg_late_init(void)\n{\n\tdbg_is_early = false;\n\tif (kgdb_io_module_registered)\n\t\tkgdb_arch_late();\n\tkdb_init(KDB_INIT_FULL);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tkgdb_io_module_registered;",
      "bool dbg_is_early = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_init",
          "args": [
            "KDB_INIT_FULL"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2920-2939",
          "snippet": "void __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_late",
          "args": [],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "860-862",
          "snippet": "void __weak kgdb_arch_late(void)\n{\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nvoid __weak kgdb_arch_late(void)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nbool dbg_is_early = true;\n\nvoid __init dbg_late_init(void)\n{\n\tdbg_is_early = false;\n\tif (kgdb_io_module_registered)\n\t\tkgdb_arch_late();\n\tkdb_init(KDB_INIT_FULL);\n}"
  },
  {
    "function_name": "kgdb_arch_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "860-862",
    "snippet": "void __weak kgdb_arch_late(void)\n{\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nvoid __weak kgdb_arch_late(void)\n{\n}"
  },
  {
    "function_name": "kgdb_panic_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "836-853",
    "snippet": "static int kgdb_panic_event(struct notifier_block *self,\n\t\t\t    unsigned long val,\n\t\t\t    void *data)\n{\n\t/*\n\t * Avoid entering the debugger if we were triggered due to a panic\n\t * We don't want to get stuck waiting for input from user in such case.\n\t * panic_timeout indicates the system should automatically\n\t * reboot on panic.\n\t */\n\tif (panic_timeout)\n\t\treturn NOTIFY_DONE;\n\n\tif (dbg_kdb_mode)\n\t\tkdb_printf(\"PANIC: %s\\n\", (char *)data);\n\tkgdb_breakpoint();\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int dbg_kdb_mode = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_breakpoint",
          "args": [],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "1068-1075",
          "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"PANIC: %s\\n\"",
            "(char *)data"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint dbg_kdb_mode = 1;\n\nstatic int kgdb_panic_event(struct notifier_block *self,\n\t\t\t    unsigned long val,\n\t\t\t    void *data)\n{\n\t/*\n\t * Avoid entering the debugger if we were triggered due to a panic\n\t * We don't want to get stuck waiting for input from user in such case.\n\t * panic_timeout indicates the system should automatically\n\t * reboot on panic.\n\t */\n\tif (panic_timeout)\n\t\treturn NOTIFY_DONE;\n\n\tif (dbg_kdb_mode)\n\t\tkdb_printf(\"PANIC: %s\\n\", (char *)data);\n\tkgdb_breakpoint();\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "sysrq_handle_dbg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "811-827",
    "snippet": "static void sysrq_handle_dbg(int key)\n{\n\tif (!dbg_io_ops) {\n\t\tpr_crit(\"ERROR: No KGDB I/O module available\\n\");\n\t\treturn;\n\t}\n\tif (!kgdb_connected) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"KGDB or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Entering KGDB\\n\");\n#endif\n\t}\n\n\tkgdb_breakpoint();\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\t\tkgdb_connected;",
      "struct kgdb_io\t\t*dbg_io_ops;",
      "int dbg_kdb_mode = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_breakpoint",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "1068-1075",
          "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Entering KGDB\\n\""
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"KGDB or $3#33 for KDB\\n\""
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"ERROR: No KGDB I/O module available\\n\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_kdb_mode = 1;\n\nstatic void sysrq_handle_dbg(int key)\n{\n\tif (!dbg_io_ops) {\n\t\tpr_crit(\"ERROR: No KGDB I/O module available\\n\");\n\t\treturn;\n\t}\n\tif (!kgdb_connected) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"KGDB or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Entering KGDB\\n\");\n#endif\n\t}\n\n\tkgdb_breakpoint();\n}"
  },
  {
    "function_name": "kgdb_console_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "788-801",
    "snippet": "static void kgdb_console_write(struct console *co, const char *s,\n   unsigned count)\n{\n\tunsigned long flags;\n\n\t/* If we're debugging, or KGDB has not connected, don't try\n\t * and print. */\n\tif (!kgdb_connected || atomic_read(&kgdb_active) != -1 || dbg_kdb_mode)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tgdbstub_msg_write(s, count);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\t\tkgdb_connected;",
      "int dbg_kdb_mode = 1;",
      "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdbstub_msg_write",
          "args": [
            "s",
            "count"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_msg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/gdbstub.c",
          "lines": "198-232",
          "snippet": "void gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char gdbmsgbuf[BUFMAX + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char gdbmsgbuf[BUFMAX + 1];\n\nvoid gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_active"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\n\nstatic void kgdb_console_write(struct console *co, const char *s,\n   unsigned count)\n{\n\tunsigned long flags;\n\n\t/* If we're debugging, or KGDB has not connected, don't try\n\t * and print. */\n\tif (!kgdb_connected || atomic_read(&kgdb_active) != -1 || dbg_kdb_mode)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tgdbstub_msg_write(s, count);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "kgdb_nmicallin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "763-786",
    "snippet": "int kgdb_nmicallin(int cpu, int trapnr, void *regs, int err_code,\n\t\t\t\t\t\t\tatomic_t *send_ready)\n{\n#ifdef CONFIG_SMP\n\tif (!kgdb_io_ready(0) || !send_ready)\n\t\treturn 1;\n\n\tif (kgdb_info[cpu].enter_kgdb == 0) {\n\t\tstruct kgdb_state kgdb_var;\n\t\tstruct kgdb_state *ks = &kgdb_var;\n\n\t\tmemset(ks, 0, sizeof(struct kgdb_state));\n\t\tks->cpu\t\t\t= cpu;\n\t\tks->ex_vector\t\t= trapnr;\n\t\tks->signo\t\t= SIGTRAP;\n\t\tks->err_code\t\t= err_code;\n\t\tks->linux_regs\t\t= regs;\n\t\tks->send_ready\t\t= send_ready;\n\t\tkgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct debuggerinfo_struct kgdb_info[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_cpu_enter",
          "args": [
            "ks",
            "regs",
            "DCPU_WANT_MASTER"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_cpu_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "468-682",
          "snippet": "static int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus(flags);\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\n\treturn kgdb_info[cpu].ret_state;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
            "int\t\t\t\tkgdb_connected;",
            "static int\t\t\texception_level;",
            "struct kgdb_io\t\t*dbg_io_ops;",
            "int dbg_switch_cpu;",
            "int dbg_kdb_mode = 1;",
            "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);",
            "static DEFINE_RAW_SPINLOCK(dbg_master_lock);",
            "static DEFINE_RAW_SPINLOCK(dbg_slave_lock);",
            "static atomic_t\t\t\tmasters_in_kgdb;",
            "static atomic_t\t\t\tslaves_in_kgdb;",
            "struct task_struct\t\t*kgdb_contthread;",
            "int\t\t\t\tkgdb_single_step;",
            "static pid_t\t\t\tkgdb_sstep_pid;",
            "atomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);",
            "static int kgdb_do_roundup = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nint\t\t\t\tkgdb_connected;\nstatic int\t\t\texception_level;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_switch_cpu;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\nstatic DEFINE_RAW_SPINLOCK(dbg_slave_lock);\nstatic atomic_t\t\t\tmasters_in_kgdb;\nstatic atomic_t\t\t\tslaves_in_kgdb;\nstruct task_struct\t\t*kgdb_contthread;\nint\t\t\t\tkgdb_single_step;\nstatic pid_t\t\t\tkgdb_sstep_pid;\natomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);\nstatic int kgdb_do_roundup = 1;\n\nstatic int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus(flags);\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\n\treturn kgdb_info[cpu].ret_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ks",
            "0",
            "sizeof(struct kgdb_state)"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_io_ready",
          "args": [
            "0"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_io_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "396-413",
          "snippet": "static int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\t\tkgdb_connected;",
            "struct kgdb_io\t\t*dbg_io_ops;",
            "int dbg_kdb_mode = 1;",
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nstatic int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\n\nint kgdb_nmicallin(int cpu, int trapnr, void *regs, int err_code,\n\t\t\t\t\t\t\tatomic_t *send_ready)\n{\n#ifdef CONFIG_SMP\n\tif (!kgdb_io_ready(0) || !send_ready)\n\t\treturn 1;\n\n\tif (kgdb_info[cpu].enter_kgdb == 0) {\n\t\tstruct kgdb_state kgdb_var;\n\t\tstruct kgdb_state *ks = &kgdb_var;\n\n\t\tmemset(ks, 0, sizeof(struct kgdb_state));\n\t\tks->cpu\t\t\t= cpu;\n\t\tks->ex_vector\t\t= trapnr;\n\t\tks->signo\t\t= SIGTRAP;\n\t\tks->err_code\t\t= err_code;\n\t\tks->linux_regs\t\t= regs;\n\t\tks->send_ready\t\t= send_ready;\n\t\tkgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "kgdb_nmicallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "744-761",
    "snippet": "int kgdb_nmicallback(int cpu, void *regs)\n{\n#ifdef CONFIG_SMP\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= cpu;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_info[ks->cpu].enter_kgdb == 0 &&\n\t\t\traw_spin_is_locked(&dbg_master_lock)) {\n\t\tkgdb_cpu_enter(ks, regs, DCPU_IS_SLAVE);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
      "static DEFINE_RAW_SPINLOCK(dbg_master_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_cpu_enter",
          "args": [
            "ks",
            "regs",
            "DCPU_IS_SLAVE"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_cpu_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "468-682",
          "snippet": "static int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus(flags);\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\n\treturn kgdb_info[cpu].ret_state;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
            "int\t\t\t\tkgdb_connected;",
            "static int\t\t\texception_level;",
            "struct kgdb_io\t\t*dbg_io_ops;",
            "int dbg_switch_cpu;",
            "int dbg_kdb_mode = 1;",
            "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);",
            "static DEFINE_RAW_SPINLOCK(dbg_master_lock);",
            "static DEFINE_RAW_SPINLOCK(dbg_slave_lock);",
            "static atomic_t\t\t\tmasters_in_kgdb;",
            "static atomic_t\t\t\tslaves_in_kgdb;",
            "struct task_struct\t\t*kgdb_contthread;",
            "int\t\t\t\tkgdb_single_step;",
            "static pid_t\t\t\tkgdb_sstep_pid;",
            "atomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);",
            "static int kgdb_do_roundup = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nint\t\t\t\tkgdb_connected;\nstatic int\t\t\texception_level;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_switch_cpu;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\nstatic DEFINE_RAW_SPINLOCK(dbg_slave_lock);\nstatic atomic_t\t\t\tmasters_in_kgdb;\nstatic atomic_t\t\t\tslaves_in_kgdb;\nstruct task_struct\t\t*kgdb_contthread;\nint\t\t\t\tkgdb_single_step;\nstatic pid_t\t\t\tkgdb_sstep_pid;\natomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);\nstatic int kgdb_do_roundup = 1;\n\nstatic int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus(flags);\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\n\treturn kgdb_info[cpu].ret_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "&dbg_master_lock"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ks",
            "0",
            "sizeof(struct kgdb_state)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\n\nint kgdb_nmicallback(int cpu, void *regs)\n{\n#ifdef CONFIG_SMP\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= cpu;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_info[ks->cpu].enter_kgdb == 0 &&\n\t\t\traw_spin_is_locked(&dbg_master_lock)) {\n\t\tkgdb_cpu_enter(ks, regs, DCPU_IS_SLAVE);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "module_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "734-738",
    "snippet": "static int module_event(struct notifier_block *self, unsigned long val,\n\tvoid *data)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int module_event(struct notifier_block *self, unsigned long val,\n\tvoid *data)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_handle_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "691-726",
    "snippet": "int\nkgdb_handle_exception(int evector, int signo, int ecode, struct pt_regs *regs)\n{\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\tint ret = 0;\n\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tarch_kgdb_ops.enable_nmi(0);\n\t/*\n\t * Avoid entering the debugger if we were triggered due to an oops\n\t * but panic_timeout indicates the system should automatically\n\t * reboot on panic. We don't want to get stuck waiting for input\n\t * on such systems, especially if its \"just\" an oops.\n\t */\n\tif (signo != SIGTRAP && panic_timeout)\n\t\treturn 1;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= raw_smp_processor_id();\n\tks->ex_vector\t\t= evector;\n\tks->signo\t\t= signo;\n\tks->err_code\t\t= ecode;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_reenter_check(ks))\n\t\tgoto out; /* Ouch, double exception ! */\n\tif (kgdb_info[ks->cpu].enter_kgdb != 0)\n\t\tgoto out;\n\n\tret = kgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\nout:\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tarch_kgdb_ops.enable_nmi(1);\n\treturn ret;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct debuggerinfo_struct kgdb_info[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kgdb_ops.enable_nmi",
          "args": [
            "1"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_cpu_enter",
          "args": [
            "ks",
            "regs",
            "DCPU_WANT_MASTER"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_cpu_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "468-682",
          "snippet": "static int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus(flags);\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\n\treturn kgdb_info[cpu].ret_state;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
            "int\t\t\t\tkgdb_connected;",
            "static int\t\t\texception_level;",
            "struct kgdb_io\t\t*dbg_io_ops;",
            "int dbg_switch_cpu;",
            "int dbg_kdb_mode = 1;",
            "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);",
            "static DEFINE_RAW_SPINLOCK(dbg_master_lock);",
            "static DEFINE_RAW_SPINLOCK(dbg_slave_lock);",
            "static atomic_t\t\t\tmasters_in_kgdb;",
            "static atomic_t\t\t\tslaves_in_kgdb;",
            "struct task_struct\t\t*kgdb_contthread;",
            "int\t\t\t\tkgdb_single_step;",
            "static pid_t\t\t\tkgdb_sstep_pid;",
            "atomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);",
            "static int kgdb_do_roundup = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nint\t\t\t\tkgdb_connected;\nstatic int\t\t\texception_level;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_switch_cpu;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\nstatic DEFINE_RAW_SPINLOCK(dbg_slave_lock);\nstatic atomic_t\t\t\tmasters_in_kgdb;\nstatic atomic_t\t\t\tslaves_in_kgdb;\nstruct task_struct\t\t*kgdb_contthread;\nint\t\t\t\tkgdb_single_step;\nstatic pid_t\t\t\tkgdb_sstep_pid;\natomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);\nstatic int kgdb_do_roundup = 1;\n\nstatic int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus(flags);\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\n\treturn kgdb_info[cpu].ret_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_reenter_check",
          "args": [
            "ks"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_reenter_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "415-459",
          "snippet": "static int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t/* Panic on recursive debugger calls: */\n\texception_level++;\n\taddr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tdbg_deactivate_sw_breakpoints();\n\n\t/*\n\t * If the break point removed ok at the place exception\n\t * occurred, try to recover and print a warning to the end\n\t * user because the user planted a breakpoint in a place that\n\t * KGDB needs in order to function.\n\t */\n\tif (dbg_remove_sw_break(addr) == 0) {\n\t\texception_level = 0;\n\t\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\t\tdbg_activate_sw_breakpoints();\n\t\tpr_crit(\"re-enter error: breakpoint removed %lx\\n\", addr);\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn 1;\n\t}\n\tdbg_remove_all_break();\n\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\n\tif (exception_level > 1) {\n\t\tdump_stack();\n\t\tpanic(\"Recursive entry to debugger\");\n\t}\n\n\tpr_crit(\"re-enter exception: ALL breakpoints killed\\n\");\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow kdb to debug itself one level */\n\treturn 0;\n#endif\n\tdump_stack();\n\tpanic(\"Recursive entry to debugger\");\n\n\treturn 1;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\texception_level;",
            "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int\t\t\texception_level;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\n\nstatic int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t/* Panic on recursive debugger calls: */\n\texception_level++;\n\taddr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tdbg_deactivate_sw_breakpoints();\n\n\t/*\n\t * If the break point removed ok at the place exception\n\t * occurred, try to recover and print a warning to the end\n\t * user because the user planted a breakpoint in a place that\n\t * KGDB needs in order to function.\n\t */\n\tif (dbg_remove_sw_break(addr) == 0) {\n\t\texception_level = 0;\n\t\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\t\tdbg_activate_sw_breakpoints();\n\t\tpr_crit(\"re-enter error: breakpoint removed %lx\\n\", addr);\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn 1;\n\t}\n\tdbg_remove_all_break();\n\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\n\tif (exception_level > 1) {\n\t\tdump_stack();\n\t\tpanic(\"Recursive entry to debugger\");\n\t}\n\n\tpr_crit(\"re-enter exception: ALL breakpoints killed\\n\");\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow kdb to debug itself one level */\n\treturn 0;\n#endif\n\tdump_stack();\n\tpanic(\"Recursive entry to debugger\");\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ks",
            "0",
            "sizeof(struct kgdb_state)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kgdb_ops.enable_nmi",
          "args": [
            "0"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\n\nint\nkgdb_handle_exception(int evector, int signo, int ecode, struct pt_regs *regs)\n{\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\tint ret = 0;\n\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tarch_kgdb_ops.enable_nmi(0);\n\t/*\n\t * Avoid entering the debugger if we were triggered due to an oops\n\t * but panic_timeout indicates the system should automatically\n\t * reboot on panic. We don't want to get stuck waiting for input\n\t * on such systems, especially if its \"just\" an oops.\n\t */\n\tif (signo != SIGTRAP && panic_timeout)\n\t\treturn 1;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= raw_smp_processor_id();\n\tks->ex_vector\t\t= evector;\n\tks->signo\t\t= signo;\n\tks->err_code\t\t= ecode;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_reenter_check(ks))\n\t\tgoto out; /* Ouch, double exception ! */\n\tif (kgdb_info[ks->cpu].enter_kgdb != 0)\n\t\tgoto out;\n\n\tret = kgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\nout:\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tarch_kgdb_ops.enable_nmi(1);\n\treturn ret;\n}"
  },
  {
    "function_name": "kgdb_cpu_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "468-682",
    "snippet": "static int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus(flags);\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\n\treturn kgdb_info[cpu].ret_state;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
      "int\t\t\t\tkgdb_connected;",
      "static int\t\t\texception_level;",
      "struct kgdb_io\t\t*dbg_io_ops;",
      "int dbg_switch_cpu;",
      "int dbg_kdb_mode = 1;",
      "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);",
      "static DEFINE_RAW_SPINLOCK(dbg_master_lock);",
      "static DEFINE_RAW_SPINLOCK(dbg_slave_lock);",
      "static atomic_t\t\t\tmasters_in_kgdb;",
      "static atomic_t\t\t\tslaves_in_kgdb;",
      "struct task_struct\t\t*kgdb_contthread;",
      "int\t\t\t\tkgdb_single_step;",
      "static pid_t\t\t\tkgdb_sstep_pid;",
      "atomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);",
      "static int kgdb_do_roundup = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_touch_watchdogs",
          "args": [],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_touch_watchdogs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "461-466",
          "snippet": "static void dbg_touch_watchdogs(void)\n{\n\ttouch_softlockup_watchdog_sync();\n\tclocksource_touch_watchdog();\n\trcu_cpu_stall_reset();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic void dbg_touch_watchdogs(void)\n{\n\ttouch_softlockup_watchdog_sync();\n\tclocksource_touch_watchdog();\n\trcu_cpu_stall_reset();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&dbg_master_lock"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kgdb_active",
            "-1"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&masters_in_kgdb"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_on",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "783-786",
          "snippet": "void tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_kgdb_ops.correct_hw_break",
          "args": [],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_cpu_doing_single_step"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_cpu_doing_single_step"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&slaves_in_kgdb"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->post_exception",
          "args": [],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdb_serial_stub",
          "args": [
            "ks"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_serial_stub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/gdbstub.c",
          "lines": "944-1080",
          "snippet": "int gdb_serial_stub(struct kgdb_state *ks)\n{\n\tint error = 0;\n\tint tmp;\n\n\t/* Initialize comm buffer and globals. */\n\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\tkgdb_usethread = kgdb_info[ks->cpu].task;\n\tks->kgdb_usethreadid = shadow_pid(kgdb_info[ks->cpu].task->pid);\n\tks->pass_exception = 0;\n\n\tif (kgdb_connected) {\n\t\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\t\tchar *ptr;\n\n\t\t/* Reply to host that an exception has occurred */\n\t\tptr = remcom_out_buffer;\n\t\t*ptr++ = 'T';\n\t\tptr = hex_byte_pack(ptr, ks->signo);\n\t\tptr += strlen(strcpy(ptr, \"thread:\"));\n\t\tint_to_threadref(thref, shadow_pid(current->pid));\n\t\tptr = pack_threadid(ptr, thref);\n\t\t*ptr++ = ';';\n\t\tput_packet(remcom_out_buffer);\n\t}\n\n\twhile (1) {\n\t\terror = 0;\n\n\t\t/* Clear the out buffer. */\n\t\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\n\t\tget_packet(remcom_in_buffer);\n\n\t\tswitch (remcom_in_buffer[0]) {\n\t\tcase '?': /* gdbserial status */\n\t\t\tgdb_cmd_status(ks);\n\t\t\tbreak;\n\t\tcase 'g': /* return the value of the CPU registers */\n\t\t\tgdb_cmd_getregs(ks);\n\t\t\tbreak;\n\t\tcase 'G': /* set the value of the CPU registers - return OK */\n\t\t\tgdb_cmd_setregs(ks);\n\t\t\tbreak;\n\t\tcase 'm': /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memread(ks);\n\t\t\tbreak;\n\t\tcase 'M': /* MAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memwrite(ks);\n\t\t\tbreak;\n#if DBG_MAX_REG_NUM > 0\n\t\tcase 'p': /* pXX Return gdb register XX (in hex) */\n\t\t\tgdb_cmd_reg_get(ks);\n\t\t\tbreak;\n\t\tcase 'P': /* PXX=aaaa Set gdb register XX to aaaa (in hex) */\n\t\t\tgdb_cmd_reg_set(ks);\n\t\t\tbreak;\n#endif /* DBG_MAX_REG_NUM > 0 */\n\t\tcase 'X': /* XAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_binwrite(ks);\n\t\t\tbreak;\n\t\t\t/* kill or detach. KGDB should treat this like a\n\t\t\t * continue.\n\t\t\t */\n\t\tcase 'D': /* Debugger detach */\n\t\tcase 'k': /* Debugger detach via kill */\n\t\t\tgdb_cmd_detachkill(ks);\n\t\t\tgoto default_handle;\n\t\tcase 'R': /* Reboot */\n\t\t\tif (gdb_cmd_reboot(ks))\n\t\t\t\tgoto default_handle;\n\t\t\tbreak;\n\t\tcase 'q': /* query command */\n\t\t\tgdb_cmd_query(ks);\n\t\t\tbreak;\n\t\tcase 'H': /* task related */\n\t\t\tgdb_cmd_task(ks);\n\t\t\tbreak;\n\t\tcase 'T': /* Query thread status */\n\t\t\tgdb_cmd_thread(ks);\n\t\t\tbreak;\n\t\tcase 'z': /* Break point remove */\n\t\tcase 'Z': /* Break point set */\n\t\t\tgdb_cmd_break(ks);\n\t\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\t\tcase '3': /* Escape into back into kdb */\n\t\t\tif (remcom_in_buffer[1] == '\\0') {\n\t\t\t\tgdb_cmd_detachkill(ks);\n\t\t\t\treturn DBG_PASS_EVENT;\n\t\t\t}\n#endif\n\t\tcase 'C': /* Exception passing */\n\t\t\ttmp = gdb_cmd_exception_pass(ks);\n\t\t\tif (tmp > 0)\n\t\t\t\tgoto default_handle;\n\t\t\tif (tmp == 0)\n\t\t\t\tbreak;\n\t\t\t/* Fall through on tmp < 0 */\n\t\tcase 'c': /* Continue packet */\n\t\tcase 's': /* Single step packet */\n\t\t\tif (kgdb_contthread && kgdb_contthread != current) {\n\t\t\t\t/* Can't switch threads in kgdb */\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdbg_activate_sw_breakpoints();\n\t\t\t/* Fall through to default processing */\n\t\tdefault:\ndefault_handle:\n\t\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\tks->signo,\n\t\t\t\t\t\tks->err_code,\n\t\t\t\t\t\tremcom_in_buffer,\n\t\t\t\t\t\tremcom_out_buffer,\n\t\t\t\t\t\tks->linux_regs);\n\t\t\t/*\n\t\t\t * Leave cmd processing on error, detach,\n\t\t\t * kill, continue, or single step.\n\t\t\t */\n\t\t\tif (error >= 0 || remcom_in_buffer[0] == 'D' ||\n\t\t\t    remcom_in_buffer[0] == 'k') {\n\t\t\t\terror = 0;\n\t\t\t\tgoto kgdb_exit;\n\t\t\t}\n\n\t\t}\n\n\t\t/* reply to the request */\n\t\tput_packet(remcom_out_buffer);\n\t}\n\nkgdb_exit:\n\tif (ks->pass_exception)\n\t\terror = 1;\n\treturn error;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BUF_THREAD_ID_SIZE\t8"
          ],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BUF_THREAD_ID_SIZE\t8\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nint gdb_serial_stub(struct kgdb_state *ks)\n{\n\tint error = 0;\n\tint tmp;\n\n\t/* Initialize comm buffer and globals. */\n\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\tkgdb_usethread = kgdb_info[ks->cpu].task;\n\tks->kgdb_usethreadid = shadow_pid(kgdb_info[ks->cpu].task->pid);\n\tks->pass_exception = 0;\n\n\tif (kgdb_connected) {\n\t\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\t\tchar *ptr;\n\n\t\t/* Reply to host that an exception has occurred */\n\t\tptr = remcom_out_buffer;\n\t\t*ptr++ = 'T';\n\t\tptr = hex_byte_pack(ptr, ks->signo);\n\t\tptr += strlen(strcpy(ptr, \"thread:\"));\n\t\tint_to_threadref(thref, shadow_pid(current->pid));\n\t\tptr = pack_threadid(ptr, thref);\n\t\t*ptr++ = ';';\n\t\tput_packet(remcom_out_buffer);\n\t}\n\n\twhile (1) {\n\t\terror = 0;\n\n\t\t/* Clear the out buffer. */\n\t\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\n\t\tget_packet(remcom_in_buffer);\n\n\t\tswitch (remcom_in_buffer[0]) {\n\t\tcase '?': /* gdbserial status */\n\t\t\tgdb_cmd_status(ks);\n\t\t\tbreak;\n\t\tcase 'g': /* return the value of the CPU registers */\n\t\t\tgdb_cmd_getregs(ks);\n\t\t\tbreak;\n\t\tcase 'G': /* set the value of the CPU registers - return OK */\n\t\t\tgdb_cmd_setregs(ks);\n\t\t\tbreak;\n\t\tcase 'm': /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memread(ks);\n\t\t\tbreak;\n\t\tcase 'M': /* MAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memwrite(ks);\n\t\t\tbreak;\n#if DBG_MAX_REG_NUM > 0\n\t\tcase 'p': /* pXX Return gdb register XX (in hex) */\n\t\t\tgdb_cmd_reg_get(ks);\n\t\t\tbreak;\n\t\tcase 'P': /* PXX=aaaa Set gdb register XX to aaaa (in hex) */\n\t\t\tgdb_cmd_reg_set(ks);\n\t\t\tbreak;\n#endif /* DBG_MAX_REG_NUM > 0 */\n\t\tcase 'X': /* XAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_binwrite(ks);\n\t\t\tbreak;\n\t\t\t/* kill or detach. KGDB should treat this like a\n\t\t\t * continue.\n\t\t\t */\n\t\tcase 'D': /* Debugger detach */\n\t\tcase 'k': /* Debugger detach via kill */\n\t\t\tgdb_cmd_detachkill(ks);\n\t\t\tgoto default_handle;\n\t\tcase 'R': /* Reboot */\n\t\t\tif (gdb_cmd_reboot(ks))\n\t\t\t\tgoto default_handle;\n\t\t\tbreak;\n\t\tcase 'q': /* query command */\n\t\t\tgdb_cmd_query(ks);\n\t\t\tbreak;\n\t\tcase 'H': /* task related */\n\t\t\tgdb_cmd_task(ks);\n\t\t\tbreak;\n\t\tcase 'T': /* Query thread status */\n\t\t\tgdb_cmd_thread(ks);\n\t\t\tbreak;\n\t\tcase 'z': /* Break point remove */\n\t\tcase 'Z': /* Break point set */\n\t\t\tgdb_cmd_break(ks);\n\t\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\t\tcase '3': /* Escape into back into kdb */\n\t\t\tif (remcom_in_buffer[1] == '\\0') {\n\t\t\t\tgdb_cmd_detachkill(ks);\n\t\t\t\treturn DBG_PASS_EVENT;\n\t\t\t}\n#endif\n\t\tcase 'C': /* Exception passing */\n\t\t\ttmp = gdb_cmd_exception_pass(ks);\n\t\t\tif (tmp > 0)\n\t\t\t\tgoto default_handle;\n\t\t\tif (tmp == 0)\n\t\t\t\tbreak;\n\t\t\t/* Fall through on tmp < 0 */\n\t\tcase 'c': /* Continue packet */\n\t\tcase 's': /* Single step packet */\n\t\t\tif (kgdb_contthread && kgdb_contthread != current) {\n\t\t\t\t/* Can't switch threads in kgdb */\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdbg_activate_sw_breakpoints();\n\t\t\t/* Fall through to default processing */\n\t\tdefault:\ndefault_handle:\n\t\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\tks->signo,\n\t\t\t\t\t\tks->err_code,\n\t\t\t\t\t\tremcom_in_buffer,\n\t\t\t\t\t\tremcom_out_buffer,\n\t\t\t\t\t\tks->linux_regs);\n\t\t\t/*\n\t\t\t * Leave cmd processing on error, detach,\n\t\t\t * kill, continue, or single step.\n\t\t\t */\n\t\t\tif (error >= 0 || remcom_in_buffer[0] == 'D' ||\n\t\t\t    remcom_in_buffer[0] == 'k') {\n\t\t\t\terror = 0;\n\t\t\t\tgoto kgdb_exit;\n\t\t\t}\n\n\t\t}\n\n\t\t/* reply to the request */\n\t\tput_packet(remcom_out_buffer);\n\t}\n\nkgdb_exit:\n\tif (ks->pass_exception)\n\t\terror = 1;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_stub",
          "args": [
            "ks"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_stub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.h",
          "lines": "79-82",
          "snippet": "static inline int kdb_stub(struct kgdb_state *ks)\n{\n\treturn DBG_PASS_EVENT;\n}",
          "includes": [],
          "macros_used": [
            "#define DBG_PASS_EVENT -12345"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define DBG_PASS_EVENT -12345\n\nstatic inline int kdb_stub(struct kgdb_state *ks)\n{\n\treturn DBG_PASS_EVENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_off",
          "args": [],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1073-1076",
          "snippet": "void tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1101-1104",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_deactivate_sw_breakpoints",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_deactivate_sw_breakpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "315-335",
          "snippet": "int dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Timed out waiting for secondary CPUs.\\n\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1000"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&slaves_in_kgdb"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&masters_in_kgdb"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_roundup_cpus",
          "args": [
            "flags"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "ks->send_ready",
            "1"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&dbg_slave_lock"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->pre_exception",
          "args": [],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_skipexception",
          "args": [
            "ks->ex_vector",
            "ks->linux_regs"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_skipexception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "218-221",
          "snippet": "int __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_io_ready",
          "args": [
            "1"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_io_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "396-413",
          "snippet": "static int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\t\tkgdb_connected;",
            "struct kgdb_io\t\t*dbg_io_ops;",
            "int dbg_kdb_mode = 1;",
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nstatic int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kgdb_active",
            "-1"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_cpu_doing_single_step"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&slaves_in_kgdb"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kgdb_ops.correct_hw_break",
          "args": [],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "&dbg_slave_lock"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&kgdb_active",
            "cpu"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&dbg_master_lock"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "134-137",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&kgdb_active",
            "cpu"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kgdb_ops.disable_hw_break",
          "args": [
            "regs"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&slaves_in_kgdb"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&masters_in_kgdb"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nint\t\t\t\tkgdb_connected;\nstatic int\t\t\texception_level;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_switch_cpu;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\nstatic DEFINE_RAW_SPINLOCK(dbg_slave_lock);\nstatic atomic_t\t\t\tmasters_in_kgdb;\nstatic atomic_t\t\t\tslaves_in_kgdb;\nstruct task_struct\t\t*kgdb_contthread;\nint\t\t\t\tkgdb_single_step;\nstatic pid_t\t\t\tkgdb_sstep_pid;\natomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);\nstatic int kgdb_do_roundup = 1;\n\nstatic int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus(flags);\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\n\treturn kgdb_info[cpu].ret_state;\n}"
  },
  {
    "function_name": "dbg_touch_watchdogs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "461-466",
    "snippet": "static void dbg_touch_watchdogs(void)\n{\n\ttouch_softlockup_watchdog_sync();\n\tclocksource_touch_watchdog();\n\trcu_cpu_stall_reset();\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_cpu_stall_reset",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cpu_stall_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1428-1431",
          "snippet": "void rcu_cpu_stall_reset(void)\n{\n\tWRITE_ONCE(rcu_state.jiffies_stall, jiffies + ULONG_MAX / 2);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nvoid rcu_cpu_stall_reset(void)\n{\n\tWRITE_ONCE(rcu_state.jiffies_stall, jiffies + ULONG_MAX / 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_touch_watchdog",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_touch_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "641-644",
          "snippet": "void clocksource_touch_watchdog(void)\n{\n\tclocksource_resume_watchdog();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_touch_watchdog(void)\n{\n\tclocksource_resume_watchdog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog_sync",
          "args": [],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "298-302",
          "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_touch_ts, 0);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_touch_ts, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic void dbg_touch_watchdogs(void)\n{\n\ttouch_softlockup_watchdog_sync();\n\tclocksource_touch_watchdog();\n\trcu_cpu_stall_reset();\n}"
  },
  {
    "function_name": "kgdb_reenter_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "415-459",
    "snippet": "static int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t/* Panic on recursive debugger calls: */\n\texception_level++;\n\taddr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tdbg_deactivate_sw_breakpoints();\n\n\t/*\n\t * If the break point removed ok at the place exception\n\t * occurred, try to recover and print a warning to the end\n\t * user because the user planted a breakpoint in a place that\n\t * KGDB needs in order to function.\n\t */\n\tif (dbg_remove_sw_break(addr) == 0) {\n\t\texception_level = 0;\n\t\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\t\tdbg_activate_sw_breakpoints();\n\t\tpr_crit(\"re-enter error: breakpoint removed %lx\\n\", addr);\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn 1;\n\t}\n\tdbg_remove_all_break();\n\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\n\tif (exception_level > 1) {\n\t\tdump_stack();\n\t\tpanic(\"Recursive entry to debugger\");\n\t}\n\n\tpr_crit(\"re-enter exception: ALL breakpoints killed\\n\");\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow kdb to debug itself one level */\n\treturn 0;\n#endif\n\tdump_stack();\n\tpanic(\"Recursive entry to debugger\");\n\n\treturn 1;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\texception_level;",
      "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Recursive entry to debugger\""
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_panic_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "181-185",
          "snippet": "static int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"re-enter exception: ALL breakpoints killed\\n\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_skipexception",
          "args": [
            "ks->ex_vector",
            "ks->linux_regs"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_skipexception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "218-221",
          "snippet": "int __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_remove_all_break",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_remove_all_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "363-385",
          "snippet": "int dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"re-enter error: breakpoint removed %lx\\n\"",
            "addr"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_activate_sw_breakpoints",
          "args": [],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_activate_sw_breakpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "250-272",
          "snippet": "int dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_remove_sw_break",
          "args": [
            "addr"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_remove_sw_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "337-349",
          "snippet": "int dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_deactivate_sw_breakpoints",
          "args": [],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_deactivate_sw_breakpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "315-335",
          "snippet": "int dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_pc",
          "args": [
            "ks->ex_vector",
            "ks->linux_regs"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "208-211",
          "snippet": "unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nunsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_active"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int\t\t\texception_level;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\n\nstatic int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t/* Panic on recursive debugger calls: */\n\texception_level++;\n\taddr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tdbg_deactivate_sw_breakpoints();\n\n\t/*\n\t * If the break point removed ok at the place exception\n\t * occurred, try to recover and print a warning to the end\n\t * user because the user planted a breakpoint in a place that\n\t * KGDB needs in order to function.\n\t */\n\tif (dbg_remove_sw_break(addr) == 0) {\n\t\texception_level = 0;\n\t\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\t\tdbg_activate_sw_breakpoints();\n\t\tpr_crit(\"re-enter error: breakpoint removed %lx\\n\", addr);\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn 1;\n\t}\n\tdbg_remove_all_break();\n\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\n\tif (exception_level > 1) {\n\t\tdump_stack();\n\t\tpanic(\"Recursive entry to debugger\");\n\t}\n\n\tpr_crit(\"re-enter exception: ALL breakpoints killed\\n\");\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow kdb to debug itself one level */\n\treturn 0;\n#endif\n\tdump_stack();\n\tpanic(\"Recursive entry to debugger\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "kgdb_io_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "396-413",
    "snippet": "static int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\t\tkgdb_connected;",
      "struct kgdb_io\t\t*dbg_io_ops;",
      "int dbg_kdb_mode = 1;",
      "atomic_t\t\t\tkgdb_setting_breakpoint;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Waiting for remote debugger\\n\""
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"waiting... or $3#33 for KDB\\n\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_setting_breakpoint"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nstatic int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "dbg_remove_all_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "363-385",
    "snippet": "int dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kgdb_ops.remove_all_hw_break",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"breakpoint remove failed: %lx\\n\"",
            "kgdb_break[i].bpt_addr"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_remove_breakpoint",
          "args": [
            "&kgdb_break[i]"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_remove_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "182-186",
          "snippet": "int __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_isremovedbreak",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "351-361",
    "snippet": "int kgdb_isremovedbreak(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_REMOVED) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint kgdb_isremovedbreak(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_REMOVED) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_remove_sw_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "337-349",
    "snippet": "int dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "dbg_deactivate_sw_breakpoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "315-335",
    "snippet": "int dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_flush_swbreak_addr",
          "args": [
            "kgdb_break[i].bpt_addr"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_flush_swbreak_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "227-245",
          "snippet": "static void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"BP remove failed: %lx\\n\"",
            "kgdb_break[i].bpt_addr"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_remove_breakpoint",
          "args": [
            "&kgdb_break[i]"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_remove_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "182-186",
          "snippet": "int __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dbg_set_sw_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "274-313",
    "snippet": "int dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -EEXIST;\n\t}\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_REMOVED &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\t\tif (kgdb_break[i].state == BP_UNDEFINED) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -E2BIG;\n\n\tkgdb_break[breakno].state = BP_SET;\n\tkgdb_break[breakno].type = BP_BREAKPOINT;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_validate_break_address",
          "args": [
            "addr"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_validate_break_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "188-206",
          "snippet": "int __weak kgdb_validate_break_address(unsigned long addr)\n{\n\tstruct kgdb_bkpt tmp;\n\tint err;\n\t/* Validate setting the breakpoint and then removing it.  If the\n\t * remove fails, the kernel needs to emit a bad message because we\n\t * are deep trouble not being able to put things back the way we\n\t * found them.\n\t */\n\ttmp.bpt_addr = addr;\n\terr = kgdb_arch_set_breakpoint(&tmp);\n\tif (err)\n\t\treturn err;\n\terr = kgdb_arch_remove_breakpoint(&tmp);\n\tif (err)\n\t\tpr_err(\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\",\n\t\t       addr);\n\treturn err;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_validate_break_address(unsigned long addr)\n{\n\tstruct kgdb_bkpt tmp;\n\tint err;\n\t/* Validate setting the breakpoint and then removing it.  If the\n\t * remove fails, the kernel needs to emit a bad message because we\n\t * are deep trouble not being able to put things back the way we\n\t * found them.\n\t */\n\ttmp.bpt_addr = addr;\n\terr = kgdb_arch_set_breakpoint(&tmp);\n\tif (err)\n\t\treturn err;\n\terr = kgdb_arch_remove_breakpoint(&tmp);\n\tif (err)\n\t\tpr_err(\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\",\n\t\t       addr);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -EEXIST;\n\t}\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_REMOVED &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\t\tif (kgdb_break[i].state == BP_UNDEFINED) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -E2BIG;\n\n\tkgdb_break[breakno].state = BP_SET;\n\tkgdb_break[breakno].type = BP_BREAKPOINT;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_activate_sw_breakpoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "250-272",
    "snippet": "int dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_flush_swbreak_addr",
          "args": [
            "kgdb_break[i].bpt_addr"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_flush_swbreak_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "227-245",
          "snippet": "static void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"BP install failed: %lx\\n\"",
            "kgdb_break[i].bpt_addr"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_set_breakpoint",
          "args": [
            "&kgdb_break[i]"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "169-180",
          "snippet": "int __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = probe_kernel_read(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = probe_kernel_read(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "kgdb_flush_swbreak_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "227-245",
    "snippet": "static void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "addr",
            "addr + BREAK_INSTR_SIZE"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_range",
          "args": [
            "current->vmacache.vmas[i]",
            "addr",
            "addr + BREAK_INSTR_SIZE"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}"
  },
  {
    "function_name": "kgdb_skipexception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "218-221",
    "snippet": "int __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_arch_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "213-216",
    "snippet": "int __weak kgdb_arch_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_arch_pc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "208-211",
    "snippet": "unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nunsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}"
  },
  {
    "function_name": "kgdb_validate_break_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "188-206",
    "snippet": "int __weak kgdb_validate_break_address(unsigned long addr)\n{\n\tstruct kgdb_bkpt tmp;\n\tint err;\n\t/* Validate setting the breakpoint and then removing it.  If the\n\t * remove fails, the kernel needs to emit a bad message because we\n\t * are deep trouble not being able to put things back the way we\n\t * found them.\n\t */\n\ttmp.bpt_addr = addr;\n\terr = kgdb_arch_set_breakpoint(&tmp);\n\tif (err)\n\t\treturn err;\n\terr = kgdb_arch_remove_breakpoint(&tmp);\n\tif (err)\n\t\tpr_err(\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\",\n\t\t       addr);\n\treturn err;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\"",
            "addr"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_remove_breakpoint",
          "args": [
            "&tmp"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_remove_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "182-186",
          "snippet": "int __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_set_breakpoint",
          "args": [
            "&tmp"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "169-180",
          "snippet": "int __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = probe_kernel_read(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = probe_kernel_read(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_validate_break_address(unsigned long addr)\n{\n\tstruct kgdb_bkpt tmp;\n\tint err;\n\t/* Validate setting the breakpoint and then removing it.  If the\n\t * remove fails, the kernel needs to emit a bad message because we\n\t * are deep trouble not being able to put things back the way we\n\t * found them.\n\t */\n\ttmp.bpt_addr = addr;\n\terr = kgdb_arch_set_breakpoint(&tmp);\n\tif (err)\n\t\treturn err;\n\terr = kgdb_arch_remove_breakpoint(&tmp);\n\tif (err)\n\t\tpr_err(\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\",\n\t\t       addr);\n\treturn err;\n}"
  },
  {
    "function_name": "kgdb_arch_remove_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "182-186",
    "snippet": "int __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "probe_kernel_write",
          "args": [
            "(char *)bpt->bpt_addr",
            "(char *)bpt->saved_instr",
            "BREAK_INSTR_SIZE"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}"
  },
  {
    "function_name": "kgdb_arch_set_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "169-180",
    "snippet": "int __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = probe_kernel_read(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "probe_kernel_write",
          "args": [
            "(char *)bpt->bpt_addr",
            "arch_kgdb_ops.gdb_bpt_instr",
            "BREAK_INSTR_SIZE"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "bpt->saved_instr",
            "(char *)bpt->bpt_addr",
            "BREAK_INSTR_SIZE"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = probe_kernel_read(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = probe_kernel_write((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}"
  },
  {
    "function_name": "opt_nokgdbroundup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "152-157",
    "snippet": "static int __init opt_nokgdbroundup(char *str)\n{\n\tkgdb_do_roundup = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdb_do_roundup = 1;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_do_roundup = 1;\n\nstatic int __init opt_nokgdbroundup(char *str)\n{\n\tkgdb_do_roundup = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "opt_kgdb_con",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
    "lines": "98-102",
    "snippet": "static int __init opt_kgdb_con(char *str)\n{\n\tkgdb_use_con = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdb_use_con;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_use_con;\n\nstatic int __init opt_kgdb_con(char *str)\n{\n\tkgdb_use_con = 1;\n\treturn 0;\n}"
  }
]