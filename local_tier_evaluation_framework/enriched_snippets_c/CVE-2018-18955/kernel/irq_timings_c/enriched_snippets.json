[
  {
    "function_name": "irq_timings_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/timings.c",
    "lines": "333-362",
    "snippet": "int irq_timings_alloc(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\tint id;\n\n\t/*\n\t * Some platforms can have the same private interrupt per cpu,\n\t * so this function may be be called several times with the\n\t * same interrupt number. Just bail out in case the per cpu\n\t * stat structure is already allocated.\n\t */\n\ts = idr_find(&irqt_stats, irq);\n\tif (s)\n\t\treturn 0;\n\n\ts = alloc_percpu(*s);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tidr_preload(GFP_KERNEL);\n\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);\n\tidr_preload_end();\n\n\tif (id < 0) {\n\t\tfree_percpu(s);\n\t\treturn id;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(irqt_stats);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "s"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&irqt_stats",
            "s",
            "irq",
            "irq + 1",
            "GFP_NOWAIT"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "301-312",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "*s"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&irqt_stats",
            "irq"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_IDR(irqt_stats);\n\nint irq_timings_alloc(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\tint id;\n\n\t/*\n\t * Some platforms can have the same private interrupt per cpu,\n\t * so this function may be be called several times with the\n\t * same interrupt number. Just bail out in case the per cpu\n\t * stat structure is already allocated.\n\t */\n\ts = idr_find(&irqt_stats, irq);\n\tif (s)\n\t\treturn 0;\n\n\ts = alloc_percpu(*s);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tidr_preload(GFP_KERNEL);\n\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);\n\tidr_preload_end();\n\n\tif (id < 0) {\n\t\tfree_percpu(s);\n\t\treturn id;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_timings_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/timings.c",
    "lines": "322-331",
    "snippet": "void irq_timings_free(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (s) {\n\t\tfree_percpu(s);\n\t\tidr_remove(&irqt_stats, irq);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(irqt_stats);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&irqt_stats",
            "irq"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "324-329",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "s"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&irqt_stats",
            "irq"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_IDR(irqt_stats);\n\nvoid irq_timings_free(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (s) {\n\t\tfree_percpu(s);\n\t\tidr_remove(&irqt_stats, irq);\n\t}\n}"
  },
  {
    "function_name": "irq_timings_next_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/timings.c",
    "lines": "247-320",
    "snippet": "u64 irq_timings_next_event(u64 now)\n{\n\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);\n\tstruct irqt_stat *irqs;\n\tstruct irqt_stat __percpu *s;\n\tu64 ts, next_evt = U64_MAX;\n\tint i, irq = 0;\n\n\t/*\n\t * This function must be called with the local irq disabled in\n\t * order to prevent the timings circular buffer to be updated\n\t * while we are reading it.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * Number of elements in the circular buffer: If it happens it\n\t * was flushed before, then the number of elements could be\n\t * smaller than IRQ_TIMINGS_SIZE, so the count is used,\n\t * otherwise the array size is used as we wrapped. The index\n\t * begins from zero when we did not wrap. That could be done\n\t * in a nicer way with the proper circular array structure\n\t * type but with the cost of extra computation in the\n\t * interrupt handler hot path. We choose efficiency.\n\t *\n\t * Inject measured irq/timestamp to the statistical model\n\t * while decrementing the counter because we consume the data\n\t * from our circular buffer.\n\t */\n\tfor (i = irqts->count & IRQ_TIMINGS_MASK,\n\t\t     irqts->count = min(IRQ_TIMINGS_SIZE, irqts->count);\n\t     irqts->count > 0; irqts->count--, i = (i + 1) & IRQ_TIMINGS_MASK) {\n\n\t\tirq = irq_timing_decode(irqts->values[i], &ts);\n\n\t\ts = idr_find(&irqt_stats, irq);\n\t\tif (s) {\n\t\t\tirqs = this_cpu_ptr(s);\n\t\t\tirqs_update(irqs, ts);\n\t\t}\n\t}\n\n\t/*\n\t * Look in the list of interrupts' statistics, the earliest\n\t * next event.\n\t */\n\tidr_for_each_entry(&irqt_stats, s, i) {\n\n\t\tirqs = this_cpu_ptr(s);\n\n\t\tif (!irqs->valid)\n\t\t\tcontinue;\n\n\t\tif (irqs->next_evt <= now) {\n\t\t\tirq = i;\n\t\t\tnext_evt = now;\n\n\t\t\t/*\n\t\t\t * This interrupt mustn't use in the future\n\t\t\t * until new events occur and update the\n\t\t\t * statistics.\n\t\t\t */\n\t\t\tirqs->valid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (irqs->next_evt < next_evt) {\n\t\t\tirq = i;\n\t\t\tnext_evt = irqs->next_evt;\n\t\t}\n\t}\n\n\treturn next_evt;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(irqt_stats);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_for_each_entry",
          "args": [
            "&irqt_stats",
            "s",
            "i"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_update",
          "args": [
            "irqs",
            "ts"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "irqs_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/timings.c",
          "lines": "106-219",
          "snippet": "static void irqs_update(struct irqt_stat *irqs, u64 ts)\n{\n\tu64 old_ts = irqs->last_ts;\n\tu64 variance = 0;\n\tu64 interval;\n\ts64 diff;\n\n\t/*\n\t * The timestamps are absolute time values, we need to compute\n\t * the timing interval between two interrupts.\n\t */\n\tirqs->last_ts = ts;\n\n\t/*\n\t * The interval type is u64 in order to deal with the same\n\t * type in our computation, that prevent mindfuck issues with\n\t * overflow, sign and division.\n\t */\n\tinterval = ts - old_ts;\n\n\t/*\n\t * The interrupt triggered more than one second apart, that\n\t * ends the sequence as predictible for our purpose. In this\n\t * case, assume we have the beginning of a sequence and the\n\t * timestamp is the first value. As it is impossible to\n\t * predict anything at this point, return.\n\t *\n\t * Note the first timestamp of the sequence will always fall\n\t * in this test because the old_ts is zero. That is what we\n\t * want as we need another timestamp to compute an interval.\n\t */\n\tif (interval >= NSEC_PER_SEC) {\n\t\tmemset(irqs, 0, sizeof(*irqs));\n\t\tirqs->last_ts = ts;\n\t\treturn;\n\t}\n\n\t/*\n\t * Pre-compute the delta with the average as the result is\n\t * used several times in this function.\n\t */\n\tdiff = interval - irqs->avg;\n\n\t/*\n\t * Increment the number of samples.\n\t */\n\tirqs->nr_samples++;\n\n\t/*\n\t * Online variance divided by the number of elements if there\n\t * is more than one sample.  Normally the formula is division\n\t * by nr_samples - 1 but we assume the number of element will be\n\t * more than 32 and dividing by 32 instead of 31 is enough\n\t * precise.\n\t */\n\tif (likely(irqs->nr_samples > 1))\n\t\tvariance = irqs->variance >> IRQ_TIMINGS_SHIFT;\n\n\t/*\n\t * The rule of thumb in statistics for the normal distribution\n\t * is having at least 30 samples in order to have the model to\n\t * apply. Values outside the interval are considered as an\n\t * anomaly.\n\t */\n\tif ((irqs->nr_samples >= 30) && ((diff * diff) > (9 * variance))) {\n\t\t/*\n\t\t * After three consecutive anomalies, we reset the\n\t\t * stats as it is no longer stable enough.\n\t\t */\n\t\tif (irqs->anomalies++ >= 3) {\n\t\t\tmemset(irqs, 0, sizeof(*irqs));\n\t\t\tirqs->last_ts = ts;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The anomalies must be consecutives, so at this\n\t\t * point, we reset the anomalies counter.\n\t\t */\n\t\tirqs->anomalies = 0;\n\t}\n\n\t/*\n\t * The interrupt is considered stable enough to try to predict\n\t * the next event on it.\n\t */\n\tirqs->valid = 1;\n\n\t/*\n\t * Online average algorithm:\n\t *\n\t *  new_average = average + ((value - average) / count)\n\t *\n\t * The variance computation depends on the new average\n\t * to be computed here first.\n\t *\n\t */\n\tirqs->avg = irqs->avg + (diff >> IRQ_TIMINGS_SHIFT);\n\n\t/*\n\t * Online variance algorithm:\n\t *\n\t *  new_variance = variance + (value - average) x (value - new_average)\n\t *\n\t * Warning: irqs->avg is updated with the line above, hence\n\t * 'interval - irqs->avg' is no longer equal to 'diff'\n\t */\n\tirqs->variance = irqs->variance + (diff * (interval - irqs->avg));\n\n\t/*\n\t * Update the next event\n\t */\n\tirqs->next_evt = ts + irqs->avg;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic void irqs_update(struct irqt_stat *irqs, u64 ts)\n{\n\tu64 old_ts = irqs->last_ts;\n\tu64 variance = 0;\n\tu64 interval;\n\ts64 diff;\n\n\t/*\n\t * The timestamps are absolute time values, we need to compute\n\t * the timing interval between two interrupts.\n\t */\n\tirqs->last_ts = ts;\n\n\t/*\n\t * The interval type is u64 in order to deal with the same\n\t * type in our computation, that prevent mindfuck issues with\n\t * overflow, sign and division.\n\t */\n\tinterval = ts - old_ts;\n\n\t/*\n\t * The interrupt triggered more than one second apart, that\n\t * ends the sequence as predictible for our purpose. In this\n\t * case, assume we have the beginning of a sequence and the\n\t * timestamp is the first value. As it is impossible to\n\t * predict anything at this point, return.\n\t *\n\t * Note the first timestamp of the sequence will always fall\n\t * in this test because the old_ts is zero. That is what we\n\t * want as we need another timestamp to compute an interval.\n\t */\n\tif (interval >= NSEC_PER_SEC) {\n\t\tmemset(irqs, 0, sizeof(*irqs));\n\t\tirqs->last_ts = ts;\n\t\treturn;\n\t}\n\n\t/*\n\t * Pre-compute the delta with the average as the result is\n\t * used several times in this function.\n\t */\n\tdiff = interval - irqs->avg;\n\n\t/*\n\t * Increment the number of samples.\n\t */\n\tirqs->nr_samples++;\n\n\t/*\n\t * Online variance divided by the number of elements if there\n\t * is more than one sample.  Normally the formula is division\n\t * by nr_samples - 1 but we assume the number of element will be\n\t * more than 32 and dividing by 32 instead of 31 is enough\n\t * precise.\n\t */\n\tif (likely(irqs->nr_samples > 1))\n\t\tvariance = irqs->variance >> IRQ_TIMINGS_SHIFT;\n\n\t/*\n\t * The rule of thumb in statistics for the normal distribution\n\t * is having at least 30 samples in order to have the model to\n\t * apply. Values outside the interval are considered as an\n\t * anomaly.\n\t */\n\tif ((irqs->nr_samples >= 30) && ((diff * diff) > (9 * variance))) {\n\t\t/*\n\t\t * After three consecutive anomalies, we reset the\n\t\t * stats as it is no longer stable enough.\n\t\t */\n\t\tif (irqs->anomalies++ >= 3) {\n\t\t\tmemset(irqs, 0, sizeof(*irqs));\n\t\t\tirqs->last_ts = ts;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The anomalies must be consecutives, so at this\n\t\t * point, we reset the anomalies counter.\n\t\t */\n\t\tirqs->anomalies = 0;\n\t}\n\n\t/*\n\t * The interrupt is considered stable enough to try to predict\n\t * the next event on it.\n\t */\n\tirqs->valid = 1;\n\n\t/*\n\t * Online average algorithm:\n\t *\n\t *  new_average = average + ((value - average) / count)\n\t *\n\t * The variance computation depends on the new average\n\t * to be computed here first.\n\t *\n\t */\n\tirqs->avg = irqs->avg + (diff >> IRQ_TIMINGS_SHIFT);\n\n\t/*\n\t * Online variance algorithm:\n\t *\n\t *  new_variance = variance + (value - average) x (value - new_average)\n\t *\n\t * Warning: irqs->avg is updated with the line above, hence\n\t * 'interval - irqs->avg' is no longer equal to 'diff'\n\t */\n\tirqs->variance = irqs->variance + (diff * (interval - irqs->avg));\n\n\t/*\n\t * Update the next event\n\t */\n\tirqs->next_evt = ts + irqs->avg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&irqt_stats",
            "irq"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_timing_decode",
          "args": [
            "irqts->values[i]",
            "&ts"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timing_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "343-347",
          "snippet": "static inline int irq_timing_decode(u64 value, u64 *timestamp)\n{\n\t*timestamp = value >> 16;\n\treturn value & U16_MAX;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline int irq_timing_decode(u64 value, u64 *timestamp)\n{\n\t*timestamp = value >> 16;\n\treturn value & U16_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "IRQ_TIMINGS_SIZE",
            "irqts->count"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&irq_timings"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_IDR(irqt_stats);\n\nu64 irq_timings_next_event(u64 now)\n{\n\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);\n\tstruct irqt_stat *irqs;\n\tstruct irqt_stat __percpu *s;\n\tu64 ts, next_evt = U64_MAX;\n\tint i, irq = 0;\n\n\t/*\n\t * This function must be called with the local irq disabled in\n\t * order to prevent the timings circular buffer to be updated\n\t * while we are reading it.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * Number of elements in the circular buffer: If it happens it\n\t * was flushed before, then the number of elements could be\n\t * smaller than IRQ_TIMINGS_SIZE, so the count is used,\n\t * otherwise the array size is used as we wrapped. The index\n\t * begins from zero when we did not wrap. That could be done\n\t * in a nicer way with the proper circular array structure\n\t * type but with the cost of extra computation in the\n\t * interrupt handler hot path. We choose efficiency.\n\t *\n\t * Inject measured irq/timestamp to the statistical model\n\t * while decrementing the counter because we consume the data\n\t * from our circular buffer.\n\t */\n\tfor (i = irqts->count & IRQ_TIMINGS_MASK,\n\t\t     irqts->count = min(IRQ_TIMINGS_SIZE, irqts->count);\n\t     irqts->count > 0; irqts->count--, i = (i + 1) & IRQ_TIMINGS_MASK) {\n\n\t\tirq = irq_timing_decode(irqts->values[i], &ts);\n\n\t\ts = idr_find(&irqt_stats, irq);\n\t\tif (s) {\n\t\t\tirqs = this_cpu_ptr(s);\n\t\t\tirqs_update(irqs, ts);\n\t\t}\n\t}\n\n\t/*\n\t * Look in the list of interrupts' statistics, the earliest\n\t * next event.\n\t */\n\tidr_for_each_entry(&irqt_stats, s, i) {\n\n\t\tirqs = this_cpu_ptr(s);\n\n\t\tif (!irqs->valid)\n\t\t\tcontinue;\n\n\t\tif (irqs->next_evt <= now) {\n\t\t\tirq = i;\n\t\t\tnext_evt = now;\n\n\t\t\t/*\n\t\t\t * This interrupt mustn't use in the future\n\t\t\t * until new events occur and update the\n\t\t\t * statistics.\n\t\t\t */\n\t\t\tirqs->valid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (irqs->next_evt < next_evt) {\n\t\t\tirq = i;\n\t\t\tnext_evt = irqs->next_evt;\n\t\t}\n\t}\n\n\treturn next_evt;\n}"
  },
  {
    "function_name": "irqs_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/timings.c",
    "lines": "106-219",
    "snippet": "static void irqs_update(struct irqt_stat *irqs, u64 ts)\n{\n\tu64 old_ts = irqs->last_ts;\n\tu64 variance = 0;\n\tu64 interval;\n\ts64 diff;\n\n\t/*\n\t * The timestamps are absolute time values, we need to compute\n\t * the timing interval between two interrupts.\n\t */\n\tirqs->last_ts = ts;\n\n\t/*\n\t * The interval type is u64 in order to deal with the same\n\t * type in our computation, that prevent mindfuck issues with\n\t * overflow, sign and division.\n\t */\n\tinterval = ts - old_ts;\n\n\t/*\n\t * The interrupt triggered more than one second apart, that\n\t * ends the sequence as predictible for our purpose. In this\n\t * case, assume we have the beginning of a sequence and the\n\t * timestamp is the first value. As it is impossible to\n\t * predict anything at this point, return.\n\t *\n\t * Note the first timestamp of the sequence will always fall\n\t * in this test because the old_ts is zero. That is what we\n\t * want as we need another timestamp to compute an interval.\n\t */\n\tif (interval >= NSEC_PER_SEC) {\n\t\tmemset(irqs, 0, sizeof(*irqs));\n\t\tirqs->last_ts = ts;\n\t\treturn;\n\t}\n\n\t/*\n\t * Pre-compute the delta with the average as the result is\n\t * used several times in this function.\n\t */\n\tdiff = interval - irqs->avg;\n\n\t/*\n\t * Increment the number of samples.\n\t */\n\tirqs->nr_samples++;\n\n\t/*\n\t * Online variance divided by the number of elements if there\n\t * is more than one sample.  Normally the formula is division\n\t * by nr_samples - 1 but we assume the number of element will be\n\t * more than 32 and dividing by 32 instead of 31 is enough\n\t * precise.\n\t */\n\tif (likely(irqs->nr_samples > 1))\n\t\tvariance = irqs->variance >> IRQ_TIMINGS_SHIFT;\n\n\t/*\n\t * The rule of thumb in statistics for the normal distribution\n\t * is having at least 30 samples in order to have the model to\n\t * apply. Values outside the interval are considered as an\n\t * anomaly.\n\t */\n\tif ((irqs->nr_samples >= 30) && ((diff * diff) > (9 * variance))) {\n\t\t/*\n\t\t * After three consecutive anomalies, we reset the\n\t\t * stats as it is no longer stable enough.\n\t\t */\n\t\tif (irqs->anomalies++ >= 3) {\n\t\t\tmemset(irqs, 0, sizeof(*irqs));\n\t\t\tirqs->last_ts = ts;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The anomalies must be consecutives, so at this\n\t\t * point, we reset the anomalies counter.\n\t\t */\n\t\tirqs->anomalies = 0;\n\t}\n\n\t/*\n\t * The interrupt is considered stable enough to try to predict\n\t * the next event on it.\n\t */\n\tirqs->valid = 1;\n\n\t/*\n\t * Online average algorithm:\n\t *\n\t *  new_average = average + ((value - average) / count)\n\t *\n\t * The variance computation depends on the new average\n\t * to be computed here first.\n\t *\n\t */\n\tirqs->avg = irqs->avg + (diff >> IRQ_TIMINGS_SHIFT);\n\n\t/*\n\t * Online variance algorithm:\n\t *\n\t *  new_variance = variance + (value - average) x (value - new_average)\n\t *\n\t * Warning: irqs->avg is updated with the line above, hence\n\t * 'interval - irqs->avg' is no longer equal to 'diff'\n\t */\n\tirqs->variance = irqs->variance + (diff * (interval - irqs->avg));\n\n\t/*\n\t * Update the next event\n\t */\n\tirqs->next_evt = ts + irqs->avg;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "irqs",
            "0",
            "sizeof(*irqs)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "irqs->nr_samples > 1"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "irqs",
            "0",
            "sizeof(*irqs)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic void irqs_update(struct irqt_stat *irqs, u64 ts)\n{\n\tu64 old_ts = irqs->last_ts;\n\tu64 variance = 0;\n\tu64 interval;\n\ts64 diff;\n\n\t/*\n\t * The timestamps are absolute time values, we need to compute\n\t * the timing interval between two interrupts.\n\t */\n\tirqs->last_ts = ts;\n\n\t/*\n\t * The interval type is u64 in order to deal with the same\n\t * type in our computation, that prevent mindfuck issues with\n\t * overflow, sign and division.\n\t */\n\tinterval = ts - old_ts;\n\n\t/*\n\t * The interrupt triggered more than one second apart, that\n\t * ends the sequence as predictible for our purpose. In this\n\t * case, assume we have the beginning of a sequence and the\n\t * timestamp is the first value. As it is impossible to\n\t * predict anything at this point, return.\n\t *\n\t * Note the first timestamp of the sequence will always fall\n\t * in this test because the old_ts is zero. That is what we\n\t * want as we need another timestamp to compute an interval.\n\t */\n\tif (interval >= NSEC_PER_SEC) {\n\t\tmemset(irqs, 0, sizeof(*irqs));\n\t\tirqs->last_ts = ts;\n\t\treturn;\n\t}\n\n\t/*\n\t * Pre-compute the delta with the average as the result is\n\t * used several times in this function.\n\t */\n\tdiff = interval - irqs->avg;\n\n\t/*\n\t * Increment the number of samples.\n\t */\n\tirqs->nr_samples++;\n\n\t/*\n\t * Online variance divided by the number of elements if there\n\t * is more than one sample.  Normally the formula is division\n\t * by nr_samples - 1 but we assume the number of element will be\n\t * more than 32 and dividing by 32 instead of 31 is enough\n\t * precise.\n\t */\n\tif (likely(irqs->nr_samples > 1))\n\t\tvariance = irqs->variance >> IRQ_TIMINGS_SHIFT;\n\n\t/*\n\t * The rule of thumb in statistics for the normal distribution\n\t * is having at least 30 samples in order to have the model to\n\t * apply. Values outside the interval are considered as an\n\t * anomaly.\n\t */\n\tif ((irqs->nr_samples >= 30) && ((diff * diff) > (9 * variance))) {\n\t\t/*\n\t\t * After three consecutive anomalies, we reset the\n\t\t * stats as it is no longer stable enough.\n\t\t */\n\t\tif (irqs->anomalies++ >= 3) {\n\t\t\tmemset(irqs, 0, sizeof(*irqs));\n\t\t\tirqs->last_ts = ts;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The anomalies must be consecutives, so at this\n\t\t * point, we reset the anomalies counter.\n\t\t */\n\t\tirqs->anomalies = 0;\n\t}\n\n\t/*\n\t * The interrupt is considered stable enough to try to predict\n\t * the next event on it.\n\t */\n\tirqs->valid = 1;\n\n\t/*\n\t * Online average algorithm:\n\t *\n\t *  new_average = average + ((value - average) / count)\n\t *\n\t * The variance computation depends on the new average\n\t * to be computed here first.\n\t *\n\t */\n\tirqs->avg = irqs->avg + (diff >> IRQ_TIMINGS_SHIFT);\n\n\t/*\n\t * Online variance algorithm:\n\t *\n\t *  new_variance = variance + (value - average) x (value - new_average)\n\t *\n\t * Warning: irqs->avg is updated with the line above, hence\n\t * 'interval - irqs->avg' is no longer equal to 'diff'\n\t */\n\tirqs->variance = irqs->variance + (diff * (interval - irqs->avg));\n\n\t/*\n\t * Update the next event\n\t */\n\tirqs->next_evt = ts + irqs->avg;\n}"
  },
  {
    "function_name": "irq_timings_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/timings.c",
    "lines": "38-41",
    "snippet": "void irq_timings_disable(void)\n{\n\tstatic_branch_disable(&irq_timing_enabled);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&irq_timing_enabled"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nvoid irq_timings_disable(void)\n{\n\tstatic_branch_disable(&irq_timing_enabled);\n}"
  },
  {
    "function_name": "irq_timings_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/timings.c",
    "lines": "33-36",
    "snippet": "void irq_timings_enable(void)\n{\n\tstatic_branch_enable(&irq_timing_enabled);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&irq_timing_enabled"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nvoid irq_timings_enable(void)\n{\n\tstatic_branch_enable(&irq_timing_enabled);\n}"
  }
]